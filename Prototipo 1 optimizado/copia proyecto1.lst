CCS PCH C Compiler, Version 3.249, 28193               26-feb-10 13:06

               Filename: E:\programming\sed\Proyecto 1\Prototipo 1 optimizado\copia proyecto1.lst

               ROM used: 27918 bytes (85%)
                         Largest free fragment is 4846
               RAM used: 138 (9%) at main() level
                         722 (47%) worst case
               Stack:    8 worst case (7 in main + 1 for interrupts)

*
0000:  GOTO   5CCA
*
0008:  MOVWF  05
000A:  MOVFF  FD8,06
000E:  MOVFF  FE0,07
0012:  MOVLB  0
0014:  MOVFF  FE9,0D
0018:  MOVFF  FEA,08
001C:  MOVFF  FE1,09
0020:  MOVFF  FE2,0A
0024:  MOVFF  FD9,0B
0028:  MOVFF  FDA,0C
002C:  MOVFF  FF3,14
0030:  MOVFF  FF4,15
0034:  MOVFF  FFA,16
0038:  MOVFF  00,0F
003C:  MOVFF  01,10
0040:  MOVFF  02,11
0044:  MOVFF  03,12
0048:  MOVFF  04,13
004C:  BTFSS  F9D.0
004E:  GOTO   0058
0052:  BTFSC  F9E.0
0054:  GOTO   1298
0058:  BTFSS  FF2.4
005A:  GOTO   0064
005E:  BTFSC  FF2.1
0060:  GOTO   1288
0064:  BTFSS  FF0.3
0066:  GOTO   0070
006A:  BTFSC  FF0.0
006C:  GOTO   1290
0070:  MOVFF  0F,00
0074:  MOVFF  10,01
0078:  MOVFF  11,02
007C:  MOVFF  12,03
0080:  MOVFF  13,04
0084:  MOVFF  0D,FE9
0088:  MOVFF  08,FEA
008C:  MOVFF  09,FE1
0090:  MOVFF  0A,FE2
0094:  MOVFF  0B,FD9
0098:  MOVFF  0C,FDA
009C:  MOVFF  14,FF3
00A0:  MOVFF  15,FF4
00A4:  MOVFF  16,FFA
00A8:  MOVF   05,W
00AA:  MOVFF  07,FE0
00AE:  MOVFF  06,FD8
00B2:  RETFIE 0
.................... //***************************************************************** 
.................... //***   PROYECTO 1: Control de un sistema de calefacción de una *** 
.................... //***   vivienda utilizando un microcontrolador PIC18F4520      *** 
.................... //***************************************************************** 
.................... //Author: Julio Navarro Lara        2010 
....................  
....................  
....................  
.................... #include "18F4520.H" 
.................... //////// Standard Header file for the PIC18F4520 device //////////////// 
.................... #DEVICE PIC18F4520 //Aunque el convertidor A/D es de 10 bits, con esta directiva 
00B4:  MOVFF  FF2,0E
00B8:  BCF    FF2.7
00BA:  CLRF   FF7
00BC:  ADDLW  CE
00BE:  MOVWF  FF6
00C0:  MOVLW  00
00C2:  ADDWFC FF7,F
00C4:  TBLRD*+
00C6:  MOVF   FF5,W
00C8:  BTFSC  0E.7
00CA:  BSF    FF2.7
00CC:  RETURN 0
00CE:  DATA 2C,0F
00D0:  DATA 01,06
00D2:  MOVFF  FF2,0E
00D6:  BCF    FF2.7
00D8:  CLRF   FF7
00DA:  ADDLW  EC
00DC:  MOVWF  FF6
00DE:  MOVLW  00
00E0:  ADDWFC FF7,F
00E2:  TBLRD*+
00E4:  MOVF   FF5,W
00E6:  BTFSC  0E.7
00E8:  BSF    FF2.7
00EA:  RETURN 0
00EC:  DATA 31,32
00EE:  DATA 33,34
00F0:  DATA 35,36
00F2:  DATA 37,38
00F4:  DATA 39,53
00F6:  DATA 30,4E
00F8:  MOVFF  FF2,0E
00FC:  BCF    FF2.7
00FE:  CLRF   FF7
0100:  ADDLW  12
0102:  MOVWF  FF6
0104:  MOVLW  01
0106:  ADDWFC FF7,F
0108:  TBLRD*+
010A:  MOVF   FF5,W
010C:  BTFSC  0E.7
010E:  BSF    FF2.7
0110:  RETURN 0
0112:  DATA 49,6E
0114:  DATA 69,63
0116:  DATA 69,61
0118:  DATA 6C,69
011A:  DATA 7A,61
011C:  DATA 6E,64
011E:  DATA 6F,2E
0120:  DATA 2E,2E
0122:  DATA 00,00
0124:  MOVFF  FF2,0E
0128:  BCF    FF2.7
012A:  CLRF   FF7
012C:  ADDLW  3E
012E:  MOVWF  FF6
0130:  MOVLW  01
0132:  ADDWFC FF7,F
0134:  TBLRD*+
0136:  MOVF   FF5,W
0138:  BTFSC  0E.7
013A:  BSF    FF2.7
013C:  RETURN 0
013E:  DATA 53,69
0140:  DATA 73,74
0142:  DATA 65,6D
0144:  DATA 61,20
0146:  DATA 69,6E
0148:  DATA 69,63
014A:  DATA 69,61
014C:  DATA 6C,69
014E:  DATA 7A,61
0150:  DATA 64,6F
0152:  DATA 20,63
0154:  DATA 6F,6E
0156:  DATA 20,65
0158:  DATA 78,69
015A:  DATA 74,6F
015C:  DATA 21,0D
015E:  DATA 00,00
0160:  MOVFF  FF2,0E
0164:  BCF    FF2.7
0166:  CLRF   FF7
0168:  ADDLW  7A
016A:  MOVWF  FF6
016C:  MOVLW  01
016E:  ADDWFC FF7,F
0170:  TBLRD*+
0172:  MOVF   FF5,W
0174:  BTFSC  0E.7
0176:  BSF    FF2.7
0178:  RETURN 0
017A:  DATA 20,20
017C:  DATA 45,6E
017E:  DATA 63,65
0180:  DATA 6E,64
0182:  DATA 69,65
0184:  DATA 6E,64
0186:  DATA 6F,0A
0188:  DATA 20,20
018A:  DATA 73,69
018C:  DATA 73,74
018E:  DATA 65,6D
0190:  DATA 61,2E
0192:  DATA 2E,2E
0194:  DATA 00,00
0196:  MOVFF  FF2,0E
019A:  BCF    FF2.7
019C:  CLRF   FF7
019E:  ADDLW  B0
01A0:  MOVWF  FF6
01A2:  MOVLW  01
01A4:  ADDWFC FF7,F
01A6:  TBLRD*+
01A8:  MOVF   FF5,W
01AA:  BTFSC  0E.7
01AC:  BSF    FF2.7
01AE:  RETURN 0
01B0:  DATA 20,20
01B2:  DATA 41,70
01B4:  DATA 61,67
01B6:  DATA 61,6E
01B8:  DATA 64,6F
01BA:  DATA 0A,20
01BC:  DATA 20,73
01BE:  DATA 69,73
01C0:  DATA 74,65
01C2:  DATA 6D,61
01C4:  DATA 2E,2E
01C6:  DATA 2E,00
01C8:  MOVFF  FF2,0E
01CC:  BCF    FF2.7
01CE:  CLRF   FF7
01D0:  ADDLW  E2
01D2:  MOVWF  FF6
01D4:  MOVLW  01
01D6:  ADDWFC FF7,F
01D8:  TBLRD*+
01DA:  MOVF   FF5,W
01DC:  BTFSC  0E.7
01DE:  BSF    FF2.7
01E0:  RETURN 0
01E2:  DATA 20,20
01E4:  DATA 49,6E
01E6:  DATA 64,69
01E8:  DATA 71,75
01EA:  DATA 65,20
01EC:  DATA 6C,61
01EE:  DATA 20,0A
01F0:  DATA 20,20
01F2:  DATA 6F,70
01F4:  DATA 65,72
01F6:  DATA 61,63
01F8:  DATA 69,6F
01FA:  DATA 6E,00
01FC:  MOVFF  FF2,0E
0200:  BCF    FF2.7
0202:  CLRF   FF7
0204:  ADDLW  16
0206:  MOVWF  FF6
0208:  MOVLW  02
020A:  ADDWFC FF7,F
020C:  TBLRD*+
020E:  MOVF   FF5,W
0210:  BTFSC  0E.7
0212:  BSF    FF2.7
0214:  RETURN 0
0216:  DATA 4D,6F
0218:  DATA 64,69
021A:  DATA 66,69
021C:  DATA 63,61
021E:  DATA 72,0A
0220:  DATA 74,65
0222:  DATA 72,6D
0224:  DATA 6F,73
0226:  DATA 74,61
0228:  DATA 74,6F
022A:  DATA 20,25
022C:  DATA 2E,30
022E:  DATA 66,25
0230:  DATA 63,43
0232:  DATA 00,00
0234:  MOVFF  FF2,0E
0238:  BCF    FF2.7
023A:  CLRF   FF7
023C:  ADDLW  4E
023E:  MOVWF  FF6
0240:  MOVLW  02
0242:  ADDWFC FF7,F
0244:  TBLRD*+
0246:  MOVF   FF5,W
0248:  BTFSC  0E.7
024A:  BSF    FF2.7
024C:  RETURN 0
024E:  DATA 4E,75
0250:  DATA 65,76
0252:  DATA 6F,20
0254:  DATA 76,61
0256:  DATA 6C,6F
0258:  DATA 72,3A
025A:  DATA 0A,25
025C:  DATA 63,43
025E:  DATA 00,00
0260:  MOVFF  FF2,0E
0264:  BCF    FF2.7
0266:  CLRF   FF7
0268:  ADDLW  7A
026A:  MOVWF  FF6
026C:  MOVLW  02
026E:  ADDWFC FF7,F
0270:  TBLRD*+
0272:  MOVF   FF5,W
0274:  BTFSC  0E.7
0276:  BSF    FF2.7
0278:  RETURN 0
027A:  DATA 20,20
027C:  DATA 41,70
027E:  DATA 6C,69
0280:  DATA 63,61
0282:  DATA 6E,64
0284:  DATA 6F,0A
0286:  DATA 20,20
0288:  DATA 63,61
028A:  DATA 6D,62
028C:  DATA 69,6F
028E:  DATA 73,2E
0290:  DATA 2E,2E
0292:  DATA 00,00
0294:  MOVFF  FF2,0E
0298:  BCF    FF2.7
029A:  CLRF   FF7
029C:  ADDLW  AE
029E:  MOVWF  FF6
02A0:  MOVLW  02
02A2:  ADDWFC FF7,F
02A4:  TBLRD*+
02A6:  MOVF   FF5,W
02A8:  BTFSC  0E.7
02AA:  BSF    FF2.7
02AC:  RETURN 0
02AE:  DATA 20,20
02B0:  DATA 20,56
02B2:  DATA 61,6C
02B4:  DATA 6F,72
02B6:  DATA 0A,20
02B8:  DATA 20,20
02BA:  DATA 69,6E
02BC:  DATA 63,6F
02BE:  DATA 72,72
02C0:  DATA 65,63
02C2:  DATA 74,6F
02C4:  DATA 00,00
02C6:  MOVFF  FF2,0E
02CA:  BCF    FF2.7
02CC:  CLRF   FF7
02CE:  ADDLW  E0
02D0:  MOVWF  FF6
02D2:  MOVLW  02
02D4:  ADDWFC FF7,F
02D6:  TBLRD*+
02D8:  MOVF   FF5,W
02DA:  BTFSC  0E.7
02DC:  BSF    FF2.7
02DE:  RETURN 0
02E0:  DATA 20,50
02E2:  DATA 72,6F
02E4:  DATA 67,72
02E6:  DATA 61,6D
02E8:  DATA 61,72
02EA:  DATA 0A,20
02EC:  DATA 73,69
02EE:  DATA 73,74
02F0:  DATA 65,6D
02F2:  DATA 61,00
02F4:  MOVFF  FF2,0E
02F8:  BCF    FF2.7
02FA:  CLRF   FF7
02FC:  ADDLW  0E
02FE:  MOVWF  FF6
0300:  MOVLW  03
0302:  ADDWFC FF7,F
0304:  TBLRD*+
0306:  MOVF   FF5,W
0308:  BTFSC  0E.7
030A:  BSF    FF2.7
030C:  RETURN 0
030E:  DATA 20,49
0310:  DATA 4E,54
0312:  DATA 45,52
0314:  DATA 56,41
0316:  DATA 4C,4F
0318:  DATA 20,25
031A:  DATA 69,0A
031C:  DATA 3A,3A
031E:  DATA 00,00
0320:  MOVFF  FF2,0E
0324:  BCF    FF2.7
0326:  CLRF   FF7
0328:  ADDLW  3A
032A:  MOVWF  FF6
032C:  MOVLW  03
032E:  ADDWFC FF7,F
0330:  TBLRD*+
0332:  MOVF   FF5,W
0334:  BTFSC  0E.7
0336:  BSF    FF2.7
0338:  RETURN 0
033A:  DATA 20,20
033C:  DATA 20,56
033E:  DATA 61,6C
0340:  DATA 6F,72
0342:  DATA 65,73
0344:  DATA 0A,20
0346:  DATA 20,20
0348:  DATA 69,6E
034A:  DATA 63,6F
034C:  DATA 72,72
034E:  DATA 65,63
0350:  DATA 74,6F
0352:  DATA 73,00
0354:  MOVFF  FF2,0E
0358:  BCF    FF2.7
035A:  CLRF   FF7
035C:  ADDLW  6E
035E:  MOVWF  FF6
0360:  MOVLW  03
0362:  ADDWFC FF7,F
0364:  TBLRD*+
0366:  MOVF   FF5,W
0368:  BTFSC  0E.7
036A:  BSF    FF2.7
036C:  RETURN 0
036E:  DATA 49,6E
0370:  DATA 74,65
0372:  DATA 72,76
0374:  DATA 61,6C
0376:  DATA 6F,20
0378:  DATA 6C,69
037A:  DATA 6D,69
037C:  DATA 74,65
037E:  DATA 0A,64
0380:  DATA 65,20
0382:  DATA 34,20
0384:  DATA 68,6F
0386:  DATA 72,61
0388:  DATA 73,00
038A:  MOVFF  FF2,0E
038E:  BCF    FF2.7
0390:  CLRF   FF7
0392:  ADDLW  A4
0394:  MOVWF  FF6
0396:  MOVLW  03
0398:  ADDWFC FF7,F
039A:  TBLRD*+
039C:  MOVF   FF5,W
039E:  BTFSC  0E.7
03A0:  BSF    FF2.7
03A2:  RETURN 0
03A4:  DATA 54,65
03A6:  DATA 72,6D
03A8:  DATA 6F,73
03AA:  DATA 74,61
03AC:  DATA 74,6F
03AE:  DATA 20,25
03B0:  DATA 69,0A
03B2:  DATA 25,63
03B4:  DATA 43,00
03B6:  MOVFF  FF2,0E
03BA:  BCF    FF2.7
03BC:  CLRF   FF7
03BE:  ADDLW  D0
03C0:  MOVWF  FF6
03C2:  MOVLW  03
03C4:  ADDWFC FF7,F
03C6:  TBLRD*+
03C8:  MOVF   FF5,W
03CA:  BTFSC  0E.7
03CC:  BSF    FF2.7
03CE:  RETURN 0
03D0:  DATA 53,6F
03D2:  DATA 6C,61
03D4:  DATA 70,61
03D6:  DATA 6D,69
03D8:  DATA 65,6E
03DA:  DATA 74,6F
03DC:  DATA 0A,64
03DE:  DATA 65,20
03E0:  DATA 69,6E
03E2:  DATA 74,65
03E4:  DATA 72,76
03E6:  DATA 61,6C
03E8:  DATA 6F,73
03EA:  DATA 21,00
03EC:  MOVFF  FF2,0E
03F0:  BCF    FF2.7
03F2:  CLRF   FF7
03F4:  ADDLW  06
03F6:  MOVWF  FF6
03F8:  MOVLW  04
03FA:  ADDWFC FF7,F
03FC:  TBLRD*+
03FE:  MOVF   FF5,W
0400:  BTFSC  0E.7
0402:  BSF    FF2.7
0404:  RETURN 0
0406:  DATA 20,20
0408:  DATA 43,4C
040A:  DATA 41,56
040C:  DATA 45,3A
040E:  DATA 0A,20
0410:  DATA 20,00
0412:  MOVFF  FF2,0E
0416:  BCF    FF2.7
0418:  CLRF   FF7
041A:  ADDLW  2C
041C:  MOVWF  FF6
041E:  MOVLW  04
0420:  ADDWFC FF7,F
0422:  TBLRD*+
0424:  MOVF   FF5,W
0426:  BTFSC  0E.7
0428:  BSF    FF2.7
042A:  RETURN 0
042C:  DATA 20,20
042E:  DATA 4D,6F
0430:  DATA 64,6F
0432:  DATA 0A,20
0434:  DATA 20,72
0436:  DATA 65,76
0438:  DATA 69,73
043A:  DATA 69,6F
043C:  DATA 6E,00
043E:  MOVFF  FF2,0E
0442:  BCF    FF2.7
0444:  CLRF   FF7
0446:  ADDLW  58
0448:  MOVWF  FF6
044A:  MOVLW  04
044C:  ADDWFC FF7,F
044E:  TBLRD*+
0450:  MOVF   FF5,W
0452:  BTFSC  0E.7
0454:  BSF    FF2.7
0456:  RETURN 0
0458:  DATA 20,20
045A:  DATA 43,6C
045C:  DATA 61,76
045E:  DATA 65,0A
0460:  DATA 20,20
0462:  DATA 69,6E
0464:  DATA 63,6F
0466:  DATA 72,72
0468:  DATA 65,63
046A:  DATA 74,61
046C:  DATA 00,00
046E:  MOVFF  FF2,0E
0472:  BCF    FF2.7
0474:  CLRF   FF7
0476:  ADDLW  88
0478:  MOVWF  FF6
047A:  MOVLW  04
047C:  ADDWFC FF7,F
047E:  TBLRD*+
0480:  MOVF   FF5,W
0482:  BTFSC  0E.7
0484:  BSF    FF2.7
0486:  RETURN 0
0488:  DATA 20,20
048A:  DATA 41,6E
048C:  DATA 75,6C
048E:  DATA 61,6E
0490:  DATA 64,6F
0492:  DATA 0A,20
0494:  DATA 20,6F
0496:  DATA 70,65
0498:  DATA 72,61
049A:  DATA 63,69
049C:  DATA 6F,6E
049E:  DATA 2E,2E
04A0:  DATA 2E,00
04A2:  MOVFF  FF2,0E
04A6:  BCF    FF2.7
04A8:  CLRF   FF7
04AA:  ADDLW  BC
04AC:  MOVWF  FF6
04AE:  MOVLW  04
04B0:  ADDWFC FF7,F
04B2:  TBLRD*+
04B4:  MOVF   FF5,W
04B6:  BTFSC  0E.7
04B8:  BSF    FF2.7
04BA:  RETURN 0
04BC:  DATA 44,65
04BE:  DATA 6D,61
04C0:  DATA 73,69
04C2:  DATA 61,64
04C4:  DATA 6F,20
04C6:  DATA 74,69
04C8:  DATA 65,6D
04CA:  DATA 70,6F
04CC:  DATA 0A,65
04CE:  DATA 6E,63
04D0:  DATA 65,6E
04D2:  DATA 64,69
04D4:  DATA 64,6F
04D6:  DATA 21,00
04D8:  MOVFF  FF2,0E
04DC:  BCF    FF2.7
04DE:  CLRF   FF7
04E0:  ADDLW  F2
04E2:  MOVWF  FF6
04E4:  MOVLW  04
04E6:  ADDWFC FF7,F
04E8:  TBLRD*+
04EA:  MOVF   FF5,W
04EC:  BTFSC  0E.7
04EE:  BSF    FF2.7
04F0:  RETURN 0
04F2:  DATA 0D,49
04F4:  DATA 6E,69
04F6:  DATA 63,69
04F8:  DATA 61,6C
04FA:  DATA 69,7A
04FC:  DATA 61,63
04FE:  DATA 69,6F
0500:  DATA 6E,20
0502:  DATA 64,65
0504:  DATA 6C,20
0506:  DATA 73,69
0508:  DATA 73,74
050A:  DATA 65,6D
050C:  DATA 61,0D
050E:  DATA 00,00
0510:  MOVFF  FF2,0E
0514:  BCF    FF2.7
0516:  CLRF   FF7
0518:  ADDLW  2A
051A:  MOVWF  FF6
051C:  MOVLW  05
051E:  ADDWFC FF7,F
0520:  TBLRD*+
0522:  MOVF   FF5,W
0524:  BTFSC  0E.7
0526:  BSF    FF2.7
0528:  RETURN 0
052A:  DATA 2A,2A
052C:  DATA 2A,2A
052E:  DATA 2A,2A
0530:  DATA 2A,2A
0532:  DATA 2A,2A
0534:  DATA 2A,2A
0536:  DATA 2A,2A
0538:  DATA 2A,2A
053A:  DATA 2A,2A
053C:  DATA 2A,2A
053E:  DATA 2A,2A
0540:  DATA 2A,2A
0542:  DATA 2A,2A
0544:  DATA 0D,00
0546:  MOVFF  FF2,0E
054A:  BCF    FF2.7
054C:  CLRF   FF7
054E:  ADDLW  60
0550:  MOVWF  FF6
0552:  MOVLW  05
0554:  ADDWFC FF7,F
0556:  TBLRD*+
0558:  MOVF   FF5,W
055A:  BTFSC  0E.7
055C:  BSF    FF2.7
055E:  RETURN 0
0560:  DATA 44,69
0562:  DATA 61,20
0564:  DATA 64,65
0566:  DATA 20,6C
0568:  DATA 61,20
056A:  DATA 73,65
056C:  DATA 6D,61
056E:  DATA 6E,61
0570:  DATA 20,28
0572:  DATA 31,2D
0574:  DATA 3E,4C
0576:  DATA 75,6E
0578:  DATA 65,73
057A:  DATA 2C,20
057C:  DATA 32,2D
057E:  DATA 3E,4D
0580:  DATA 61,72
0582:  DATA 74,65
0584:  DATA 73,2C
0586:  DATA 20,2E
0588:  DATA 2E,2E
058A:  DATA 29,3A
058C:  DATA 20,4C
058E:  DATA 55,4E
0590:  DATA 45,53
0592:  DATA 20,20
0594:  DATA 20,20
0596:  DATA 00,00
0598:  MOVFF  FF2,0E
059C:  BCF    FF2.7
059E:  CLRF   FF7
05A0:  ADDLW  B2
05A2:  MOVWF  FF6
05A4:  MOVLW  05
05A6:  ADDWFC FF7,F
05A8:  TBLRD*+
05AA:  MOVF   FF5,W
05AC:  BTFSC  0E.7
05AE:  BSF    FF2.7
05B0:  RETURN 0
05B2:  DATA 08,08
05B4:  DATA 08,08
05B6:  DATA 08,08
05B8:  DATA 08,08
05BA:  DATA 08,4C
05BC:  DATA 55,4E
05BE:  DATA 45,53
05C0:  DATA 20,20
05C2:  DATA 20,20
05C4:  DATA 00,00
05C6:  MOVFF  FF2,0E
05CA:  BCF    FF2.7
05CC:  CLRF   FF7
05CE:  ADDLW  E0
05D0:  MOVWF  FF6
05D2:  MOVLW  05
05D4:  ADDWFC FF7,F
05D6:  TBLRD*+
05D8:  MOVF   FF5,W
05DA:  BTFSC  0E.7
05DC:  BSF    FF2.7
05DE:  RETURN 0
05E0:  DATA 08,08
05E2:  DATA 08,08
05E4:  DATA 08,08
05E6:  DATA 08,08
05E8:  DATA 08,4D
05EA:  DATA 41,52
05EC:  DATA 54,45
05EE:  DATA 53,20
05F0:  DATA 20,20
05F2:  DATA 00,00
05F4:  MOVFF  FF2,0E
05F8:  BCF    FF2.7
05FA:  CLRF   FF7
05FC:  ADDLW  0E
05FE:  MOVWF  FF6
0600:  MOVLW  06
0602:  ADDWFC FF7,F
0604:  TBLRD*+
0606:  MOVF   FF5,W
0608:  BTFSC  0E.7
060A:  BSF    FF2.7
060C:  RETURN 0
060E:  DATA 08,08
0610:  DATA 08,08
0612:  DATA 08,08
0614:  DATA 08,08
0616:  DATA 08,4D
0618:  DATA 49,45
061A:  DATA 52,43
061C:  DATA 4F,4C
061E:  DATA 45,53
0620:  DATA 00,00
0622:  MOVFF  FF2,0E
0626:  BCF    FF2.7
0628:  CLRF   FF7
062A:  ADDLW  3C
062C:  MOVWF  FF6
062E:  MOVLW  06
0630:  ADDWFC FF7,F
0632:  TBLRD*+
0634:  MOVF   FF5,W
0636:  BTFSC  0E.7
0638:  BSF    FF2.7
063A:  RETURN 0
063C:  DATA 08,08
063E:  DATA 08,08
0640:  DATA 08,08
0642:  DATA 08,08
0644:  DATA 08,4A
0646:  DATA 55,45
0648:  DATA 56,45
064A:  DATA 53,20
064C:  DATA 20,20
064E:  DATA 00,00
0650:  MOVFF  FF2,0E
0654:  BCF    FF2.7
0656:  CLRF   FF7
0658:  ADDLW  6A
065A:  MOVWF  FF6
065C:  MOVLW  06
065E:  ADDWFC FF7,F
0660:  TBLRD*+
0662:  MOVF   FF5,W
0664:  BTFSC  0E.7
0666:  BSF    FF2.7
0668:  RETURN 0
066A:  DATA 08,08
066C:  DATA 08,08
066E:  DATA 08,08
0670:  DATA 08,08
0672:  DATA 08,56
0674:  DATA 49,45
0676:  DATA 52,4E
0678:  DATA 45,53
067A:  DATA 20,20
067C:  DATA 00,00
067E:  MOVFF  FF2,0E
0682:  BCF    FF2.7
0684:  CLRF   FF7
0686:  ADDLW  98
0688:  MOVWF  FF6
068A:  MOVLW  06
068C:  ADDWFC FF7,F
068E:  TBLRD*+
0690:  MOVF   FF5,W
0692:  BTFSC  0E.7
0694:  BSF    FF2.7
0696:  RETURN 0
0698:  DATA 08,08
069A:  DATA 08,08
069C:  DATA 08,08
069E:  DATA 08,08
06A0:  DATA 08,53
06A2:  DATA 41,42
06A4:  DATA 41,44
06A6:  DATA 4F,20
06A8:  DATA 20,20
06AA:  DATA 00,00
06AC:  MOVFF  FF2,0E
06B0:  BCF    FF2.7
06B2:  CLRF   FF7
06B4:  ADDLW  C6
06B6:  MOVWF  FF6
06B8:  MOVLW  06
06BA:  ADDWFC FF7,F
06BC:  TBLRD*+
06BE:  MOVF   FF5,W
06C0:  BTFSC  0E.7
06C2:  BSF    FF2.7
06C4:  RETURN 0
06C6:  DATA 08,08
06C8:  DATA 08,08
06CA:  DATA 08,08
06CC:  DATA 08,08
06CE:  DATA 08,44
06D0:  DATA 4F,4D
06D2:  DATA 49,4E
06D4:  DATA 47,4F
06D6:  DATA 20,20
06D8:  DATA 00,00
06DA:  MOVFF  FF2,0E
06DE:  BCF    FF2.7
06E0:  CLRF   FF7
06E2:  ADDLW  F4
06E4:  MOVWF  FF6
06E6:  MOVLW  06
06E8:  ADDWFC FF7,F
06EA:  TBLRD*+
06EC:  MOVF   FF5,W
06EE:  BTFSC  0E.7
06F0:  BSF    FF2.7
06F2:  RETURN 0
06F4:  DATA 0D,46
06F6:  DATA 45,43
06F8:  DATA 48,41
06FA:  DATA 3A,20
06FC:  DATA 00,00
06FE:  MOVFF  FF2,0E
0702:  BCF    FF2.7
0704:  CLRF   FF7
0706:  ADDLW  18
0708:  MOVWF  FF6
070A:  MOVLW  07
070C:  ADDWFC FF7,F
070E:  TBLRD*+
0710:  MOVF   FF5,W
0712:  BTFSC  0E.7
0714:  BSF    FF2.7
0716:  RETURN 0
0718:  DATA 0D,52
071A:  DATA 65,73
071C:  DATA 65,74
071E:  DATA 65,61
0720:  DATA 6E,64
0722:  DATA 6F,20
0724:  DATA 69,6E
0726:  DATA 69,63
0728:  DATA 69,61
072A:  DATA 6C,69
072C:  DATA 7A,61
072E:  DATA 63,69
0730:  DATA 6F,6E
0732:  DATA 2E,2E
0734:  DATA 2E,0D
0736:  DATA 00,00
0738:  MOVFF  FF2,0E
073C:  BCF    FF2.7
073E:  CLRF   FF7
0740:  ADDLW  52
0742:  MOVWF  FF6
0744:  MOVLW  07
0746:  ADDWFC FF7,F
0748:  TBLRD*+
074A:  MOVF   FF5,W
074C:  BTFSC  0E.7
074E:  BSF    FF2.7
0750:  RETURN 0
0752:  DATA 0D,44
0754:  DATA 69,61
0756:  DATA 20,69
0758:  DATA 6E,63
075A:  DATA 6F,72
075C:  DATA 72,65
075E:  DATA 63,74
0760:  DATA 6F,2E
0762:  DATA 20,52
0764:  DATA 65,73
0766:  DATA 65,74
0768:  DATA 65,61
076A:  DATA 6E,64
076C:  DATA 6F,20
076E:  DATA 69,6E
0770:  DATA 69,63
0772:  DATA 69,61
0774:  DATA 6C,69
0776:  DATA 7A,61
0778:  DATA 63,69
077A:  DATA 6F,6E
077C:  DATA 2E,2E
077E:  DATA 2E,0D
0780:  DATA 00,00
0782:  MOVFF  FF2,0E
0786:  BCF    FF2.7
0788:  CLRF   FF7
078A:  ADDLW  9C
078C:  MOVWF  FF6
078E:  MOVLW  07
0790:  ADDWFC FF7,F
0792:  TBLRD*+
0794:  MOVF   FF5,W
0796:  BTFSC  0E.7
0798:  BSF    FF2.7
079A:  RETURN 0
079C:  DATA 2F,00
079E:  MOVFF  FF2,0E
07A2:  BCF    FF2.7
07A4:  CLRF   FF7
07A6:  ADDLW  B8
07A8:  MOVWF  FF6
07AA:  MOVLW  07
07AC:  ADDWFC FF7,F
07AE:  TBLRD*+
07B0:  MOVF   FF5,W
07B2:  BTFSC  0E.7
07B4:  BSF    FF2.7
07B6:  RETURN 0
07B8:  DATA 0D,4D
07BA:  DATA 65,73
07BC:  DATA 20,69
07BE:  DATA 6E,63
07C0:  DATA 6F,72
07C2:  DATA 72,65
07C4:  DATA 63,74
07C6:  DATA 6F,2E
07C8:  DATA 20,52
07CA:  DATA 65,73
07CC:  DATA 65,74
07CE:  DATA 65,61
07D0:  DATA 6E,64
07D2:  DATA 6F,20
07D4:  DATA 69,6E
07D6:  DATA 69,63
07D8:  DATA 69,61
07DA:  DATA 6C,69
07DC:  DATA 7A,61
07DE:  DATA 63,69
07E0:  DATA 6F,6E
07E2:  DATA 2E,2E
07E4:  DATA 2E,0D
07E6:  DATA 00,00
07E8:  MOVFF  FF2,0E
07EC:  BCF    FF2.7
07EE:  CLRF   FF7
07F0:  ADDLW  02
07F2:  MOVWF  FF6
07F4:  MOVLW  08
07F6:  ADDWFC FF7,F
07F8:  TBLRD*+
07FA:  MOVF   FF5,W
07FC:  BTFSC  0E.7
07FE:  BSF    FF2.7
0800:  RETURN 0
0802:  DATA 0D,45
0804:  DATA 72,72
0806:  DATA 6F,72
0808:  DATA 20,65
080A:  DATA 6E,20
080C:  DATA 6C,61
080E:  DATA 20,66
0810:  DATA 65,63
0812:  DATA 68,61
0814:  DATA 2E,20
0816:  DATA 52,65
0818:  DATA 73,65
081A:  DATA 74,65
081C:  DATA 61,6E
081E:  DATA 64,6F
0820:  DATA 20,69
0822:  DATA 6E,69
0824:  DATA 63,69
0826:  DATA 61,6C
0828:  DATA 69,7A
082A:  DATA 61,63
082C:  DATA 69,6F
082E:  DATA 6E,2E
0830:  DATA 2E,2E
0832:  DATA 0D,00
0834:  MOVFF  FF2,0E
0838:  BCF    FF2.7
083A:  CLRF   FF7
083C:  ADDLW  4E
083E:  MOVWF  FF6
0840:  MOVLW  08
0842:  ADDWFC FF7,F
0844:  TBLRD*+
0846:  MOVF   FF5,W
0848:  BTFSC  0E.7
084A:  BSF    FF2.7
084C:  RETURN 0
084E:  DATA 0D,41
0850:  DATA 6E,6E
0852:  DATA 6F,20
0854:  DATA 69,6E
0856:  DATA 63,6F
0858:  DATA 72,72
085A:  DATA 65,63
085C:  DATA 74,6F
085E:  DATA 2E,20
0860:  DATA 52,65
0862:  DATA 73,65
0864:  DATA 74,65
0866:  DATA 61,6E
0868:  DATA 64,6F
086A:  DATA 20,69
086C:  DATA 6E,69
086E:  DATA 63,69
0870:  DATA 61,6C
0872:  DATA 69,7A
0874:  DATA 61,63
0876:  DATA 69,6F
0878:  DATA 6E,2E
087A:  DATA 2E,2E
087C:  DATA 0D,00
087E:  MOVFF  FF2,0E
0882:  BCF    FF2.7
0884:  CLRF   FF7
0886:  ADDLW  98
0888:  MOVWF  FF6
088A:  MOVLW  08
088C:  ADDWFC FF7,F
088E:  TBLRD*+
0890:  MOVF   FF5,W
0892:  BTFSC  0E.7
0894:  BSF    FF2.7
0896:  RETURN 0
0898:  DATA 0D,45
089A:  DATA 6C,20
089C:  DATA 61,6E
089E:  DATA 6E,6F
08A0:  DATA 20,6E
08A2:  DATA 6F,20
08A4:  DATA 65,73
08A6:  DATA 20,62
08A8:  DATA 69,73
08AA:  DATA 69,65
08AC:  DATA 73,74
08AE:  DATA 6F,2E
08B0:  DATA 20,52
08B2:  DATA 65,73
08B4:  DATA 65,74
08B6:  DATA 65,61
08B8:  DATA 6E,64
08BA:  DATA 6F,20
08BC:  DATA 69,6E
08BE:  DATA 69,63
08C0:  DATA 69,61
08C2:  DATA 6C,69
08C4:  DATA 7A,61
08C6:  DATA 63,69
08C8:  DATA 6F,6E
08CA:  DATA 2E,2E
08CC:  DATA 2E,0D
08CE:  DATA 00,00
08D0:  MOVFF  FF2,0E
08D4:  BCF    FF2.7
08D6:  CLRF   FF7
08D8:  ADDLW  EA
08DA:  MOVWF  FF6
08DC:  MOVLW  08
08DE:  ADDWFC FF7,F
08E0:  TBLRD*+
08E2:  MOVF   FF5,W
08E4:  BTFSC  0E.7
08E6:  BSF    FF2.7
08E8:  RETURN 0
08EA:  DATA 0D,48
08EC:  DATA 4F,52
08EE:  DATA 41,3A
08F0:  DATA 20,00
08F2:  MOVFF  FF2,0E
08F6:  BCF    FF2.7
08F8:  CLRF   FF7
08FA:  ADDLW  0C
08FC:  MOVWF  FF6
08FE:  MOVLW  09
0900:  ADDWFC FF7,F
0902:  TBLRD*+
0904:  MOVF   FF5,W
0906:  BTFSC  0E.7
0908:  BSF    FF2.7
090A:  RETURN 0
090C:  DATA 0D,52
090E:  DATA 65,73
0910:  DATA 65,74
0912:  DATA 65,61
0914:  DATA 6E,64
0916:  DATA 6F,20
0918:  DATA 6C,61
091A:  DATA 20,69
091C:  DATA 6E,69
091E:  DATA 63,69
0920:  DATA 61,6C
0922:  DATA 69,7A
0924:  DATA 61,63
0926:  DATA 69,6F
0928:  DATA 6E,2E
092A:  DATA 2E,2E
092C:  DATA 0D,00
092E:  MOVFF  FF2,0E
0932:  BCF    FF2.7
0934:  CLRF   FF7
0936:  ADDLW  48
0938:  MOVWF  FF6
093A:  MOVLW  09
093C:  ADDWFC FF7,F
093E:  TBLRD*+
0940:  MOVF   FF5,W
0942:  BTFSC  0E.7
0944:  BSF    FF2.7
0946:  RETURN 0
0948:  DATA 20,20
094A:  DATA 48,6F
094C:  DATA 72,61
094E:  DATA 20,69
0950:  DATA 6E,63
0952:  DATA 6F,72
0954:  DATA 72,65
0956:  DATA 63,74
0958:  DATA 61,21
095A:  DATA 00,00
095C:  MOVFF  FF2,0E
0960:  BCF    FF2.7
0962:  CLRF   FF7
0964:  ADDLW  76
0966:  MOVWF  FF6
0968:  MOVLW  09
096A:  ADDWFC FF7,F
096C:  TBLRD*+
096E:  MOVF   FF5,W
0970:  BTFSC  0E.7
0972:  BSF    FF2.7
0974:  RETURN 0
0976:  DATA 3A,00
0978:  MOVFF  FF2,0E
097C:  BCF    FF2.7
097E:  CLRF   FF7
0980:  ADDLW  92
0982:  MOVWF  FF6
0984:  MOVLW  09
0986:  ADDWFC FF7,F
0988:  TBLRD*+
098A:  MOVF   FF5,W
098C:  BTFSC  0E.7
098E:  BSF    FF2.7
0990:  RETURN 0
0992:  DATA 20,20
0994:  DATA 4D,69
0996:  DATA 6E,75
0998:  DATA 74,6F
099A:  DATA 73,20
099C:  DATA 69,6E
099E:  DATA 63,6F
09A0:  DATA 72,72
09A2:  DATA 65,63
09A4:  DATA 74,6F
09A6:  DATA 73,21
09A8:  DATA 00,00
09AA:  MOVFF  FF2,0E
09AE:  BCF    FF2.7
09B0:  CLRF   FF7
09B2:  ADDLW  C4
09B4:  MOVWF  FF6
09B6:  MOVLW  09
09B8:  ADDWFC FF7,F
09BA:  TBLRD*+
09BC:  MOVF   FF5,W
09BE:  BTFSC  0E.7
09C0:  BSF    FF2.7
09C2:  RETURN 0
09C4:  DATA 0D,47
09C6:  DATA 75,61
09C8:  DATA 72,64
09CA:  DATA 61,6E
09CC:  DATA 64,6F
09CE:  DATA 20,63
09D0:  DATA 6F,6E
09D2:  DATA 66,69
09D4:  DATA 67,75
09D6:  DATA 72,61
09D8:  DATA 63,69
09DA:  DATA 6F,6E
09DC:  DATA 2E,2E
09DE:  DATA 2E,00
09E0:  MOVFF  FF2,0E
09E4:  BCF    FF2.7
09E6:  CLRF   FF7
09E8:  ADDLW  FA
09EA:  MOVWF  FF6
09EC:  MOVLW  09
09EE:  ADDWFC FF7,F
09F0:  TBLRD*+
09F2:  MOVF   FF5,W
09F4:  BTFSC  0E.7
09F6:  BSF    FF2.7
09F8:  RETURN 0
09FA:  DATA 0D,49
09FC:  DATA 6E,69
09FE:  DATA 63,69
0A00:  DATA 61,6E
0A02:  DATA 64,6F
0A04:  DATA 20,73
0A06:  DATA 69,73
0A08:  DATA 74,65
0A0A:  DATA 6D,61
0A0C:  DATA 2E,2E
0A0E:  DATA 2E,0D
0A10:  DATA 00,00
0A12:  MOVFF  FF2,0E
0A16:  BCF    FF2.7
0A18:  CLRF   FF7
0A1A:  ADDLW  2C
0A1C:  MOVWF  FF6
0A1E:  MOVLW  0A
0A20:  ADDWFC FF7,F
0A22:  TBLRD*+
0A24:  MOVF   FF5,W
0A26:  BTFSC  0E.7
0A28:  BSF    FF2.7
0A2A:  RETURN 0
0A2C:  DATA 25,33
0A2E:  DATA 2E,31
0A30:  DATA 66,25
0A32:  DATA 63,43
0A34:  DATA 20,20
0A36:  DATA 25,33
0A38:  DATA 2E,31
0A3A:  DATA 66,25
0A3C:  DATA 63,43
0A3E:  DATA 0A,48
0A40:  DATA 4F,52
0A42:  DATA 41,20
0A44:  DATA 2D,20
0A46:  DATA 00,00
0A48:  MOVFF  FF2,0E
0A4C:  BCF    FF2.7
0A4E:  CLRF   FF7
0A50:  ADDLW  62
0A52:  MOVWF  FF6
0A54:  MOVLW  0A
0A56:  ADDWFC FF7,F
0A58:  TBLRD*+
0A5A:  MOVF   FF5,W
0A5C:  BTFSC  0E.7
0A5E:  BSF    FF2.7
0A60:  RETURN 0
0A62:  DATA 30,00
0A64:  MOVFF  FF2,0E
0A68:  BCF    FF2.7
0A6A:  CLRF   FF7
0A6C:  ADDLW  7E
0A6E:  MOVWF  FF6
0A70:  MOVLW  0A
0A72:  ADDWFC FF7,F
0A74:  TBLRD*+
0A76:  MOVF   FF5,W
0A78:  BTFSC  0E.7
0A7A:  BSF    FF2.7
0A7C:  RETURN 0
0A7E:  DATA 0D,52
0A80:  DATA 45,47
0A82:  DATA 49,53
0A84:  DATA 54,52
0A86:  DATA 4F,20
0A88:  DATA 44,45
0A8A:  DATA 20,45
0A8C:  DATA 56,45
0A8E:  DATA 4E,54
0A90:  DATA 4F,53
0A92:  DATA 0D,00
0A94:  MOVFF  FF2,0E
0A98:  BCF    FF2.7
0A9A:  CLRF   FF7
0A9C:  ADDLW  AE
0A9E:  MOVWF  FF6
0AA0:  MOVLW  0A
0AA2:  ADDWFC FF7,F
0AA4:  TBLRD*+
0AA6:  MOVF   FF5,W
0AA8:  BTFSC  0E.7
0AAA:  BSF    FF2.7
0AAC:  RETURN 0
0AAE:  DATA 2A,2A
0AB0:  DATA 2A,2A
0AB2:  DATA 2A,2A
0AB4:  DATA 2A,2A
0AB6:  DATA 2A,2A
0AB8:  DATA 2A,2A
0ABA:  DATA 2A,2A
0ABC:  DATA 2A,2A
0ABE:  DATA 2A,2A
0AC0:  DATA 2A,0D
0AC2:  DATA 00,00
0AC4:  MOVFF  FF2,0E
0AC8:  BCF    FF2.7
0ACA:  CLRF   FF7
0ACC:  ADDLW  DE
0ACE:  MOVWF  FF6
0AD0:  MOVLW  0A
0AD2:  ADDWFC FF7,F
0AD4:  TBLRD*+
0AD6:  MOVF   FF5,W
0AD8:  BTFSC  0E.7
0ADA:  BSF    FF2.7
0ADC:  RETURN 0
0ADE:  DATA 4D,6F
0AE0:  DATA 6D,65
0AE2:  DATA 6E,74
0AE4:  DATA 6F,20
0AE6:  DATA 64,65
0AE8:  DATA 20,61
0AEA:  DATA 70,61
0AEC:  DATA 67,61
0AEE:  DATA 64,6F
0AF0:  DATA 20,20
0AF2:  DATA 20,20
0AF4:  DATA 20,54
0AF6:  DATA 65,6D
0AF8:  DATA 70,65
0AFA:  DATA 72,61
0AFC:  DATA 74,75
0AFE:  DATA 72,61
0B00:  DATA 31,20
0B02:  DATA 20,20
0B04:  DATA 20,20
0B06:  DATA 20,20
0B08:  DATA 54,65
0B0A:  DATA 6D,70
0B0C:  DATA 65,72
0B0E:  DATA 61,74
0B10:  DATA 75,72
0B12:  DATA 61,32
0B14:  DATA 20,20
0B16:  DATA 20,20
0B18:  DATA 20,20
0B1A:  DATA 20,20
0B1C:  DATA 20,54
0B1E:  DATA 65,72
0B20:  DATA 6D,6F
0B22:  DATA 73,74
0B24:  DATA 61,74
0B26:  DATA 6F,20
0B28:  DATA 20,20
0B2A:  DATA 20,20
0B2C:  DATA 20,20
0B2E:  DATA 20,4D
0B30:  DATA 69,6E
0B32:  DATA 75,74
0B34:  DATA 6F,73
0B36:  DATA 20,65
0B38:  DATA 6E,63
0B3A:  DATA 65,6E
0B3C:  DATA 64,69
0B3E:  DATA 64,6F
0B40:  DATA 20,20
0B42:  DATA 20,20
0B44:  DATA 20,20
0B46:  DATA 20,4D
0B48:  DATA 69,6E
0B4A:  DATA 75,74
0B4C:  DATA 6F,73
0B4E:  DATA 20,63
0B50:  DATA 61,6C
0B52:  DATA 64,65
0B54:  DATA 72,61
0B56:  DATA 0D,00
0B58:  MOVFF  FF2,0E
0B5C:  BCF    FF2.7
0B5E:  CLRF   FF7
0B60:  ADDLW  72
0B62:  MOVWF  FF6
0B64:  MOVLW  0B
0B66:  ADDWFC FF7,F
0B68:  TBLRD*+
0B6A:  MOVF   FF5,W
0B6C:  BTFSC  0E.7
0B6E:  BSF    FF2.7
0B70:  RETURN 0
0B72:  DATA 3D,3D
0B74:  DATA 3D,3D
0B76:  DATA 3D,3D
0B78:  DATA 3D,3D
0B7A:  DATA 3D,3D
0B7C:  DATA 3D,3D
0B7E:  DATA 3D,3D
0B80:  DATA 3D,3D
0B82:  DATA 3D,3D
0B84:  DATA 3D,3D
0B86:  DATA 3D,3D
0B88:  DATA 3D,3D
0B8A:  DATA 3D,3D
0B8C:  DATA 3D,3D
0B8E:  DATA 3D,3D
0B90:  DATA 3D,3D
0B92:  DATA 3D,3D
0B94:  DATA 3D,3D
0B96:  DATA 3D,3D
0B98:  DATA 3D,3D
0B9A:  DATA 3D,3D
0B9C:  DATA 3D,3D
0B9E:  DATA 3D,3D
0BA0:  DATA 3D,3D
0BA2:  DATA 3D,3D
0BA4:  DATA 3D,3D
0BA6:  DATA 3D,3D
0BA8:  DATA 3D,3D
0BAA:  DATA 3D,3D
0BAC:  DATA 3D,3D
0BAE:  DATA 3D,3D
0BB0:  DATA 3D,3D
0BB2:  DATA 3D,3D
0BB4:  DATA 3D,3D
0BB6:  DATA 3D,3D
0BB8:  DATA 3D,3D
0BBA:  DATA 3D,3D
0BBC:  DATA 3D,3D
0BBE:  DATA 3D,3D
0BC0:  DATA 3D,3D
0BC2:  DATA 3D,3D
0BC4:  DATA 3D,3D
0BC6:  DATA 3D,3D
0BC8:  DATA 3D,3D
0BCA:  DATA 3D,3D
0BCC:  DATA 3D,3D
0BCE:  DATA 3D,3D
0BD0:  DATA 3D,3D
0BD2:  DATA 3D,3D
0BD4:  DATA 3D,3D
0BD6:  DATA 3D,3D
0BD8:  DATA 3D,3D
0BDA:  DATA 3D,3D
0BDC:  DATA 3D,3D
0BDE:  DATA 3D,3D
0BE0:  DATA 3D,3D
0BE2:  DATA 3D,3D
0BE4:  DATA 3D,3D
0BE6:  DATA 3D,3D
0BE8:  DATA 3D,3D
0BEA:  DATA 3D,3D
0BEC:  DATA 3D,0D
0BEE:  DATA 00,00
0BF0:  MOVFF  FF2,0E
0BF4:  BCF    FF2.7
0BF6:  CLRF   FF7
0BF8:  ADDLW  0A
0BFA:  MOVWF  FF6
0BFC:  MOVLW  0C
0BFE:  ADDWFC FF7,F
0C00:  TBLRD*+
0C02:  MOVF   FF5,W
0C04:  BTFSC  0E.7
0C06:  BSF    FF2.7
0C08:  RETURN 0
0C0A:  DATA 20,00
0C0C:  MOVFF  FF2,0E
0C10:  BCF    FF2.7
0C12:  CLRF   FF7
0C14:  ADDLW  26
0C16:  MOVWF  FF6
0C18:  MOVLW  0C
0C1A:  ADDWFC FF7,F
0C1C:  TBLRD*+
0C1E:  MOVF   FF5,W
0C20:  BTFSC  0E.7
0C22:  BSF    FF2.7
0C24:  RETURN 0
0C26:  DATA 0D,3D
0C28:  DATA 3D,3D
0C2A:  DATA 3D,3D
0C2C:  DATA 3D,3D
0C2E:  DATA 3D,3D
0C30:  DATA 3D,3D
0C32:  DATA 3D,3D
0C34:  DATA 3D,3D
0C36:  DATA 3D,3D
0C38:  DATA 3D,3D
0C3A:  DATA 3D,3D
0C3C:  DATA 3D,3D
0C3E:  DATA 3D,3D
0C40:  DATA 3D,3D
0C42:  DATA 3D,3D
0C44:  DATA 3D,3D
0C46:  DATA 3D,3D
0C48:  DATA 3D,3D
0C4A:  DATA 3D,3D
0C4C:  DATA 3D,3D
0C4E:  DATA 3D,3D
0C50:  DATA 3D,3D
0C52:  DATA 3D,3D
0C54:  DATA 3D,3D
0C56:  DATA 3D,3D
0C58:  DATA 3D,3D
0C5A:  DATA 3D,3D
0C5C:  DATA 3D,3D
0C5E:  DATA 3D,3D
0C60:  DATA 3D,3D
0C62:  DATA 3D,3D
0C64:  DATA 3D,3D
0C66:  DATA 3D,3D
0C68:  DATA 3D,3D
0C6A:  DATA 3D,3D
0C6C:  DATA 3D,3D
0C6E:  DATA 3D,3D
0C70:  DATA 3D,3D
0C72:  DATA 3D,3D
0C74:  DATA 3D,3D
0C76:  DATA 3D,3D
0C78:  DATA 3D,3D
0C7A:  DATA 3D,3D
0C7C:  DATA 3D,3D
0C7E:  DATA 3D,3D
0C80:  DATA 3D,3D
0C82:  DATA 3D,3D
0C84:  DATA 3D,3D
0C86:  DATA 3D,3D
0C88:  DATA 3D,3D
0C8A:  DATA 3D,3D
0C8C:  DATA 3D,3D
0C8E:  DATA 3D,3D
0C90:  DATA 3D,3D
0C92:  DATA 3D,3D
0C94:  DATA 3D,3D
0C96:  DATA 3D,3D
0C98:  DATA 3D,3D
0C9A:  DATA 3D,3D
0C9C:  DATA 3D,3D
0C9E:  DATA 3D,3D
0CA0:  DATA 3D,3D
0CA2:  DATA 0D,00
0CA4:  MOVFF  FF2,0E
0CA8:  BCF    FF2.7
0CAA:  CLRF   FF7
0CAC:  ADDLW  BE
0CAE:  MOVWF  FF6
0CB0:  MOVLW  0C
0CB2:  ADDWFC FF7,F
0CB4:  TBLRD*+
0CB6:  MOVF   FF5,W
0CB8:  BTFSC  0E.7
0CBA:  BSF    FF2.7
0CBC:  RETURN 0
0CBE:  DATA BF,51
0CC0:  DATA 75,65
0CC2:  DATA 20,6F
0CC4:  DATA 70,65
0CC6:  DATA 72,61
0CC8:  DATA 63,69
0CCA:  DATA 6F,6E
0CCC:  DATA 20,64
0CCE:  DATA 65,73
0CD0:  DATA 65,61
0CD2:  DATA 20,72
0CD4:  DATA 65,61
0CD6:  DATA 6C,69
0CD8:  DATA 7A,61
0CDA:  DATA 72,3F
0CDC:  DATA 0D,00
0CDE:  MOVFF  FF2,0E
0CE2:  BCF    FF2.7
0CE4:  CLRF   FF7
0CE6:  ADDLW  F8
0CE8:  MOVWF  FF6
0CEA:  MOVLW  0C
0CEC:  ADDWFC FF7,F
0CEE:  TBLRD*+
0CF0:  MOVF   FF5,W
0CF2:  BTFSC  0E.7
0CF4:  BSF    FF2.7
0CF6:  RETURN 0
0CF8:  DATA 30,2E
0CFA:  DATA 20,53
0CFC:  DATA 61,6C
0CFE:  DATA 69,72
0D00:  DATA 0D,00
0D02:  MOVFF  FF2,0E
0D06:  BCF    FF2.7
0D08:  CLRF   FF7
0D0A:  ADDLW  1C
0D0C:  MOVWF  FF6
0D0E:  MOVLW  0D
0D10:  ADDWFC FF7,F
0D12:  TBLRD*+
0D14:  MOVF   FF5,W
0D16:  BTFSC  0E.7
0D18:  BSF    FF2.7
0D1A:  RETURN 0
0D1C:  DATA 31,2E
0D1E:  DATA 20,45
0D20:  DATA 78,74
0D22:  DATA 72,61
0D24:  DATA 65,72
0D26:  DATA 20,74
0D28:  DATA 69,65
0D2A:  DATA 6D,70
0D2C:  DATA 6F,73
0D2E:  DATA 20,6D
0D30:  DATA 65,64
0D32:  DATA 69,6F
0D34:  DATA 73,20
0D36:  DATA 70,6F
0D38:  DATA 72,20
0D3A:  DATA 64,69
0D3C:  DATA 61,0D
0D3E:  DATA 00,00
0D40:  MOVFF  FF2,0E
0D44:  BCF    FF2.7
0D46:  CLRF   FF7
0D48:  ADDLW  5A
0D4A:  MOVWF  FF6
0D4C:  MOVLW  0D
0D4E:  ADDWFC FF7,F
0D50:  TBLRD*+
0D52:  MOVF   FF5,W
0D54:  BTFSC  0E.7
0D56:  BSF    FF2.7
0D58:  RETURN 0
0D5A:  DATA 32,2E
0D5C:  DATA 20,45
0D5E:  DATA 78,74
0D60:  DATA 72,61
0D62:  DATA 65,72
0D64:  DATA 20,74
0D66:  DATA 69,65
0D68:  DATA 6D,70
0D6A:  DATA 6F,73
0D6C:  DATA 20,74
0D6E:  DATA 6F,74
0D70:  DATA 61,6C
0D72:  DATA 65,73
0D74:  DATA 0D,00
0D76:  MOVFF  FF2,0E
0D7A:  BCF    FF2.7
0D7C:  CLRF   FF7
0D7E:  ADDLW  90
0D80:  MOVWF  FF6
0D82:  MOVLW  0D
0D84:  ADDWFC FF7,F
0D86:  TBLRD*+
0D88:  MOVF   FF5,W
0D8A:  BTFSC  0E.7
0D8C:  BSF    FF2.7
0D8E:  RETURN 0
0D90:  DATA 33,2E
0D92:  DATA 20,45
0D94:  DATA 78,74
0D96:  DATA 72,61
0D98:  DATA 65,72
0D9A:  DATA 20,64
0D9C:  DATA 61,74
0D9E:  DATA 6F,73
0DA0:  DATA 20,6D
0DA2:  DATA 65,6E
0DA4:  DATA 73,75
0DA6:  DATA 61,6C
0DA8:  DATA 65,73
0DAA:  DATA 0D,00
0DAC:  MOVFF  FF2,0E
0DB0:  BCF    FF2.7
0DB2:  CLRF   FF7
0DB4:  ADDLW  C6
0DB6:  MOVWF  FF6
0DB8:  MOVLW  0D
0DBA:  ADDWFC FF7,F
0DBC:  TBLRD*+
0DBE:  MOVF   FF5,W
0DC0:  BTFSC  0E.7
0DC2:  BSF    FF2.7
0DC4:  RETURN 0
0DC6:  DATA 0D,53
0DC8:  DATA 61,6C
0DCA:  DATA 69,65
0DCC:  DATA 6E,64
0DCE:  DATA 6F,2E
0DD0:  DATA 2E,2E
0DD2:  DATA 0D,00
0DD4:  MOVFF  FF2,0E
0DD8:  BCF    FF2.7
0DDA:  CLRF   FF7
0DDC:  ADDLW  EE
0DDE:  MOVWF  FF6
0DE0:  MOVLW  0D
0DE2:  ADDWFC FF7,F
0DE4:  TBLRD*+
0DE6:  MOVF   FF5,W
0DE8:  BTFSC  0E.7
0DEA:  BSF    FF2.7
0DEC:  RETURN 0
0DEE:  DATA 0D,54
0DF0:  DATA 69,65
0DF2:  DATA 6D,70
0DF4:  DATA 6F,20
0DF6:  DATA 6D,65
0DF8:  DATA 64,69
0DFA:  DATA 6F,20
0DFC:  DATA 64,65
0DFE:  DATA 20,65
0E00:  DATA 6E,63
0E02:  DATA 65,6E
0E04:  DATA 64,69
0E06:  DATA 64,6F
0E08:  DATA 20,64
0E0A:  DATA 65,6C
0E0C:  DATA 20,73
0E0E:  DATA 69,73
0E10:  DATA 74,65
0E12:  DATA 6D,61
0E14:  DATA 20,70
0E16:  DATA 6F,72
0E18:  DATA 20,64
0E1A:  DATA 69,61
0E1C:  DATA 3A,20
0E1E:  DATA 25,33
0E20:  DATA 2E,32
0E22:  DATA 66,20
0E24:  DATA 6D,69
0E26:  DATA 6E,75
0E28:  DATA 74,6F
0E2A:  DATA 73,0D
0E2C:  DATA 0D,00
0E2E:  MOVFF  FF2,0E
0E32:  BCF    FF2.7
0E34:  CLRF   FF7
0E36:  ADDLW  48
0E38:  MOVWF  FF6
0E3A:  MOVLW  0E
0E3C:  ADDWFC FF7,F
0E3E:  TBLRD*+
0E40:  MOVF   FF5,W
0E42:  BTFSC  0E.7
0E44:  BSF    FF2.7
0E46:  RETURN 0
0E48:  DATA 54,69
0E4A:  DATA 65,6D
0E4C:  DATA 70,6F
0E4E:  DATA 20,6D
0E50:  DATA 65,64
0E52:  DATA 69,6F
0E54:  DATA 20,64
0E56:  DATA 65,20
0E58:  DATA 65,6E
0E5A:  DATA 63,65
0E5C:  DATA 6E,64
0E5E:  DATA 69,64
0E60:  DATA 6F,20
0E62:  DATA 64,65
0E64:  DATA 20,6C
0E66:  DATA 61,20
0E68:  DATA 63,61
0E6A:  DATA 6C,64
0E6C:  DATA 65,72
0E6E:  DATA 61,20
0E70:  DATA 70,6F
0E72:  DATA 72,20
0E74:  DATA 64,69
0E76:  DATA 61,3A
0E78:  DATA 20,25
0E7A:  DATA 33,2E
0E7C:  DATA 32,66
0E7E:  DATA 20,6D
0E80:  DATA 69,6E
0E82:  DATA 75,74
0E84:  DATA 6F,73
0E86:  DATA 0D,0D
0E88:  DATA 00,00
0E8A:  MOVFF  FF2,0E
0E8E:  BCF    FF2.7
0E90:  CLRF   FF7
0E92:  ADDLW  A4
0E94:  MOVWF  FF6
0E96:  MOVLW  0E
0E98:  ADDWFC FF7,F
0E9A:  TBLRD*+
0E9C:  MOVF   FF5,W
0E9E:  BTFSC  0E.7
0EA0:  BSF    FF2.7
0EA2:  RETURN 0
0EA4:  DATA 0D,54
0EA6:  DATA 69,65
0EA8:  DATA 6D,70
0EAA:  DATA 6F,20
0EAC:  DATA 74,6F
0EAE:  DATA 74,61
0EB0:  DATA 6C,20
0EB2:  DATA 64,65
0EB4:  DATA 20,65
0EB6:  DATA 6E,63
0EB8:  DATA 65,6E
0EBA:  DATA 64,69
0EBC:  DATA 64,6F
0EBE:  DATA 20,64
0EC0:  DATA 65,6C
0EC2:  DATA 20,73
0EC4:  DATA 69,73
0EC6:  DATA 74,65
0EC8:  DATA 6D,61
0ECA:  DATA 3A,20
0ECC:  DATA 25,6C
0ECE:  DATA 75,20
0ED0:  DATA 6D,69
0ED2:  DATA 6E,75
0ED4:  DATA 74,6F
0ED6:  DATA 73,0D
0ED8:  DATA 0D,00
0EDA:  MOVFF  FF2,0E
0EDE:  BCF    FF2.7
0EE0:  CLRF   FF7
0EE2:  ADDLW  F4
0EE4:  MOVWF  FF6
0EE6:  MOVLW  0E
0EE8:  ADDWFC FF7,F
0EEA:  TBLRD*+
0EEC:  MOVF   FF5,W
0EEE:  BTFSC  0E.7
0EF0:  BSF    FF2.7
0EF2:  RETURN 0
0EF4:  DATA 54,69
0EF6:  DATA 65,6D
0EF8:  DATA 70,6F
0EFA:  DATA 20,74
0EFC:  DATA 6F,74
0EFE:  DATA 61,6C
0F00:  DATA 20,64
0F02:  DATA 65,20
0F04:  DATA 65,6E
0F06:  DATA 63,65
0F08:  DATA 6E,64
0F0A:  DATA 69,64
0F0C:  DATA 6F,20
0F0E:  DATA 64,65
0F10:  DATA 20,6C
0F12:  DATA 61,20
0F14:  DATA 63,61
0F16:  DATA 6C,64
0F18:  DATA 65,72
0F1A:  DATA 61,3A
0F1C:  DATA 20,25
0F1E:  DATA 6C,75
0F20:  DATA 20,6D
0F22:  DATA 69,6E
0F24:  DATA 75,74
0F26:  DATA 6F,73
0F28:  DATA 0D,0D
0F2A:  DATA 00,00
0F2C:  MOVFF  FF2,0E
0F30:  BCF    FF2.7
0F32:  CLRF   FF7
0F34:  ADDLW  46
0F36:  MOVWF  FF6
0F38:  MOVLW  0F
0F3A:  ADDWFC FF7,F
0F3C:  TBLRD*+
0F3E:  MOVF   FF5,W
0F40:  BTFSC  0E.7
0F42:  BSF    FF2.7
0F44:  RETURN 0
0F46:  DATA 0D,32
0F48:  DATA 30,00
0F4A:  MOVFF  FF2,0E
0F4E:  BCF    FF2.7
0F50:  CLRF   FF7
0F52:  ADDLW  64
0F54:  MOVWF  FF6
0F56:  MOVLW  0F
0F58:  ADDWFC FF7,F
0F5A:  TBLRD*+
0F5C:  MOVF   FF5,W
0F5E:  BTFSC  0E.7
0F60:  BSF    FF2.7
0F62:  RETURN 0
0F64:  DATA 2D,2D
0F66:  DATA 2D,2D
0F68:  DATA 2D,2D
0F6A:  DATA 2D,2D
0F6C:  DATA 2D,2D
0F6E:  DATA 2D,2D
0F70:  DATA 2D,2D
0F72:  DATA 2D,2D
0F74:  DATA 2D,2D
0F76:  DATA 2D,2D
0F78:  DATA 2D,2D
0F7A:  DATA 2D,2D
0F7C:  DATA 2D,2D
0F7E:  DATA 2D,2D
0F80:  DATA 2D,2D
0F82:  DATA 2D,2D
0F84:  DATA 2D,2D
0F86:  DATA 2D,2D
0F88:  DATA 2D,2D
0F8A:  DATA 2D,2D
0F8C:  DATA 2D,2D
0F8E:  DATA 2D,2D
0F90:  DATA 2D,2D
0F92:  DATA 2D,2D
0F94:  DATA 2D,2D
0F96:  DATA 2D,2D
0F98:  DATA 2D,2D
0F9A:  DATA 2D,2D
0F9C:  DATA 2D,2D
0F9E:  DATA 2D,2D
0FA0:  DATA 2D,2D
0FA2:  DATA 2D,2D
0FA4:  DATA 2D,2D
0FA6:  DATA 2D,2D
0FA8:  DATA 2D,2D
0FAA:  DATA 2D,2D
0FAC:  DATA 2D,2D
0FAE:  DATA 2D,2D
0FB0:  DATA 2D,2D
0FB2:  DATA 2D,2D
0FB4:  DATA 2D,2D
0FB6:  DATA 2D,2D
0FB8:  DATA 2D,2D
0FBA:  DATA 2D,2D
0FBC:  DATA 2D,2D
0FBE:  DATA 2D,2D
0FC0:  DATA 2D,2D
0FC2:  DATA 2D,2D
0FC4:  DATA 2D,2D
0FC6:  DATA 2D,2D
0FC8:  DATA 2D,2D
0FCA:  DATA 2D,2D
0FCC:  DATA 2D,2D
0FCE:  DATA 2D,2D
0FD0:  DATA 2D,2D
0FD2:  DATA 2D,2D
0FD4:  DATA 2D,2D
0FD6:  DATA 2D,2D
0FD8:  DATA 0D,00
0FDA:  MOVFF  FF2,0E
0FDE:  BCF    FF2.7
0FE0:  CLRF   FF7
0FE2:  ADDLW  F4
0FE4:  MOVWF  FF6
0FE6:  MOVLW  0F
0FE8:  ADDWFC FF7,F
0FEA:  TBLRD*+
0FEC:  MOVF   FF5,W
0FEE:  BTFSC  0E.7
0FF0:  BSF    FF2.7
0FF2:  RETURN 0
0FF4:  DATA 20,20
0FF6:  DATA 20,20
0FF8:  DATA 20,20
0FFA:  DATA 20,20
0FFC:  DATA 20,20
0FFE:  DATA 20,20
1000:  DATA 20,20
1002:  DATA 54,69
1004:  DATA 65,6D
1006:  DATA 70,6F
1008:  DATA 20,6D
100A:  DATA 65,64
100C:  DATA 69,6F
100E:  DATA 20,64
1010:  DATA 65,20
1012:  DATA 65,6E
1014:  DATA 63,65
1016:  DATA 6E,64
1018:  DATA 69,64
101A:  DATA 6F,20
101C:  DATA 64,65
101E:  DATA 6C,20
1020:  DATA 73,69
1022:  DATA 73,74
1024:  DATA 65,6D
1026:  DATA 61,20
1028:  DATA 28,6D
102A:  DATA 69,6E
102C:  DATA 2F,64
102E:  DATA 69,61
1030:  DATA 29,20
1032:  DATA 20,20
1034:  DATA 20,20
1036:  DATA 20,54
1038:  DATA 69,65
103A:  DATA 6D,70
103C:  DATA 6F,20
103E:  DATA 6D,65
1040:  DATA 64,69
1042:  DATA 6F,20
1044:  DATA 64,65
1046:  DATA 20,65
1048:  DATA 6E,63
104A:  DATA 65,6E
104C:  DATA 64,69
104E:  DATA 64,6F
1050:  DATA 20,64
1052:  DATA 65,20
1054:  DATA 6C,61
1056:  DATA 20,63
1058:  DATA 61,6C
105A:  DATA 64,65
105C:  DATA 72,61
105E:  DATA 20,28
1060:  DATA 6D,69
1062:  DATA 6E,2F
1064:  DATA 64,69
1066:  DATA 61,29
1068:  DATA 0D,00
106A:  MOVFF  FF2,0E
106E:  BCF    FF2.7
1070:  CLRF   FF7
1072:  ADDLW  84
1074:  MOVWF  FF6
1076:  MOVLW  10
1078:  ADDWFC FF7,F
107A:  TBLRD*+
107C:  MOVF   FF5,W
107E:  BTFSC  0E.7
1080:  BSF    FF2.7
1082:  RETURN 0
1084:  DATA 45,4E
1086:  DATA 45,52
1088:  DATA 4F,25
108A:  DATA 33,2E
108C:  DATA 32,66
108E:  DATA 25,33
1090:  DATA 2E,32
1092:  DATA 66,0D
1094:  DATA 00,00
1096:  MOVFF  FF2,0E
109A:  BCF    FF2.7
109C:  CLRF   FF7
109E:  ADDLW  B0
10A0:  MOVWF  FF6
10A2:  MOVLW  10
10A4:  ADDWFC FF7,F
10A6:  TBLRD*+
10A8:  MOVF   FF5,W
10AA:  BTFSC  0E.7
10AC:  BSF    FF2.7
10AE:  RETURN 0
10B0:  DATA 46,45
10B2:  DATA 42,52
10B4:  DATA 45,52
10B6:  DATA 4F,25
10B8:  DATA 33,2E
10BA:  DATA 32,66
10BC:  DATA 25,33
10BE:  DATA 2E,32
10C0:  DATA 66,0D
10C2:  DATA 00,00
10C4:  MOVFF  FF2,0E
10C8:  BCF    FF2.7
10CA:  CLRF   FF7
10CC:  ADDLW  DE
10CE:  MOVWF  FF6
10D0:  MOVLW  10
10D2:  ADDWFC FF7,F
10D4:  TBLRD*+
10D6:  MOVF   FF5,W
10D8:  BTFSC  0E.7
10DA:  BSF    FF2.7
10DC:  RETURN 0
10DE:  DATA 4D,41
10E0:  DATA 52,5A
10E2:  DATA 4F,25
10E4:  DATA 33,2E
10E6:  DATA 32,66
10E8:  DATA 25,33
10EA:  DATA 2E,32
10EC:  DATA 66,0D
10EE:  DATA 00,00
10F0:  MOVFF  FF2,0E
10F4:  BCF    FF2.7
10F6:  CLRF   FF7
10F8:  ADDLW  0A
10FA:  MOVWF  FF6
10FC:  MOVLW  11
10FE:  ADDWFC FF7,F
1100:  TBLRD*+
1102:  MOVF   FF5,W
1104:  BTFSC  0E.7
1106:  BSF    FF2.7
1108:  RETURN 0
110A:  DATA 41,42
110C:  DATA 52,49
110E:  DATA 4C,25
1110:  DATA 33,2E
1112:  DATA 32,66
1114:  DATA 25,33
1116:  DATA 2E,32
1118:  DATA 66,0D
111A:  DATA 00,00
111C:  MOVFF  FF2,0E
1120:  BCF    FF2.7
1122:  CLRF   FF7
1124:  ADDLW  36
1126:  MOVWF  FF6
1128:  MOVLW  11
112A:  ADDWFC FF7,F
112C:  TBLRD*+
112E:  MOVF   FF5,W
1130:  BTFSC  0E.7
1132:  BSF    FF2.7
1134:  RETURN 0
1136:  DATA 4D,41
1138:  DATA 59,4F
113A:  DATA 25,33
113C:  DATA 2E,32
113E:  DATA 66,25
1140:  DATA 33,2E
1142:  DATA 32,66
1144:  DATA 0D,00
1146:  MOVFF  FF2,0E
114A:  BCF    FF2.7
114C:  CLRF   FF7
114E:  ADDLW  60
1150:  MOVWF  FF6
1152:  MOVLW  11
1154:  ADDWFC FF7,F
1156:  TBLRD*+
1158:  MOVF   FF5,W
115A:  BTFSC  0E.7
115C:  BSF    FF2.7
115E:  RETURN 0
1160:  DATA 4A,55
1162:  DATA 4E,49
1164:  DATA 4F,25
1166:  DATA 33,2E
1168:  DATA 32,66
116A:  DATA 25,33
116C:  DATA 2E,32
116E:  DATA 66,0D
1170:  DATA 00,00
1172:  MOVFF  FF2,0E
1176:  BCF    FF2.7
1178:  CLRF   FF7
117A:  ADDLW  8C
117C:  MOVWF  FF6
117E:  MOVLW  11
1180:  ADDWFC FF7,F
1182:  TBLRD*+
1184:  MOVF   FF5,W
1186:  BTFSC  0E.7
1188:  BSF    FF2.7
118A:  RETURN 0
118C:  DATA 4A,55
118E:  DATA 4C,49
1190:  DATA 4F,25
1192:  DATA 33,2E
1194:  DATA 32,66
1196:  DATA 25,33
1198:  DATA 2E,32
119A:  DATA 66,0D
119C:  DATA 00,00
119E:  MOVFF  FF2,0E
11A2:  BCF    FF2.7
11A4:  CLRF   FF7
11A6:  ADDLW  B8
11A8:  MOVWF  FF6
11AA:  MOVLW  11
11AC:  ADDWFC FF7,F
11AE:  TBLRD*+
11B0:  MOVF   FF5,W
11B2:  BTFSC  0E.7
11B4:  BSF    FF2.7
11B6:  RETURN 0
11B8:  DATA 41,47
11BA:  DATA 4F,53
11BC:  DATA 54,4F
11BE:  DATA 25,33
11C0:  DATA 2E,32
11C2:  DATA 66,25
11C4:  DATA 33,2E
11C6:  DATA 32,66
11C8:  DATA 0D,00
11CA:  MOVFF  FF2,0E
11CE:  BCF    FF2.7
11D0:  CLRF   FF7
11D2:  ADDLW  E4
11D4:  MOVWF  FF6
11D6:  MOVLW  11
11D8:  ADDWFC FF7,F
11DA:  TBLRD*+
11DC:  MOVF   FF5,W
11DE:  BTFSC  0E.7
11E0:  BSF    FF2.7
11E2:  RETURN 0
11E4:  DATA 53,45
11E6:  DATA 50,54
11E8:  DATA 49,45
11EA:  DATA 4D,42
11EC:  DATA 52,45
11EE:  DATA 25,33
11F0:  DATA 2E,32
11F2:  DATA 66,25
11F4:  DATA 33,2E
11F6:  DATA 32,66
11F8:  DATA 0D,00
11FA:  MOVFF  FF2,0E
11FE:  BCF    FF2.7
1200:  CLRF   FF7
1202:  ADDLW  14
1204:  MOVWF  FF6
1206:  MOVLW  12
1208:  ADDWFC FF7,F
120A:  TBLRD*+
120C:  MOVF   FF5,W
120E:  BTFSC  0E.7
1210:  BSF    FF2.7
1212:  RETURN 0
1214:  DATA 4F,43
1216:  DATA 54,55
1218:  DATA 42,52
121A:  DATA 45,25
121C:  DATA 33,2E
121E:  DATA 32,66
1220:  DATA 25,33
1222:  DATA 2E,32
1224:  DATA 66,0D
1226:  DATA 00,00
1228:  MOVFF  FF2,0E
122C:  BCF    FF2.7
122E:  CLRF   FF7
1230:  ADDLW  42
1232:  MOVWF  FF6
1234:  MOVLW  12
1236:  ADDWFC FF7,F
1238:  TBLRD*+
123A:  MOVF   FF5,W
123C:  BTFSC  0E.7
123E:  BSF    FF2.7
1240:  RETURN 0
1242:  DATA 4E,4F
1244:  DATA 56,49
1246:  DATA 45,4D
1248:  DATA 42,52
124A:  DATA 45,25
124C:  DATA 33,2E
124E:  DATA 32,66
1250:  DATA 25,33
1252:  DATA 2E,32
1254:  DATA 66,0D
1256:  DATA 00,00
1258:  MOVFF  FF2,0E
125C:  BCF    FF2.7
125E:  CLRF   FF7
1260:  ADDLW  72
1262:  MOVWF  FF6
1264:  MOVLW  12
1266:  ADDWFC FF7,F
1268:  TBLRD*+
126A:  MOVF   FF5,W
126C:  BTFSC  0E.7
126E:  BSF    FF2.7
1270:  RETURN 0
1272:  DATA 44,49
1274:  DATA 43,49
1276:  DATA 45,4D
1278:  DATA 42,52
127A:  DATA 45,25
127C:  DATA 33,2E
127E:  DATA 32,66
1280:  DATA 25,33
1282:  DATA 2E,32
1284:  DATA 66,0D
1286:  DATA 00,00
*
1404:  CLRF   00
1406:  CLRF   01
1408:  MOVF   xAF,W
140A:  BCF    FD8.0
140C:  BTFSC  xB0.0
140E:  ADDWF  00,F
1410:  RRCF   00,F
1412:  RRCF   01,F
1414:  BTFSC  xB0.1
1416:  ADDWF  00,F
1418:  RRCF   00,F
141A:  RRCF   01,F
141C:  BTFSC  xB0.2
141E:  ADDWF  00,F
1420:  RRCF   00,F
1422:  RRCF   01,F
1424:  BTFSC  xB0.3
1426:  ADDWF  00,F
1428:  RRCF   00,F
142A:  RRCF   01,F
142C:  BTFSC  xB0.4
142E:  ADDWF  00,F
1430:  RRCF   00,F
1432:  RRCF   01,F
1434:  BTFSC  xB0.5
1436:  ADDWF  00,F
1438:  RRCF   00,F
143A:  RRCF   01,F
143C:  BTFSC  xB0.6
143E:  ADDWF  00,F
1440:  RRCF   00,F
1442:  RRCF   01,F
1444:  BTFSC  xB0.7
1446:  ADDWF  00,F
1448:  RRCF   00,F
144A:  RRCF   01,F
144C:  GOTO   1528 (RETURN)
*
17F2:  MOVLW  8E
17F4:  MOVWF  00
17F6:  MOVF   xA5,W
17F8:  SUBWF  00,F
17FA:  MOVFF  A6,02
17FE:  MOVFF  A7,01
1802:  BSF    02.7
1804:  MOVF   00,F
1806:  BZ    181A
1808:  BCF    FD8.0
180A:  MOVF   02,F
180C:  BNZ   1812
180E:  MOVF   01,F
1810:  BZ    181A
1812:  RRCF   02,F
1814:  RRCF   01,F
1816:  DECFSZ 00,F
1818:  BRA    1808
181A:  BTFSS  xA6.7
181C:  BRA    1828
181E:  COMF   01,F
1820:  COMF   02,F
1822:  INCF   01,F
1824:  BTFSC  FD8.2
1826:  INCF   02,F
1828:  NOP   
182A:  RETLW  00
182C:  MOVF   xB2,W
182E:  MULWF  xB4
1830:  MOVFF  FF3,01
1834:  MOVFF  FF4,00
1838:  MULWF  xB5
183A:  MOVF   FF3,W
183C:  ADDWF  00,F
183E:  MOVF   xB3,W
1840:  MULWF  xB4
1842:  MOVF   FF3,W
1844:  ADDWFC 00,W
1846:  MOVWF  02
1848:  RETLW  00
*
1DBA:  MOVFF  FF2,0E
1DBE:  BCF    FF2.7
1DC0:  ADDWF  FE8,W
1DC2:  ADDLW  DF
1DC4:  MOVWF  FF6
1DC6:  MOVLW  1D
1DC8:  MOVWF  FF7
1DCA:  BTFSC  FD8.0
1DCC:  INCF   FF7,F
1DCE:  TBLRD*-
1DD0:  MOVF   FF5,W
1DD2:  MOVWF  FFA
1DD4:  TBLRD*
1DD6:  MOVF   FF5,W
1DD8:  BTFSC  0E.7
1DDA:  BSF    FF2.7
1DDC:  MOVWF  FF9
1DDE:  DATA 26,19
1DE0:  DATA 3E,19
1DE2:  DATA 56,19
1DE4:  DATA 6E,19
1DE6:  DATA 86,19
1DE8:  DATA 9E,19
1DEA:  DATA B6,19
*
200C:  MOVLW  8E
200E:  MOVWF  00
2010:  MOVFF  AD,01
2014:  MOVFF  AC,02
2018:  CLRF   03
201A:  BTFSS  xAD.7
201C:  BRA    2028
201E:  COMF   01,F
2020:  COMF   02,F
2022:  INCF   02,F
2024:  BNZ   2028
2026:  INCF   01,F
2028:  MOVF   01,F
202A:  BNZ   203E
202C:  MOVFF  02,01
2030:  CLRF   02
2032:  MOVLW  08
2034:  SUBWF  00,F
2036:  MOVF   01,F
2038:  BNZ   203E
203A:  CLRF   00
203C:  BRA    2052
203E:  BCF    FD8.0
2040:  BTFSC  01.7
2042:  BRA    204C
2044:  RLCF   02,F
2046:  RLCF   01,F
2048:  DECF   00,F
204A:  BRA    203E
204C:  BTFSC  xAD.7
204E:  BRA    2052
2050:  BCF    01.7
2052:  NOP   
2054:  GOTO   2358 (RETURN)
2058:  MOVLB  2
205A:  MOVF   xAF,W
205C:  BTFSC  FD8.2
205E:  BRA    21AA
2060:  MOVWF  xBB
2062:  MOVF   xB3,W
2064:  BTFSC  FD8.2
2066:  BRA    21AA
2068:  SUBWF  xBB,F
206A:  BNC   2076
206C:  MOVLW  7F
206E:  ADDWF  xBB,F
2070:  BTFSC  FD8.0
2072:  BRA    21AA
2074:  BRA    2082
2076:  MOVLW  81
2078:  SUBWF  xBB,F
207A:  BTFSS  FD8.0
207C:  BRA    21AA
207E:  BTFSC  FD8.2
2080:  BRA    21AA
2082:  MOVFF  2BB,00
2086:  CLRF   01
2088:  CLRF   02
208A:  CLRF   03
208C:  CLRF   xBA
208E:  MOVFF  2B0,2B9
2092:  BSF    xB9.7
2094:  MOVFF  2B1,2B8
2098:  MOVFF  2B2,2B7
209C:  MOVLW  19
209E:  MOVWF  xBB
20A0:  MOVF   xB6,W
20A2:  SUBWF  xB7,F
20A4:  BC    20C0
20A6:  MOVLW  01
20A8:  SUBWF  xB8,F
20AA:  BC    20C0
20AC:  SUBWF  xB9,F
20AE:  BC    20C0
20B0:  SUBWF  xBA,F
20B2:  BC    20C0
20B4:  INCF   xBA,F
20B6:  INCF   xB9,F
20B8:  INCF   xB8,F
20BA:  MOVF   xB6,W
20BC:  ADDWF  xB7,F
20BE:  BRA    2110
20C0:  MOVF   xB5,W
20C2:  SUBWF  xB8,F
20C4:  BC    20EA
20C6:  MOVLW  01
20C8:  SUBWF  xB9,F
20CA:  BC    20EA
20CC:  SUBWF  xBA,F
20CE:  BC    20EA
20D0:  INCF   xBA,F
20D2:  INCF   xB9,F
20D4:  MOVF   xB5,W
20D6:  ADDWF  xB8,F
20D8:  MOVF   xB6,W
20DA:  ADDWF  xB7,F
20DC:  BNC   2110
20DE:  INCF   xB8,F
20E0:  BNZ   2110
20E2:  INCF   xB9,F
20E4:  BNZ   2110
20E6:  INCF   xBA,F
20E8:  BRA    2110
20EA:  MOVF   xB4,W
20EC:  IORLW  80
20EE:  SUBWF  xB9,F
20F0:  BC    210E
20F2:  MOVLW  01
20F4:  SUBWF  xBA,F
20F6:  BC    210E
20F8:  INCF   xBA,F
20FA:  MOVF   xB4,W
20FC:  IORLW  80
20FE:  ADDWF  xB9,F
2100:  MOVF   xB5,W
2102:  ADDWF  xB8,F
2104:  BNC   20D8
2106:  INCF   xB9,F
2108:  BNZ   20D8
210A:  INCF   xBA,F
210C:  BRA    20D8
210E:  BSF    03.0
2110:  DECFSZ xBB,F
2112:  BRA    2116
2114:  BRA    212C
2116:  BCF    FD8.0
2118:  RLCF   xB7,F
211A:  RLCF   xB8,F
211C:  RLCF   xB9,F
211E:  RLCF   xBA,F
2120:  BCF    FD8.0
2122:  RLCF   03,F
2124:  RLCF   02,F
2126:  RLCF   01,F
2128:  RLCF   xBC,F
212A:  BRA    20A0
212C:  BTFSS  xBC.0
212E:  BRA    213C
2130:  BCF    FD8.0
2132:  RRCF   01,F
2134:  RRCF   02,F
2136:  RRCF   03,F
2138:  RRCF   xBC,F
213A:  BRA    2140
213C:  DECF   00,F
213E:  BZ    21AA
2140:  BTFSC  xBC.7
2142:  BRA    2180
2144:  BCF    FD8.0
2146:  RLCF   xB7,F
2148:  RLCF   xB8,F
214A:  RLCF   xB9,F
214C:  RLCF   xBA,F
214E:  MOVF   xB6,W
2150:  SUBWF  xB7,F
2152:  BC    2162
2154:  MOVLW  01
2156:  SUBWF  xB8,F
2158:  BC    2162
215A:  SUBWF  xB9,F
215C:  BC    2162
215E:  SUBWF  xBA,F
2160:  BNC   2196
2162:  MOVF   xB5,W
2164:  SUBWF  xB8,F
2166:  BC    2172
2168:  MOVLW  01
216A:  SUBWF  xB9,F
216C:  BC    2172
216E:  SUBWF  xBA,F
2170:  BNC   2196
2172:  MOVF   xB4,W
2174:  IORLW  80
2176:  SUBWF  xB9,F
2178:  BC    2180
217A:  MOVLW  01
217C:  SUBWF  xBA,F
217E:  BNC   2196
2180:  INCF   03,F
2182:  BNZ   2196
2184:  INCF   02,F
2186:  BNZ   2196
2188:  INCF   01,F
218A:  BNZ   2196
218C:  INCF   00,F
218E:  BZ    21AA
2190:  RRCF   01,F
2192:  RRCF   02,F
2194:  RRCF   03,F
2196:  MOVFF  2B0,2BB
219A:  MOVF   xB4,W
219C:  XORWF  xBB,F
219E:  BTFSS  xBB.7
21A0:  BRA    21A6
21A2:  BSF    01.7
21A4:  BRA    21B2
21A6:  BCF    01.7
21A8:  BRA    21B2
21AA:  CLRF   00
21AC:  CLRF   01
21AE:  CLRF   02
21B0:  CLRF   03
21B2:  NOP   
21B4:  MOVLB  0
21B6:  RETLW  00
*
23B2:  MOVFF  9E,A5
23B6:  MOVF   xA2,W
23B8:  XORWF  xA5,F
23BA:  BTFSS  xA5.7
23BC:  BRA    23C8
23BE:  BCF    FD8.2
23C0:  BCF    FD8.0
23C2:  BTFSC  x9E.7
23C4:  BSF    FD8.0
23C6:  BRA    2426
23C8:  MOVFF  9E,A5
23CC:  MOVFF  A1,A6
23D0:  MOVF   x9D,W
23D2:  SUBWF  xA6,F
23D4:  BZ    23E2
23D6:  BTFSS  xA5.7
23D8:  BRA    2426
23DA:  MOVF   FD8,W
23DC:  XORLW  01
23DE:  MOVWF  FD8
23E0:  BRA    2426
23E2:  MOVFF  A2,A6
23E6:  MOVF   x9E,W
23E8:  SUBWF  xA6,F
23EA:  BZ    23F8
23EC:  BTFSS  xA5.7
23EE:  BRA    2426
23F0:  MOVF   FD8,W
23F2:  XORLW  01
23F4:  MOVWF  FD8
23F6:  BRA    2426
23F8:  MOVFF  A3,A6
23FC:  MOVF   x9F,W
23FE:  SUBWF  xA6,F
2400:  BZ    240E
2402:  BTFSS  xA5.7
2404:  BRA    2426
2406:  MOVF   FD8,W
2408:  XORLW  01
240A:  MOVWF  FD8
240C:  BRA    2426
240E:  MOVFF  A4,A6
2412:  MOVF   xA0,W
2414:  SUBWF  xA6,F
2416:  BZ    2424
2418:  BTFSS  xA5.7
241A:  BRA    2426
241C:  MOVF   FD8,W
241E:  XORLW  01
2420:  MOVWF  FD8
2422:  BRA    2426
2424:  BCF    FD8.0
2426:  RETLW  00
2428:  MOVLW  80
242A:  BTFSS  FD8.1
242C:  BRA    2432
242E:  MOVLB  2
2430:  XORWF  xAE,F
2432:  MOVLB  2
2434:  CLRF   xB3
2436:  CLRF   xB4
2438:  MOVFF  2AA,2B2
243C:  MOVF   xAE,W
243E:  XORWF  xB2,F
2440:  MOVF   xA9,W
2442:  BTFSC  FD8.2
2444:  BRA    2604
2446:  MOVWF  xB1
2448:  MOVWF  00
244A:  MOVF   xAD,W
244C:  BTFSC  FD8.2
244E:  BRA    2616
2450:  SUBWF  xB1,F
2452:  BTFSC  FD8.2
2454:  BRA    255C
2456:  BNC   24D4
2458:  MOVFF  2AE,2B7
245C:  BSF    xB7.7
245E:  MOVFF  2AF,2B6
2462:  MOVFF  2B0,2B5
2466:  CLRF   xB4
2468:  BCF    FD8.0
246A:  RRCF   xB7,F
246C:  RRCF   xB6,F
246E:  RRCF   xB5,F
2470:  RRCF   xB4,F
2472:  DECFSZ xB1,F
2474:  BRA    2466
2476:  BTFSS  xB2.7
2478:  BRA    2480
247A:  BSF    xB3.0
247C:  BRA    263E
247E:  BCF    xB3.0
2480:  BCF    xB1.0
2482:  BSF    xB3.4
2484:  MOVLW  02
2486:  MOVWF  FEA
2488:  MOVLW  AC
248A:  MOVWF  FE9
248C:  BRA    2664
248E:  BCF    xB3.4
2490:  BTFSC  xB2.7
2492:  BRA    24A8
2494:  BTFSS  xB1.0
2496:  BRA    24BE
2498:  RRCF   xB7,F
249A:  RRCF   xB6,F
249C:  RRCF   xB5,F
249E:  RRCF   xB4,F
24A0:  INCF   00,F
24A2:  BTFSC  FD8.2
24A4:  BRA    2634
24A6:  BRA    24BE
24A8:  BTFSC  xB7.7
24AA:  BRA    24C4
24AC:  BCF    FD8.0
24AE:  RLCF   xB4,F
24B0:  RLCF   xB5,F
24B2:  RLCF   xB6,F
24B4:  RLCF   xB7,F
24B6:  DECF   00,F
24B8:  BTFSC  FD8.2
24BA:  BRA    2634
24BC:  BRA    24A8
24BE:  BSF    xB3.6
24C0:  BRA    259C
24C2:  BCF    xB3.6
24C4:  MOVFF  2AA,2B2
24C8:  BTFSS  xAA.7
24CA:  BRA    24D0
24CC:  BSF    xB7.7
24CE:  BRA    2626
24D0:  BCF    xB7.7
24D2:  BRA    2626
24D4:  MOVFF  2AD,2B1
24D8:  MOVFF  2AD,00
24DC:  MOVF   xA9,W
24DE:  SUBWF  xB1,F
24E0:  MOVFF  2AA,2B7
24E4:  BSF    xB7.7
24E6:  MOVFF  2AB,2B6
24EA:  MOVFF  2AC,2B5
24EE:  CLRF   xB4
24F0:  BCF    FD8.0
24F2:  RRCF   xB7,F
24F4:  RRCF   xB6,F
24F6:  RRCF   xB5,F
24F8:  RRCF   xB4,F
24FA:  DECFSZ xB1,F
24FC:  BRA    24EE
24FE:  BTFSS  xB2.7
2500:  BRA    2508
2502:  BSF    xB3.1
2504:  BRA    263E
2506:  BCF    xB3.1
2508:  BCF    xB1.0
250A:  BSF    xB3.5
250C:  MOVLW  02
250E:  MOVWF  FEA
2510:  MOVLW  B0
2512:  MOVWF  FE9
2514:  BRA    2664
2516:  BCF    xB3.5
2518:  BTFSC  xB2.7
251A:  BRA    2530
251C:  BTFSS  xB1.0
251E:  BRA    2546
2520:  RRCF   xB7,F
2522:  RRCF   xB6,F
2524:  RRCF   xB5,F
2526:  RRCF   xB4,F
2528:  INCF   00,F
252A:  BTFSC  FD8.2
252C:  BRA    2634
252E:  BRA    2546
2530:  BTFSC  xB7.7
2532:  BRA    254C
2534:  BCF    FD8.0
2536:  RLCF   xB4,F
2538:  RLCF   xB5,F
253A:  RLCF   xB6,F
253C:  RLCF   xB7,F
253E:  DECF   00,F
2540:  BTFSC  FD8.2
2542:  BRA    2634
2544:  BRA    2530
2546:  BSF    xB3.7
2548:  BRA    259C
254A:  BCF    xB3.7
254C:  MOVFF  2AE,2B2
2550:  BTFSS  xAE.7
2552:  BRA    2558
2554:  BSF    xB7.7
2556:  BRA    2626
2558:  BCF    xB7.7
255A:  BRA    2626
255C:  MOVFF  2AE,2B7
2560:  BSF    xB7.7
2562:  MOVFF  2AF,2B6
2566:  MOVFF  2B0,2B5
256A:  BTFSS  xB2.7
256C:  BRA    2576
256E:  BCF    xB7.7
2570:  BSF    xB3.2
2572:  BRA    263E
2574:  BCF    xB3.2
2576:  CLRF   xB4
2578:  BCF    xB1.0
257A:  MOVLW  02
257C:  MOVWF  FEA
257E:  MOVLW  AC
2580:  MOVWF  FE9
2582:  BRA    2664
2584:  BTFSC  xB2.7
2586:  BRA    25C0
2588:  MOVFF  2AA,2B2
258C:  BTFSS  xB1.0
258E:  BRA    259C
2590:  RRCF   xB7,F
2592:  RRCF   xB6,F
2594:  RRCF   xB5,F
2596:  RRCF   xB4,F
2598:  INCF   00,F
259A:  BZ    2634
259C:  BTFSS  xB4.7
259E:  BRA    25B6
25A0:  INCF   xB5,F
25A2:  BNZ   25B6
25A4:  INCF   xB6,F
25A6:  BNZ   25B6
25A8:  INCF   xB7,F
25AA:  BNZ   25B6
25AC:  RRCF   xB7,F
25AE:  RRCF   xB6,F
25B0:  RRCF   xB5,F
25B2:  INCF   00,F
25B4:  BZ    2634
25B6:  BTFSC  xB3.6
25B8:  BRA    24C2
25BA:  BTFSC  xB3.7
25BC:  BRA    254A
25BE:  BRA    25F8
25C0:  MOVLW  80
25C2:  XORWF  xB7,F
25C4:  BTFSS  xB7.7
25C6:  BRA    25D0
25C8:  BRA    263E
25CA:  MOVFF  2AE,2B2
25CE:  BRA    25E4
25D0:  MOVFF  2AA,2B2
25D4:  MOVF   xB7,F
25D6:  BNZ   25E4
25D8:  MOVF   xB6,F
25DA:  BNZ   25E4
25DC:  MOVF   xB5,F
25DE:  BNZ   25E4
25E0:  CLRF   00
25E2:  BRA    2626
25E4:  BTFSC  xB7.7
25E6:  BRA    25F8
25E8:  BCF    FD8.0
25EA:  RLCF   xB4,F
25EC:  RLCF   xB5,F
25EE:  RLCF   xB6,F
25F0:  RLCF   xB7,F
25F2:  DECFSZ 00,F
25F4:  BRA    25E4
25F6:  BRA    2634
25F8:  BTFSS  xB2.7
25FA:  BRA    2600
25FC:  BSF    xB7.7
25FE:  BRA    2626
2600:  BCF    xB7.7
2602:  BRA    2626
2604:  MOVFF  2AD,00
2608:  MOVFF  2AE,2B7
260C:  MOVFF  2AF,2B6
2610:  MOVFF  2B0,2B5
2614:  BRA    2626
2616:  MOVFF  2A9,00
261A:  MOVFF  2AA,2B7
261E:  MOVFF  2AB,2B6
2622:  MOVFF  2AC,2B5
2626:  MOVFF  2B7,01
262A:  MOVFF  2B6,02
262E:  MOVFF  2B5,03
2632:  BRA    269C
2634:  CLRF   00
2636:  CLRF   01
2638:  CLRF   02
263A:  CLRF   03
263C:  BRA    269C
263E:  CLRF   xB4
2640:  COMF   xB5,F
2642:  COMF   xB6,F
2644:  COMF   xB7,F
2646:  COMF   xB4,F
2648:  INCF   xB4,F
264A:  BNZ   2656
264C:  INCF   xB5,F
264E:  BNZ   2656
2650:  INCF   xB6,F
2652:  BNZ   2656
2654:  INCF   xB7,F
2656:  BTFSC  xB3.0
2658:  BRA    247E
265A:  BTFSC  xB3.1
265C:  BRA    2506
265E:  BTFSC  xB3.2
2660:  BRA    2574
2662:  BRA    25CA
2664:  MOVF   FEF,W
2666:  ADDWF  xB5,F
2668:  BNC   2674
266A:  INCF   xB6,F
266C:  BNZ   2674
266E:  INCF   xB7,F
2670:  BTFSC  FD8.2
2672:  BSF    xB1.0
2674:  MOVF   FED,F
2676:  MOVF   FEF,W
2678:  ADDWF  xB6,F
267A:  BNC   2682
267C:  INCF   xB7,F
267E:  BTFSC  FD8.2
2680:  BSF    xB1.0
2682:  MOVF   FED,F
2684:  MOVF   FEF,W
2686:  BTFSC  FEF.7
2688:  BRA    268C
268A:  XORLW  80
268C:  ADDWF  xB7,F
268E:  BTFSC  FD8.0
2690:  BSF    xB1.0
2692:  BTFSC  xB3.4
2694:  BRA    248E
2696:  BTFSC  xB3.5
2698:  BRA    2516
269A:  BRA    2584
269C:  NOP   
269E:  MOVLB  0
26A0:  RETLW  00
26A2:  MOVLW  8E
26A4:  MOVWF  00
26A6:  MOVFF  2B0,01
26AA:  MOVFF  2AF,02
26AE:  CLRF   03
26B0:  MOVF   01,F
26B2:  BNZ   26C6
26B4:  MOVFF  02,01
26B8:  CLRF   02
26BA:  MOVLW  08
26BC:  SUBWF  00,F
26BE:  MOVF   01,F
26C0:  BNZ   26C6
26C2:  CLRF   00
26C4:  BRA    26D6
26C6:  BCF    FD8.0
26C8:  BTFSC  01.7
26CA:  BRA    26D4
26CC:  RLCF   02,F
26CE:  RLCF   01,F
26D0:  DECF   00,F
26D2:  BRA    26C6
26D4:  BCF    01.7
26D6:  NOP   
26D8:  RETLW  00
*
29F2:  MOVLB  2
29F4:  MOVF   xC5,W
29F6:  BTFSC  FD8.2
29F8:  BRA    2ADC
29FA:  MOVWF  00
29FC:  MOVF   xC9,W
29FE:  BTFSC  FD8.2
2A00:  BRA    2ADC
2A02:  ADDWF  00,F
2A04:  BNC   2A0E
2A06:  MOVLW  81
2A08:  ADDWF  00,F
2A0A:  BC    2ADC
2A0C:  BRA    2A16
2A0E:  MOVLW  7F
2A10:  SUBWF  00,F
2A12:  BNC   2ADC
2A14:  BZ    2ADC
2A16:  MOVFF  2C6,2CD
2A1A:  MOVF   xCA,W
2A1C:  XORWF  xCD,F
2A1E:  BSF    xC6.7
2A20:  BSF    xCA.7
2A22:  MOVF   xC8,W
2A24:  MULWF  xCC
2A26:  MOVFF  FF4,2CF
2A2A:  MOVF   xC7,W
2A2C:  MULWF  xCB
2A2E:  MOVFF  FF4,03
2A32:  MOVFF  FF3,2CE
2A36:  MULWF  xCC
2A38:  MOVF   FF3,W
2A3A:  ADDWF  xCF,F
2A3C:  MOVF   FF4,W
2A3E:  ADDWFC xCE,F
2A40:  MOVLW  00
2A42:  ADDWFC 03,F
2A44:  MOVF   xC8,W
2A46:  MULWF  xCB
2A48:  MOVF   FF3,W
2A4A:  ADDWF  xCF,F
2A4C:  MOVF   FF4,W
2A4E:  ADDWFC xCE,F
2A50:  MOVLW  00
2A52:  CLRF   02
2A54:  ADDWFC 03,F
2A56:  ADDWFC 02,F
2A58:  MOVF   xC6,W
2A5A:  MULWF  xCC
2A5C:  MOVF   FF3,W
2A5E:  ADDWF  xCE,F
2A60:  MOVF   FF4,W
2A62:  ADDWFC 03,F
2A64:  MOVLW  00
2A66:  ADDWFC 02,F
2A68:  MOVF   xC6,W
2A6A:  MULWF  xCB
2A6C:  MOVF   FF3,W
2A6E:  ADDWF  03,F
2A70:  MOVF   FF4,W
2A72:  ADDWFC 02,F
2A74:  MOVLW  00
2A76:  CLRF   01
2A78:  ADDWFC 01,F
2A7A:  MOVF   xC8,W
2A7C:  MULWF  xCA
2A7E:  MOVF   FF3,W
2A80:  ADDWF  xCE,F
2A82:  MOVF   FF4,W
2A84:  ADDWFC 03,F
2A86:  MOVLW  00
2A88:  ADDWFC 02,F
2A8A:  ADDWFC 01,F
2A8C:  MOVF   xC7,W
2A8E:  MULWF  xCA
2A90:  MOVF   FF3,W
2A92:  ADDWF  03,F
2A94:  MOVF   FF4,W
2A96:  ADDWFC 02,F
2A98:  MOVLW  00
2A9A:  ADDWFC 01,F
2A9C:  MOVF   xC6,W
2A9E:  MULWF  xCA
2AA0:  MOVF   FF3,W
2AA2:  ADDWF  02,F
2AA4:  MOVF   FF4,W
2AA6:  ADDWFC 01,F
2AA8:  INCF   00,F
2AAA:  BTFSC  01.7
2AAC:  BRA    2AB8
2AAE:  RLCF   xCE,F
2AB0:  RLCF   03,F
2AB2:  RLCF   02,F
2AB4:  RLCF   01,F
2AB6:  DECF   00,F
2AB8:  MOVLW  00
2ABA:  BTFSS  xCE.7
2ABC:  BRA    2AD2
2ABE:  INCF   03,F
2AC0:  ADDWFC 02,F
2AC2:  ADDWFC 01,F
2AC4:  MOVF   01,W
2AC6:  BNZ   2AD2
2AC8:  MOVF   02,W
2ACA:  BNZ   2AD2
2ACC:  MOVF   03,W
2ACE:  BNZ   2AD2
2AD0:  INCF   00,F
2AD2:  BTFSC  xCD.7
2AD4:  BSF    01.7
2AD6:  BTFSS  xCD.7
2AD8:  BCF    01.7
2ADA:  BRA    2AE4
2ADC:  CLRF   00
2ADE:  CLRF   01
2AE0:  CLRF   02
2AE2:  CLRF   03
2AE4:  NOP   
2AE6:  MOVLB  0
2AE8:  RETLW  00
*
2D70:  CLRF   01
2D72:  CLRF   02
2D74:  CLRF   00
2D76:  CLRF   03
2D78:  MOVF   xA4,W
2D7A:  BNZ   2D80
2D7C:  MOVF   xA3,W
2D7E:  BZ    2DB0
2D80:  MOVLW  10
2D82:  MOVWF  xA5
2D84:  BCF    FD8.0
2D86:  RLCF   xA1,F
2D88:  RLCF   xA2,F
2D8A:  RLCF   00,F
2D8C:  RLCF   03,F
2D8E:  MOVF   xA4,W
2D90:  SUBWF  03,W
2D92:  BNZ   2D98
2D94:  MOVF   xA3,W
2D96:  SUBWF  00,W
2D98:  BNC   2DA8
2D9A:  MOVF   xA3,W
2D9C:  SUBWF  00,F
2D9E:  BTFSS  FD8.0
2DA0:  DECF   03,F
2DA2:  MOVF   xA4,W
2DA4:  SUBWF  03,F
2DA6:  BSF    FD8.0
2DA8:  RLCF   01,F
2DAA:  RLCF   02,F
2DAC:  DECFSZ xA5,F
2DAE:  BRA    2D84
2DB0:  NOP   
2DB2:  GOTO   3040 (RETURN)
*
322C:  MOVLB  2
322E:  MOVF   xC5,W
3230:  SUBLW  B6
3232:  MOVWF  xC5
3234:  CLRF   03
3236:  MOVFF  2C6,2C9
323A:  BSF    xC6.7
323C:  BCF    FD8.0
323E:  RRCF   xC6,F
3240:  RRCF   xC7,F
3242:  RRCF   xC8,F
3244:  RRCF   03,F
3246:  RRCF   02,F
3248:  RRCF   01,F
324A:  RRCF   00,F
324C:  DECFSZ xC5,F
324E:  BRA    323C
3250:  BTFSS  xC9.7
3252:  BRA    326A
3254:  COMF   00,F
3256:  COMF   01,F
3258:  COMF   02,F
325A:  COMF   03,F
325C:  INCF   00,F
325E:  BTFSC  FD8.2
3260:  INCF   01,F
3262:  BTFSC  FD8.2
3264:  INCF   02,F
3266:  BTFSC  FD8.2
3268:  INCF   03,F
326A:  MOVLB  0
326C:  RETLW  00
326E:  CLRF   00
3270:  CLRF   01
3272:  CLRF   02
3274:  CLRF   03
3276:  MOVLB  2
3278:  CLRF   xCD
327A:  CLRF   xCE
327C:  CLRF   xCF
327E:  CLRF   xD0
3280:  MOVF   xCC,W
3282:  IORWF  xCB,W
3284:  IORWF  xCA,W
3286:  IORWF  xC9,W
3288:  BZ    32E2
328A:  MOVLW  20
328C:  MOVWF  xD1
328E:  BCF    FD8.0
3290:  RLCF   xC5,F
3292:  RLCF   xC6,F
3294:  RLCF   xC7,F
3296:  RLCF   xC8,F
3298:  RLCF   xCD,F
329A:  RLCF   xCE,F
329C:  RLCF   xCF,F
329E:  RLCF   xD0,F
32A0:  MOVF   xCC,W
32A2:  SUBWF  xD0,W
32A4:  BNZ   32B6
32A6:  MOVF   xCB,W
32A8:  SUBWF  xCF,W
32AA:  BNZ   32B6
32AC:  MOVF   xCA,W
32AE:  SUBWF  xCE,W
32B0:  BNZ   32B6
32B2:  MOVF   xC9,W
32B4:  SUBWF  xCD,W
32B6:  BNC   32D6
32B8:  MOVF   xC9,W
32BA:  SUBWF  xCD,F
32BC:  MOVF   xCA,W
32BE:  BTFSS  FD8.0
32C0:  INCFSZ xCA,W
32C2:  SUBWF  xCE,F
32C4:  MOVF   xCB,W
32C6:  BTFSS  FD8.0
32C8:  INCFSZ xCB,W
32CA:  SUBWF  xCF,F
32CC:  MOVF   xCC,W
32CE:  BTFSS  FD8.0
32D0:  INCFSZ xCC,W
32D2:  SUBWF  xD0,F
32D4:  BSF    FD8.0
32D6:  RLCF   00,F
32D8:  RLCF   01,F
32DA:  RLCF   02,F
32DC:  RLCF   03,F
32DE:  DECFSZ xD1,F
32E0:  BRA    328E
32E2:  NOP   
32E4:  MOVLW  02
32E6:  MOVWF  FEA
32E8:  MOVLW  CD
32EA:  MOVWF  FE9
32EC:  MOVLB  0
32EE:  RETLW  00
32F0:  MOVF   FE9,W
32F2:  MOVWF  x9F
32F4:  MOVF   x9E,W
32F6:  MOVWF  xA1
32F8:  BZ    3332
32FA:  MOVFF  9D,2C8
32FE:  MOVFF  9C,2C7
3302:  MOVFF  9B,2C6
3306:  MOVFF  9A,2C5
330A:  MOVLB  2
330C:  CLRF   xCC
330E:  CLRF   xCB
3310:  MOVLW  20
3312:  MOVWF  xCA
3314:  MOVLW  82
3316:  MOVWF  xC9
3318:  MOVLB  0
331A:  CALL   29F2
331E:  MOVFF  03,9D
3322:  MOVFF  02,9C
3326:  MOVFF  01,9B
332A:  MOVFF  00,9A
332E:  DECFSZ xA1,F
3330:  BRA    32FA
3332:  MOVFF  9D,2C8
3336:  MOVFF  9C,2C7
333A:  MOVFF  9B,2C6
333E:  MOVFF  9A,2C5
3342:  RCALL  322C
3344:  MOVFF  03,9D
3348:  MOVFF  02,9C
334C:  MOVFF  01,9B
3350:  MOVFF  00,9A
3354:  BTFSS  x9D.7
3356:  BRA    3372
3358:  DECF   x9F,F
335A:  BSF    x9F.5
335C:  COMF   x9A,F
335E:  COMF   x9B,F
3360:  COMF   x9C,F
3362:  COMF   x9D,F
3364:  INCF   x9A,F
3366:  BTFSC  FD8.2
3368:  INCF   x9B,F
336A:  BTFSC  FD8.2
336C:  INCF   x9C,F
336E:  BTFSC  FD8.2
3370:  INCF   x9D,F
3372:  MOVLW  3B
3374:  MOVWF  xA6
3376:  MOVLW  9A
3378:  MOVWF  xA5
337A:  MOVLW  CA
337C:  MOVWF  xA4
337E:  CLRF   xA3
3380:  MOVLW  0A
3382:  MOVWF  xA1
3384:  MOVF   x9E,W
3386:  BTFSC  FD8.2
3388:  INCF   x9F,F
338A:  MOVFF  9D,2C8
338E:  MOVFF  9C,2C7
3392:  MOVFF  9B,2C6
3396:  MOVFF  9A,2C5
339A:  MOVFF  A6,2CC
339E:  MOVFF  A5,2CB
33A2:  MOVFF  A4,2CA
33A6:  MOVFF  A3,2C9
33AA:  RCALL  326E
33AC:  MOVF   01,W
33AE:  MOVFF  FEF,9A
33B2:  MOVFF  FEC,9B
33B6:  MOVFF  FEC,9C
33BA:  MOVFF  FEC,9D
33BE:  MOVF   00,F
33C0:  BNZ   33E0
33C2:  INCF   x9E,W
33C4:  SUBWF  xA1,W
33C6:  BZ    33E0
33C8:  MOVF   x9F,W
33CA:  BZ    33E4
33CC:  ANDLW  0F
33CE:  SUBWF  xA1,W
33D0:  BZ    33D4
33D2:  BC    344A
33D4:  BTFSC  x9F.7
33D6:  BRA    344A
33D8:  BTFSC  x9F.6
33DA:  BRA    33E4
33DC:  MOVLW  20
33DE:  BRA    3440
33E0:  MOVLW  20
33E2:  ANDWF  x9F,F
33E4:  BTFSS  x9F.5
33E6:  BRA    3402
33E8:  BCF    x9F.5
33EA:  MOVF   x9E,W
33EC:  BTFSS  FD8.2
33EE:  DECF   x9F,F
33F0:  MOVF   00,W
33F2:  MOVWF  x9F
33F4:  MOVLW  2D
33F6:  MOVWF  xA7
33F8:  CALL   13C0
33FC:  MOVF   x9F,W
33FE:  MOVWF  00
3400:  CLRF   x9F
3402:  MOVF   x9E,W
3404:  SUBWF  xA1,W
3406:  BNZ   341E
3408:  MOVF   00,W
340A:  MOVWF  x9F
340C:  MOVLW  2E
340E:  MOVWF  xA7
3410:  CALL   13C0
3414:  MOVF   x9F,W
3416:  MOVWF  00
3418:  MOVLW  20
341A:  ANDWF  x9F,F
341C:  MOVLW  00
341E:  MOVLW  30
3420:  BTFSS  x9F.5
3422:  BRA    3440
3424:  BCF    x9F.5
3426:  MOVF   x9E,W
3428:  BTFSS  FD8.2
342A:  DECF   x9F,F
342C:  MOVF   00,W
342E:  MOVWF  x9F
3430:  MOVLW  2D
3432:  MOVWF  xA7
3434:  CALL   13C0
3438:  MOVF   x9F,W
343A:  MOVWF  00
343C:  CLRF   x9F
343E:  MOVLW  30
3440:  ADDWF  00,F
3442:  MOVFF  00,A7
3446:  CALL   13C0
344A:  MOVFF  A6,2C8
344E:  MOVFF  A5,2C7
3452:  MOVFF  A4,2C6
3456:  MOVFF  A3,2C5
345A:  MOVLB  2
345C:  CLRF   xCC
345E:  CLRF   xCB
3460:  CLRF   xCA
3462:  MOVLW  0A
3464:  MOVWF  xC9
3466:  MOVLB  0
3468:  RCALL  326E
346A:  MOVFF  03,A6
346E:  MOVFF  02,A5
3472:  MOVFF  01,A4
3476:  MOVFF  00,A3
347A:  DECFSZ xA1,F
347C:  BRA    338A
347E:  RETLW  00
*
350A:  MOVLB  2
350C:  MOVF   xAD,W
350E:  CLRF   01
3510:  SUBWF  xAC,W
3512:  BC    351A
3514:  MOVFF  2AC,00
3518:  BRA    3532
351A:  CLRF   00
351C:  MOVLW  08
351E:  MOVWF  xAE
3520:  RLCF   xAC,F
3522:  RLCF   00,F
3524:  MOVF   xAD,W
3526:  SUBWF  00,W
3528:  BTFSC  FD8.0
352A:  MOVWF  00
352C:  RLCF   01,F
352E:  DECFSZ xAE,F
3530:  BRA    3520
3532:  MOVLB  0
3534:  RETLW  00
3536:  MOVLW  20
3538:  BTFSS  x98.4
353A:  MOVLW  30
353C:  MOVWF  x99
353E:  MOVFF  97,00
3542:  BTFSS  x97.7
3544:  BRA    3554
3546:  COMF   00,F
3548:  INCF   00,F
354A:  MOVFF  00,97
354E:  MOVLW  2D
3550:  MOVWF  x99
3552:  BSF    x98.7
3554:  MOVF   01,W
3556:  MOVFF  97,2AC
355A:  MOVLW  64
355C:  MOVLB  2
355E:  MOVWF  xAD
3560:  MOVLB  0
3562:  RCALL  350A
3564:  MOVFF  00,97
3568:  MOVLW  30
356A:  ADDWF  01,W
356C:  MOVWF  x9A
356E:  MOVFF  97,2AC
3572:  MOVLW  0A
3574:  MOVLB  2
3576:  MOVWF  xAD
3578:  MOVLB  0
357A:  RCALL  350A
357C:  MOVLW  30
357E:  ADDWF  00,W
3580:  MOVWF  x9C
3582:  MOVLW  30
3584:  ADDWF  01,W
3586:  MOVWF  x9B
3588:  MOVFF  99,00
358C:  BTFSS  x98.3
358E:  BRA    3594
3590:  BTFSS  x98.7
3592:  BCF    x98.2
3594:  BTFSC  x98.4
3596:  BRA    35AE
3598:  BTFSS  x98.7
359A:  BRA    35E0
359C:  BTFSC  x98.2
359E:  BRA    35E0
35A0:  MOVFF  00,9A
35A4:  BTFSC  x98.1
35A6:  BRA    35E0
35A8:  MOVFF  00,9B
35AC:  BRA    35E0
35AE:  MOVLW  30
35B0:  SUBWF  x9A,W
35B2:  BNZ   35E0
35B4:  MOVFF  00,9A
35B8:  MOVLW  20
35BA:  MOVWF  x99
35BC:  BTFSS  x98.3
35BE:  BRA    35C8
35C0:  BCF    x98.2
35C2:  BSF    x98.1
35C4:  BTFSS  x98.7
35C6:  BCF    x98.1
35C8:  MOVLW  30
35CA:  SUBWF  x9B,W
35CC:  BNZ   35E0
35CE:  MOVFF  00,9B
35D2:  MOVLW  20
35D4:  MOVWF  x9A
35D6:  BTFSS  x98.3
35D8:  BRA    35C8
35DA:  BCF    x98.1
35DC:  BTFSS  x98.7
35DE:  BCF    x98.0
35E0:  BTFSS  x98.2
35E2:  BRA    35EC
35E4:  MOVFF  99,A7
35E8:  CALL   13C0
35EC:  BTFSS  x98.1
35EE:  BRA    35F8
35F0:  MOVFF  9A,A7
35F4:  CALL   13C0
35F8:  BTFSS  x98.0
35FA:  BRA    3604
35FC:  MOVFF  9B,A7
3600:  CALL   13C0
3604:  MOVFF  9C,A7
3608:  CALL   13C0
360C:  RETLW  00
*
3900:  MOVF   01,W
3902:  MOVFF  2AA,2AC
3906:  MOVLW  64
3908:  MOVLB  2
390A:  MOVWF  xAD
390C:  MOVLB  0
390E:  RCALL  350A
3910:  MOVFF  00,2AA
3914:  MOVF   01,W
3916:  MOVLW  30
3918:  BNZ   392A
391A:  MOVLB  2
391C:  BTFSS  xAB.1
391E:  BRA    393C
3920:  BTFSC  xAB.3
3922:  BRA    393C
3924:  BTFSC  xAB.4
3926:  MOVLW  20
3928:  BRA    3932
392A:  MOVLB  2
392C:  BCF    xAB.3
392E:  BCF    xAB.4
3930:  BSF    xAB.0
3932:  ADDWF  01,F
3934:  MOVF   01,W
3936:  BTFSS  F9E.4
3938:  BRA    3936
393A:  MOVWF  FAD
393C:  MOVFF  2AA,2AC
3940:  MOVLW  0A
3942:  MOVWF  xAD
3944:  MOVLB  0
3946:  RCALL  350A
3948:  MOVFF  00,2AA
394C:  MOVF   01,W
394E:  MOVLW  30
3950:  BNZ   3962
3952:  MOVLB  2
3954:  BTFSC  xAB.3
3956:  BRA    396E
3958:  BTFSS  xAB.0
395A:  BRA    396E
395C:  BTFSC  xAB.4
395E:  MOVLW  20
3960:  MOVLB  0
3962:  ADDWF  01,F
3964:  MOVF   01,W
3966:  BTFSS  F9E.4
3968:  BRA    3966
396A:  MOVWF  FAD
396C:  MOVLB  2
396E:  MOVLW  30
3970:  ADDWF  xAA,F
3972:  MOVF   xAA,W
3974:  BTFSS  F9E.4
3976:  BRA    3974
3978:  MOVWF  FAD
397A:  MOVLB  0
397C:  RETLW  00
397E:  MOVF   FE9,W
3980:  MOVLB  2
3982:  MOVWF  xBD
3984:  MOVF   xBC,W
3986:  MOVWF  xBF
3988:  BZ    39C2
398A:  MOVFF  2BB,2C8
398E:  MOVFF  2BA,2C7
3992:  MOVFF  2B9,2C6
3996:  MOVFF  2B8,2C5
399A:  CLRF   xCC
399C:  CLRF   xCB
399E:  MOVLW  20
39A0:  MOVWF  xCA
39A2:  MOVLW  82
39A4:  MOVWF  xC9
39A6:  MOVLB  0
39A8:  CALL   29F2
39AC:  MOVFF  03,2BB
39B0:  MOVFF  02,2BA
39B4:  MOVFF  01,2B9
39B8:  MOVFF  00,2B8
39BC:  MOVLB  2
39BE:  DECFSZ xBF,F
39C0:  BRA    398A
39C2:  MOVFF  2BB,2C8
39C6:  MOVFF  2BA,2C7
39CA:  MOVFF  2B9,2C6
39CE:  MOVFF  2B8,2C5
39D2:  MOVLB  0
39D4:  RCALL  322C
39D6:  MOVFF  03,2BB
39DA:  MOVFF  02,2BA
39DE:  MOVFF  01,2B9
39E2:  MOVFF  00,2B8
39E6:  MOVLB  2
39E8:  BTFSS  xBB.7
39EA:  BRA    3A06
39EC:  DECF   xBD,F
39EE:  BSF    xBD.5
39F0:  COMF   xB8,F
39F2:  COMF   xB9,F
39F4:  COMF   xBA,F
39F6:  COMF   xBB,F
39F8:  INCF   xB8,F
39FA:  BTFSC  FD8.2
39FC:  INCF   xB9,F
39FE:  BTFSC  FD8.2
3A00:  INCF   xBA,F
3A02:  BTFSC  FD8.2
3A04:  INCF   xBB,F
3A06:  MOVLW  3B
3A08:  MOVWF  xC4
3A0A:  MOVLW  9A
3A0C:  MOVWF  xC3
3A0E:  MOVLW  CA
3A10:  MOVWF  xC2
3A12:  CLRF   xC1
3A14:  MOVLW  0A
3A16:  MOVWF  xBF
3A18:  MOVF   xBC,W
3A1A:  BTFSC  FD8.2
3A1C:  INCF   xBD,F
3A1E:  MOVFF  2BB,2C8
3A22:  MOVFF  2BA,2C7
3A26:  MOVFF  2B9,2C6
3A2A:  MOVFF  2B8,2C5
3A2E:  MOVFF  2C4,2CC
3A32:  MOVFF  2C3,2CB
3A36:  MOVFF  2C2,2CA
3A3A:  MOVFF  2C1,2C9
3A3E:  MOVLB  0
3A40:  RCALL  326E
3A42:  MOVF   01,W
3A44:  MOVFF  FEF,2B8
3A48:  MOVFF  FEC,2B9
3A4C:  MOVFF  FEC,2BA
3A50:  MOVFF  FEC,2BB
3A54:  MOVF   00,F
3A56:  BNZ   3A7E
3A58:  MOVLB  2
3A5A:  INCF   xBC,W
3A5C:  SUBWF  xBF,W
3A5E:  BTFSS  FD8.2
3A60:  BRA    3A66
3A62:  MOVLB  0
3A64:  BRA    3A7E
3A66:  MOVF   xBD,W
3A68:  BZ    3A84
3A6A:  ANDLW  0F
3A6C:  SUBWF  xBF,W
3A6E:  BZ    3A72
3A70:  BC    3AEA
3A72:  BTFSC  xBD.7
3A74:  BRA    3AEA
3A76:  BTFSC  xBD.6
3A78:  BRA    3A84
3A7A:  MOVLW  20
3A7C:  BRA    3AE0
3A7E:  MOVLW  20
3A80:  MOVLB  2
3A82:  ANDWF  xBD,F
3A84:  BTFSS  xBD.5
3A86:  BRA    3AA2
3A88:  BCF    xBD.5
3A8A:  MOVF   xBC,W
3A8C:  BTFSS  FD8.2
3A8E:  DECF   xBD,F
3A90:  MOVF   00,W
3A92:  MOVWF  xBD
3A94:  MOVLW  2D
3A96:  BTFSS  F9E.4
3A98:  BRA    3A96
3A9A:  MOVWF  FAD
3A9C:  MOVF   xBD,W
3A9E:  MOVWF  00
3AA0:  CLRF   xBD
3AA2:  MOVF   xBC,W
3AA4:  SUBWF  xBF,W
3AA6:  BNZ   3ABE
3AA8:  MOVF   00,W
3AAA:  MOVWF  xBD
3AAC:  MOVLW  2E
3AAE:  BTFSS  F9E.4
3AB0:  BRA    3AAE
3AB2:  MOVWF  FAD
3AB4:  MOVF   xBD,W
3AB6:  MOVWF  00
3AB8:  MOVLW  20
3ABA:  ANDWF  xBD,F
3ABC:  MOVLW  00
3ABE:  MOVLW  30
3AC0:  BTFSS  xBD.5
3AC2:  BRA    3AE0
3AC4:  BCF    xBD.5
3AC6:  MOVF   xBC,W
3AC8:  BTFSS  FD8.2
3ACA:  DECF   xBD,F
3ACC:  MOVF   00,W
3ACE:  MOVWF  xBD
3AD0:  MOVLW  2D
3AD2:  BTFSS  F9E.4
3AD4:  BRA    3AD2
3AD6:  MOVWF  FAD
3AD8:  MOVF   xBD,W
3ADA:  MOVWF  00
3ADC:  CLRF   xBD
3ADE:  MOVLW  30
3AE0:  ADDWF  00,F
3AE2:  MOVF   00,W
3AE4:  BTFSS  F9E.4
3AE6:  BRA    3AE4
3AE8:  MOVWF  FAD
3AEA:  MOVFF  2C4,2C8
3AEE:  MOVFF  2C3,2C7
3AF2:  MOVFF  2C2,2C6
3AF6:  MOVFF  2C1,2C5
3AFA:  CLRF   xCC
3AFC:  CLRF   xCB
3AFE:  CLRF   xCA
3B00:  MOVLW  0A
3B02:  MOVWF  xC9
3B04:  MOVLB  0
3B06:  CALL   326E
3B0A:  MOVFF  03,2C4
3B0E:  MOVFF  02,2C3
3B12:  MOVFF  01,2C2
3B16:  MOVFF  00,2C1
3B1A:  MOVLB  2
3B1C:  DECFSZ xBF,F
3B1E:  BRA    3A1E
3B20:  MOVLB  0
3B22:  RETLW  00
3B24:  MOVFF  FEA,2B2
3B28:  MOVFF  FE9,2B1
3B2C:  MOVLB  2
3B2E:  SWAPF  xAB,W
3B30:  IORLW  F0
3B32:  MOVWF  xAD
3B34:  ADDWF  xAD,F
3B36:  ADDLW  E2
3B38:  MOVWF  xAE
3B3A:  ADDLW  32
3B3C:  MOVWF  xB0
3B3E:  MOVF   xAB,W
3B40:  ANDLW  0F
3B42:  ADDWF  xAE,F
3B44:  ADDWF  xAE,F
3B46:  ADDWF  xB0,F
3B48:  ADDLW  E9
3B4A:  MOVWF  xAF
3B4C:  ADDWF  xAF,F
3B4E:  ADDWF  xAF,F
3B50:  SWAPF  xAA,W
3B52:  ANDLW  0F
3B54:  ADDWF  xAF,F
3B56:  ADDWF  xB0,F
3B58:  RLCF   xAF,F
3B5A:  RLCF   xB0,F
3B5C:  COMF   xB0,F
3B5E:  RLCF   xB0,F
3B60:  MOVF   xAA,W
3B62:  ANDLW  0F
3B64:  ADDWF  xB0,F
3B66:  RLCF   xAD,F
3B68:  MOVLW  07
3B6A:  MOVWF  xAC
3B6C:  MOVLW  0A
3B6E:  DECF   xAF,F
3B70:  ADDWF  xB0,F
3B72:  BNC   3B6E
3B74:  DECF   xAE,F
3B76:  ADDWF  xAF,F
3B78:  BNC   3B74
3B7A:  DECF   xAD,F
3B7C:  ADDWF  xAE,F
3B7E:  BNC   3B7A
3B80:  DECF   xAC,F
3B82:  ADDWF  xAD,F
3B84:  BNC   3B80
3B86:  MOVLW  02
3B88:  MOVWF  FEA
3B8A:  MOVLW  AC
3B8C:  MOVWF  FE9
3B8E:  MOVLW  07
3B90:  ANDWF  xB1,W
3B92:  BCF    xB1.6
3B94:  ADDWF  FE9,F
3B96:  MOVLW  B0
3B98:  SUBWF  FE9,W
3B9A:  BTFSC  FD8.2
3B9C:  BSF    xB1.6
3B9E:  MOVF   FEF,W
3BA0:  MOVWF  00
3BA2:  BNZ   3BB4
3BA4:  BTFSC  xB1.6
3BA6:  BRA    3BB4
3BA8:  BTFSC  xB1.4
3BAA:  BRA    3BC4
3BAC:  BTFSC  xB1.3
3BAE:  BRA    3BB4
3BB0:  MOVLW  20
3BB2:  BRA    3BBA
3BB4:  BSF    xB1.3
3BB6:  BCF    xB1.4
3BB8:  MOVLW  30
3BBA:  ADDWF  00,F
3BBC:  MOVF   00,W
3BBE:  BTFSS  F9E.4
3BC0:  BRA    3BBE
3BC2:  MOVWF  FAD
3BC4:  MOVF   FEE,W
3BC6:  BTFSS  xB1.6
3BC8:  BRA    3B96
3BCA:  MOVLB  0
3BCC:  RETLW  00
*
5766:  MOVFF  FF2,0E
576A:  BCF    FF2.7
576C:  ADDWF  FE8,W
576E:  ADDLW  8B
5770:  MOVWF  FF6
5772:  MOVLW  57
5774:  MOVWF  FF7
5776:  BTFSC  FD8.0
5778:  INCF   FF7,F
577A:  TBLRD*-
577C:  MOVF   FF5,W
577E:  MOVWF  FFA
5780:  TBLRD*
5782:  MOVF   FF5,W
5784:  BTFSC  0E.7
5786:  BSF    FF2.7
5788:  MOVWF  FF9
578A:  DATA F4,49
578C:  DATA 16,4A
578E:  DATA DC,4A
5790:  DATA 8E,4B
*
59B2:  MOVF   01,W
59B4:  MOVFF  96,2AC
59B8:  MOVLW  64
59BA:  MOVLB  2
59BC:  MOVWF  xAD
59BE:  MOVLB  0
59C0:  CALL   350A
59C4:  MOVFF  00,96
59C8:  MOVF   01,W
59CA:  MOVLW  30
59CC:  BNZ   59DC
59CE:  BTFSS  x97.1
59D0:  BRA    59EC
59D2:  BTFSC  x97.3
59D4:  BRA    59EC
59D6:  BTFSC  x97.4
59D8:  MOVLW  20
59DA:  BRA    59E2
59DC:  BCF    x97.3
59DE:  BCF    x97.4
59E0:  BSF    x97.0
59E2:  ADDWF  01,F
59E4:  MOVFF  01,A7
59E8:  CALL   13C0
59EC:  MOVFF  96,2AC
59F0:  MOVLW  0A
59F2:  MOVLB  2
59F4:  MOVWF  xAD
59F6:  MOVLB  0
59F8:  CALL   350A
59FC:  MOVFF  00,96
5A00:  MOVF   01,W
5A02:  MOVLW  30
5A04:  BNZ   5A12
5A06:  BTFSC  x97.3
5A08:  BRA    5A1C
5A0A:  BTFSS  x97.0
5A0C:  BRA    5A1C
5A0E:  BTFSC  x97.4
5A10:  MOVLW  20
5A12:  ADDWF  01,F
5A14:  MOVFF  01,A7
5A18:  CALL   13C0
5A1C:  MOVLW  30
5A1E:  ADDWF  x96,F
5A20:  MOVFF  96,A7
5A24:  CALL   13C0
5A28:  RETLW  00
....................                   //fijamos que el valor leído esté representado con 8 bits 
....................                   //(es decir de 00 a FF). 
....................                   //Para cambiar el rango de salida usamos: ADC=10 (000 a 3FF) 
....................                   //                                      ó ADC=16 (0000 a FFC0) 
.................... #list 
....................  
.................... #include "proyecto1.h" 
.................... //****************************************** 
.................... //Archivo de cabecera del Proyecto 1 
.................... //****************************************** 
.................... //Author: Julio Navarro Lara         2010 
....................  
.................... //Definimos los puertos del microcontrolador 
.................... #byte port_a = 0xF80 
.................... #byte port_b = 0xF81 
.................... #byte port_c = 0xF82 
.................... #byte port_d = 0xF83 
.................... #byte port_e = 0xF84 
....................  
.................... #bit sistema_encendido = 0xF83.4    //Pin que indica el encendido del sistema con un valor alto 
.................... #bit caldera_encendida = 0xF83.5    //Pin que indica el encendido de la caldera con un valor alto 
.................... #bit motor1 = 0xF83.6               //Pines que indican el encendido de los motores de circulación del agua con un valor alto 
.................... #bit motor2 = 0xF83.7               //El motor1 se refiere a la circulación del agua por los radiadores de la habitación 1, mientras 
....................                                     //que el motor2, a los radiadores de la habitación 2 
.................... #bit teclado1 = 0xF81.4             //Pines para gestionar la entrada del teclado 
.................... #bit teclado2 = 0xF81.5             //'' 
.................... #bit teclado3 = 0xF81.6             //'' 
.................... #bit teclado4 = 0xF81.7             //'' 
.................... #bit lcd_rs   = 0xF81.2             //Pin que controla la entrada RS de la pantalla LCD 
....................  
.................... //Parámetros de la pantalla LCD 
.................... #define LCD_ORDEN       0    //Código para enviar un orden 
.................... #define LCD_DATO        1    //Código para enviar un dato 
....................  
.................... #define LCD_CLEAR       0x01  //Orden para borrar la pantalla 
.................... #define LCD_NO_CURSOR   0x0C  //Orden para eliminar el cursor de la pantalla 
.................... #define LCD_CURSOR      0x0E  //Orden para visualizar el cursor en la pantalla 
.................... #define LCD_APAGAR      0x08  //Orden para apagar la pantalla 
....................  
.................... //Tiempo que se mantienen los mensajes temporales en pantalla (ms) 
.................... #define LCD_T_RETARDO   500 
....................  
.................... //Clave de acceso 
.................... #define clave           2401 
....................  
....................  
.................... //Parámetros del teclado 
.................... #define NUM_COLUMNAS 3     //Número de columnas del teclado matricial 
.................... #define NUM_FILAS    4     //Número de filas del teclado matricial 
.................... #define NO           100  //Codificación del NO en el método buscar_numero() 
.................... #define SI           101  //Codificación del SI en el método buscar_numero() 
....................  
.................... //Parámetros del conversor AD 
.................... #define termostato_caldera   3   //Entrada AD que se refiere a la temperatura de referencia de la caldera 
.................... #define temperatura_caldera  0   //Entrada AD que se refiere a la temperatura del agua en la caldera 
.................... #define histeresis_caldera   10   //Diferencia de histéresis para el agua de la caldera 
.................... //La histéresis es tan grande debido a que los potenciómetros incluidos en la simulación de PROTEUS no tienen 
.................... //más sensibilidad. Lo normal sería poner una histéresis de unos 5 ºC. 
.................... #define t_max_caldera        100  //Temperatura máxima a la que puede regularse la caldera 
.................... #define t_min_caldera        0  //Temperatura mínima a la que puede regularse la caldera 
.................... #define AD_num_valores       255 //Número de valores de escala del conversor (sensibilidad de los potenciómetros) 
....................  
.................... //Parámetros de control de temperatura 
.................... //Datos suministrados por el aparato de aire acondicionado (con bomba de calor) de mi casa 
.................... #define temp_max          32  //Temperatura máxima de regulación del termostato 
.................... #define temp_min          16  //Temperatura mínima de regulación del termostato 
....................  
....................  
.................... //Direcciones para la EEPROM 
.................... #define eeprom_termostato        0x10  //Valor del termostato 
.................... #define eeprom_num_intervalos    0x11  //Número de intervalos de programación de los que disponemos 
.................... #define eeprom_num_registros     0x12  //Número de registros de desconexión de los que se disponen 
.................... #define eeprom_anno_actual       0x14  //Año en el que nos encontramos 
.................... #define eeprom_anno_1_to_3       0x15  //Año en el que nos encontramos medido de 0 a 3 (llamado 1_to_3 por razones "históricas") 
.................... #define eeprom_programaciones    0x18  //Posición a partir de la cual se almacenan las programaciones de alarmas 
.................... #define eeprom_registros         0x50  //Posición a partir de la cual se almacenan los registros 
....................  
.................... #fuses HS, NOPROTECT, BROWNOUT, PUT, NOLVP, NOXINST, WDT4096, NOWDT 
.................... //El watchdog-timer salta cada 16.384 segundos, aproximadamente 
.................... #use delay(clock=8000000, restart_wdt) 
*
12A8:  CLRF   FEA
12AA:  MOVLW  AE
12AC:  MOVWF  FE9
12AE:  MOVF   FEF,W
12B0:  BZ    12D6
12B2:  MOVLW  02
12B4:  MOVWF  01
12B6:  MOVLW  BF
12B8:  MOVWF  00
12BA:  CLRWDT
12BC:  DECFSZ 00,F
12BE:  BRA    12BA
12C0:  DECFSZ 01,F
12C2:  BRA    12B6
12C4:  MOVLW  96
12C6:  MOVWF  00
12C8:  DECFSZ 00,F
12CA:  BRA    12C8
12CC:  NOP   
12CE:  NOP   
12D0:  CLRWDT
12D2:  DECFSZ FEF,F
12D4:  BRA    12B2
12D6:  RETLW  00
*
12F6:  MOVLW  09
12F8:  SUBWF  xAF,F
12FA:  BNC   1312
12FC:  CLRF   FEA
12FE:  MOVLW  AF
1300:  MOVWF  FE9
1302:  BCF    FD8.0
1304:  RRCF   FEF,F
1306:  MOVF   FEF,W
1308:  BZ    1312
130A:  BRA    130E
130C:  CLRWDT
130E:  DECFSZ FEF,F
1310:  BRA    130C
1312:  RETLW  00
.................... #use rs232(baud=4800, xmit=PIN_C6,rcv=PIN_C7) 
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  (x==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  (x<' ') 
.................... #define isprint(x)  (x>=' ') 
.................... #define isgraph(x)  (x>' ') 
.................... #define ispunct(x)  ((x>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(int *)==1 
.................... #define ptrdiff_t int 
.................... #else 
.................... #define ptrdiff_t long 
.................... #endif 
....................  
.................... #define size_t int 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: float atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... float atof(char * s); 
....................  
.................... /* Standard template: float atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... float atoe(char * s); 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int32 atoi32(char *s); 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, int8 base, char * s); 
....................  
.................... /* Standard template: signed long  atol(char * s) 
....................  * converts the initial portion of the string s to a signed long 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: float strtol(char * s,char *endptr) 
....................  * converts the initial portion of the string s to a float 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... float strtod(char *s,char *endptr); 
....................  
.................... /* Standard template: long strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr,signed int base); 
....................  
.................... /* Standard template: long strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... long strtoul(char *s,char *endptr,signed int base); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... long rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer,signed int denom); 
.................... ldiv_t ldiv(signed long numer,signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(int *)==1 
.................... #define ptrdiff_t int 
.................... #else 
.................... #define ptrdiff_t long 
.................... #endif 
....................  
.................... #define size_t int 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(int *)==1 
.................... #define ptrdiff_t int 
.................... #else 
.................... #define ptrdiff_t long 
.................... #endif 
....................  
.................... #define size_t int 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  (x==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  (x<' ') 
.................... #define isprint(x)  (x>=' ') 
.................... #define isgraph(x)  (x>' ') 
.................... #define ispunct(x)  ((x>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* compiler ignored the name 'strcpy()'; perhaps, it's reserved? 
....................    Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1*/ 
....................  
.................... char *strcopy(char *s1, char *s2) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; *s2 != 0; s++, s2++) { 
.................... 	  *s = *s2; 
....................   } 
....................   *s = *s2; 
....................   return(s1); 
.................... } 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   int n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,int c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, int c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... int *strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, int c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... int *strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
.................... 	 if (*sc2 == '\0') 
.................... 	    return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
.................... 	char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
.................... 	while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && *s == *t; ++s, ++t); 
....................  
.................... 		if (*t == '\0') 
.................... 			return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
.................... 	} 
.................... 	return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(int errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... int *strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer,signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer,signed long denom) 
.................... { 
....................    ldiv_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... float atof(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int sign = 0; 
....................    char c; 
....................    int ptr = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
....................  
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int sign = 0; 
....................    int expsign = 0; 
....................    char c; 
....................    int ptr = 0; 
....................    int i; 
....................    float exp = 1.0; 
....................    int expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
1450:  CLRF   xAD
....................    sign = 0; 
1452:  CLRF   xAB
....................    base = 10; 
1454:  MOVLW  0A
1456:  MOVWF  xAC
....................    result = 0; 
1458:  CLRF   xAA
....................  
....................    if (!s) 
145A:  MOVF   xA8,W
145C:  IORWF  xA9,W
145E:  BNZ   1466
....................       return 0; 
1460:  MOVLW  00
1462:  MOVWF  01
1464:  BRA    15E8
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
1466:  MOVF   xAD,W
1468:  INCF   xAD,F
146A:  CLRF   03
146C:  ADDWF  xA8,W
146E:  MOVWF  FE9
1470:  MOVF   xA9,W
1472:  ADDWFC 03,W
1474:  MOVWF  FEA
1476:  MOVFF  FEF,AE
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
147A:  MOVF   xAE,W
147C:  SUBLW  2D
147E:  BNZ   149A
....................    { 
....................       sign = 1;         // Set the sign to negative 
1480:  MOVLW  01
1482:  MOVWF  xAB
....................       c = s[index++]; 
1484:  MOVF   xAD,W
1486:  INCF   xAD,F
1488:  CLRF   03
148A:  ADDWF  xA8,W
148C:  MOVWF  FE9
148E:  MOVF   xA9,W
1490:  ADDWFC 03,W
1492:  MOVWF  FEA
1494:  MOVFF  FEF,AE
....................    } 
....................    else if (c == '+') 
1498:  BRA    14B4
149A:  MOVF   xAE,W
149C:  SUBLW  2B
149E:  BNZ   14B4
....................    { 
....................       c = s[index++]; 
14A0:  MOVF   xAD,W
14A2:  INCF   xAD,F
14A4:  CLRF   03
14A6:  ADDWF  xA8,W
14A8:  MOVWF  FE9
14AA:  MOVF   xA9,W
14AC:  ADDWFC 03,W
14AE:  MOVWF  FEA
14B0:  MOVFF  FEF,AE
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
14B4:  MOVF   xAE,W
14B6:  SUBLW  2F
14B8:  BTFSC  FD8.0
14BA:  BRA    15D8
14BC:  MOVF   xAE,W
14BE:  SUBLW  39
14C0:  BTFSS  FD8.0
14C2:  BRA    15D8
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
14C4:  MOVF   xAE,W
14C6:  SUBLW  30
14C8:  BNZ   150C
14CA:  CLRF   03
14CC:  MOVF   xAD,W
14CE:  ADDWF  xA8,W
14D0:  MOVWF  FE9
14D2:  MOVF   xA9,W
14D4:  ADDWFC 03,W
14D6:  MOVWF  FEA
14D8:  MOVF   FEF,W
14DA:  SUBLW  78
14DC:  BZ    14F2
14DE:  CLRF   03
14E0:  MOVF   xAD,W
14E2:  ADDWF  xA8,W
14E4:  MOVWF  FE9
14E6:  MOVF   xA9,W
14E8:  ADDWFC 03,W
14EA:  MOVWF  FEA
14EC:  MOVF   FEF,W
14EE:  SUBLW  58
14F0:  BNZ   150C
....................       { 
....................          base = 16; 
14F2:  MOVLW  10
14F4:  MOVWF  xAC
....................          index++; 
14F6:  INCF   xAD,F
....................          c = s[index++]; 
14F8:  MOVF   xAD,W
14FA:  INCF   xAD,F
14FC:  CLRF   03
14FE:  ADDWF  xA8,W
1500:  MOVWF  FE9
1502:  MOVF   xA9,W
1504:  ADDWFC 03,W
1506:  MOVWF  FEA
1508:  MOVFF  FEF,AE
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
150C:  MOVF   xAC,W
150E:  SUBLW  0A
1510:  BNZ   1548
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
1512:  MOVF   xAE,W
1514:  SUBLW  2F
1516:  BC    1546
1518:  MOVF   xAE,W
151A:  SUBLW  39
151C:  BNC   1546
....................             result = 10*result + (c - '0'); 
151E:  MOVLW  0A
1520:  MOVWF  xAF
1522:  MOVFF  AA,B0
1526:  BRA    1404
1528:  MOVLW  30
152A:  SUBWF  xAE,W
152C:  ADDWF  01,W
152E:  MOVWF  xAA
....................             c = s[index++]; 
1530:  MOVF   xAD,W
1532:  INCF   xAD,F
1534:  CLRF   03
1536:  ADDWF  xA8,W
1538:  MOVWF  FE9
153A:  MOVF   xA9,W
153C:  ADDWFC 03,W
153E:  MOVWF  FEA
1540:  MOVFF  FEF,AE
....................          } 
1544:  BRA    1512
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
1546:  BRA    15D8
1548:  MOVF   xAC,W
154A:  SUBLW  10
154C:  BNZ   15D8
....................       { 
....................          c = toupper(c); 
154E:  MOVF   xAE,W
1550:  SUBLW  60
1552:  BC    1560
1554:  MOVF   xAE,W
1556:  SUBLW  7A
1558:  BNC   1560
155A:  MOVF   xAE,W
155C:  ANDLW  DF
155E:  BRA    1562
1560:  MOVF   xAE,W
1562:  MOVWF  xAE
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
1564:  MOVF   xAE,W
1566:  SUBLW  2F
1568:  BC    1570
156A:  MOVF   xAE,W
156C:  SUBLW  39
156E:  BC    157C
1570:  MOVF   xAE,W
1572:  SUBLW  40
1574:  BC    15D8
1576:  MOVF   xAE,W
1578:  SUBLW  46
157A:  BNC   15D8
....................             if (c >= '0' && c <= '9') 
157C:  MOVF   xAE,W
157E:  SUBLW  2F
1580:  BC    159A
1582:  MOVF   xAE,W
1584:  SUBLW  39
1586:  BNC   159A
....................                result = (result << 4) + (c - '0'); 
1588:  SWAPF  xAA,W
158A:  MOVWF  xAF
158C:  MOVLW  F0
158E:  ANDWF  xAF,F
1590:  MOVLW  30
1592:  SUBWF  xAE,W
1594:  ADDWF  xAF,W
1596:  MOVWF  xAA
....................             else 
1598:  BRA    15AC
....................                result = (result << 4) + (c - 'A' + 10); 
159A:  SWAPF  xAA,W
159C:  MOVWF  xAF
159E:  MOVLW  F0
15A0:  ANDWF  xAF,F
15A2:  MOVLW  41
15A4:  SUBWF  xAE,W
15A6:  ADDLW  0A
15A8:  ADDWF  xAF,W
15AA:  MOVWF  xAA
....................  
....................             c = s[index++]; 
15AC:  MOVF   xAD,W
15AE:  INCF   xAD,F
15B0:  CLRF   03
15B2:  ADDWF  xA8,W
15B4:  MOVWF  FE9
15B6:  MOVF   xA9,W
15B8:  ADDWFC 03,W
15BA:  MOVWF  FEA
15BC:  MOVFF  FEF,AE
....................             c = toupper(c); 
15C0:  MOVF   xAE,W
15C2:  SUBLW  60
15C4:  BC    15D2
15C6:  MOVF   xAE,W
15C8:  SUBLW  7A
15CA:  BNC   15D2
15CC:  MOVF   xAE,W
15CE:  ANDLW  DF
15D0:  BRA    15D4
15D2:  MOVF   xAE,W
15D4:  MOVWF  xAE
....................          } 
15D6:  BRA    1564
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
15D8:  DECFSZ xAB,W
15DA:  BRA    15E4
15DC:  MOVF   xAC,W
15DE:  SUBLW  0A
15E0:  BNZ   15E4
....................        result = -result; 
15E2:  NEGF   xAA
....................  
....................    return(result); 
15E4:  MOVFF  AA,01
.................... } 
15E8:  RETLW  00
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... char * itoa(signed int32 num, int8 base, char *s) 
.................... { 
....................      int32 temp=1; 
....................      int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... float strtod(char *s,char *endptr) { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int sign = 0, point = 0; 
....................    char c; 
....................    int ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c=s[ptr++]; 
....................  
....................  
....................    while((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 0) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          point = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 1) { 
....................          pow10 = pow10*10; 
....................          result += (c - '0')/pow10; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '+') { 
....................          c = s[ptr++]; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................          *((char *)endptr)=s+ptr; 
....................       } 
....................       else 
....................          *((char *)endptr)=s; 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... long strtoul(char *s,char *endptr,signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-') 
....................    { 
....................       if (endptr) 
....................       { 
....................         *((char *)endptr)=s; 
....................       } 
....................       return 0; 
....................    } 
....................  
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    { 
....................       if (endptr) 
....................       { 
....................         *((char *)endptr)=s; 
....................       } 
....................       return 0; 
....................    } 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................       if (endptr) 
....................       { 
....................         *((char *)endptr)=s; 
....................       } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................         *((char *)endptr)=sc; 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr,signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    { 
....................       if (endptr) 
....................       { 
....................         *((char *)endptr)=s; 
....................       } 
....................       return 0; 
....................    } 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................       if (endptr) 
....................       { 
....................         *((char *)endptr)=s; 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................         *((char *)endptr)=sc; 
....................    return x; 
.................... } 
....................  
.................... signed int system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed = 1; 
....................  
.................... long rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned long)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... typedef signed int (*_Cmpfun)(char * p1,char * p2); 
....................  
.................... void qsort(char * qdata, int qitems, int qsize, _Cmpfun cmp) { 
....................    int m,j,i,l; 
....................    short done; 
....................    BYTE t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=TRUE; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = FALSE; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include "PCF8583.c" 
.................... // Funciones para el RTC I2c: PCF8583 
.................... // Este código no procede de CCS (no está totalmente verificado) 
.................... // Inluye funciones de conversión BCD-Binario 
.................... // y de lectura/escritura a través de I2C. 
....................  
.................... //Vamos a eliminar todos los casos en los que se habiliten las interrupciones globales 
.................... //Estas sentencias nos impedían utilizar estos métodos en las interrupciones 
....................  
.................... #ifndef PCF8583_SDA 
.................... #define PCF8583_SDA  PIN_C4 
.................... #define PCF8583_SCL  PIN_C3 
.................... #endif 
....................  
.................... #use i2c(master, sda=PCF8583_SDA, scl=PCF8583_SCL, NOFORCE_SW) 
*
1680:  BCF    FC6.7
1682:  BCF    F9E.3
1684:  MOVFF  2BA,FC9
1688:  MOVLW  02
168A:  BTFSC  FC6.7
168C:  BRA    1698
168E:  BTFSS  F9E.3
1690:  BRA    168E
1692:  MOVLW  00
1694:  BTFSC  FC5.6
1696:  MOVLW  01
1698:  MOVWF  01
169A:  RETLW  00
*
26DA:  BSF    FC5.3
26DC:  BTFSC  FC5.3
26DE:  BRA    26DC
26E0:  BTFSC  00.0
26E2:  BCF    FC5.5
26E4:  BTFSS  00.0
26E6:  BSF    FC5.5
26E8:  BSF    FC5.4
26EA:  BTFSC  FC5.4
26EC:  BRA    26EA
26EE:  MOVFF  FC9,01
26F2:  RETLW  00
....................  
.................... #ifndef PCF8583_WRITE_ADDRESS 
.................... #define PCF8583_WRITE_ADDRESS 0xA0 
.................... #define PCF8583_READ_ADDRESS  0xA1 
.................... #endif 
....................  
.................... // Register addresses 
.................... #define PCF8583_CTRL_STATUS_REG    0x00 
.................... #define PCF8583_100S_REG           0x01 
.................... #define PCF8583_SECONDS_REG        0x02 
.................... #define PCF8583_MINUTES_REG        0x03 
.................... #define PCF8583_HOURS_REG          0x04 
.................... #define PCF8583_DATE_REG           0x05 
.................... #define PCF8583_MONTHS_REG         0x06 
.................... #define PCF8583_TIMER_REG          0x07 
....................  
.................... #define PCF8583_ALARM_CONTROL_REG  0x08 
.................... #define PCF8583_ALARM_100S_REG     0x09 
.................... #define PCF8583_ALARM_SECS_REG     0x0A 
.................... #define PCF8583_ALARM_MINS_REG     0x0B 
.................... #define PCF8583_ALARM_HOURS_REG    0x0C 
.................... #define PCF8583_ALARM_DATE_REG     0x0D 
.................... #define PCF8583_ALARM_MONTHS_REG   0x0E 
.................... #define PCF8583_ALARM_TIMER_REG    0x0F 
....................  
.................... // Use the first NVRAM address for the year byte. 
.................... #define PCF8583_YEAR_REG           0x10 
....................  
....................  
.................... // Commands for the Control/Status register. 
.................... #define PCF8583_START_COUNTING     0x00 
.................... #define PCF8583_STOP_COUNTING      0x80 
.................... #define PCF8583_ACTIVAR_ALARMA     0b00000100  //Palabra de activación de la alarma 
.................... #define PCF8583_DEFINIR_ALARMA     0b10010000  //Palabra para definir el comportamiento 
....................                                                //de la alarma en su registro 
....................  
.................... #define PCF8583_DESACTIVAR_INT     0b00010000 
....................  
....................  
.................... int8 alarma_activada=0; 
....................  
....................  
.................... char const weekday_names[7][10] = 
.................... { 
.................... {"DOM"}, 
.................... {"LUN"}, 
.................... {"MAR"}, 
.................... {"MIE"}, 
.................... {"JUE"}, 
.................... {"VIE"}, 
.................... {"SAB"} 
.................... }; 
....................  
.................... // This structure defines the user's date and time data. 
.................... // The values are stored as unsigned integers.  The user 
.................... // should declare a structure of this type in the application 
.................... // program. Then the address of the structure should be 
.................... // passed to the PCF8583 read/write functions in this 
.................... // driver, whenever you want to talk to the chip. 
.................... typedef struct 
.................... { 
.................... int8 seconds;    // 0 to 59 
.................... int8 minutes;    // 0 to 59 
.................... int8 hours;      // 0 to 23  (24-hour time) 
.................... int8 day;        // 1 to 31 
.................... int8 month;      // 1 to 12 
.................... int8 year;       // 00 to 99 
.................... int8 weekday;    // 0 = Sunday, 1 = Monday, etc. 
.................... }date_time_t; 
....................  
....................  
.................... //---------------------------------------------- 
.................... void PCF8583_write_byte(int8 address, int8 data) 
.................... { 
.................... disable_interrupts(GLOBAL); 
*
169C:  BCF    FF2.6
169E:  BCF    FF2.7
16A0:  BTFSC  FF2.7
16A2:  BRA    169E
.................... i2c_start(); 
16A4:  BSF    FC5.0
16A6:  BTFSC  FC5.0
16A8:  BRA    16A6
.................... i2c_write(PCF8583_WRITE_ADDRESS); 
16AA:  MOVLW  A0
16AC:  MOVLB  2
16AE:  MOVWF  xBA
16B0:  MOVLB  0
16B2:  RCALL  1680
.................... i2c_write(address); 
16B4:  MOVFF  AD,2BA
16B8:  RCALL  1680
.................... i2c_write(data); 
16BA:  MOVFF  AE,2BA
16BE:  RCALL  1680
.................... i2c_stop(); 
16C0:  BSF    FC5.2
16C2:  BTFSC  FC5.2
16C4:  BRA    16C2
.................... } 
16C6:  RETLW  00
....................  
.................... //---------------------------------------------- 
.................... int8 PCF8583_read_byte(int8 address) 
.................... { 
.................... int8 retval; 
....................  
.................... disable_interrupts(GLOBAL); 
*
271A:  BCF    FF2.6
271C:  BCF    FF2.7
271E:  BTFSC  FF2.7
2720:  BRA    271C
.................... i2c_start(); 
2722:  BSF    FC5.0
2724:  BTFSC  FC5.0
2726:  BRA    2724
.................... i2c_write(PCF8583_WRITE_ADDRESS); 
2728:  MOVLW  A0
272A:  MOVLB  2
272C:  MOVWF  xBA
272E:  MOVLB  0
2730:  CALL   1680
.................... i2c_write(address); 
2734:  MOVFF  AA,2BA
2738:  CALL   1680
.................... i2c_start(); 
273C:  BSF    FC5.1
273E:  BTFSC  FC5.1
2740:  BRA    273E
.................... i2c_write(PCF8583_READ_ADDRESS); 
2742:  MOVLW  A1
2744:  MOVLB  2
2746:  MOVWF  xBA
2748:  MOVLB  0
274A:  CALL   1680
.................... retval = i2c_read(0); 
274E:  CLRF   00
2750:  RCALL  26DA
2752:  MOVFF  01,AB
.................... i2c_stop(); 
2756:  BSF    FC5.2
2758:  BTFSC  FC5.2
275A:  BRA    2758
....................  
.................... return(retval); 
275C:  MOVFF  AB,01
.................... } 
2760:  GOTO   28BC (RETURN)
....................  
....................  
.................... void PCF8583_init(void) 
.................... { 
.................... PCF8583_write_byte(PCF8583_CTRL_STATUS_REG, 
....................                               PCF8583_START_COUNTING); 
.................... } 
....................  
.................... //---------------------------------------------- 
.................... // This function converts an 8 bit binary value 
.................... // to an 8 bit BCD value. 
.................... // The input range must be from 0 to 99. 
....................  
.................... int8 bin2bcd(int8 value) 
.................... { 
.................... char retval; 
....................  
.................... retval = 0; 
*
1660:  CLRF   xAE
....................  
.................... while(1) 
....................   { 
....................    // Get the tens digit by doing multiple subtraction 
....................    // of 10 from the binary value. 
....................    if(value >= 10) 
1662:  MOVF   xAD,W
1664:  SUBLW  09
1666:  BC    1672
....................      { 
....................       value -= 10; 
1668:  MOVLW  0A
166A:  SUBWF  xAD,F
....................       retval += 0x10; 
166C:  MOVLW  10
166E:  ADDWF  xAE,F
....................      } 
....................    else // Get the ones digit by adding the remainder. 
1670:  BRA    1678
....................      { 
....................       retval += value; 
1672:  MOVF   xAD,W
1674:  ADDWF  xAE,F
....................       break; 
1676:  BRA    167A
....................      } 
....................    } 
1678:  BRA    1662
....................  
.................... return(retval); 
167A:  MOVFF  AE,01
.................... } 
167E:  RETLW  00
....................  
.................... //---------------------------------------------- 
.................... // This function converts an 8 bit BCD value to 
.................... // an 8 bit binary value. 
.................... // The input range must be from 00 to 99. 
....................  
.................... char bcd2bin(char bcd_value) 
.................... { 
.................... char temp; 
....................  
.................... temp = bcd_value; 
*
26F4:  MOVFF  AD,AE
....................  
.................... // Shifting the upper digit right by 1 is 
.................... // the same as multiplying it by 8. 
.................... temp >>= 1; 
26F8:  BCF    FD8.0
26FA:  RRCF   xAE,F
....................  
.................... // Isolate the bits for the upper digit. 
.................... temp &= 0x78; 
26FC:  MOVLW  78
26FE:  ANDWF  xAE,F
....................  
.................... // Now return: (Tens * 8) + (Tens * 2) + Ones 
.................... return(temp + (temp >> 2) + (bcd_value & 0x0f)); 
2700:  RRCF   xAE,W
2702:  MOVWF  00
2704:  RRCF   00,F
2706:  MOVLW  3F
2708:  ANDWF  00,F
270A:  MOVF   00,W
270C:  ADDWF  xAE,W
270E:  MOVWF  xAF
2710:  MOVF   xAD,W
2712:  ANDLW  0F
2714:  ADDWF  xAF,W
2716:  MOVWF  01
....................  
.................... } 
2718:  RETLW  00
....................  
.................... //---------------------------------------------- 
.................... void PCF8583_set_datetime(date_time_t *dt) 
.................... { 
.................... int8 bcd_sec; 
.................... int8 bcd_min; 
.................... int8 bcd_hrs; 
.................... int8 bcd_day; 
.................... int8 bcd_mon; 
....................  
.................... // Convert the input date/time into BCD values 
.................... // that are formatted for the PCF8583 registers. 
.................... bcd_sec = bin2bcd(dt->seconds); 
*
16C8:  MOVF   xA5,W
16CA:  MOVWF  FE9
16CC:  MOVFF  A6,FEA
16D0:  MOVFF  FEF,AC
16D4:  MOVFF  AC,AD
16D8:  RCALL  1660
16DA:  MOVFF  01,A7
.................... bcd_min = bin2bcd(dt->minutes); 
16DE:  MOVLW  01
16E0:  ADDWF  xA5,W
16E2:  MOVWF  FE9
16E4:  MOVLW  00
16E6:  ADDWFC xA6,W
16E8:  MOVWF  FEA
16EA:  MOVFF  FEF,AC
16EE:  MOVFF  AC,AD
16F2:  RCALL  1660
16F4:  MOVFF  01,A8
.................... bcd_hrs = bin2bcd(dt->hours); 
16F8:  MOVLW  02
16FA:  ADDWF  xA5,W
16FC:  MOVWF  FE9
16FE:  MOVLW  00
1700:  ADDWFC xA6,W
1702:  MOVWF  FEA
1704:  MOVFF  FEF,AC
1708:  MOVFF  AC,AD
170C:  RCALL  1660
170E:  MOVFF  01,A9
.................... bcd_day = bin2bcd(dt->day) | (dt->year << 6); 
1712:  MOVLW  03
1714:  ADDWF  xA5,W
1716:  MOVWF  FE9
1718:  MOVLW  00
171A:  ADDWFC xA6,W
171C:  MOVWF  FEA
171E:  MOVFF  FEF,AC
1722:  MOVFF  AC,AD
1726:  RCALL  1660
1728:  MOVLW  05
172A:  ADDWF  xA5,W
172C:  MOVWF  FE9
172E:  MOVLW  00
1730:  ADDWFC xA6,W
1732:  MOVWF  FEA
1734:  SWAPF  FEF,W
1736:  MOVWF  00
1738:  RLCF   00,F
173A:  RLCF   00,F
173C:  MOVLW  C0
173E:  ANDWF  00,F
1740:  MOVF   00,W
1742:  IORWF  01,W
1744:  MOVWF  xAA
.................... bcd_mon = bin2bcd(dt->month) | (dt->weekday << 5); 
1746:  MOVLW  04
1748:  ADDWF  xA5,W
174A:  MOVWF  FE9
174C:  MOVLW  00
174E:  ADDWFC xA6,W
1750:  MOVWF  FEA
1752:  MOVFF  FEF,AC
1756:  MOVFF  AC,AD
175A:  RCALL  1660
175C:  MOVLW  06
175E:  ADDWF  xA5,W
1760:  MOVWF  FE9
1762:  MOVLW  00
1764:  ADDWFC xA6,W
1766:  MOVWF  FEA
1768:  SWAPF  FEF,W
176A:  MOVWF  00
176C:  RLCF   00,F
176E:  MOVLW  E0
1770:  ANDWF  00,F
1772:  MOVF   00,W
1774:  IORWF  01,W
1776:  MOVWF  xAB
....................  
.................... // Stop the RTC from counting, before we write to 
.................... // the date and time registers. 
.................... PCF8583_write_byte(PCF8583_CTRL_STATUS_REG, 
....................                               PCF8583_STOP_COUNTING); 
1778:  CLRF   xAD
177A:  MOVLW  80
177C:  MOVWF  xAE
177E:  RCALL  169C
....................  
.................... // Write to the date and time registers.  Disable interrupts 
.................... // so they can't disrupt the i2c operations. 
.................... disable_interrupts(GLOBAL); 
1780:  BCF    FF2.6
1782:  BCF    FF2.7
1784:  BTFSC  FF2.7
1786:  BRA    1782
.................... i2c_start(); 
1788:  BSF    FC5.0
178A:  BTFSC  FC5.0
178C:  BRA    178A
.................... i2c_write(PCF8583_WRITE_ADDRESS); 
178E:  MOVLW  A0
1790:  MOVLB  2
1792:  MOVWF  xBA
1794:  MOVLB  0
1796:  RCALL  1680
.................... i2c_write(PCF8583_100S_REG);   // Start at 100's reg. 
1798:  MOVLW  01
179A:  MOVLB  2
179C:  MOVWF  xBA
179E:  MOVLB  0
17A0:  RCALL  1680
.................... i2c_write(0x00);               // Set 100's reg = 0 
17A2:  MOVLB  2
17A4:  CLRF   xBA
17A6:  MOVLB  0
17A8:  RCALL  1680
.................... i2c_write(bcd_sec); 
17AA:  MOVFF  A7,2BA
17AE:  RCALL  1680
.................... i2c_write(bcd_min); 
17B0:  MOVFF  A8,2BA
17B4:  RCALL  1680
.................... i2c_write(bcd_hrs); 
17B6:  MOVFF  A9,2BA
17BA:  RCALL  1680
.................... i2c_write(bcd_day); 
17BC:  MOVFF  AA,2BA
17C0:  RCALL  1680
.................... i2c_write(bcd_mon); 
17C2:  MOVFF  AB,2BA
17C6:  RCALL  1680
.................... i2c_stop(); 
17C8:  BSF    FC5.2
17CA:  BTFSC  FC5.2
17CC:  BRA    17CA
....................  
.................... // Write the year byte to the first NVRAM location. 
.................... // Leave it in binary format. 
.................... PCF8583_write_byte(PCF8583_YEAR_REG, dt->year); 
17CE:  MOVLW  05
17D0:  ADDWF  xA5,W
17D2:  MOVWF  FE9
17D4:  MOVLW  00
17D6:  ADDWFC xA6,W
17D8:  MOVWF  FEA
17DA:  MOVFF  FEF,AC
17DE:  MOVLW  10
17E0:  MOVWF  xAD
17E2:  MOVFF  AC,AE
17E6:  RCALL  169C
....................  
.................... // Now allow the PCF8583 to start counting again. 
.................... PCF8583_write_byte(PCF8583_CTRL_STATUS_REG, 
....................                               PCF8583_START_COUNTING); 
17E8:  CLRF   xAD
17EA:  CLRF   xAE
17EC:  RCALL  169C
.................... } 
17EE:  GOTO   1D26 (RETURN)
....................  
.................... //---------------------------------------------- 
.................... // Read the Date and Time from the hardware registers 
.................... // in the PCF8583.   We don't have to disable counting 
.................... // during read operations, because according to the data 
.................... // sheet, if any of the lower registers (1 to 7) is read, 
.................... // all of them are loaded into "capture" registers. 
.................... // All further reading within that cycle is done from 
.................... // those registers. 
....................  
.................... void PCF8583_read_datetime(date_time_t *dt) 
.................... { 
.................... int8 year_bits; 
.................... int8 year; 
....................  
.................... int8 bcd_sec; 
.................... int8 bcd_min; 
.................... int8 bcd_hrs; 
.................... int8 bcd_day; 
.................... int8 bcd_mon; 
....................  
.................... // Disable interrupts so the i2c process is not disrupted. 
.................... disable_interrupts(GLOBAL); 
*
2764:  BCF    FF2.6
2766:  BCF    FF2.7
2768:  BTFSC  FF2.7
276A:  BRA    2766
....................  
.................... // Read the date/time registers inside the PCF8583. 
.................... i2c_start(); 
276C:  BSF    FC5.0
276E:  BTFSC  FC5.0
2770:  BRA    276E
.................... i2c_write(PCF8583_WRITE_ADDRESS); 
2772:  MOVLW  A0
2774:  MOVLB  2
2776:  MOVWF  xBA
2778:  MOVLB  0
277A:  CALL   1680
.................... i2c_write(PCF8583_SECONDS_REG);   // Start at seconds reg. 
277E:  MOVLW  02
2780:  MOVLB  2
2782:  MOVWF  xBA
2784:  MOVLB  0
2786:  CALL   1680
.................... i2c_start(); 
278A:  BSF    FC5.1
278C:  BTFSC  FC5.1
278E:  BRA    278C
.................... i2c_write(PCF8583_READ_ADDRESS); 
2790:  MOVLW  A1
2792:  MOVLB  2
2794:  MOVWF  xBA
2796:  MOVLB  0
2798:  CALL   1680
....................  
.................... bcd_sec = i2c_read(); 
279C:  MOVLW  01
279E:  MOVWF  00
27A0:  RCALL  26DA
27A2:  MOVFF  01,A5
.................... bcd_min = i2c_read(); 
27A6:  MOVLW  01
27A8:  MOVWF  00
27AA:  RCALL  26DA
27AC:  MOVFF  01,A6
.................... bcd_hrs = i2c_read(); 
27B0:  MOVLW  01
27B2:  MOVWF  00
27B4:  RCALL  26DA
27B6:  MOVFF  01,A7
.................... bcd_day = i2c_read(); 
27BA:  MOVLW  01
27BC:  MOVWF  00
27BE:  RCALL  26DA
27C0:  MOVFF  01,A8
.................... bcd_mon = i2c_read(0); 
27C4:  CLRF   00
27C6:  RCALL  26DA
27C8:  MOVFF  01,A9
.................... i2c_stop(); 
27CC:  BSF    FC5.2
27CE:  BTFSC  FC5.2
27D0:  BRA    27CE
....................  
....................  
.................... // Convert the date/time values from BCD to 
.................... // unsigned 8-bit integers.  Unpack the bits 
.................... // in the PCF8583 registers where required. 
.................... dt->seconds = bcd2bin(bcd_sec); 
27D2:  MOVFF  A1,01
27D6:  MOVFF  A2,03
27DA:  MOVFF  A1,AA
27DE:  MOVFF  A2,AB
27E2:  MOVFF  A5,AD
27E6:  RCALL  26F4
27E8:  MOVFF  AB,FEA
27EC:  MOVFF  AA,FE9
27F0:  MOVFF  01,FEF
.................... dt->minutes = bcd2bin(bcd_min); 
27F4:  MOVLW  01
27F6:  ADDWF  xA1,W
27F8:  MOVWF  01
27FA:  MOVLW  00
27FC:  ADDWFC xA2,W
27FE:  MOVWF  03
2800:  MOVFF  01,AA
2804:  MOVWF  xAB
2806:  MOVFF  A6,AD
280A:  RCALL  26F4
280C:  MOVFF  AB,FEA
2810:  MOVFF  AA,FE9
2814:  MOVFF  01,FEF
.................... dt->hours   = bcd2bin(bcd_hrs & 0x3F); 
2818:  MOVLW  02
281A:  ADDWF  xA1,W
281C:  MOVWF  01
281E:  MOVLW  00
2820:  ADDWFC xA2,W
2822:  MOVWF  03
2824:  MOVFF  01,AA
2828:  MOVWF  xAB
282A:  MOVF   xA7,W
282C:  ANDLW  3F
282E:  MOVWF  xAC
2830:  MOVWF  xAD
2832:  RCALL  26F4
2834:  MOVFF  AB,FEA
2838:  MOVFF  AA,FE9
283C:  MOVFF  01,FEF
.................... dt->day     = bcd2bin(bcd_day & 0x3F); 
2840:  MOVLW  03
2842:  ADDWF  xA1,W
2844:  MOVWF  01
2846:  MOVLW  00
2848:  ADDWFC xA2,W
284A:  MOVWF  03
284C:  MOVFF  01,AA
2850:  MOVWF  xAB
2852:  MOVF   xA8,W
2854:  ANDLW  3F
2856:  MOVWF  xAC
2858:  MOVWF  xAD
285A:  RCALL  26F4
285C:  MOVFF  AB,FEA
2860:  MOVFF  AA,FE9
2864:  MOVFF  01,FEF
.................... dt->month   = bcd2bin(bcd_mon & 0x1F); 
2868:  MOVLW  04
286A:  ADDWF  xA1,W
286C:  MOVWF  01
286E:  MOVLW  00
2870:  ADDWFC xA2,W
2872:  MOVWF  03
2874:  MOVFF  01,AA
2878:  MOVWF  xAB
287A:  MOVF   xA9,W
287C:  ANDLW  1F
287E:  MOVWF  xAC
2880:  MOVWF  xAD
2882:  RCALL  26F4
2884:  MOVFF  AB,FEA
2888:  MOVFF  AA,FE9
288C:  MOVFF  01,FEF
.................... dt->weekday = bcd_mon >> 5; 
2890:  MOVLW  06
2892:  ADDWF  xA1,W
2894:  MOVWF  FE9
2896:  MOVLW  00
2898:  ADDWFC xA2,W
289A:  MOVWF  FEA
289C:  SWAPF  xA9,W
289E:  MOVWF  00
28A0:  RRCF   00,F
28A2:  MOVLW  07
28A4:  ANDWF  00,F
28A6:  MOVFF  00,FEF
.................... year_bits   = bcd_day >> 6; 
28AA:  SWAPF  xA8,W
28AC:  MOVWF  xA3
28AE:  RRCF   xA3,F
28B0:  RRCF   xA3,F
28B2:  MOVLW  03
28B4:  ANDWF  xA3,F
....................  
.................... // Read the year byte from NVRAM. 
.................... // This is an added feature of this driver. 
.................... year = PCF8583_read_byte(PCF8583_YEAR_REG); 
28B6:  MOVLW  10
28B8:  MOVWF  xAA
28BA:  BRA    271A
28BC:  MOVFF  01,A4
....................  
.................... // Check if the two "year bits" were incremented by 
.................... // the PCF8583.  If so, increment the 8-bit year 
.................... // byte (read from NVRAM) by the same amount. 
.................... while(year_bits != (year & 3)) 
....................       year++; 
28C0:  MOVF   xA4,W
28C2:  ANDLW  03
28C4:  SUBWF  xA3,W
28C6:  BZ    28CC
28C8:  INCF   xA4,F
28CA:  BRA    28C0
....................  
.................... dt->year = year; 
28CC:  MOVLW  05
28CE:  ADDWF  xA1,W
28D0:  MOVWF  FE9
28D2:  MOVLW  00
28D4:  ADDWFC xA2,W
28D6:  MOVWF  FEA
28D8:  MOVFF  A4,FEF
....................  
.................... // Now update the year byte in the NVRAM 
.................... // inside the PCF8583. 
.................... PCF8583_write_byte(PCF8583_YEAR_REG, year); 
28DC:  MOVLW  10
28DE:  MOVWF  xAD
28E0:  MOVFF  A4,AE
28E4:  CALL   169C
....................  
.................... } 
28E8:  RETLW  00
....................  
.................... //Método que permite establecer una alarma, dados horas, minutos y segundos 
.................... //Author: Julio Navarro Lara 
.................... void PCF8583_establecer_alarma(int8 horas, int8 minutos, int8 segundos){ 
....................    int8 bcd_horas; 
....................    int8 bcd_minutos; 
....................    int8 bcd_segundos; 
....................  
....................    //Transformamos a BCD las horas y los minutos introducidos 
....................    bcd_horas = bin2bcd(horas); 
*
2912:  MOVFF  97,AD
2916:  CALL   1660
291A:  MOVFF  01,9A
....................    bcd_minutos = bin2bcd(minutos); 
291E:  MOVFF  98,AD
2922:  CALL   1660
2926:  MOVFF  01,9B
....................    bcd_segundos = bin2bcd(segundos); 
292A:  MOVFF  99,AD
292E:  CALL   1660
2932:  MOVFF  01,9C
....................  
....................    //Paramos de contar el tiempo para escribir los datos 
....................    PCF8583_write_byte(PCF8583_CTRL_STATUS_REG, 
....................                               PCF8583_STOP_COUNTING); 
2936:  CLRF   xAD
2938:  MOVLW  80
293A:  MOVWF  xAE
293C:  CALL   169C
....................  
....................    //Definimos las condiciones de la alarma 
....................    PCF8583_write_byte(PCF8583_ALARM_CONTROL_REG, 
....................                               PCF8583_DEFINIR_ALARMA); 
2940:  MOVLW  08
2942:  MOVWF  xAD
2944:  MOVLW  90
2946:  MOVWF  xAE
2948:  CALL   169C
....................  
....................    //Desactivamos las interrupciones para que no interfieran en la escritura i2c 
....................    disable_interrupts(GLOBAL); 
294C:  BCF    FF2.6
294E:  BCF    FF2.7
2950:  BTFSC  FF2.7
2952:  BRA    294E
....................    i2c_start(); 
2954:  BSF    FC5.0
2956:  BTFSC  FC5.0
2958:  BRA    2956
....................    i2c_write(PCF8583_WRITE_ADDRESS); 
295A:  MOVLW  A0
295C:  MOVLB  2
295E:  MOVWF  xBA
2960:  MOVLB  0
2962:  CALL   1680
....................    //Escribimos en los registros de hora y minutos 
....................    i2c_write(PCF8583_ALARM_100S_REG); 
2966:  MOVLW  09
2968:  MOVLB  2
296A:  MOVWF  xBA
296C:  MOVLB  0
296E:  CALL   1680
....................    i2c_write(0x00); 
2972:  MOVLB  2
2974:  CLRF   xBA
2976:  MOVLB  0
2978:  CALL   1680
....................    i2c_write(bcd_segundos); 
297C:  MOVFF  9C,2BA
2980:  CALL   1680
....................    i2c_write(bcd_minutos); 
2984:  MOVFF  9B,2BA
2988:  CALL   1680
....................    i2c_write(bcd_horas); 
298C:  MOVFF  9A,2BA
2990:  CALL   1680
....................    i2c_stop(); 
2994:  BSF    FC5.2
2996:  BTFSC  FC5.2
2998:  BRA    2996
....................  
....................    //OJO! No volvemos a activar las interrupciones por si llamamos al método 
....................    //dentro de una rutina de interrupción 
....................  
....................    //Activamos la alarma 
....................    PCF8583_write_byte(PCF8583_CTRL_STATUS_REG, 
....................                               PCF8583_ACTIVAR_ALARMA); 
299A:  CLRF   xAD
299C:  MOVLW  04
299E:  MOVWF  xAE
29A0:  CALL   169C
....................  
....................  
....................  
....................    //Activamos el flag indicador de alarma 
....................    alarma_activada = TRUE; 
29A4:  MOVLW  01
29A6:  MOVWF  1E
....................  
.................... } 
29A8:  RETLW  00
....................  
.................... #include "LCDeasy.c" 
.................... ////----------------------------------------------------------------------------//// 
.................... // 	Funciones para la gestion del display LCD de la EasyPIC3 
.................... //	con el compilador de CCS. 
.................... //	Es una adaptación del archivo LCD.c de CCS para las prácticas de la 
.................... //	asignatura, y por tanto no distribuible a usuarios no autorizados. 
.................... //------------------------------------------------------------------------------//// 
....................  
.................... //  lcd_init()   Inicializa el LCD: debe ser llamada antes que las otras funciones. 
.................... // 
.................... //  lcd_putc(c)  Visualiza c en la siguiente posición del display. 
.................... //               Caracteres especiales de control: 
.................... //                      \f  Borrar display 
.................... //                      \n  Saltar a la segunda linea 
.................... //                      \b  Retroceder una posición. 
.................... // 
.................... //  lcd_gotoxy(x,y) Selecciona la nueva posicion de escritura en el display. 
.................... //                  (la esquina superior izquierda es 1,1) 
.................... // 
.................... //  lcd_getc(x,y)   Devuelve el caracter de la posicion x,y del display. 
.................... //			(esta función no va en la EASYPIC3, pues R/W=0) 
.................... // 
.................... //  lcd_send_byte(rs,byte)	escribe byte en el registro de datos(con rs=1) o de 
.................... //				instrucciones (con rs=0). 
.................... //------------------------------------------------------------------------------// 
.................... // Conexion del LCD con el PIC: 
.................... //     RB0 -- 
.................... //     RB1 -- 
.................... //     RB2  rs 
.................... //     RB3  Enable 
.................... //     RB4  D4 
.................... //     RB5  D5 
.................... //     RB6  D6 
.................... //     RB7  D7 
.................... // 
.................... // Los pines D0-D3 del LCD no se usan 
.................... // El pin RB0 del PIC no se usa 
.................... // El pin RB1 no está conectado en la tarjeta, 
.................... // podría ser para r/w 
....................  
.................... // Un-comment the following define to use port B 
.................... #define use_portb_lcd TRUE 		//LINEA DES-COMENTADA---------------- 
....................  
....................  
.................... struct lcd_pin_map {                 // This structure is overlayed 
....................            int unused : 2 ;	//MODIFICADA PARA EASYPIC-------------------- 
.................... 	   //BOOLEAN rw;		//MODIFICADA PARA EASYPIC-------------------- 
.................... 	   BOOLEAN rs;           // on to an I/O port to gain 
....................            BOOLEAN ENABLE;            // access to the LCD pins. 
....................            		           	// The bits are allocated from 
....................            			          // low order up.  ENABLE will 
....................            int     data : 4;         	// be pin B3------------------------- 
....................         } lcd; 
....................  
....................  
.................... #if defined(__PCH__) 
.................... #if defined use_portb_lcd 
....................    #byte lcd = 0xF81                   // This puts the entire structure 
.................... #else 
....................    #byte lcd = 0xF83                   // This puts the entire structure 
.................... #endif 
.................... #else 
.................... #if defined use_portb_lcd 
....................    #byte lcd = 6                  // on to port B (at address 6) 
.................... #else 
....................    #byte lcd = 8                 // on to port D (at address 8) 
.................... #endif 
.................... #endif 
....................  
.................... #if defined use_portb_lcd 
....................    #define set_tris_lcd(x) set_tris_b(x) 
.................... #else 
....................    #define set_tris_lcd(x) set_tris_d(x) 
.................... #endif 
....................  
....................  
.................... #define lcd_type 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #define lcd_line_two 0x40    // LCD RAM address for the second line 
....................  
....................  
.................... BYTE const LCD_INIT_STRING[4] = {0x24 | (lcd_type << 2), 0xF, 1, 6}; 
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................  
....................  
....................                              // The following are used for setting 
....................                              // the I/O port direction register. 
....................  
.................... struct lcd_pin_map const LCD_WRITE = {3,0,0,0}; // For write mode all pins are out 
.................... struct lcd_pin_map const LCD_READ = {3,0,0,15}; // For read mode data pins are in 
....................  
....................  
....................  
.................... BYTE lcd_read_byte() { 
....................       BYTE low,high; 
....................       set_tris_lcd(LCD_READ); 
....................       //////lcd.rw = 1; 
....................       delay_cycles(1); 
....................       lcd.enable = 1; 
....................       delay_cycles(1); 
....................       high = lcd.data; 
....................       lcd.enable = 0; 
....................       delay_cycles(1); 
....................       lcd.enable = 1; 
....................       delay_us(1); 
....................       low = lcd.data; 
....................       lcd.enable = 0; 
....................       set_tris_lcd(LCD_WRITE); 
....................       return( (high<<4) | low); 
.................... } 
....................  
....................  
.................... void lcd_send_nibble( BYTE n ) { 
....................       lcd.data = n; 
*
12D8:  SWAPF  xAF,W
12DA:  ANDLW  F0
12DC:  MOVWF  00
12DE:  MOVLW  0F
12E0:  ANDWF  F81,W
12E2:  IORWF  00,W
12E4:  MOVWF  F81
....................       delay_cycles(1); 
12E6:  NOP   
....................       lcd.enable = 1; 
12E8:  BSF    F81.3
....................       delay_us(2); 
12EA:  CLRWDT
12EC:  NOP   
12EE:  NOP   
12F0:  NOP   
....................       lcd.enable = 0; 
12F2:  BCF    F81.3
.................... } 
12F4:  RETLW  00
....................  
....................  
.................... void lcd_send_byte( BYTE address, BYTE n ) { 
....................  
....................       lcd.rs = 0; 
*
1314:  BCF    F81.2
....................       delay_us(3000); 
1316:  CLRWDT
1318:  MOVLW  02
131A:  MOVWF  xAE
131C:  RCALL  12A8
131E:  MOVLW  09
1320:  MOVWF  xAE
1322:  MOVLW  6D
1324:  MOVWF  xAF
1326:  RCALL  12F6
1328:  DECFSZ xAE,F
132A:  BRA    1322
.................... //      while ( bit_test(lcd_read_byte(),7) ) ; 
....................       lcd.rs = address; 
132C:  BTFSS  xAC.0
132E:  BCF    F81.2
1330:  BTFSC  xAC.0
1332:  BSF    F81.2
....................       delay_cycles(1); 
1334:  NOP   
....................       //////////lcd.rw = 0; 
....................       delay_cycles(1); 
1336:  NOP   
....................       lcd.enable = 0; 
1338:  BCF    F81.3
....................       lcd_send_nibble(n >> 4); 
133A:  SWAPF  xAD,W
133C:  MOVWF  xAE
133E:  MOVLW  0F
1340:  ANDWF  xAE,F
1342:  MOVFF  AE,AF
1346:  RCALL  12D8
....................       lcd_send_nibble(n & 0xf); 
1348:  MOVF   xAD,W
134A:  ANDLW  0F
134C:  MOVWF  xAE
134E:  MOVWF  xAF
1350:  RCALL  12D8
.................... } 
1352:  RETLW  00
....................  
....................  
.................... void lcd_init() { 
....................     BYTE i; 
....................     set_tris_lcd(LCD_WRITE); 
1354:  MOVLW  03
1356:  MOVWF  F93
....................     lcd.rs = 0; 
1358:  BCF    F81.2
....................     /////lcd.rw = 0; 
....................     lcd.enable = 0; 
135A:  BCF    F81.3
....................     delay_ms(50); 
135C:  MOVLW  32
135E:  MOVWF  xAE
1360:  RCALL  12A8
....................     //for(i=1;i<=3;++i) { 
....................     //   lcd_send_nibble(3); 
....................     //  delay_ms(5); 
....................     //} 
....................     lcd_send_nibble(2); 
1362:  MOVLW  02
1364:  MOVWF  xAF
1366:  RCALL  12D8
....................     delay_ms(5); 
1368:  MOVLW  05
136A:  MOVWF  xAE
136C:  RCALL  12A8
....................     for(i=0;i<=3;++i) 
136E:  CLRF   x95
1370:  MOVF   x95,W
1372:  SUBLW  03
1374:  BNC   139A
....................        { lcd_send_byte(0,LCD_INIT_STRING[i]); 
1376:  CLRF   03
1378:  MOVF   x95,W
137A:  MOVFF  FF2,96
137E:  BCF    FF2.7
1380:  CALL   00B4
1384:  BTFSC  x96.7
1386:  BSF    FF2.7
1388:  MOVWF  x97
138A:  CLRF   xAC
138C:  MOVWF  xAD
138E:  RCALL  1314
....................         delay_ms(5); } 
1390:  MOVLW  05
1392:  MOVWF  xAE
1394:  RCALL  12A8
1396:  INCF   x95,F
1398:  BRA    1370
.................... } 
139A:  GOTO   5D32 (RETURN)
....................  
....................  
.................... void lcd_gotoxy( BYTE x, BYTE y) { 
....................    BYTE address; 
....................  
....................    if(y!=1) 
139E:  DECFSZ xA9,W
13A0:  BRA    13A4
13A2:  BRA    13AA
....................      address=lcd_line_two; 
13A4:  MOVLW  40
13A6:  MOVWF  xAA
....................    else 
13A8:  BRA    13AC
....................      address=0; 
13AA:  CLRF   xAA
....................    address+=x-1; 
13AC:  MOVLW  01
13AE:  SUBWF  xA8,W
13B0:  ADDWF  xAA,F
....................    lcd_send_byte(0,0x80|address); 
13B2:  MOVF   xAA,W
13B4:  IORLW  80
13B6:  MOVWF  xAB
13B8:  CLRF   xAC
13BA:  MOVWF  xAD
13BC:  RCALL  1314
.................... } 
13BE:  RETLW  00
....................  
.................... void lcd_putc( char c) { 
....................    switch (c) { 
13C0:  MOVF   xA7,W
13C2:  XORLW  0C
13C4:  BZ    13D0
13C6:  XORLW  06
13C8:  BZ    13E0
13CA:  XORLW  02
13CC:  BZ    13EC
13CE:  BRA    13F6
....................      case '\f'   : lcd_send_byte(0,1); 
13D0:  CLRF   xAC
13D2:  MOVLW  01
13D4:  MOVWF  xAD
13D6:  RCALL  1314
....................                    delay_ms(2); 
13D8:  MOVLW  02
13DA:  MOVWF  xAE
13DC:  RCALL  12A8
....................                                            break; 
13DE:  BRA    1402
....................      case '\n'   : lcd_gotoxy(1,2);        break; 
13E0:  MOVLW  01
13E2:  MOVWF  xA8
13E4:  MOVLW  02
13E6:  MOVWF  xA9
13E8:  RCALL  139E
13EA:  BRA    1402
....................      case '\b'   : lcd_send_byte(0,0x10);  break; 
13EC:  CLRF   xAC
13EE:  MOVLW  10
13F0:  MOVWF  xAD
13F2:  RCALL  1314
13F4:  BRA    1402
....................      default     : lcd_send_byte(1,c);     break; 
13F6:  MOVLW  01
13F8:  MOVWF  xAC
13FA:  MOVFF  A7,AD
13FE:  RCALL  1314
1400:  BRA    1402
....................    } 
.................... } 
1402:  RETLW  00
....................  
.................... char lcd_getc( BYTE x, BYTE y) { 
....................    char value; 
....................  
....................     lcd_gotoxy(x,y); 
....................     while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................     lcd.rs=1; 
....................     value = lcd_read_byte(); 
....................     lcd.rs=0; 
....................     return(value); 
.................... } 
....................  
.................... #include "1wire.c" 
.................... /***********************1Wire Class***********************/ 
.................... /*Funciones básicas para comunicación con un solo sensor 1wire */ 
.................... /*********************************************************/ 
.................... /*-------1-wire definitions-------*/ 
....................  
.................... #define ONE_WIRE_PIN PIN_A5 //modificar de acuerdo con la tarjeta 
....................  
....................  
.................... /************onewire_reset*************************************************/ 
.................... void onewire_reset()  // OK if just using a single permanently connected device 
.................... { 
....................  output_low(ONE_WIRE_PIN); 
*
1DEC:  BCF    F92.5
1DEE:  BCF    F89.5
....................  delay_us( 500 ); // pull 1-wire low for reset pulse 
1DF0:  CLRWDT
1DF2:  MOVLW  02
1DF4:  MOVWF  xAC
1DF6:  MOVLW  F7
1DF8:  MOVWF  xAF
1DFA:  CALL   12F6
1DFE:  DECFSZ xAC,F
1E00:  BRA    1DF6
....................  output_float(ONE_WIRE_PIN); // float 1-wire high 
1E02:  BSF    F92.5
....................  delay_us( 500 ); // wait-out remaining initialisation window. 
1E04:  CLRWDT
1E06:  MOVLW  02
1E08:  MOVWF  xAC
1E0A:  MOVLW  F7
1E0C:  MOVWF  xAF
1E0E:  CALL   12F6
1E12:  DECFSZ xAC,F
1E14:  BRA    1E0A
....................  output_float(ONE_WIRE_PIN); 
1E16:  BSF    F92.5
.................... } 
1E18:  RETLW  00
....................  
.................... /*********************** onewire_write() ********************************/ 
.................... /*Esta función escribe un byte en el sensor.*/ 
.................... /* */ 
.................... /*Parametros: byte - el byte a escribir en el 1wire */ 
....................  
.................... void onewire_write(int data) 
.................... { 
....................  int count; 
....................  
....................  for (count=0; count<8; ++count) 
1E1A:  CLRF   xAE
1E1C:  MOVF   xAE,W
1E1E:  SUBLW  07
1E20:  BNC   1E56
....................  { 
....................   output_low(ONE_WIRE_PIN); 
1E22:  BCF    F92.5
1E24:  BCF    F89.5
....................   delay_us( 2 ); // pull 1-wire low to initiate write time-slot. 
1E26:  CLRWDT
1E28:  NOP   
1E2A:  NOP   
1E2C:  NOP   
....................   output_bit(ONE_WIRE_PIN, shift_right(&data,1,0)); // set output bit on 1-wire 
1E2E:  BCF    FD8.0
1E30:  RRCF   xAD,F
1E32:  BC    1E38
1E34:  BCF    F89.5
1E36:  BRA    1E3A
1E38:  BSF    F89.5
1E3A:  BCF    F92.5
....................   delay_us( 60 ); // wait until end of write slot. 
1E3C:  CLRWDT
1E3E:  MOVLW  27
1E40:  MOVWF  00
1E42:  DECFSZ 00,F
1E44:  BRA    1E42
1E46:  NOP   
....................   output_float(ONE_WIRE_PIN); // set 1-wire high again, 
1E48:  BSF    F92.5
....................   delay_us( 2 ); // for more than 1us minimum. 
1E4A:  CLRWDT
1E4C:  NOP   
1E4E:  NOP   
1E50:  NOP   
....................  } 
1E52:  INCF   xAE,F
1E54:  BRA    1E1C
.................... } 
1E56:  RETLW  00
....................  
.................... /*********************** read1wire() *********************************/ 
.................... /*Esta función lee un dato de 8 bits del sensor.*/ 
.................... /*Devuelve: dato de 8-bit (1-byte)*/ 
....................  
.................... int onewire_read() 
.................... { 
....................  int count, data; 
....................  
....................  for (count=0; count<8; ++count) 
*
1FC4:  CLRF   xAC
1FC6:  MOVF   xAC,W
1FC8:  SUBLW  07
1FCA:  BNC   2006
....................  { 
....................   output_low(ONE_WIRE_PIN); 
1FCC:  BCF    F92.5
1FCE:  BCF    F89.5
....................   delay_us( 2 ); // pull 1-wire low to initiate read time-slot. 
1FD0:  CLRWDT
1FD2:  NOP   
1FD4:  NOP   
1FD6:  NOP   
....................   output_float(ONE_WIRE_PIN); // now let 1-wire float high, 
1FD8:  BSF    F92.5
....................   delay_us( 8 ); // let device state stabilise, 
1FDA:  CLRWDT
1FDC:  MOVLW  04
1FDE:  MOVWF  00
1FE0:  DECFSZ 00,F
1FE2:  BRA    1FE0
1FE4:  NOP   
1FE6:  NOP   
....................   shift_right(&data,1,input(ONE_WIRE_PIN)); // and load result. 
1FE8:  BSF    F92.5
1FEA:  BTFSC  F80.5
1FEC:  BRA    1FF2
1FEE:  BCF    FD8.0
1FF0:  BRA    1FF4
1FF2:  BSF    FD8.0
1FF4:  RRCF   xAD,F
....................   delay_us( 120 ); // wait until end of read slot. 
1FF6:  CLRWDT
1FF8:  MOVLW  4F
1FFA:  MOVWF  00
1FFC:  DECFSZ 00,F
1FFE:  BRA    1FFC
2000:  NOP   
....................  } 
2002:  INCF   xAC,F
2004:  BRA    1FC6
....................  
....................  return( data ); 
2006:  MOVFF  AD,01
.................... } 
200A:  RETLW  00
....................  
.................... void ow_write_bit(int1 data) 
.................... { 
....................   output_low(ONE_WIRE_PIN); 
*
1E92:  BCF    F92.5
1E94:  BCF    F89.5
....................   delay_us( 2 ); // pull 1-wire low to initiate write time-slot. 
1E96:  CLRWDT
1E98:  NOP   
1E9A:  NOP   
1E9C:  NOP   
....................   output_bit(ONE_WIRE_PIN, data); // set output bit on 1-wire 
1E9E:  MOVF   x9D,F
1EA0:  BNZ   1EA6
1EA2:  BCF    F89.5
1EA4:  BRA    1EA8
1EA6:  BSF    F89.5
1EA8:  BCF    F92.5
....................   delay_us( 60 ); // wait until end of write slot. 
1EAA:  CLRWDT
1EAC:  MOVLW  27
1EAE:  MOVWF  00
1EB0:  DECFSZ 00,F
1EB2:  BRA    1EB0
1EB4:  NOP   
....................   output_float(ONE_WIRE_PIN); // set 1-wire high again, 
1EB6:  BSF    F92.5
....................   delay_us( 2 ); // for more than 1us minimum. 
1EB8:  CLRWDT
1EBA:  NOP   
1EBC:  NOP   
1EBE:  NOP   
.................... } 
1EC0:  RETLW  00
....................  
.................... int1 ow_read_bit() 
.................... { 
....................   int1 data; 
....................  
....................   output_low(ONE_WIRE_PIN); 
*
1E58:  BCF    F92.5
1E5A:  BCF    F89.5
....................   delay_us( 2 ); // pull 1-wire low to initiate read time-slot. 
1E5C:  CLRWDT
1E5E:  NOP   
1E60:  NOP   
1E62:  NOP   
....................   output_float(ONE_WIRE_PIN); // now let 1-wire float high, 
1E64:  BSF    F92.5
....................   delay_us( 8 ); // let device state stabilise, 
1E66:  CLRWDT
1E68:  MOVLW  04
1E6A:  MOVWF  00
1E6C:  DECFSZ 00,F
1E6E:  BRA    1E6C
1E70:  NOP   
1E72:  NOP   
....................   data = input(ONE_WIRE_PIN); // and load result. 
1E74:  BSF    F92.5
1E76:  BCF    x9D.0
1E78:  BTFSC  F80.5
1E7A:  BSF    x9D.0
....................   delay_us( 120 ); // wait until end of read slot. 
1E7C:  CLRWDT
1E7E:  MOVLW  4F
1E80:  MOVWF  00
1E82:  DECFSZ 00,F
1E84:  BRA    1E82
1E86:  NOP   
....................  
....................   return( data ); 
1E88:  MOVLW  00
1E8A:  BTFSC  x9D.0
1E8C:  MOVLW  01
1E8E:  MOVWF  01
.................... } 
1E90:  RETLW  00
....................  
.................... /////////////////////////////////////////////////////////////////// 
....................  
.................... void write_bit(int1 bitval) 
.................... { 
....................    output_low(ONE_WIRE_PIN); 
....................  
....................    if(bitval == 1) { 
....................       delay_us(1);      // 1uS min. Original code relied on 8051 being slow 
....................       output_float(ONE_WIRE_PIN); 
....................    } 
....................    delay_us(105);       // Wait for end of timeslot 
....................    output_float(ONE_WIRE_PIN); 
.................... } 
....................  
.................... int8 read_bit(void) 
.................... { 
....................    output_low(ONE_WIRE_PIN); 
....................    delay_us(1);         // 1uS min. Original code relied on 8051 being slow 
....................    output_float(ONE_WIRE_PIN); 
....................    delay_us(20);        // Wait at least 15mS from start of time slot 
....................    return(input(ONE_WIRE_PIN));   // Delay to finish time slot (total 60 to 120uS) 
.................... }                       // must be done next. 
....................  
....................  
....................  
.................... #include "ds1820.c" 
....................  
.................... /***************************************************/ 
.................... /*Driver básico del termómetro/termostato ds1820.c */ 
.................... // 
.................... //Realiza una secuencia completa de incialización, conversión 
.................... //de temperatura, y lectura del (único) sensor de temperatura 
.................... //con alimentación externa (no parásita). 
.................... // 
.................... /***************************************************/ 
....................  
.................... float ds1820_read(int* dir) 
.................... { 
....................  int8 busy=0, temp1, temp2; 
*
21B8:  CLRF   xA3
....................  signed int16 temp3; 
....................  float result; 
....................  
....................  onewire_reset();     // Cada acceso al sensor debe iniciarse con reset 
21BA:  RCALL  1DEC
....................  onewire_write(0x55); //Instrucción MATCH ROM 
21BC:  MOVLW  55
21BE:  MOVWF  xAD
21C0:  RCALL  1E1A
....................  //Mandamos por el one wire la dirección dir de 64 bits 
....................  onewire_write(dir[0]); 
21C2:  MOVFF  A1,FE9
21C6:  MOVFF  A2,FEA
21CA:  MOVFF  FEF,AC
21CE:  MOVFF  AC,AD
21D2:  RCALL  1E1A
....................  onewire_write(dir[1]); 
21D4:  MOVLW  01
21D6:  ADDWF  xA1,W
21D8:  MOVWF  FE9
21DA:  MOVLW  00
21DC:  ADDWFC xA2,W
21DE:  MOVWF  FEA
21E0:  MOVFF  FEF,AC
21E4:  MOVFF  AC,AD
21E8:  RCALL  1E1A
....................  onewire_write(dir[2]); 
21EA:  MOVLW  02
21EC:  ADDWF  xA1,W
21EE:  MOVWF  FE9
21F0:  MOVLW  00
21F2:  ADDWFC xA2,W
21F4:  MOVWF  FEA
21F6:  MOVFF  FEF,AC
21FA:  MOVFF  AC,AD
21FE:  RCALL  1E1A
....................  onewire_write(dir[3]); 
2200:  MOVLW  03
2202:  ADDWF  xA1,W
2204:  MOVWF  FE9
2206:  MOVLW  00
2208:  ADDWFC xA2,W
220A:  MOVWF  FEA
220C:  MOVFF  FEF,AC
2210:  MOVFF  AC,AD
2214:  RCALL  1E1A
....................  onewire_write(dir[4]); 
2216:  MOVLW  04
2218:  ADDWF  xA1,W
221A:  MOVWF  FE9
221C:  MOVLW  00
221E:  ADDWFC xA2,W
2220:  MOVWF  FEA
2222:  MOVFF  FEF,AC
2226:  MOVFF  AC,AD
222A:  RCALL  1E1A
....................  onewire_write(dir[5]); 
222C:  MOVLW  05
222E:  ADDWF  xA1,W
2230:  MOVWF  FE9
2232:  MOVLW  00
2234:  ADDWFC xA2,W
2236:  MOVWF  FEA
2238:  MOVFF  FEF,AC
223C:  MOVFF  AC,AD
2240:  RCALL  1E1A
....................  onewire_write(dir[6]); 
2242:  MOVLW  06
2244:  ADDWF  xA1,W
2246:  MOVWF  FE9
2248:  MOVLW  00
224A:  ADDWFC xA2,W
224C:  MOVWF  FEA
224E:  MOVFF  FEF,AC
2252:  MOVFF  AC,AD
2256:  RCALL  1E1A
....................  onewire_write(dir[7]); 
2258:  MOVLW  07
225A:  ADDWF  xA1,W
225C:  MOVWF  FE9
225E:  MOVLW  00
2260:  ADDWFC xA2,W
2262:  MOVWF  FEA
2264:  MOVFF  FEF,AC
2268:  MOVFF  AC,AD
226C:  RCALL  1E1A
....................  onewire_write(0x44); //Orden de inicio de conversión de temperatura 
226E:  MOVLW  44
2270:  MOVWF  xAD
2272:  RCALL  1E1A
....................  
....................  while (busy == 0) 	//el sensor mantiene la linea a 0 mientras realiza la conversión 
....................   busy = onewire_read(); //y la deja a 1 al completarla 
2274:  MOVF   xA3,F
2276:  BNZ   2280
2278:  RCALL  1FC4
227A:  MOVFF  01,A3
227E:  BRA    2274
....................  
....................  onewire_reset(); 
2280:  RCALL  1DEC
....................  onewire_write(0x55); //Instrucción MATCH ROM 
2282:  MOVLW  55
2284:  MOVWF  xAD
2286:  RCALL  1E1A
....................  onewire_write(dir[0]); 
2288:  MOVFF  A1,FE9
228C:  MOVFF  A2,FEA
2290:  MOVFF  FEF,AC
2294:  MOVFF  AC,AD
2298:  RCALL  1E1A
....................  onewire_write(dir[1]); 
229A:  MOVLW  01
229C:  ADDWF  xA1,W
229E:  MOVWF  FE9
22A0:  MOVLW  00
22A2:  ADDWFC xA2,W
22A4:  MOVWF  FEA
22A6:  MOVFF  FEF,AC
22AA:  MOVFF  AC,AD
22AE:  RCALL  1E1A
....................  onewire_write(dir[2]); 
22B0:  MOVLW  02
22B2:  ADDWF  xA1,W
22B4:  MOVWF  FE9
22B6:  MOVLW  00
22B8:  ADDWFC xA2,W
22BA:  MOVWF  FEA
22BC:  MOVFF  FEF,AC
22C0:  MOVFF  AC,AD
22C4:  RCALL  1E1A
....................  onewire_write(dir[3]); 
22C6:  MOVLW  03
22C8:  ADDWF  xA1,W
22CA:  MOVWF  FE9
22CC:  MOVLW  00
22CE:  ADDWFC xA2,W
22D0:  MOVWF  FEA
22D2:  MOVFF  FEF,AC
22D6:  MOVFF  AC,AD
22DA:  RCALL  1E1A
....................  onewire_write(dir[4]); 
22DC:  MOVLW  04
22DE:  ADDWF  xA1,W
22E0:  MOVWF  FE9
22E2:  MOVLW  00
22E4:  ADDWFC xA2,W
22E6:  MOVWF  FEA
22E8:  MOVFF  FEF,AC
22EC:  MOVFF  AC,AD
22F0:  RCALL  1E1A
....................  onewire_write(dir[5]); 
22F2:  MOVLW  05
22F4:  ADDWF  xA1,W
22F6:  MOVWF  FE9
22F8:  MOVLW  00
22FA:  ADDWFC xA2,W
22FC:  MOVWF  FEA
22FE:  MOVFF  FEF,AC
2302:  MOVFF  AC,AD
2306:  RCALL  1E1A
....................  onewire_write(dir[6]); 
2308:  MOVLW  06
230A:  ADDWF  xA1,W
230C:  MOVWF  FE9
230E:  MOVLW  00
2310:  ADDWFC xA2,W
2312:  MOVWF  FEA
2314:  MOVFF  FEF,AC
2318:  MOVFF  AC,AD
231C:  RCALL  1E1A
....................  onewire_write(dir[7]); 
231E:  MOVLW  07
2320:  ADDWF  xA1,W
2322:  MOVWF  FE9
2324:  MOVLW  00
2326:  ADDWFC xA2,W
2328:  MOVWF  FEA
232A:  MOVFF  FEF,AC
232E:  MOVFF  AC,AD
2332:  RCALL  1E1A
....................  onewire_write(0xBE); //Envío de la orden READ SCRATCHPAD (lectura de la memoria temporal) 
2334:  MOVLW  BE
2336:  MOVWF  xAD
2338:  RCALL  1E1A
....................  temp1 = onewire_read(); //lectura del LSB de la temperatura 
233A:  RCALL  1FC4
233C:  MOVFF  01,A4
....................  temp2 = onewire_read(); //lectura del MSB de la temperatura 
2340:  RCALL  1FC4
2342:  MOVFF  01,A5
....................  
....................  temp3 = make16(temp2, temp1); // 
2346:  MOVFF  A5,A7
234A:  MOVFF  A4,A6
....................  result = (float) temp3 / 2.0;   //Cálculo para el DS18S20 con 0.5 grad C de resolución 
234E:  MOVFF  A7,AD
2352:  MOVFF  A6,AC
2356:  BRA    200C
2358:  MOVFF  00,AC
235C:  MOVFF  01,AD
2360:  MOVFF  02,AE
2364:  MOVFF  03,AF
2368:  MOVFF  03,2B2
236C:  MOVFF  02,2B1
2370:  MOVFF  01,2B0
2374:  MOVFF  00,2AF
2378:  MOVLB  2
237A:  CLRF   xB6
237C:  CLRF   xB5
237E:  CLRF   xB4
2380:  MOVLW  80
2382:  MOVWF  xB3
2384:  MOVLB  0
2386:  RCALL  2058
2388:  MOVFF  03,AB
238C:  MOVFF  02,AA
2390:  MOVFF  01,A9
2394:  MOVFF  00,A8
.................... // result = (float) temp3 / 16.0;  //Cálculo para el DS18B20 con 0.1 grad C de resolución 
....................  
....................  delay_ms(200); 
2398:  MOVLW  C8
239A:  MOVWF  xAE
239C:  CALL   12A8
....................  return(result); 
23A0:  MOVFF  A8,00
23A4:  MOVFF  A9,01
23A8:  MOVFF  AA,02
23AC:  MOVFF  AB,03
.................... } 
23B0:  RETLW  00
....................  
.................... //Recoge las direcciones de dos dispositivos y las devuelve en los vectores de int pasados como 
.................... //argumento (cada instrucción ocupa 64 bits). Funciona también si hay más dispositivos conectados, 
.................... //pero sólo devuelve las direcciones de dos de ellos. 
.................... void ds1820_recoger_direcciones(int* dir1, int* dir2) 
.................... { 
....................    int contador, contador2; 
....................    int bit1, bit2; 
....................  
....................    onewire_reset(); 
*
1EC2:  RCALL  1DEC
....................    onewire_write(0xF0); //Función ROM SEARCH 
1EC4:  MOVLW  F0
1EC6:  MOVWF  xAD
1EC8:  RCALL  1E1A
....................  
....................    //Recorremos el array de 8 ints que contiene la dirección 
....................    for(contador=0; contador<8; contador++) 
1ECA:  CLRF   x99
1ECC:  MOVF   x99,W
1ECE:  SUBLW  07
1ED0:  BNC   1F42
....................    { 
....................       for(contador2=0; contador2<8; contador2++) 
1ED2:  CLRF   x9A
1ED4:  MOVF   x9A,W
1ED6:  SUBLW  07
1ED8:  BNC   1F3E
....................       { 
....................         //Leemos el bit correspondiente de dirección de los dispositivos 
....................         bit1 = ow_read_bit(); 
1EDA:  RCALL  1E58
1EDC:  MOVFF  01,9B
....................  
....................         //Leemos el segundo bit, que será el complemento del anterior si no hay conflictos 
....................         bit2 = ow_read_bit(); 
1EE0:  RCALL  1E58
1EE2:  MOVFF  01,9C
....................  
....................         //Si los bits son complementarios, tenemos que todos los dispositivos tienen el mismo bit de 
....................         //dirección en esa posición. 
....................         if(bit1!=bit2) 
1EE6:  MOVF   x9C,W
1EE8:  SUBWF  x9B,W
1EEA:  BZ    1F16
....................         { 
....................            shift_right(&(dir1[contador]),1,bit1); //Guardamos el resultado 
1EEC:  CLRF   03
1EEE:  MOVF   x99,W
1EF0:  ADDWF  x95,W
1EF2:  MOVWF  x9D
1EF4:  MOVF   x96,W
1EF6:  ADDWFC 03,W
1EF8:  MOVWF  x9E
1EFA:  MOVF   x9B,F
1EFC:  BNZ   1F02
1EFE:  BCF    FD8.0
1F00:  BRA    1F04
1F02:  BSF    FD8.0
1F04:  MOVFF  9E,FEA
1F08:  MOVFF  9D,FE9
1F0C:  RRCF   FED,F
....................  
....................            //Escribimos el bit de dirección para confirmar a los dispositivos la identificación 
....................            ow_write_bit(bit1); 
1F0E:  MOVFF  9B,9D
1F12:  RCALL  1E92
....................         }else 
1F14:  BRA    1F3A
....................         { 
....................            //Si no son complementarios, habrá conflicto, y habrá al menos un dispositivo con 0 en esa 
....................            //posición y al menos uno con 1. Elegimos el que tiene el 1 enviando un 1 por la línea e 
....................            //inhabilitándose los que tienen 0, que ya no contestarán a la función. 
....................            shift_right(&(dir1[contador]),1,1); 
1F16:  CLRF   03
1F18:  MOVF   x99,W
1F1A:  ADDWF  x95,W
1F1C:  MOVWF  x9D
1F1E:  MOVF   x96,W
1F20:  ADDWFC 03,W
1F22:  MOVWF  x9E
1F24:  MOVFF  9E,FEA
1F28:  MOVFF  9D,FE9
1F2C:  MOVLW  00
1F2E:  ADDWF  FE9,F
1F30:  BSF    FD8.0
1F32:  RRCF   FED,F
....................  
....................            ow_write_bit(1); 
1F34:  MOVLW  01
1F36:  MOVWF  x9D
1F38:  RCALL  1E92
....................         } 
....................       } 
1F3A:  INCF   x9A,F
1F3C:  BRA    1ED4
....................    } 
1F3E:  INCF   x99,F
1F40:  BRA    1ECC
....................  
....................    //Repetimos exactamente el mismo proceso pero eligiendo en los conflictos el dispositivo con 0. 
....................    onewire_reset(); 
1F42:  RCALL  1DEC
....................    onewire_write(0xF0); 
1F44:  MOVLW  F0
1F46:  MOVWF  xAD
1F48:  RCALL  1E1A
....................  
....................    for(contador=0; contador<8; contador++) 
1F4A:  CLRF   x99
1F4C:  MOVF   x99,W
1F4E:  SUBLW  07
1F50:  BNC   1FC0
....................    { 
....................       for(contador2=0; contador2<8; contador2++) 
1F52:  CLRF   x9A
1F54:  MOVF   x9A,W
1F56:  SUBLW  07
1F58:  BNC   1FBC
....................       { 
....................         bit1 = ow_read_bit(); 
1F5A:  RCALL  1E58
1F5C:  MOVFF  01,9B
....................  
....................         bit2 = ow_read_bit(); 
1F60:  RCALL  1E58
1F62:  MOVFF  01,9C
....................  
....................         if(bit1!=bit2) 
1F66:  MOVF   x9C,W
1F68:  SUBWF  x9B,W
1F6A:  BZ    1F96
....................         { 
....................            shift_right(&(dir2[contador]),1,bit1); 
1F6C:  CLRF   03
1F6E:  MOVF   x99,W
1F70:  ADDWF  x97,W
1F72:  MOVWF  x9D
1F74:  MOVF   x98,W
1F76:  ADDWFC 03,W
1F78:  MOVWF  x9E
1F7A:  MOVF   x9B,F
1F7C:  BNZ   1F82
1F7E:  BCF    FD8.0
1F80:  BRA    1F84
1F82:  BSF    FD8.0
1F84:  MOVFF  9E,FEA
1F88:  MOVFF  9D,FE9
1F8C:  RRCF   FED,F
....................  
....................            ow_write_bit(bit1); 
1F8E:  MOVFF  9B,9D
1F92:  RCALL  1E92
....................         }else 
1F94:  BRA    1FB8
....................         { 
....................            shift_right(&(dir2[contador]),1,0); 
1F96:  CLRF   03
1F98:  MOVF   x99,W
1F9A:  ADDWF  x97,W
1F9C:  MOVWF  x9D
1F9E:  MOVF   x98,W
1FA0:  ADDWFC 03,W
1FA2:  MOVWF  x9E
1FA4:  MOVFF  9E,FEA
1FA8:  MOVFF  9D,FE9
1FAC:  MOVLW  00
1FAE:  ADDWF  FE9,F
1FB0:  BCF    FD8.0
1FB2:  RRCF   FED,F
....................  
....................            ow_write_bit(0); 
1FB4:  CLRF   x9D
1FB6:  RCALL  1E92
....................         } 
....................       } 
1FB8:  INCF   x9A,F
1FBA:  BRA    1F54
....................    } 
1FBC:  INCF   x99,F
1FBE:  BRA    1F4C
....................  
.................... } 
1FC0:  GOTO   5D78 (RETURN)
....................  
.................... #include "teclado.c" 
.................... //*********************************************************************************** 
.................... // Método que permite gestionar un teclado matricial de 4x3 conectado a los pines 
.................... // B4B5B6B7 (filas) y a los D0D1D2 (columnas). El puerto D deberá estar definido como 
.................... // port_d y los bits utilizados de B deberán ser "tecladox", dónde x va de 1 a 4 
.................... //*********************************************************************************** 
.................... //Author: Julio Navarro Lara 
....................  
.................... //Definimos los caracteres que corresponden a cada botón del teclado 
.................... const char caracteres[12]={'1','2','3','4','5','6','7','8','9','S','0','N'}; 
....................  
.................... //Método para detectar la pulsación de una tecla. Devuelve el caracter pulsado. 
.................... char find_key() 
.................... { 
....................    //Variables auxiliares 
....................    int8 fila, columna, temp, contador, puertoB; 
....................    char key = 0; //Tecla pulsada 
*
3128:  CLRF   x9D
....................  
....................    //Recorremos las filas forzando un valor con el puerto B para detectar 
....................    //la tecla pulsada 
....................    for(fila=0; fila < NUM_FILAS; fila++){ 
312A:  CLRF   x98
312C:  MOVF   x98,W
312E:  SUBLW  03
3130:  BTFSS  FD8.0
3132:  BRA    3210
....................  
....................       //Forzamos la salida de B a que tenga todo 1 menos la posición a inspeccionar 
....................       puertoB = ~(1 << fila); 
3134:  MOVLW  01
3136:  MOVWF  00
3138:  MOVF   x98,W
313A:  MOVWF  01
313C:  BZ    3146
313E:  BCF    FD8.0
3140:  RLCF   00,F
3142:  DECFSZ 01,F
3144:  BRA    313E
3146:  MOVF   00,W
3148:  XORLW  FF
314A:  MOVWF  x9C
....................       teclado1 = puertoB & 0b1; 
314C:  MOVF   x9C,W
314E:  ANDLW  01
3150:  MOVWF  01
3152:  BTFSC  FE8.0
3154:  BRA    315A
3156:  BCF    F81.4
3158:  BRA    315C
315A:  BSF    F81.4
....................       teclado2 = (puertoB & 0b10) >> 1; 
315C:  MOVF   x9C,W
315E:  ANDLW  02
3160:  MOVWF  00
3162:  BCF    FD8.0
3164:  RRCF   00,F
3166:  MOVFF  00,01
316A:  BTFSC  00.0
316C:  BRA    3172
316E:  BCF    F81.5
3170:  BRA    3174
3172:  BSF    F81.5
....................       teclado3 = (puertoB & 0b100) >> 2; 
3174:  MOVF   x9C,W
3176:  ANDLW  04
3178:  MOVWF  00
317A:  RRCF   00,F
317C:  RRCF   00,F
317E:  MOVLW  3F
3180:  ANDWF  00,F
3182:  MOVFF  00,01
3186:  BTFSC  00.0
3188:  BRA    318E
318A:  BCF    F81.6
318C:  BRA    3190
318E:  BSF    F81.6
....................       teclado4 = (puertoB & 0b1000) >> 3; 
3190:  MOVF   x9C,W
3192:  ANDLW  08
3194:  MOVWF  00
3196:  RRCF   00,F
3198:  RRCF   00,F
319A:  RRCF   00,F
319C:  MOVLW  1F
319E:  ANDWF  00,F
31A0:  MOVFF  00,01
31A4:  BTFSC  00.0
31A6:  BRA    31AC
31A8:  BCF    F81.7
31AA:  BRA    31AE
31AC:  BSF    F81.7
....................  
....................       //Introducimos un poco de retraso 
....................       for(contador=0; contador<100; contador++); 
31AE:  CLRF   x9B
31B0:  MOVF   x9B,W
31B2:  SUBLW  63
31B4:  BNC   31BA
31B6:  INCF   x9B,F
31B8:  BRA    31B0
....................  
....................       //Guardamos el valor que aparece en el puerto D 
....................       //(en sus 3 bits menos significativos) 
....................       temp = port_d & 0b00000111; 
31BA:  MOVF   F83,W
31BC:  ANDLW  07
31BE:  MOVWF  x9A
....................  
....................       //Iteramos en base a esto para ver si alguna columna está activa 
....................       //Una vez localizada la columna, podemos encontrar el caracter teniendo en cuenta 
....................       //también la fila que está activa. 
....................       for(columna=0; columna < NUM_COLUMNAS; columna++){ 
31C0:  CLRF   x99
31C2:  MOVF   x99,W
31C4:  SUBLW  02
31C6:  BNC   320C
....................  
....................          //Realizamos la operación AND entre el valor que hay y un 1 desplazado 
....................          //según la columna que nos encontremos 
....................          if((temp & (1 << columna))==0) 
31C8:  MOVLW  01
31CA:  MOVWF  00
31CC:  MOVF   x99,W
31CE:  MOVWF  01
31D0:  BZ    31DA
31D2:  BCF    FD8.0
31D4:  RLCF   00,F
31D6:  DECFSZ 01,F
31D8:  BRA    31D2
31DA:  MOVF   00,W
31DC:  ANDWF  x9A,W
31DE:  BNZ   3208
....................          { 
....................             //Si da 0, hemos localizado la columna dónde se encuentra la tecla 
....................             //Guardamos su índice teniendo en cuenta que las teclas se numeran de izquierda a derecha y 
....................             //de arriba a abajo. 
....................             int8 index; 
....................             index = (fila*NUM_COLUMNAS)+(2-columna); 
31E0:  MOVF   x98,W
31E2:  MULLW  03
31E4:  MOVFF  FF3,9F
31E8:  MOVLW  02
31EA:  BSF    FD8.0
31EC:  SUBFWB x99,W
31EE:  ADDWF  x9F,W
31F0:  MOVWF  x9E
....................  
....................             //Buscamos la tecla a la que se hace referencia 
....................             key = caracteres[index]; 
31F2:  CLRF   03
31F4:  MOVF   x9E,W
31F6:  MOVFF  FF2,9F
31FA:  BCF    FF2.7
31FC:  CALL   00D2
3200:  BTFSC  x9F.7
3202:  BSF    FF2.7
3204:  MOVWF  x9D
....................  
....................             //Saltamos para salirnos del bucle 
....................             goto hecho; 
3206:  BRA    3210
....................  
....................          } 
....................  
....................       } 
3208:  INCF   x99,F
320A:  BRA    31C2
....................    } 
320C:  INCF   x98,F
320E:  BRA    312C
....................  
....................    hecho: 
....................  
....................    //Devolvemos el caracter 
....................    return key; 
3210:  MOVFF  9D,01
....................  
.................... } 
3214:  RETLW  00
....................  
.................... //Devuelve la tecla pulsada, esperando a que el usuario la suelte 
.................... char get_key() 
.................... { 
....................    char key; 
....................    //Detectamos la tecla pulsada 
....................    key=find_key(); 
3216:  RCALL  3128
3218:  MOVFF  01,97
....................    //Si se pulsa alguna tecla, nos esperamos hasta que se suelte para recoger el valor 
....................    if(key) 
321C:  MOVF   x97,F
321E:  BZ    3226
....................       while(find_key() != 0); 
3220:  RCALL  3128
3222:  MOVF   01,F
3224:  BNZ   3220
....................    return key; 
3226:  MOVFF  97,01
.................... } 
322A:  RETLW  00
....................  
....................  
....................  
.................... #include "eeprom.c" 
.................... //****************************************************** 
.................... //Programa para escritura y lectura de la memoria EEPROM 
.................... //****************************************************** 
.................... //Author: Julio Navarro Lara 
....................  
....................  
.................... //Definimos las palabras de control, que constan de tres partes 
.................... //   - Los bits más altos de direccionamiento del dispositivo (fijos): 1010 
.................... //   - Los bits de dirección configurables A2A1A0: 111 (en este caso) 
.................... //   - El bit R/W', 1 para lectura y 0 para escritura 
.................... //NOTA: No es necesario definir las características de la comunicación I2C porque se supone 
.................... //que ya han sido especificadas en el código principal. 
.................... #define CONTROL_W 0b10101110 
.................... #define CONTROL_R 0b10101111 
....................  
.................... void graba_ee(long int dir, int tam, int *wdata) 
.................... { 
....................    boolean ack; 
....................    int i; 
....................    //Escribimos la palabra de control 
....................    do{ 
....................       i2c_start(); 
*
184A:  BSF    FC5.0
184C:  BTFSC  FC5.0
184E:  BRA    184C
....................       ack=i2c_write(CONTROL_W); 
1850:  MOVLW  AE
1852:  MOVLB  2
1854:  MOVWF  xBA
1856:  MOVLB  0
1858:  RCALL  1680
185A:  MOVF   01,W
185C:  BTFSC  01.0
185E:  BRA    1864
1860:  BCF    xAC.0
1862:  BRA    1866
1864:  BSF    xAC.0
....................    }while(ack); //Esperamos a que el dispositivo responda 
1866:  BTFSC  xAC.0
1868:  BRA    184A
....................    //Cuando está listo, devuelve un ACK como 0 
....................    //Mandamos la dirección en la que se quiere escribir 
....................    i2c_write(dir>>8); 
186A:  MOVFF  A8,AE
186E:  CLRF   xAF
1870:  MOVFF  A8,2BA
1874:  RCALL  1680
....................    i2c_write(dir & 255); 
1876:  MOVFF  A7,AE
187A:  CLRF   xAF
187C:  MOVFF  A7,2BA
1880:  RCALL  1680
....................  
....................    //Escribimos los datos contenidos en wdata 
....................    for(i=0;i<tam;i++){ 
1882:  CLRF   xAD
1884:  MOVF   xA9,W
1886:  SUBWF  xAD,W
1888:  BC    18AA
....................       i2c_write(*wdata); 
188A:  MOVFF  AB,03
188E:  MOVFF  AA,FE9
1892:  MOVFF  AB,FEA
1896:  MOVFF  FEF,AE
189A:  MOVFF  AE,2BA
189E:  RCALL  1680
....................       wdata++; 
18A0:  INCF   xAA,F
18A2:  BTFSC  FD8.2
18A4:  INCF   xAB,F
....................    } 
18A6:  INCF   xAD,F
18A8:  BRA    1884
....................  
....................    //Finalizamos la comunicación 
....................    i2c_stop(); 
18AA:  BSF    FC5.2
18AC:  BTFSC  FC5.2
18AE:  BRA    18AC
.................... } 
18B0:  RETLW  00
....................  
.................... void lee_ee(long int dir, int tam, int8 *rdata) 
.................... { 
....................    boolean ack; 
....................    int i; 
....................    //Comenzamos escribiendo la dirección que queremos consultar 
....................    //al igual que ya hicimos con el método de escritura 
....................    do{ 
....................       i2c_start(); 
*
3850:  BSF    FC5.0
3852:  BTFSC  FC5.0
3854:  BRA    3852
....................       ack=i2c_write(CONTROL_W); 
3856:  MOVLW  AE
3858:  MOVLB  2
385A:  MOVWF  xBA
385C:  MOVLB  0
385E:  CALL   1680
3862:  MOVF   01,W
3864:  BTFSC  01.0
3866:  BRA    386E
3868:  MOVLB  2
386A:  BCF    xB6.0
386C:  BRA    3872
386E:  MOVLB  2
3870:  BSF    xB6.0
....................    }while(ack); //Esperamos a que el dispositivo responda 
3872:  BTFSS  xB6.0
3874:  BRA    387A
3876:  MOVLB  0
3878:  BRA    3850
....................    i2c_write(dir>>8); 
387A:  MOVFF  2B2,2B8
387E:  CLRF   xB9
3880:  MOVFF  2B2,2BA
3884:  MOVLB  0
3886:  CALL   1680
....................    i2c_write(dir & 255); 
388A:  MOVLB  2
388C:  MOVFF  2B1,2B8
3890:  CLRF   xB9
3892:  MOVFF  2B1,2BA
3896:  MOVLB  0
3898:  CALL   1680
....................  
....................    //Reiniciamos la comunicación para leer los datos 
....................    i2c_start(); 
389C:  BSF    FC5.1
389E:  BTFSC  FC5.1
38A0:  BRA    389E
....................    //Escribimos palabra de control de escritura 
....................    i2c_write(CONTROL_R); 
38A2:  MOVLW  AF
38A4:  MOVLB  2
38A6:  MOVWF  xBA
38A8:  MOVLB  0
38AA:  CALL   1680
....................  
....................    //Leemos hasta que completemos el bus 
....................    for(i=0; i<tam-1; i++){ 
38AE:  MOVLB  2
38B0:  CLRF   xB7
38B2:  MOVLW  01
38B4:  SUBWF  xB3,W
38B6:  SUBWF  xB7,W
38B8:  BC    38E0
....................       //Se responde en cada caso con ACK 
....................       //(la función i2c_read tiene su argumento al revés: 1 corresponde a 
....................       //ACK y 0 a NACK, cuando en la línea un valor bajo es ACK y uno alto, NACK) 
....................       *rdata=i2c_read(1); 
38BA:  MOVFF  2B5,03
38BE:  MOVFF  2B4,FE9
38C2:  MOVFF  2B5,FEA
38C6:  MOVLW  01
38C8:  MOVWF  00
38CA:  MOVLB  0
38CC:  CALL   26DA
38D0:  MOVFF  01,FEF
....................       rdata++; 
38D4:  MOVLB  2
38D6:  INCF   xB4,F
38D8:  BTFSC  FD8.2
38DA:  INCF   xB5,F
....................    } 
38DC:  INCF   xB7,F
38DE:  BRA    38B2
....................    //Debemos terminar la lectura con un NACK 
....................    *rdata=i2c_read(0); 
38E0:  MOVFF  2B5,03
38E4:  MOVFF  2B4,FE9
38E8:  MOVFF  2B5,FEA
38EC:  CLRF   00
38EE:  MOVLB  0
38F0:  CALL   26DA
38F4:  MOVFF  01,FEF
....................    i2c_stop(); 
38F8:  BSF    FC5.2
38FA:  BTFSC  FC5.2
38FC:  BRA    38FA
.................... } 
38FE:  RETLW  00
....................  
....................  
....................  
.................... #use fast_io(A) 
.................... #use fast_io(B) 
.................... #use fast_io(C) 
.................... #use fast_io(D) 
....................  
.................... int1 temperatura_caldera_superada; //Control de la histéresis en la caldera 
.................... int1 temp_habitacion_superada1;  //Control de la histéresis del ambiente 
.................... int1 temp_habitacion_superada2; 
.................... int1 encendido_por_alarma; //Indica si la última vez que se encendió fue en respuesta o no a una alarma 
.................... int1 toca_encender; //Indica si la próxima alarma es de encendido o de apagado 
.................... float termostato1; //Temperatura límite de la zona 1 de la vivienda 
.................... float termostato2; //Temperatura límite de la zona 2 de la vivienda 
.................... float termostato_provisional; //Valor de termostato provisional para cuando saltan las alarmas 
.................... float temperatura1; //Temperatura de la zona 1 de la vivienda 
.................... float temperatura2; //Temperatura de la zona 2 de la vivienda 
.................... float histeresis_vivienda = 0.5; //Intervalo de histéresis de la vivienda 
.................... char key; //Tecla a pulsar 
.................... char keys[2]; //Cadena para almacenar números como caracteres 
....................  
.................... //Estructura de un intervalo de programación 
.................... typedef struct 
.................... { 
....................    unsigned int horas_inicio;    //Hora a la que se inicia el encendido 
....................    unsigned int minutos_inicio;  // 
....................    unsigned int horas_fin;       //Hora a la que se apaga el sistema 
....................    unsigned int minutos_fin;     // 
....................    unsigned int termostato;      //Termostato vigente en ese intervalo 
.................... }programacion; 
....................  
.................... //Vector que incluye todas las programaciones horarias 
.................... //La información se distribuye en grupos de 5: hora_inicio, minutos_inicio, 
.................... //hora_fin, minutos_fin y termostato. 
.................... programacion programaciones[5]; 
....................  
.................... //Programación en curso en este momento 
.................... programacion prg; 
.................... int num_intervalos; //Número de intervalos de programación con los que contamos 
.................... int posicion_alarmas; //Variable que apunta a la posición de la próxima alarma 
....................  
.................... //Estructura para leer el tiempo del reloj 
.................... date_time_t tiempo; 
....................  
.................... //Registro de la hora en la que se enciende el sistema 
.................... int hora_encendido; 
.................... int minutos_encendido; 
....................  
.................... //Registro de la hora en la que se enciende la caldera 
.................... //Se supone que el encendido de la caldera se realiza en intervalos cortos, 
.................... //que se alcanza la temperatura deseada relativamente rápido. 
.................... int hora_caldera; 
.................... int minutos_caldera; 
.................... int segundos_caldera; 
.................... //Tiempo total de encendido de la caldera en cada intervalo de encendido del sistema 
.................... long t_total_caldera; 
....................  
.................... //Variables para el registro en memoria 
.................... unsigned long num_registros;  //Número de registros de fechas almacenados 
.................... int anno_actual;             //Año en el que estamos (de 0 a 99) 
.................... int anno_actual_0_to_3;      //Año en el que estamos (de 0 a 3) 
....................  
.................... //Flag para activar las interrupciones de interfaz con el teclado y alarma 
.................... int1 led_int; 
.................... int1 alarma_int; 
.................... //Flag para controlar el desbordamiento del TIMER1 
.................... int1 timer_int; 
....................  
.................... //Arrays para almacenar las direcciones de las ROM de ambos sensores de temperatura 
.................... int dir1[8], dir2[8]; 
....................  
.................... //Contador para medir el tiempo transcurrido con el menú activo 
.................... unsigned int contador_tiempo; 
....................  
....................  
.................... //Listado de métodos utilizados ordenados por orden alfabético 
.................... //************************************************************ 
.................... //Mostramos aquí una breve explicación de cada uno. El interior de los métodos está 
.................... //descrito después del método main. 
....................  
.................... //apagar_caldera() -> Apaga la caldera, almacenando el tiempo que ha estado encendida. 
.................... void apagar_caldera(); 
.................... //apagar_sistema() -> Realiza todas las operaciones necesarias para el apagado 
.................... //del sistema, como el almacenamiento de los datos necesarios en memoria. 
.................... void apagar_sistema(); 
.................... //buscar_numero() -> Escanea el teclado hasta encontrar un número de dos cifras o hasta que se decida salir 
.................... //mediante la pulsación de los botones de SI o NO. 
.................... int buscar_numero(); 
.................... //buscar_numero_rs232() -> Registra la introducción de un número de dos cifras mediante la interfaz RS232 y 
.................... //lo devuelve. Además, si se pulsa el "backspace" durante el proceso, devuelve el código correspondiente a NO 
.................... int buscar_numero_rs232(); 
.................... //comp_caldera() -> Devuelve TRUE si debemos apagar la caldera. Esta función tiene en cuenta 
.................... //cierta histéresis para evitar ciclos continuos de apagado-encendido. Hay que considerar 
.................... //que sólo puede emplearse una vez que la temperatura del agua ha superado ya el valor necesario. 
.................... int comp_caldera(); 
.................... //comprobar_hora(int hora1, int min1, int hora2, int min2) -> Devuelve TRUE 
.................... //si hora1:min1 corresponde a un tiempo menor o igual que hora2:min2. 
.................... int comprobar_hora(int hora1,int min1, int hora2, int min2); 
.................... //comprobar_temperatura() -> Devuelve un código según la temperatura de los dos sensores: 
.................... //0: Ninguno de los dos supera la temperatura del termostato 
.................... //1: El sensor 1 supera la temperatura del termostato 
.................... //2: El sensor 2 supera la temperatura del termostato 
.................... //3: Ambos sensores superan la temperatura del termostato 
.................... int comprobar_temperatura(); 
.................... //diferencia_tiempo(int hora1, int min1, int hora2, int min2) -> Calcula la 
.................... //diferencia de tiempo en minutos entre hora1:min1 y hora2:min2. 
.................... //Si hora1:min1 es mayor que hora2:min2, los considera en días consecutivos. 
.................... long diferencia_tiempo(int hora1,int min1, int hora2, int min2); 
.................... //diferencia_tiempo_sec(int hora1, int min1, int sec1, int hora2, int min2, int sec2) -> 
.................... //Calcula la diferencia de tiempo en segundos entre hora1:min1:sec1 y hora2:min2:sec2 
.................... //Si hora1:min1:sec1 es mayor que hora2:min2:sec2, los considera en días consecutivos 
.................... long diferencia_tiempo_sec(int hora1,int min1, int sec1, int hora2, int min2, int sec2); 
.................... //encender_caldera() -> Enciende la caldera, almacenando el tiempo de encendido en 
.................... //las variables correspondientes. 
.................... void encender_caldera(); 
.................... //encender_sistema() -> Realiza todas las operaciones necesarias para el encendido 
.................... //del sistema, como registro del tiempo de inicio. 
.................... void encender_sistema(); 
.................... //grabar_programaciones() -> Graba los datos de las programaciones en la memoria EEPROM. 
.................... void grabar_programaciones(); 
.................... //inicializacion() -> Lleva a cabo la inicialización del sistema (introducción de hora y fecha, 
.................... //puesta a punto de variables, etc) 
.................... void inicializacion(); 
.................... //leer_programaciones() -> Recupera de la memoria los datos de las programaciones. 
.................... void leer_programaciones(); 
.................... //mostrar_temperatura() -> Muestra en la pantalla LCD la temperatura actual y la hora. 
.................... void mostrar_temperatura(); 
.................... //ordenar_programaciones -> Ordena las programaciones por orden creciente de hora. 
.................... void ordenar_programaciones(); 
.................... //programar_proxima_alarma() -> Programa la próxima alarma que tendrá lugar. 
.................... //Siempre se tratará de una alarma para el encendido. 
.................... void programar_proxima_alarma(); 
.................... //representar_registros() -> Representa la información de los registros en el puerto RS232 
.................... //Nunca guardamos la información de los registros para no saturar la memoria y 
.................... //aprovechamos la representación de los datos para calcular medias y demás y así 
.................... //no tener que realizar un segundo barrido de lectura en memoria. 
.................... void representar_registros(); 
.................... //seleccionar_alarma() -> Selecciona la alarma más cercana a la hora en la que nos encontramos, 
.................... //en el caso de que las hubiese. 
.................... void seleccionar_alarma(); 
....................  
.................... //-------------------------------------------------------------------------------- 
....................  
.................... //Gestión de interrupciones de activación de la alarma 
.................... #INT_EXT 
.................... void alarma(){ 
....................    //Se activa el flag correspondiente 
....................    alarma_int = TRUE; 
*
1288:  BSF    1F.6
.................... } 
....................  
.................... //Gestión de interrupciones de activación de la interfaz de usuario 
128A:  BCF    FF2.1
128C:  GOTO   0070
.................... #INT_EXT1 
.................... void activacion_led(){ 
....................    //Se activa el flag correspondiente 
....................    led_int = TRUE; 
1290:  BSF    1F.5
.................... } 
....................  
.................... //Interrupción de reloj para controlar el tiempo que está activo el menú 
1292:  BCF    FF0.0
1294:  GOTO   0070
.................... #INT_TIMER1 
.................... void contador(){ 
....................    //Aumentamos en uno el valor del contador 
....................    contador_tiempo++; 
1298:  INCF   7D,F
....................    //Si llega a 76 (unos 20 segundos), activamos el flag correspondiente 
....................    if(contador_tiempo >= 76) 
129A:  MOVF   7D,W
129C:  SUBLW  4B
129E:  BC    12A2
....................       timer_int = TRUE; 
12A0:  BSF    1F.7
.................... } 
....................  
....................  
.................... //*********************************************************** 
.................... //Método main 
.................... //*********************************************************** 
12A2:  BCF    F9E.0
12A4:  GOTO   0070
.................... void main() 
.................... { 
*
5CCA:  CLRF   FF8
5CCC:  BCF    FD0.7
5CCE:  BSF    0D.7
5CD0:  CLRF   FEA
5CD2:  CLRF   FE9
5CD4:  BCF    FB8.3
5CD6:  MOVLW  19
5CD8:  MOVWF  FAF
5CDA:  MOVLW  22
5CDC:  MOVWF  FAC
5CDE:  MOVLW  90
5CE0:  MOVWF  FAB
5CE2:  BSF    F94.3
5CE4:  BSF    F94.4
5CE6:  MOVLW  13
5CE8:  MOVWF  FC8
5CEA:  MOVLW  28
5CEC:  MOVWF  FC6
5CEE:  BSF    FC7.7
5CF0:  BCF    FC7.6
5CF2:  MOVF   FC1,W
5CF4:  ANDLW  C0
5CF6:  IORLW  0F
5CF8:  MOVWF  FC1
5CFA:  MOVLW  07
5CFC:  MOVWF  FB4
5CFE:  CLRF   18
5D00:  CLRF   19
5D02:  MOVLW  01
5D04:  MOVWF  1A
5D06:  CLRF   1B
5D08:  CLRF   1C
5D0A:  CLRF   1D
5D0C:  CLRF   1E
5D0E:  MOVLW  7E
5D10:  MOVWF  34
5D12:  CLRF   35
5D14:  CLRF   36
5D16:  CLRF   37
....................    //Vector para recoger los datos iniciales leídos de memoria 
....................    int data[6]; 
....................  
....................    //Valor auxiliar 
....................    int valor; 
....................  
....................    //Inicializamos salidas 
....................    //Comenzamos con todo apagado (sistema, motor y caldera) 
....................    sistema_encendido = FALSE; 
5D18:  BCF    F83.4
....................    motor1 = FALSE; 
5D1A:  BCF    F83.6
....................    motor2 = FALSE; 
5D1C:  BCF    F83.7
....................    caldera_encendida = FALSE; 
5D1E:  BCF    F83.5
....................    encendido_por_alarma = FALSE; 
5D20:  BCF    1F.3
....................    t_total_caldera = 0; //El tiempo total de encendido de la caldera también lo ponemos a 0 
5D22:  CLRF   68
5D24:  CLRF   67
....................  
....................    //Establecemos el estado de los puertos como entradas o salidas 
....................    set_tris_b(0x03); 
5D26:  MOVLW  03
5D28:  MOVWF  F93
....................    set_tris_d(0x0F); 
5D2A:  MOVLW  0F
5D2C:  MOVWF  F95
....................  
....................  
....................    //Inicializamos la pantalla lcd 
....................    lcd_init(); 
5D2E:  GOTO   1354
....................  
....................    //Mostramos un mensaje de inicio 
....................    lcd_send_byte(LCD_ORDEN, LCD_CLEAR); 
5D32:  CLRF   xAC
5D34:  MOVLW  01
5D36:  MOVWF  xAD
5D38:  CALL   1314
....................    lcd_send_byte(LCD_ORDEN, LCD_NO_CURSOR); 
5D3C:  CLRF   xAC
5D3E:  MOVLW  0C
5D40:  MOVWF  xAD
5D42:  CALL   1314
....................    printf(lcd_putc, "Inicializando..."); 
5D46:  CLRF   x95
5D48:  MOVF   x95,W
5D4A:  CALL   00F8
5D4E:  IORLW  00
5D50:  BZ    5D5C
5D52:  INCF   x95,F
5D54:  MOVWF  xA7
5D56:  CALL   13C0
5D5A:  BRA    5D48
....................  
....................    /* 
....................    NOTA: En el guión se nos pide que se realice la inicialización del sistema cuando 
....................    éste se instala, introduciendo fecha y hora y reseteando los datos de memoria para 
....................    iniciar el funcionamiento. Esto lo hace en nuestro programa la funcion inicializar. 
....................    Sin embargo, se ha preferido, dado que PROTEUS actualiza su reloj con el del ordenador, 
....................    dar la opción de dejar inhabilitada esta rutina para así disponer de datos históricos guardados en la 
....................    EEPROM y poder analizarlos. Debido a que nuestra simulación no puede estar las 24 horas 
....................    funcionando (entre otras cosas, porque el PCF se para) es la única forma de simular 
....................    que el sistema está siempre encendido. 
....................       De todas formas, ambas rutinas están implementadas con plena operatividad. Si se quiere 
....................    inicializar el sistema como ocurriría en la vida real, simplemente dejar descomentadas las dos 
....................    líneas de código que siguen a este comentario y mantener comentado el trozo de código que está 
....................    enmarcado por las ristras de arrobas (@), un poco más abajo. 
....................    */ 
....................  
....................  
....................    inicializacion(); 
5D5C:  GOTO   18B2
....................    PCF8583_write_byte(PCF8583_CTRL_STATUS_REG, PCF8583_START_COUNTING); 
5D60:  CLRF   xAD
5D62:  CLRF   xAE
5D64:  CALL   169C
....................  
....................  
....................    //Recogemos las direcciones de los sensores de temperatura 
....................    ds1820_recoger_direcciones(dir1, dir2); 
5D68:  CLRF   x96
5D6A:  MOVLW  6D
5D6C:  MOVWF  x95
5D6E:  CLRF   x98
5D70:  MOVLW  75
5D72:  MOVWF  x97
5D74:  GOTO   1EC2
....................  
....................    //Propiedades de conversión analógico digital 
....................    //Establecemos el comparador entre A0 y A3, y entre A1 y A2 
....................    setup_comparator(A0_A3_A1_A2); 
5D78:  MOVLW  02
5D7A:  MOVWF  FB4
5D7C:  MOVF   F92,W
5D7E:  IORLW  0F
5D80:  MOVWF  F92
5D82:  CLRWDT
5D84:  MOVLW  06
5D86:  MOVWF  00
5D88:  DECFSZ 00,F
5D8A:  BRA    5D88
5D8C:  MOVF   FB4,W
5D8E:  BCF    FA1.6
....................    //Caracterizamos los puertos A0 a A3 como entradas analógicas 
....................    setup_adc_ports(AN0_TO_AN3); 
5D90:  MOVF   FC1,W
5D92:  ANDLW  C0
5D94:  IORLW  0B
5D96:  MOVWF  FC1
....................    //Definimos el reloj de conversión 
....................    setup_adc(adc_clock_div_32); 
5D98:  MOVF   FC0,W
5D9A:  ANDLW  C0
5D9C:  IORLW  02
5D9E:  MOVWF  FC0
5DA0:  BCF    FC0.7
5DA2:  BSF    FC2.0
....................  
.................... /* 
....................    //@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ 
....................  
....................    //Recuperación de datos de la memoria 
....................    //Recuperamos a partir de la dirección eeprom_termostato los datos en 
....................    //el siguiente orden: termostato, número de intervalos de alarma, número de registros 
....................    //de encendido de la caldera, año actual en valores de 0 a 99 y año actual en valores de 0 a 3. 
....................    lee_ee(eeprom_termostato, 6, data); 
....................    termostato1 = termostato2 = (float)data[0]; 
....................    num_intervalos = data[1]; 
....................    //El número de registros está almacenado en un long y debemos realizar la conversión desde dos int 
....................    num_registros = (long)data[2]*256 + (long)data[3]; 
....................    anno_actual = data[4]; 
....................    anno_actual_0_to_3 = data[5]; 
....................  
....................    //Lee las programaciones de alarmas guardadas en memoria 
....................    leer_programaciones(); 
....................  
....................    //Comprobamos si hay alarmas programadas en memoria 
....................    if(num_intervalos!=0) 
....................    { 
....................       //Si las hay, seleccionamos la siguiente y programamos su activación 
....................       seleccionar_alarma(); 
....................       programar_proxima_alarma(); 
....................       toca_encender = TRUE; 
....................    }else 
....................    { 
....................       //Si no, simplemente inciamos la cuenta del reloj 
....................       PCF8583_write_byte(PCF8583_CTRL_STATUS_REG, 
....................                               PCF8583_START_COUNTING); 
....................    } 
....................  
....................    //@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ 
.................... */ 
....................  
....................    //Leemos la temperatura de las dos zonas de la vivienda 
....................    temperatura1 = ds1820_read(dir1); 
5DA4:  CLRF   xA2
5DA6:  MOVLW  6D
5DA8:  MOVWF  xA1
5DAA:  CALL   21B8
5DAE:  MOVFF  03,2F
5DB2:  MOVFF  02,2E
5DB6:  MOVFF  01,2D
5DBA:  MOVFF  00,2C
....................    temperatura2 = ds1820_read(dir2); 
5DBE:  CLRF   xA2
5DC0:  MOVLW  75
5DC2:  MOVWF  xA1
5DC4:  CALL   21B8
5DC8:  MOVFF  03,33
5DCC:  MOVFF  02,32
5DD0:  MOVFF  01,31
5DD4:  MOVFF  00,30
....................  
....................    if(temperatura1 >= termostato1) 
5DD8:  MOVFF  23,A0
5DDC:  MOVFF  22,9F
5DE0:  MOVFF  21,9E
5DE4:  MOVFF  20,9D
5DE8:  MOVFF  2F,A4
5DEC:  MOVFF  2E,A3
5DF0:  MOVFF  2D,A2
5DF4:  MOVFF  2C,A1
5DF8:  CALL   23B2
5DFC:  BC    5E00
5DFE:  BNZ   5E3A
....................    { 
....................       //Si supera el valor del termostato, lo indicamos con el flag 
....................       temp_habitacion_superada1 = TRUE; 
5E00:  BSF    1F.1
....................       //Tendremos que establecer un nuevo termostato teniendo en cuenta la histéresis de la temperatura 
....................       termostato1 = termostato1 - histeresis_vivienda; 
5E02:  BSF    FD8.1
5E04:  MOVFF  23,2AC
5E08:  MOVFF  22,2AB
5E0C:  MOVFF  21,2AA
5E10:  MOVFF  20,2A9
5E14:  MOVFF  37,2B0
5E18:  MOVFF  36,2AF
5E1C:  MOVFF  35,2AE
5E20:  MOVFF  34,2AD
5E24:  CALL   2428
5E28:  MOVFF  03,23
5E2C:  MOVFF  02,22
5E30:  MOVFF  01,21
5E34:  MOVFF  00,20
....................    }else 
5E38:  BRA    5E3C
....................       //Si no se supera, se indica también 
....................       temp_habitacion_superada1 = FALSE; 
5E3A:  BCF    1F.1
....................  
....................    if(temperatura2 >= termostato2) 
5E3C:  MOVFF  27,A0
5E40:  MOVFF  26,9F
5E44:  MOVFF  25,9E
5E48:  MOVFF  24,9D
5E4C:  MOVFF  33,A4
5E50:  MOVFF  32,A3
5E54:  MOVFF  31,A2
5E58:  MOVFF  30,A1
5E5C:  CALL   23B2
5E60:  BC    5E64
5E62:  BNZ   5E9E
....................    { 
....................       //Si supera el valor del termostato, lo indicamos con el flag 
....................       temp_habitacion_superada2 = TRUE; 
5E64:  BSF    1F.2
....................       //Tendremos que establecer un nuevo termostato teniendo en cuenta la histéresis de la temperatura 
....................       termostato2 = termostato2 - histeresis_vivienda; 
5E66:  BSF    FD8.1
5E68:  MOVFF  27,2AC
5E6C:  MOVFF  26,2AB
5E70:  MOVFF  25,2AA
5E74:  MOVFF  24,2A9
5E78:  MOVFF  37,2B0
5E7C:  MOVFF  36,2AF
5E80:  MOVFF  35,2AE
5E84:  MOVFF  34,2AD
5E88:  CALL   2428
5E8C:  MOVFF  03,27
5E90:  MOVFF  02,26
5E94:  MOVFF  01,25
5E98:  MOVFF  00,24
....................    }else 
5E9C:  BRA    5EA0
....................       //Si no se supera, se indica también 
....................       temp_habitacion_superada2 = FALSE; 
5E9E:  BCF    1F.2
....................  
....................  
....................    if(!C1OUT) 
5EA0:  BTFSC  FB4.6
5EA2:  BRA    5EA8
....................       //Si la temperatura del agua en la caldera supera el termostato, activamos el flag 
....................       temperatura_caldera_superada = TRUE; 
5EA4:  BSF    1F.0
....................    else 
5EA6:  BRA    5EAA
....................       //Si no es así, lo desactivamos 
....................       temperatura_caldera_superada = FALSE; 
5EA8:  BCF    1F.0
....................  
....................    //Desactivamos los flag de las interrupciones 
....................    alarma_int = led_int = timer_int = FALSE; 
5EAA:  BCF    1F.7
5EAC:  BCF    1F.5
5EAE:  BCF    1F.6
....................  
....................    //Determinamos que la patilla de interrupción de la alarma se activa al pasar de alta a baja 
....................    ext_int_edge(0, H_TO_L); 
5EB0:  BCF    FF1.6
....................  
....................    //Configuramos las interrupciones del temporizador 
....................    setup_timer_1(T1_INTERNAL | T1_DIV_BY_8); 
5EB2:  MOVLW  B5
5EB4:  MOVWF  FCD
....................  
....................    //Activamos las interrupciones del puerto B0 y B1 
....................    enable_interrupts(INT_EXT); 
5EB6:  BSF    FF2.4
....................    enable_interrupts(INT_EXT1); 
5EB8:  BSF    FF0.3
....................    enable_interrupts(GLOBAL); 
5EBA:  MOVLW  C0
5EBC:  IORWF  FF2,F
....................  
....................    //Mostramos un mensaje que indica al técnico el éxito en la inicialización 
....................    printf("Sistema inicializado con exito!\r"); 
5EBE:  CLRF   x95
5EC0:  MOVF   x95,W
5EC2:  CALL   0124
5EC6:  IORLW  00
5EC8:  BZ    5ED4
5ECA:  INCF   x95,F
5ECC:  BTFSS  F9E.4
5ECE:  BRA    5ECC
5ED0:  MOVWF  FAD
5ED2:  BRA    5EC0
....................  
....................    //Repetimos la siguiente rutina hasta que se desconecte el micro 
....................    while(1){ 
....................       inicio: 
....................       //Inhabilitamos el perro guardián para que no interfiera con las gestión de interrupciones y 
....................       //con la medida de la temperatura 
....................       setup_wdt(WDT_OFF); 
5ED4:  BCF    FD1.0
....................  
....................       //Si la interrupción de alarma se activa, gestionamos el proceso 
....................       if(alarma_int) 
5ED6:  BTFSS  1F.6
5ED8:  BRA    60C8
....................       { 
....................          //Variables para almacenar el tiempo 
....................          int hora, minutos; 
....................  
....................          //Desactivamos las interrupciones para que no interfieran con la gestión de la alarma 
....................          disable_interrupts(GLOBAL); 
5EDA:  BCF    FF2.6
5EDC:  BCF    FF2.7
5EDE:  BTFSC  FF2.7
5EE0:  BRA    5EDC
....................  
....................          //Desactivamos el flag de la alarma en el PCF8583 
....................          PCF8583_write_byte(PCF8583_CTRL_STATUS_REG, 
....................                                  PCF8583_START_COUNTING); 
5EE2:  CLRF   xAD
5EE4:  CLRF   xAE
5EE6:  CALL   169C
....................  
....................          if(toca_encender) 
5EEA:  BTFSS  1F.4
5EEC:  BRA    6052
....................          { 
....................             if(!sistema_encendido) 
5EEE:  BTFSC  F83.4
5EF0:  BRA    6038
....................             { 
....................                //Ejecutamos esto si se trata de una alarma de encendido y el sistema 
....................                //está apagado. 
....................                //Actualizamos el termostato, guardando el valor que había ya (teniendo en 
....................                //cuenta la histéresis) 
....................                if(temp_habitacion_superada1) 
5EF2:  BTFSS  1F.1
5EF4:  BRA    5F2E
....................                   termostato_provisional = termostato1 + histeresis_vivienda; 
5EF6:  BCF    FD8.1
5EF8:  MOVFF  23,2AC
5EFC:  MOVFF  22,2AB
5F00:  MOVFF  21,2AA
5F04:  MOVFF  20,2A9
5F08:  MOVFF  37,2B0
5F0C:  MOVFF  36,2AF
5F10:  MOVFF  35,2AE
5F14:  MOVFF  34,2AD
5F18:  CALL   2428
5F1C:  MOVFF  03,2B
5F20:  MOVFF  02,2A
5F24:  MOVFF  01,29
5F28:  MOVFF  00,28
....................                else 
5F2C:  BRA    5F3E
....................                   termostato_provisional = termostato1; 
5F2E:  MOVFF  23,2B
5F32:  MOVFF  22,2A
5F36:  MOVFF  21,29
5F3A:  MOVFF  20,28
....................  
....................                termostato1 = termostato2 = prg.termostato; 
5F3E:  MOVLB  2
5F40:  CLRF   xB0
5F42:  MOVFF  58,2AF
5F46:  MOVLB  0
5F48:  CALL   26A2
5F4C:  MOVFF  03,27
5F50:  MOVFF  02,26
5F54:  MOVFF  01,25
5F58:  MOVFF  00,24
5F5C:  MOVFF  27,23
5F60:  MOVFF  26,22
5F64:  MOVFF  25,21
5F68:  MOVFF  24,20
....................  
....................                //Si la temperatura no está superada, desactivamos los flag por si acaso 
....................                //lo estaba con el otro valor de termostato. 
....................                if(ds1820_read(dir1) < termostato1) 
5F6C:  CLRF   xA2
5F6E:  MOVLW  6D
5F70:  MOVWF  xA1
5F72:  CALL   21B8
5F76:  MOVFF  00,95
5F7A:  MOVFF  01,96
5F7E:  MOVFF  02,97
5F82:  MOVFF  03,98
5F86:  MOVFF  03,A0
5F8A:  MOVFF  02,9F
5F8E:  MOVFF  01,9E
5F92:  MOVFF  00,9D
5F96:  MOVFF  23,A4
5F9A:  MOVFF  22,A3
5F9E:  MOVFF  21,A2
5FA2:  MOVFF  20,A1
5FA6:  CALL   23B2
5FAA:  BNC   5FAE
....................                   temp_habitacion_superada1 = FALSE; 
5FAC:  BCF    1F.1
....................                if(ds1820_read(dir2) < termostato2) 
5FAE:  CLRF   xA2
5FB0:  MOVLW  75
5FB2:  MOVWF  xA1
5FB4:  CALL   21B8
5FB8:  MOVFF  00,95
5FBC:  MOVFF  01,96
5FC0:  MOVFF  02,97
5FC4:  MOVFF  03,98
5FC8:  MOVFF  03,A0
5FCC:  MOVFF  02,9F
5FD0:  MOVFF  01,9E
5FD4:  MOVFF  00,9D
5FD8:  MOVFF  27,A4
5FDC:  MOVFF  26,A3
5FE0:  MOVFF  25,A2
5FE4:  MOVFF  24,A1
5FE8:  CALL   23B2
5FEC:  BNC   5FF0
....................                   temp_habitacion_superada2 = FALSE; 
5FEE:  BCF    1F.2
....................  
....................                //Determinamos la próxima alarma como de apagado 
....................                toca_encender = FALSE; 
5FF0:  BCF    1F.4
....................  
....................                //Activamos el flag de sistema encendido por alarma 
....................                encendido_por_alarma = TRUE; 
5FF2:  BSF    1F.3
....................                //Mostramos un mensaje 
....................                lcd_send_byte(LCD_ORDEN,LCD_CLEAR); 
5FF4:  CLRF   xAC
5FF6:  MOVLW  01
5FF8:  MOVWF  xAD
5FFA:  CALL   1314
....................                printf(lcd_putc, "  Encendiendo\n  sistema..."); 
5FFE:  CLRF   x95
6000:  MOVF   x95,W
6002:  CALL   0160
6006:  IORLW  00
6008:  BZ    6014
600A:  INCF   x95,F
600C:  MOVWF  xA7
600E:  CALL   13C0
6012:  BRA    6000
....................                //Encendemos el sistema 
....................                encender_sistema(); 
6014:  CALL   28EA
....................  
....................                //Recogemos el tiempo en el que debe de saltar la alarma de apagado. 
....................                //Lo hacemos mediante variables auxiliares para dividir mejor las tareas 
....................                //y no condensar todo en una línea. 
....................                hora = prg.horas_fin; 
6018:  MOVFF  56,85
....................                minutos = prg.minutos_fin; 
601C:  MOVFF  57,86
....................  
....................                delay_ms(250); //Retraso para evitar solapamiento de alarmas 
6020:  MOVLW  FA
6022:  MOVWF  xAE
6024:  CALL   12A8
....................                               //(que salte una dos veces seguidas o algo así) 
....................  
....................                //Establecemos la alarma de apagado del sistema (segundos=0) 
....................                PCF8583_establecer_alarma(hora, minutos, 0); 
6028:  MOVFF  85,97
602C:  MOVFF  86,98
6030:  CLRF   x99
6032:  CALL   2912
....................  
....................             }else 
6036:  BRA    6050
....................             { 
....................                //Si se trata de una alarma de encendido y el sistema está encendido 
....................                delay_ms(250); //Retraso para evitar solapamiento de alarmas 
6038:  MOVLW  FA
603A:  MOVWF  xAE
603C:  CALL   12A8
....................  
....................                //Nos vamos a la siguiente alarma 
....................                posicion_alarmas++; 
6040:  INCF   5A,F
....................                //Si hemos llegado al final de la lista, volvemos al principio 
....................                if(posicion_alarmas==num_intervalos) 
6042:  MOVF   59,W
6044:  SUBWF  5A,W
6046:  BNZ   604A
....................                   posicion_alarmas = 0; 
6048:  CLRF   5A
....................  
....................                //Programamos la próxima alarma de encendido 
....................                programar_proxima_alarma(); 
604A:  CALL   29AA
....................  
....................                //Determinamos que la siguiente es de encendido 
....................                toca_encender = TRUE; 
604E:  BSF    1F.4
....................             } 
....................          }else 
6050:  BRA    60B8
....................          { 
....................             //Si se trata de una alarma de apagado 
....................  
....................             delay_ms(250); //Retraso para evitar el solapamiento de alarmas 
6052:  MOVLW  FA
6054:  MOVWF  xAE
6056:  CALL   12A8
....................  
....................             if(sistema_encendido && encendido_por_alarma) 
605A:  BTFSS  F83.4
605C:  BRA    60A8
605E:  BTFSS  1F.3
6060:  BRA    60A8
....................             { 
....................                //Si el sistema está encendido y se trata de un encendido por alarma: 
....................                //Restauramos el valor del termostato que había antes de la alarma 
....................                termostato1 = termostato2 = termostato_provisional; 
6062:  MOVFF  2B,27
6066:  MOVFF  2A,26
606A:  MOVFF  29,25
606E:  MOVFF  28,24
6072:  MOVFF  27,23
6076:  MOVFF  26,22
607A:  MOVFF  25,21
607E:  MOVFF  24,20
....................                //Determinamos que la próxima vez que se encienda no sea por alarma 
....................                encendido_por_alarma = FALSE; 
6082:  BCF    1F.3
....................                //Mostramos un mensaje 
....................                lcd_send_byte(LCD_ORDEN,LCD_CLEAR); 
6084:  CLRF   xAC
6086:  MOVLW  01
6088:  MOVWF  xAD
608A:  CALL   1314
....................                printf(lcd_putc, "  Apagando\n  sistema..."); 
608E:  CLRF   x95
6090:  MOVF   x95,W
6092:  CALL   0196
6096:  IORLW  00
6098:  BZ    60A4
609A:  INCF   x95,F
609C:  MOVWF  xA7
609E:  CALL   13C0
60A2:  BRA    6090
....................                //Apagamos el sistema 
....................                apagar_sistema(); 
60A4:  CALL   2DB6
....................             } 
....................  
....................             //Nos vamos a la siguiente alarma 
....................             posicion_alarmas++; 
60A8:  INCF   5A,F
....................             //Si llegamos al final de la lista, volvemos al principio 
....................             if(posicion_alarmas==num_intervalos) 
60AA:  MOVF   59,W
60AC:  SUBWF  5A,W
60AE:  BNZ   60B2
....................                posicion_alarmas = 0; 
60B0:  CLRF   5A
....................  
....................             //Programamos la próxima alarma de encendido 
....................             programar_proxima_alarma(); 
60B2:  CALL   29AA
....................  
....................             //Y activamos que, efectivamente, se trata de una alarma de encendido 
....................             toca_encender = TRUE; 
60B6:  BSF    1F.4
....................          } 
....................  
....................          //Activamos de nuevo la alarma 
....................          PCF8583_write_byte(PCF8583_CTRL_STATUS_REG, 
....................                                  PCF8583_ACTIVAR_ALARMA); 
60B8:  CLRF   xAD
60BA:  MOVLW  04
60BC:  MOVWF  xAE
60BE:  CALL   169C
....................  
....................          //Desactivamos el flag de interrupción 
....................          alarma_int = FALSE; 
60C2:  BCF    1F.6
....................  
....................          //Volvemos a activar las interrupciones 
....................          enable_interrupts(GLOBAL); 
60C4:  MOVLW  C0
60C6:  IORWF  FF2,F
....................       } 
....................  
....................  
....................       //Si se activa la interrupción de interfaz con el usuario, se gestiona el proceso 
....................       if(led_int) 
60C8:  BTFSS  1F.5
60CA:  GOTO   6BEA
....................       { 
....................          //Contadores 
....................          int contador, contador2; 
....................          //Variable para la conversión de los valores de teclado 
....................          long numero; 
....................          //Variables provisionales para buscar en la lista de programaciones 
....................          programacion pr, pr2; 
....................  
....................          //Desactivamos interrupciones externas 
....................          disable_interrupts(GLOBAL); 
60CE:  BCF    FF2.6
60D0:  BCF    FF2.7
60D2:  BTFSC  FF2.7
60D4:  BRA    60D0
....................           
....................  
....................          //Ponemos en key un caracter cualquiera para que no se corresponda 
....................          //con ningún botón del teclado. 
....................          key='J'; 
60D6:  MOVLW  4A
60D8:  MOVWF  38
....................  
....................          //Mostramos un mensaje al usuario para que elija su opción 
....................          lcd_send_byte(LCD_ORDEN,LCD_CLEAR); 
60DA:  CLRF   xAC
60DC:  MOVLW  01
60DE:  MOVWF  xAD
60E0:  CALL   1314
....................          printf(lcd_putc, "  Indique la \n  operacion"); 
60E4:  CLRF   x95
60E6:  MOVF   x95,W
60E8:  CALL   01C8
60EC:  IORLW  00
60EE:  BZ    60FA
60F0:  INCF   x95,F
60F2:  MOVWF  xA7
60F4:  CALL   13C0
60F8:  BRA    60E6
....................  
....................          //Activamos el temporizador para controlar el tiempo que el menú está activo, 
....................          //poniendo el contador a 0. 
....................          contador_tiempo = 0; 
60FA:  CLRF   7D
....................          enable_interrupts(INT_TIMER1); 
60FC:  BSF    F9D.0
....................  
....................          //Mientras que la tecla pulsada no sea una de las válidas, seguimos barriendo el teclado 
....................          while(key!='1' && key!='2' && key!='3' && key!='4' && key!='N'){ 
60FE:  MOVF   38,W
6100:  SUBLW  31
6102:  BZ    6130
6104:  MOVF   38,W
6106:  SUBLW  32
6108:  BZ    6130
610A:  MOVF   38,W
610C:  SUBLW  33
610E:  BZ    6130
6110:  MOVF   38,W
6112:  SUBLW  34
6114:  BZ    6130
6116:  MOVF   38,W
6118:  SUBLW  4E
611A:  BZ    6130
....................             key=get_key(); 
611C:  CALL   3216
6120:  MOVFF  01,38
....................             //Si el tiempo de espera consignado expira, es equivalente a pulsar la tecla NO para salir. 
....................             if(timer_int){ 
6124:  BTFSS  1F.7
6126:  BRA    612E
....................                key='N'; 
6128:  MOVLW  4E
612A:  MOVWF  38
....................                timer_int = FALSE; //Desactivamos flag 
612C:  BCF    1F.7
....................             } 
....................          } 
612E:  BRA    60FE
....................  
....................          //Volvemos a deshabilitar la interrupción que controla el tiempo de espera 
....................          disable_interrupts(INT_TIMER1); 
6130:  BCF    F9D.0
....................  
....................          //Se elige la opción pertinente 
....................          switch(key) 
....................          { 
6132:  MOVF   38,W
6134:  XORLW  31
6136:  BZ    6156
6138:  XORLW  03
613A:  BZ    61CE
613C:  XORLW  01
613E:  BTFSC  FD8.2
6140:  BRA    653C
6142:  XORLW  07
6144:  BTFSC  FD8.2
6146:  GOTO   6A0A
614A:  XORLW  7A
614C:  BTFSC  FD8.2
614E:  GOTO   6BA8
6152:  GOTO   6BE4
....................             //Si es 1, entramos en la opción de apagado y encendido manual del sistema 
....................             case '1': 
....................                      //Si el sistema está apagado, lo encendemos 
....................                      if(!sistema_encendido) 
6156:  BTFSC  F83.4
6158:  BRA    6180
....................                      { 
....................                         lcd_send_byte(LCD_ORDEN,LCD_CLEAR); 
615A:  CLRF   xAC
615C:  MOVLW  01
615E:  MOVWF  xAD
6160:  CALL   1314
....................                         printf(lcd_putc, "  Encendiendo\n  sistema..."); 
6164:  CLRF   x95
6166:  MOVF   x95,W
6168:  CALL   0160
616C:  IORLW  00
616E:  BZ    617A
6170:  INCF   x95,F
6172:  MOVWF  xA7
6174:  CALL   13C0
6178:  BRA    6166
....................                         encender_sistema(); 
617A:  CALL   28EA
....................                      }else 
617E:  BRA    61CA
....................                      //Si está encendido, lo apagamos 
....................                      { 
....................                         lcd_send_byte(LCD_ORDEN,LCD_CLEAR); 
6180:  CLRF   xAC
6182:  MOVLW  01
6184:  MOVWF  xAD
6186:  CALL   1314
....................                         printf(lcd_putc, "  Apagando\n  sistema..."); 
618A:  CLRF   x95
618C:  MOVF   x95,W
618E:  CALL   0196
6192:  IORLW  00
6194:  BZ    61A0
6196:  INCF   x95,F
6198:  MOVWF  xA7
619A:  CALL   13C0
619E:  BRA    618C
....................                         apagar_sistema(); 
61A0:  CALL   2DB6
....................                         //Si los motores estaban en marcha, debemos apagarlos 
....................                         //motor1 = FALSE;   /* Lo hacemos ya dentro de la rutina 
....................                         //motor2 = FALSE; 
....................  
....................                         //Si estaba encendido por alguna alarma debemos indicarlo 
....................                         if(encendido_por_alarma) 
61A4:  BTFSS  1F.3
61A6:  BRA    61CA
....................                         { 
....................                            //Recuperamos el valor del termostato 
....................                            termostato1 = termostato2 = termostato_provisional; 
61A8:  MOVFF  2B,27
61AC:  MOVFF  2A,26
61B0:  MOVFF  29,25
61B4:  MOVFF  28,24
61B8:  MOVFF  27,23
61BC:  MOVFF  26,22
61C0:  MOVFF  25,21
61C4:  MOVFF  24,20
....................                            encendido_por_alarma = FALSE; 
61C8:  BCF    1F.3
....................                         } 
....................                      } 
....................                      break; 
61CA:  GOTO   6BE4
....................  
....................  
....................             //Si es 2, entramos en la opción de configuración del termostato 
....................             case '2': 
....................  
....................                      //Mostramos el valor del termostato actual 
....................                      lcd_send_byte(LCD_ORDEN, LCD_CLEAR); 
61CE:  CLRF   xAC
61D0:  MOVLW  01
61D2:  MOVWF  xAD
61D4:  CALL   1314
....................                      //Para considerar el valor del termostato hay que tener en cuenta el valor de la histéresis. 
....................                      //El termostato de la vivienda es único y no depende de la habitación en la que nos encontremos. 
....................                      if(temp_habitacion_superada1) 
61D8:  BTFSS  1F.1
61DA:  BRA    6256
....................                         printf(lcd_putc, "Modificar\ntermostato %.0f%cC",termostato1+histeresis_vivienda,223); 
61DC:  BCF    FD8.1
61DE:  MOVFF  23,2AC
61E2:  MOVFF  22,2AB
61E6:  MOVFF  21,2AA
61EA:  MOVFF  20,2A9
61EE:  MOVFF  37,2B0
61F2:  MOVFF  36,2AF
61F6:  MOVFF  35,2AE
61FA:  MOVFF  34,2AD
61FE:  CALL   2428
6202:  MOVFF  00,95
6206:  MOVFF  01,96
620A:  MOVFF  02,97
620E:  MOVFF  03,98
6212:  CLRF   x99
6214:  MOVF   x99,W
6216:  CALL   01FC
621A:  INCF   x99,F
621C:  MOVWF  00
621E:  MOVWF  xA7
6220:  CALL   13C0
6224:  MOVLW  15
6226:  SUBWF  x99,W
6228:  BNZ   6214
622A:  MOVLW  89
622C:  MOVWF  FE9
622E:  MOVFF  98,9D
6232:  MOVFF  97,9C
6236:  MOVFF  96,9B
623A:  MOVFF  95,9A
623E:  CLRF   x9E
6240:  CALL   32F0
6244:  MOVLW  DF
6246:  MOVWF  xA7
6248:  CALL   13C0
624C:  MOVLW  43
624E:  MOVWF  xA7
6250:  CALL   13C0
....................                      else 
6254:  BRA    6298
....................                         printf(lcd_putc, "Modificar\ntermostato %.0f%cC",termostato1,223); 
6256:  CLRF   x95
6258:  MOVF   x95,W
625A:  CALL   01FC
625E:  INCF   x95,F
6260:  MOVWF  00
6262:  MOVWF  xA7
6264:  CALL   13C0
6268:  MOVLW  15
626A:  SUBWF  x95,W
626C:  BNZ   6258
626E:  MOVLW  89
6270:  MOVWF  FE9
6272:  MOVFF  23,9D
6276:  MOVFF  22,9C
627A:  MOVFF  21,9B
627E:  MOVFF  20,9A
6282:  CLRF   x9E
6284:  CALL   32F0
6288:  MOVLW  DF
628A:  MOVWF  xA7
628C:  CALL   13C0
6290:  MOVLW  43
6292:  MOVWF  xA7
6294:  CALL   13C0
....................  
....................                      //Retardamos cierto tiempo para que el usuario vea correctamente los datos de la pantalla 
....................                      delay_ms(LCD_T_RETARDO*2); 
6298:  MOVLW  04
629A:  MOVWF  x95
629C:  MOVLW  FA
629E:  MOVWF  xAE
62A0:  CALL   12A8
62A4:  DECFSZ x95,F
62A6:  BRA    629C
....................  
....................                      //Pedimos la introducción de nuevo valor 
....................                      lcd_send_byte(LCD_ORDEN, LCD_CLEAR); 
62A8:  CLRF   xAC
62AA:  MOVLW  01
62AC:  MOVWF  xAD
62AE:  CALL   1314
....................                      lcd_send_byte(LCD_ORDEN, LCD_CURSOR); //Activamos el cursor en la pantalla 
62B2:  CLRF   xAC
62B4:  MOVLW  0E
62B6:  MOVWF  xAD
62B8:  CALL   1314
....................                      printf(lcd_putc, "Nuevo valor:\n       %cC",223); 
62BC:  CLRF   x95
62BE:  MOVF   x95,W
62C0:  CALL   0234
62C4:  INCF   x95,F
62C6:  MOVWF  00
62C8:  MOVWF  xA7
62CA:  CALL   13C0
62CE:  MOVLW  0D
62D0:  SUBWF  x95,W
62D2:  BNZ   62BE
62D4:  MOVLW  07
62D6:  MOVWF  x96
62D8:  MOVLW  20
62DA:  MOVWF  xA7
62DC:  CALL   13C0
62E0:  DECFSZ x96,F
62E2:  BRA    62D8
62E4:  MOVLW  DF
62E6:  MOVWF  xA7
62E8:  CALL   13C0
62EC:  MOVLW  43
62EE:  MOVWF  xA7
62F0:  CALL   13C0
....................                      lcd_gotoxy(6,2); 
62F4:  MOVLW  06
62F6:  MOVWF  xA8
62F8:  MOVLW  02
62FA:  MOVWF  xA9
62FC:  CALL   139E
....................  
....................                      //Recogemos el número de dos cifras introducido por el teclado 
....................                      valor=buscar_numero(); 
6300:  CALL   3480
6304:  MOVFF  01,84
....................  
....................                      //Si se pulsa la tecla SI o NO, salimos 
....................                      if(valor==NO || valor==SI) 
6308:  MOVF   x84,W
630A:  SUBLW  64
630C:  BZ    6314
630E:  MOVF   x84,W
6310:  SUBLW  65
6312:  BNZ   631A
....................                         goto salir; 
6314:  GOTO   6BA8
....................                      else 
6318:  BRA    653A
....................                      { 
....................                         //Retardamos cierto tiempo para permitir al usuario visualizar el valor que ha introducido 
....................                         delay_ms(LCD_T_RETARDO); 
631A:  MOVLW  02
631C:  MOVWF  x95
631E:  MOVLW  FA
6320:  MOVWF  xAE
6322:  CALL   12A8
6326:  DECFSZ x95,F
6328:  BRA    631E
....................  
....................                         //Mostramos un mensaje de aplicación de cambios y desactivamos el cursor 
....................                         lcd_send_byte(LCD_ORDEN, LCD_CLEAR); 
632A:  CLRF   xAC
632C:  MOVLW  01
632E:  MOVWF  xAD
6330:  CALL   1314
....................                         lcd_send_byte(LCD_ORDEN, LCD_NO_CURSOR); 
6334:  CLRF   xAC
6336:  MOVLW  0C
6338:  MOVWF  xAD
633A:  CALL   1314
....................                         printf(lcd_putc, "  Aplicando\n  cambios..."); 
633E:  CLRF   x95
6340:  MOVF   x95,W
6342:  CALL   0260
6346:  IORLW  00
6348:  BZ    6354
634A:  INCF   x95,F
634C:  MOVWF  xA7
634E:  CALL   13C0
6352:  BRA    6340
....................  
....................                         if(valor<=temp_max && valor>=temp_min) 
6354:  MOVF   x84,W
6356:  SUBLW  20
6358:  BTFSS  FD8.0
635A:  BRA    650A
635C:  MOVF   x84,W
635E:  SUBLW  0F
6360:  BTFSC  FD8.0
6362:  BRA    650A
....................                         { 
....................                            //Si el valor está dentro de los límites propuestos, guardamos el valor nuevo 
....................  
....................                            //Leemos la temperatura de la zona1 de la vivienda 
....................                            temperatura1 = ds1820_read(dir1); 
6364:  CLRF   xA2
6366:  MOVLW  6D
6368:  MOVWF  xA1
636A:  CALL   21B8
636E:  MOVFF  03,2F
6372:  MOVFF  02,2E
6376:  MOVFF  01,2D
637A:  MOVFF  00,2C
....................                            if(temperatura1 >= (float)valor) 
637E:  MOVLB  2
6380:  CLRF   xB0
6382:  MOVFF  84,2AF
6386:  MOVLB  0
6388:  CALL   26A2
638C:  MOVFF  03,A0
6390:  MOVFF  02,9F
6394:  MOVFF  01,9E
6398:  MOVFF  00,9D
639C:  MOVFF  2F,A4
63A0:  MOVFF  2E,A3
63A4:  MOVFF  2D,A2
63A8:  MOVFF  2C,A1
63AC:  CALL   23B2
63B0:  BC    63B4
63B2:  BNZ   640C
....................                            { 
....................                               //Si supera el valor del termostato, lo indicamos con el flag 
....................                               temp_habitacion_superada1 = TRUE; 
63B4:  BSF    1F.1
....................                               //Guardamos el termostato nuevo teniendo en cuenta la histeresis de la vivienda 
....................                               termostato1 = (float)valor - histeresis_vivienda; 
63B6:  MOVLB  2
63B8:  CLRF   xB0
63BA:  MOVFF  84,2AF
63BE:  MOVLB  0
63C0:  CALL   26A2
63C4:  MOVFF  00,95
63C8:  MOVFF  01,96
63CC:  MOVFF  02,97
63D0:  MOVFF  03,98
63D4:  BSF    FD8.1
63D6:  MOVFF  03,2AC
63DA:  MOVFF  02,2AB
63DE:  MOVFF  01,2AA
63E2:  MOVFF  00,2A9
63E6:  MOVFF  37,2B0
63EA:  MOVFF  36,2AF
63EE:  MOVFF  35,2AE
63F2:  MOVFF  34,2AD
63F6:  CALL   2428
63FA:  MOVFF  03,23
63FE:  MOVFF  02,22
6402:  MOVFF  01,21
6406:  MOVFF  00,20
....................                            }else 
640A:  BRA    642C
....................                            { 
....................                               //Si no se supera, se indica también 
....................                               temp_habitacion_superada1 = FALSE; 
640C:  BCF    1F.1
....................                               //Se guarda el valor tal cual 
....................                               termostato1 = (float)valor; 
640E:  MOVLB  2
6410:  CLRF   xB0
6412:  MOVFF  84,2AF
6416:  MOVLB  0
6418:  CALL   26A2
641C:  MOVFF  03,23
6420:  MOVFF  02,22
6424:  MOVFF  01,21
6428:  MOVFF  00,20
....................                            } 
....................  
....................                            //Repetimos el proceso con la zona2 de la vivienda 
....................                            temperatura2 = ds1820_read(dir2); 
642C:  CLRF   xA2
642E:  MOVLW  75
6430:  MOVWF  xA1
6432:  CALL   21B8
6436:  MOVFF  03,33
643A:  MOVFF  02,32
643E:  MOVFF  01,31
6442:  MOVFF  00,30
....................                            if(temperatura2 >= (float)valor) 
6446:  MOVLB  2
6448:  CLRF   xB0
644A:  MOVFF  84,2AF
644E:  MOVLB  0
6450:  CALL   26A2
6454:  MOVFF  03,A0
6458:  MOVFF  02,9F
645C:  MOVFF  01,9E
6460:  MOVFF  00,9D
6464:  MOVFF  33,A4
6468:  MOVFF  32,A3
646C:  MOVFF  31,A2
6470:  MOVFF  30,A1
6474:  CALL   23B2
6478:  BC    647C
647A:  BNZ   64D4
....................                            { 
....................                               //Si supera el valor del termostato, lo indicamos con el flag 
....................                               temp_habitacion_superada2 = TRUE; 
647C:  BSF    1F.2
....................                               //Guardamos el termostato nuevo teniendo en cuenta la histeresis de la vivienda 
....................                               termostato2 = (float)valor - histeresis_vivienda; 
647E:  MOVLB  2
6480:  CLRF   xB0
6482:  MOVFF  84,2AF
6486:  MOVLB  0
6488:  CALL   26A2
648C:  MOVFF  00,95
6490:  MOVFF  01,96
6494:  MOVFF  02,97
6498:  MOVFF  03,98
649C:  BSF    FD8.1
649E:  MOVFF  03,2AC
64A2:  MOVFF  02,2AB
64A6:  MOVFF  01,2AA
64AA:  MOVFF  00,2A9
64AE:  MOVFF  37,2B0
64B2:  MOVFF  36,2AF
64B6:  MOVFF  35,2AE
64BA:  MOVFF  34,2AD
64BE:  CALL   2428
64C2:  MOVFF  03,27
64C6:  MOVFF  02,26
64CA:  MOVFF  01,25
64CE:  MOVFF  00,24
....................                            }else 
64D2:  BRA    64F4
....................                            { 
....................                               //Si no se supera, se indica también 
....................                               temp_habitacion_superada2 = FALSE; 
64D4:  BCF    1F.2
....................                               //Se guarda el valor tal cual 
....................                               termostato2 = (float)valor; 
64D6:  MOVLB  2
64D8:  CLRF   xB0
64DA:  MOVFF  84,2AF
64DE:  MOVLB  0
64E0:  CALL   26A2
64E4:  MOVFF  03,27
64E8:  MOVFF  02,26
64EC:  MOVFF  01,25
64F0:  MOVFF  00,24
....................                            } 
....................  
....................                            //Guardamos el nuevo valor del termostato en memoria 
....................                            graba_ee(eeprom_termostato, 1, &valor); 
64F4:  CLRF   xA8
64F6:  MOVLW  10
64F8:  MOVWF  xA7
64FA:  MOVLW  01
64FC:  MOVWF  xA9
64FE:  CLRF   xAB
6500:  MOVLW  84
6502:  MOVWF  xAA
6504:  CALL   184A
....................  
....................                         } 
....................                         else 
6508:  BRA    653A
....................                         { 
....................                            //Si el valor es incorrecto, mostramos un mensaje de error 
....................                            lcd_send_byte(LCD_ORDEN, LCD_CLEAR); 
650A:  CLRF   xAC
650C:  MOVLW  01
650E:  MOVWF  xAD
6510:  CALL   1314
....................                            printf(lcd_putc, "   Valor\n   incorrecto"); 
6514:  CLRF   x95
6516:  MOVF   x95,W
6518:  CALL   0294
651C:  IORLW  00
651E:  BZ    652A
6520:  INCF   x95,F
6522:  MOVWF  xA7
6524:  CALL   13C0
6528:  BRA    6516
....................                            delay_ms(LCD_T_RETARDO); 
652A:  MOVLW  02
652C:  MOVWF  x95
652E:  MOVLW  FA
6530:  MOVWF  xAE
6532:  CALL   12A8
6536:  DECFSZ x95,F
6538:  BRA    652E
....................                         } 
....................                      } 
....................  
....................                      break; 
653A:  BRA    6BE4
....................  
....................  
....................             //Si es 3, entramos en la opción de configuración de las alarmas 
....................             case '3': 
....................  
....................                      //Mostramos el encabezamiento de la operación 
....................                      lcd_send_byte(LCD_ORDEN, LCD_CLEAR); 
653C:  CLRF   xAC
653E:  MOVLW  01
6540:  MOVWF  xAD
6542:  CALL   1314
....................                      printf(lcd_putc," Programar\n sistema"); 
6546:  CLRF   x95
6548:  MOVF   x95,W
654A:  CALL   02C6
654E:  IORLW  00
6550:  BZ    655C
6552:  INCF   x95,F
6554:  MOVWF  xA7
6556:  CALL   13C0
655A:  BRA    6548
....................                      delay_ms(LCD_T_RETARDO); 
655C:  MOVLW  02
655E:  MOVWF  x95
6560:  MOVLW  FA
6562:  MOVWF  xAE
6564:  CALL   12A8
6568:  DECFSZ x95,F
656A:  BRA    6560
....................  
....................                      //Tenemos la posibilidad de introducir 5 intervalos de alarma. 
....................                      //Se va guiando al usuario por la configuración de cada intervalo mediante el siguiente bucle 
....................                      for(contador=0; contador<5; contador++) 
656C:  CLRF   x87
656E:  MOVF   x87,W
6570:  SUBLW  04
6572:  BTFSS  FD8.0
6574:  BRA    69C0
....................                      { 
....................                         //Se muestra el intervalo a configurar 
....................                         lcd_send_byte(LCD_ORDEN, LCD_CLEAR); 
6576:  CLRF   xAC
6578:  MOVLW  01
657A:  MOVWF  xAD
657C:  CALL   1314
....................                         printf(lcd_putc, " INTERVALO %i\n   :      :",contador+1); 
6580:  MOVLW  01
6582:  ADDWF  x87,W
6584:  MOVWF  x95
6586:  CLRF   x96
6588:  MOVF   x96,W
658A:  CALL   02F4
658E:  INCF   x96,F
6590:  MOVWF  00
6592:  MOVWF  xA7
6594:  CALL   13C0
6598:  MOVLW  0B
659A:  SUBWF  x96,W
659C:  BNZ   6588
659E:  MOVFF  95,97
65A2:  MOVLW  1F
65A4:  MOVWF  x98
65A6:  CALL   3536
65AA:  MOVLW  0A
65AC:  MOVWF  xA7
65AE:  CALL   13C0
65B2:  MOVLW  03
65B4:  MOVWF  x97
65B6:  MOVLW  20
65B8:  MOVWF  xA7
65BA:  CALL   13C0
65BE:  DECFSZ x97,F
65C0:  BRA    65B6
65C2:  MOVLW  3A
65C4:  MOVWF  xA7
65C6:  CALL   13C0
65CA:  MOVLW  06
65CC:  MOVWF  x98
65CE:  MOVLW  20
65D0:  MOVWF  xA7
65D2:  CALL   13C0
65D6:  DECFSZ x98,F
65D8:  BRA    65CE
65DA:  MOVLW  3A
65DC:  MOVWF  xA7
65DE:  CALL   13C0
....................                         lcd_gotoxy(2,2); 
65E2:  MOVLW  02
65E4:  MOVWF  xA8
65E6:  MOVWF  xA9
65E8:  CALL   139E
....................                         lcd_send_byte(LCD_ORDEN, LCD_CURSOR); 
65EC:  CLRF   xAC
65EE:  MOVLW  0E
65F0:  MOVWF  xAD
65F2:  CALL   1314
....................  
....................                         //Se pide al usuario el valor de hora de inicio de la alarma 
....................                         pr.horas_inicio = buscar_numero(); 
65F6:  CALL   3480
65FA:  MOVFF  01,8B
....................  
....................                         //Si se pulsa el botón de NO, se sale de la configuración 
....................                         if(pr.horas_inicio==NO) 
65FE:  MOVF   x8B,W
6600:  SUBLW  64
6602:  BNZ   6606
....................                            goto salir; 
6604:  BRA    6BA8
....................  
....................                         //Si se pulsa Sí, se indica que no quieren introducirse más alarmas 
....................                         if(pr.horas_inicio==SI) 
6606:  MOVF   x8B,W
6608:  SUBLW  65
660A:  BNZ   661E
....................                         { 
....................                            //Si era la primera alarma que se gestionaba, se interpreta como que 
....................                            //no se quiere activar ninguna alarma 
....................                            if(contador==0) 
660C:  MOVF   x87,F
660E:  BNZ   661C
....................                            { 
....................                               //Desactivamos las alarmas 
....................                               PCF8583_write_byte(PCF8583_CTRL_STATUS_REG, 
....................                                     PCF8583_START_COUNTING); 
6610:  CLRF   xAD
6612:  CLRF   xAE
6614:  CALL   169C
....................                               //Habilitamos interrupciones 
....................                               //enable_interrupts(GLOBAL); 
....................                               //Salimos 
....................                               goto salir; 
6618:  BRA    6BA8
....................                            } 
....................                            else 
661A:  BRA    661E
....................                               //Salimos simplemente del bucle 
....................                               break; 
661C:  BRA    69C0
....................                         } 
....................  
....................                         //Movemos el cursor en la pantalla 
....................                         lcd_gotoxy(5,2); 
661E:  MOVLW  05
6620:  MOVWF  xA8
6622:  MOVLW  02
6624:  MOVWF  xA9
6626:  CALL   139E
....................  
....................                         //Se pide al usuario el valor de los minutos de inicio 
....................                         pr.minutos_inicio = buscar_numero(); 
662A:  CALL   3480
662E:  MOVFF  01,8C
....................  
....................                         //Si se pulsa NO, se sale 
....................                         if(pr.minutos_inicio==NO) 
6632:  MOVF   x8C,W
6634:  SUBLW  64
6636:  BNZ   663A
....................                            goto salir; 
6638:  BRA    6BA8
....................  
....................                         //Si se pulsa SI, interrumpimos la introducción de alarmas 
....................                         if(pr.minutos_inicio==SI) 
663A:  MOVF   x8C,W
663C:  SUBLW  65
663E:  BNZ   6652
....................                         { 
....................                            //Si es el primer intervalo, interpretamos como que el usuario 
....................                            //no quiere programar alarmas 
....................                            if(contador==0) 
6640:  MOVF   x87,F
6642:  BNZ   6650
....................                            { 
....................                               //Desactivamos las alarmas 
....................                               PCF8583_write_byte(PCF8583_CTRL_STATUS_REG, 
....................                                     PCF8583_START_COUNTING); 
6644:  CLRF   xAD
6646:  CLRF   xAE
6648:  CALL   169C
....................                               //Habilitamos interrupciones 
....................                               //enable_interrupts(GLOBAL); 
....................                               goto salir; 
664C:  BRA    6BA8
....................                            } 
....................                            else 
664E:  BRA    6652
....................                               //Salimos del bucle 
....................                               break; 
6650:  BRA    69C0
....................                         } 
....................  
....................                         //******************************************************************************** 
....................                         //Los comentarios a partir de este punto y hasta la siguiente línea de asteriscos 
....................                         //son equivalentes a los mostrados arriba pero esta vez con la hora de finalización 
....................  
....................                         lcd_gotoxy(9,2); 
6652:  MOVLW  09
6654:  MOVWF  xA8
6656:  MOVLW  02
6658:  MOVWF  xA9
665A:  CALL   139E
....................  
....................                         pr.horas_fin = buscar_numero(); 
665E:  CALL   3480
6662:  MOVFF  01,8D
....................  
....................                         if(pr.horas_fin==NO) 
6666:  MOVF   x8D,W
6668:  SUBLW  64
666A:  BNZ   666E
....................                            goto salir; 
666C:  BRA    6BA8
....................  
....................                         if(pr.horas_fin==SI) 
666E:  MOVF   x8D,W
6670:  SUBLW  65
6672:  BNZ   6686
....................                         { 
....................                            if(contador==0) 
6674:  MOVF   x87,F
6676:  BNZ   6684
....................                            { 
....................                               PCF8583_write_byte(PCF8583_CTRL_STATUS_REG, 
....................                                     PCF8583_START_COUNTING); 
6678:  CLRF   xAD
667A:  CLRF   xAE
667C:  CALL   169C
....................                               //Habilitamos interrupciones 
....................                               //enable_interrupts(GLOBAL); 
....................                               goto salir; 
6680:  BRA    6BA8
....................                            } 
....................                            else 
6682:  BRA    6686
....................                               break; 
6684:  BRA    69C0
....................                         } 
....................  
....................  
....................                         lcd_gotoxy(12,2); 
6686:  MOVLW  0C
6688:  MOVWF  xA8
668A:  MOVLW  02
668C:  MOVWF  xA9
668E:  CALL   139E
....................  
....................                         pr.minutos_fin = buscar_numero(); 
6692:  CALL   3480
6696:  MOVFF  01,8E
....................  
....................                         if(pr.minutos_fin==NO) 
669A:  MOVF   x8E,W
669C:  SUBLW  64
669E:  BNZ   66A2
....................                            goto salir; 
66A0:  BRA    6BA8
....................  
....................                         if(pr.minutos_fin==SI) 
66A2:  MOVF   x8E,W
66A4:  SUBLW  65
66A6:  BNZ   66BA
....................                         { 
....................                            if(contador==0) 
66A8:  MOVF   x87,F
66AA:  BNZ   66B8
....................                            { 
....................                               PCF8583_write_byte(PCF8583_CTRL_STATUS_REG, 
....................                                     PCF8583_START_COUNTING); 
66AC:  CLRF   xAD
66AE:  CLRF   xAE
66B0:  CALL   169C
....................                               //Habilitamos interrupciones 
....................                               //enable_interrupts(GLOBAL); 
....................                               goto salir; 
66B4:  BRA    6BA8
....................                            } 
....................                            else 
66B6:  BRA    66BA
....................                               break; 
66B8:  BRA    69C0
....................                         } 
....................  
....................                         //Ver comentarios arriba 
....................                         //************************************************************ 
....................  
....................                         //Desactivamos el cursor de la pantalla 
....................                         lcd_send_byte(LCD_ORDEN, LCD_NO_CURSOR); 
66BA:  CLRF   xAC
66BC:  MOVLW  0C
66BE:  MOVWF  xAD
66C0:  CALL   1314
....................  
....................                         //Introducimos cierto retardo para que el usuario pueda visualizar los valores introducidos en la pantalla 
....................                         delay_ms(LCD_T_RETARDO); 
66C4:  MOVLW  02
66C6:  MOVWF  x95
66C8:  MOVLW  FA
66CA:  MOVWF  xAE
66CC:  CALL   12A8
66D0:  DECFSZ x95,F
66D2:  BRA    66C8
....................  
....................                         //Comprobamos que los valores introducidos son correctos: horas menores que 24 y minutos menores que 60 
....................                         //Además, comprobamos que la hora de finalización no vaya antes que la de inicio 
....................                         if(pr.horas_inicio>23 || pr.horas_fin>23 || pr.minutos_inicio>59 || pr.minutos_fin>59 
....................                               || comprobar_hora(pr.horas_fin,pr.minutos_fin,pr.horas_inicio,pr.minutos_inicio)) 
66D4:  MOVF   x8B,W
66D6:  SUBLW  17
66D8:  BNC   6704
66DA:  MOVF   x8D,W
66DC:  SUBLW  17
66DE:  BNC   6704
66E0:  MOVF   x8C,W
66E2:  SUBLW  3B
66E4:  BNC   6704
66E6:  MOVF   x8E,W
66E8:  SUBLW  3B
66EA:  BNC   6704
66EC:  MOVFF  8D,AB
66F0:  MOVFF  8E,AC
66F4:  MOVFF  8B,AD
66F8:  MOVFF  8C,AE
66FC:  CALL   2AEA
6700:  MOVF   01,F
6702:  BZ    6738
....................                         { 
....................                            //Si se produce un error de este tipo, se indica 
....................                            lcd_send_byte(LCD_ORDEN, LCD_CLEAR); 
6704:  CLRF   xAC
6706:  MOVLW  01
6708:  MOVWF  xAD
670A:  CALL   1314
....................                            printf(lcd_putc, "   Valores\n   incorrectos"); 
670E:  CLRF   x95
6710:  MOVF   x95,W
6712:  CALL   0320
6716:  IORLW  00
6718:  BZ    6724
671A:  INCF   x95,F
671C:  MOVWF  xA7
671E:  CALL   13C0
6722:  BRA    6710
....................                            delay_ms(LCD_T_RETARDO); 
6724:  MOVLW  02
6726:  MOVWF  x95
6728:  MOVLW  FA
672A:  MOVWF  xAE
672C:  CALL   12A8
6730:  DECFSZ x95,F
6732:  BRA    6728
....................                            //Se repite la última iteración del bloque 
....................                            contador--; 
6734:  DECF   x87,F
....................                            continue; 
6736:  BRA    69BC
....................                         } 
....................  
....................                         //No puede haber un intervalo de encendido de más de 4 horas. 
....................                         //Esto deriva de un problema propio de almacenamiento de números enteros, pero es perfectamente lógico 
....................                         //que un sistema de calefacción tenga un tiempo máximo de encendido para regular el uso abusivo del sistema 
....................                         //y evitar averías por un funcionamiento muy prolongado. 
....................                         if(diferencia_tiempo(pr.horas_inicio, pr.minutos_inicio, pr.horas_fin, pr.minutos_fin)>240) 
6738:  MOVFF  8B,A1
673C:  MOVFF  8C,A2
6740:  MOVFF  8D,A3
6744:  MOVFF  8E,A4
6748:  CALL   2B1E
674C:  MOVFF  02,96
6750:  MOVFF  01,95
6754:  MOVF   x96,F
6756:  BNZ   675E
6758:  MOVF   x95,W
675A:  SUBLW  F0
675C:  BC    6792
....................                         { 
....................                            //Mostramos un aviso 
....................                            lcd_send_byte(LCD_ORDEN, LCD_CLEAR); 
675E:  CLRF   xAC
6760:  MOVLW  01
6762:  MOVWF  xAD
6764:  CALL   1314
....................                            printf(lcd_putc, "Intervalo limite\nde 4 horas"); 
6768:  CLRF   x95
676A:  MOVF   x95,W
676C:  CALL   0354
6770:  IORLW  00
6772:  BZ    677E
6774:  INCF   x95,F
6776:  MOVWF  xA7
6778:  CALL   13C0
677C:  BRA    676A
....................                            delay_ms(LCD_T_RETARDO); 
677E:  MOVLW  02
6780:  MOVWF  x95
6782:  MOVLW  FA
6784:  MOVWF  xAE
6786:  CALL   12A8
678A:  DECFSZ x95,F
678C:  BRA    6782
....................                            //Se repite la última iteración del bloque 
....................                            contador--; 
678E:  DECF   x87,F
....................                            continue; 
6790:  BRA    69BC
....................  
....................                         } 
....................  
....................                         //El usuario debe ahora introducir el valor del temostato para ese periodo de encendido 
....................                         lcd_send_byte(LCD_ORDEN, LCD_CLEAR); 
6792:  CLRF   xAC
6794:  MOVLW  01
6796:  MOVWF  xAD
6798:  CALL   1314
....................                         printf(lcd_putc, "Termostato %i\n      %cC", contador+1, 223); 
679C:  MOVLW  01
679E:  ADDWF  x87,W
67A0:  MOVWF  x95
67A2:  CLRF   x96
67A4:  MOVF   x96,W
67A6:  CALL   038A
67AA:  INCF   x96,F
67AC:  MOVWF  00
67AE:  MOVWF  xA7
67B0:  CALL   13C0
67B4:  MOVLW  0B
67B6:  SUBWF  x96,W
67B8:  BNZ   67A4
67BA:  MOVFF  95,97
67BE:  MOVLW  1F
67C0:  MOVWF  x98
67C2:  CALL   3536
67C6:  MOVLW  0A
67C8:  MOVWF  xA7
67CA:  CALL   13C0
67CE:  MOVLW  06
67D0:  MOVWF  x97
67D2:  MOVLW  20
67D4:  MOVWF  xA7
67D6:  CALL   13C0
67DA:  DECFSZ x97,F
67DC:  BRA    67D2
67DE:  MOVLW  DF
67E0:  MOVWF  xA7
67E2:  CALL   13C0
67E6:  MOVLW  43
67E8:  MOVWF  xA7
67EA:  CALL   13C0
....................                         lcd_gotoxy(4,2); 
67EE:  MOVLW  04
67F0:  MOVWF  xA8
67F2:  MOVLW  02
67F4:  MOVWF  xA9
67F6:  CALL   139E
....................                         lcd_send_byte(LCD_ORDEN, LCD_CURSOR); //Activamos el cursor 
67FA:  CLRF   xAC
67FC:  MOVLW  0E
67FE:  MOVWF  xAD
6800:  CALL   1314
....................  
....................                         //Recogemos el número introducido por el usuario 
....................                         pr.termostato = buscar_numero(); 
6804:  CALL   3480
6808:  MOVFF  01,8F
....................  
....................                         //Eliminamos el cursor 
....................                         lcd_send_byte(LCD_ORDEN, LCD_NO_CURSOR); 
680C:  CLRF   xAC
680E:  MOVLW  0C
6810:  MOVWF  xAD
6812:  CALL   1314
....................  
....................                         //Retardamos para que el usuario pueda ver el valor que ha introducido 
....................                         delay_ms(LCD_T_RETARDO); 
6816:  MOVLW  02
6818:  MOVWF  x95
681A:  MOVLW  FA
681C:  MOVWF  xAE
681E:  CALL   12A8
6822:  DECFSZ x95,F
6824:  BRA    681A
....................  
....................                         //Si no se cumplen los límites de temperatura especificados para el termostato, no es válido el valor 
....................                         if(pr.termostato>temp_max || pr.termostato<temp_min) 
6826:  MOVF   x8F,W
6828:  SUBLW  20
682A:  BNC   6832
682C:  MOVF   x8F,W
682E:  SUBLW  0F
6830:  BNC   6866
....................                         { 
....................                            //Se muestra un mensaje de error 
....................                            lcd_send_byte(LCD_ORDEN, LCD_CLEAR); 
6832:  CLRF   xAC
6834:  MOVLW  01
6836:  MOVWF  xAD
6838:  CALL   1314
....................                            printf(lcd_putc, "   Valor\n   incorrecto"); 
683C:  CLRF   x95
683E:  MOVF   x95,W
6840:  CALL   0294
6844:  IORLW  00
6846:  BZ    6852
6848:  INCF   x95,F
684A:  MOVWF  xA7
684C:  CALL   13C0
6850:  BRA    683E
....................                            delay_ms(LCD_T_RETARDO); 
6852:  MOVLW  02
6854:  MOVWF  x95
6856:  MOVLW  FA
6858:  MOVWF  xAE
685A:  CALL   12A8
685E:  DECFSZ x95,F
6860:  BRA    6856
....................                            //Se repite la última iteración 
....................                            contador--; 
6862:  DECF   x87,F
....................                            continue; 
6864:  BRA    69BC
....................                         } 
....................  
....................                         //Comprobamos que los intervalos sean correctos respecto a los otros, es decir, 
....................                         //que no haya solapamiento entre los distintos intervalos programados. 
....................                         for(contador2=0; contador2<contador; contador2++) 
6866:  CLRF   x88
6868:  MOVF   x87,W
686A:  SUBWF  x88,W
686C:  BTFSC  FD8.0
686E:  BRA    6998
....................                         { 
....................                            //Tomamos las programaciones almacenadas anteriormente 
....................                            pr2 = programaciones[contador2]; 
6870:  MOVF   x88,W
6872:  MULLW  05
6874:  MOVF   FF3,W
6876:  CLRF   03
6878:  ADDLW  3B
687A:  MOVWF  01
687C:  MOVLW  00
687E:  ADDWFC 03,F
6880:  MOVFF  01,95
6884:  MOVFF  03,96
6888:  CLRF   FEA
688A:  MOVLW  90
688C:  MOVWF  FE9
688E:  MOVFF  03,FE2
6892:  MOVFF  01,FE1
6896:  MOVLW  05
6898:  MOVWF  01
689A:  MOVFF  FE6,FEE
689E:  DECFSZ 01,F
68A0:  BRA    689A
....................  
....................                            //Controlamos todas las posibilidades de solapamiento 
....................                            if( 
....................                               (comprobar_hora(pr2.horas_inicio, pr2.minutos_inicio, pr.horas_fin, pr.minutos_fin) && 
....................                               !comprobar_hora(pr2.horas_inicio, pr2.minutos_inicio, pr.horas_inicio, pr.minutos_inicio)) 
....................  
....................                               ||(comprobar_hora(pr2.horas_fin, pr2.minutos_fin, pr.horas_fin, pr.minutos_fin) && 
....................                                 !comprobar_hora(pr2.horas_fin, pr2.minutos_fin, pr.horas_inicio, pr.minutos_inicio)) 
....................  
....................                               ||(comprobar_hora(pr.horas_inicio, pr.minutos_inicio, pr2.horas_fin, pr2.minutos_fin) && 
....................                                 !comprobar_hora(pr.horas_inicio, pr.minutos_inicio, pr2.horas_inicio, pr2.minutos_inicio)) 
....................  
....................                               ||(comprobar_hora(pr.horas_fin, pr.minutos_fin, pr2.horas_fin, pr2.minutos_fin) && 
....................                                 !comprobar_hora(pr.horas_fin, pr.minutos_fin, pr2.horas_inicio, pr2.minutos_inicio)) 
....................                            ) 
68A2:  MOVFF  90,AB
68A6:  MOVFF  91,AC
68AA:  MOVFF  8D,AD
68AE:  MOVFF  8E,AE
68B2:  CALL   2AEA
68B6:  MOVF   01,F
68B8:  BZ    68D2
68BA:  MOVFF  90,AB
68BE:  MOVFF  91,AC
68C2:  MOVFF  8B,AD
68C6:  MOVFF  8C,AE
68CA:  CALL   2AEA
68CE:  MOVF   01,F
68D0:  BZ    6962
68D2:  MOVFF  92,AB
68D6:  MOVFF  93,AC
68DA:  MOVFF  8D,AD
68DE:  MOVFF  8E,AE
68E2:  CALL   2AEA
68E6:  MOVF   01,F
68E8:  BZ    6902
68EA:  MOVFF  92,AB
68EE:  MOVFF  93,AC
68F2:  MOVFF  8B,AD
68F6:  MOVFF  8C,AE
68FA:  CALL   2AEA
68FE:  MOVF   01,F
6900:  BZ    6962
6902:  MOVFF  8B,AB
6906:  MOVFF  8C,AC
690A:  MOVFF  92,AD
690E:  MOVFF  93,AE
6912:  CALL   2AEA
6916:  MOVF   01,F
6918:  BZ    6932
691A:  MOVFF  8B,AB
691E:  MOVFF  8C,AC
6922:  MOVFF  90,AD
6926:  MOVFF  91,AE
692A:  CALL   2AEA
692E:  MOVF   01,F
6930:  BZ    6962
6932:  MOVFF  8D,AB
6936:  MOVFF  8E,AC
693A:  MOVFF  92,AD
693E:  MOVFF  93,AE
6942:  CALL   2AEA
6946:  MOVF   01,F
6948:  BZ    6994
694A:  MOVFF  8D,AB
694E:  MOVFF  8E,AC
6952:  MOVFF  90,AD
6956:  MOVFF  91,AE
695A:  CALL   2AEA
695E:  MOVF   01,F
6960:  BNZ   6994
....................                            { 
....................                               //Si hay solapamiento, mostramos un mensaje de error y salimos 
....................                               lcd_send_byte(LCD_ORDEN, LCD_CLEAR); 
6962:  CLRF   xAC
6964:  MOVLW  01
6966:  MOVWF  xAD
6968:  CALL   1314
....................                               printf(lcd_putc, "Solapamiento\nde intervalos!"); 
696C:  CLRF   x95
696E:  MOVF   x95,W
6970:  CALL   03B6
6974:  IORLW  00
6976:  BZ    6982
6978:  INCF   x95,F
697A:  MOVWF  xA7
697C:  CALL   13C0
6980:  BRA    696E
....................                               delay_ms(LCD_T_RETARDO*2); 
6982:  MOVLW  04
6984:  MOVWF  x95
6986:  MOVLW  FA
6988:  MOVWF  xAE
698A:  CALL   12A8
698E:  DECFSZ x95,F
6990:  BRA    6986
....................                               goto salir; 
6992:  BRA    6BA8
....................                            } 
....................                         } 
6994:  INCF   x88,F
6996:  BRA    6868
....................  
....................                         //Añadimos esta programación a la lista de programaciones 
....................                         programaciones[contador]=pr; 
6998:  MOVF   x87,W
699A:  MULLW  05
699C:  MOVF   FF3,W
699E:  CLRF   03
69A0:  ADDLW  3B
69A2:  MOVWF  FE9
69A4:  MOVLW  00
69A6:  ADDWFC 03,W
69A8:  MOVWF  FEA
69AA:  CLRF   FE2
69AC:  MOVLW  8B
69AE:  MOVWF  FE1
69B0:  MOVLW  05
69B2:  MOVWF  01
69B4:  MOVFF  FE6,FEE
69B8:  DECFSZ 01,F
69BA:  BRA    69B4
....................                      } 
69BC:  INCF   x87,F
69BE:  BRA    656E
....................  
....................                      //Mostramos un mensaje 
....................                      lcd_send_byte(LCD_ORDEN,LCD_CLEAR); 
69C0:  CLRF   xAC
69C2:  MOVLW  01
69C4:  MOVWF  xAD
69C6:  CALL   1314
....................                      lcd_send_byte(LCD_ORDEN,LCD_NO_CURSOR); 
69CA:  CLRF   xAC
69CC:  MOVLW  0C
69CE:  MOVWF  xAD
69D0:  CALL   1314
....................                      printf(lcd_putc, "  Aplicando\n  cambios..."); 
69D4:  CLRF   x95
69D6:  MOVF   x95,W
69D8:  CALL   0260
69DC:  IORLW  00
69DE:  BZ    69EA
69E0:  INCF   x95,F
69E2:  MOVWF  xA7
69E4:  CALL   13C0
69E8:  BRA    69D6
....................  
....................                      //Habilitamos la alarma 
....................                      PCF8583_write_byte(PCF8583_CTRL_STATUS_REG, 
....................                                  PCF8583_ACTIVAR_ALARMA); 
69EA:  CLRF   xAD
69EC:  MOVLW  04
69EE:  MOVWF  xAE
69F0:  CALL   169C
....................                      //Habilitamos interrupciones 
....................                      //enable_interrupts(GLOBAL); 
....................  
....................                      //Guardamos el número de intervalos configurados 
....................                      num_intervalos = contador; 
69F4:  MOVFF  87,59
....................  
....................                      //Ordenamos las programaciones por orden de hora de inicio 
....................                      ordenar_programaciones(); 
69F8:  GOTO   360E
....................  
....................                      //Seleccionamos la próxima alarma a ejecutar 
....................                      seleccionar_alarma(); 
69FC:  GOTO   3746
....................  
....................                      //Programamos la próxima alarma para que salte el reloj en el momento indicado 
....................                      programar_proxima_alarma(); 
6A00:  CALL   29AA
....................  
....................                      //Indicamos que se trata de una alarma de encendido 
....................                      toca_encender = TRUE; 
6A04:  BSF    1F.4
....................  
....................                      //Guardamos las programaciones introducidas 
....................                      grabar_programaciones(); 
6A06:  GOTO   37C8
....................  
....................                      break; 
....................  
....................  
....................             //Si es 4, entramos en el modo de revisión y obtención de datos históricos 
....................             case '4': 
....................                      key = 'J'; //Carácter falso para permitir la entrada de datos 
6A0A:  MOVLW  4A
6A0C:  MOVWF  38
....................                      //Solicitamos la introducción de una clave 
....................                      lcd_send_byte(LCD_ORDEN, LCD_CLEAR); 
6A0E:  CLRF   xAC
6A10:  MOVLW  01
6A12:  MOVWF  xAD
6A14:  CALL   1314
....................                      lcd_send_byte(LCD_ORDEN, LCD_CURSOR); 
6A18:  CLRF   xAC
6A1A:  MOVLW  0E
6A1C:  MOVWF  xAD
6A1E:  CALL   1314
....................                      printf(lcd_putc, "  CLAVE:\n  "); 
6A22:  CLRF   x95
6A24:  MOVF   x95,W
6A26:  CALL   03EC
6A2A:  IORLW  00
6A2C:  BZ    6A38
6A2E:  INCF   x95,F
6A30:  MOVWF  xA7
6A32:  CALL   13C0
6A36:  BRA    6A24
....................  
....................                      //Habilitamos de nuevo el temporizador para evitar 
....................                      //que el menú esté mucho tiempo activo 
....................                      contador_tiempo = 0; 
6A38:  CLRF   7D
....................                      enable_interrupts(INT_TIMER1); 
6A3A:  BSF    F9D.0
....................  
....................                      //Introducimos primero los dos primero dígitos 
....................                      contador = 0; 
6A3C:  CLRF   x87
....................                      while(contador!=2) 
....................                      { 
6A3E:  MOVF   x87,W
6A40:  SUBLW  02
6A42:  BZ    6A84
....................                         key = get_key(); 
6A44:  CALL   3216
6A48:  MOVFF  01,38
....................                         //Si se trata de un número, lo guardamos y mostramos un asterisco 
....................                         //por tratarse de una clave 
....................                         if(isdigit(key)){ 
6A4C:  MOVF   38,W
6A4E:  SUBLW  2F
6A50:  BC    6A7A
6A52:  MOVF   38,W
6A54:  SUBLW  39
6A56:  BNC   6A7A
....................                            //Reseteamos el contador de espera 
....................                            contador_tiempo = 0; 
6A58:  CLRF   7D
....................                            lcd_putc('*'); 
6A5A:  MOVLW  2A
6A5C:  MOVWF  xA7
6A5E:  CALL   13C0
....................                            keys[contador] = key; 
6A62:  CLRF   03
6A64:  MOVF   x87,W
6A66:  ADDLW  39
6A68:  MOVWF  FE9
6A6A:  MOVLW  00
6A6C:  ADDWFC 03,W
6A6E:  MOVWF  FEA
6A70:  MOVFF  38,FEF
....................                            key = 'J'; 
6A74:  MOVLW  4A
6A76:  MOVWF  38
....................                            contador++; 
6A78:  INCF   x87,F
....................                         } 
....................                         //Si transcurre el tiempo máximo, salimos, anulando el flag 
....................                         if(timer_int){ 
6A7A:  BTFSS  1F.7
6A7C:  BRA    6A82
....................                            timer_int = FALSE; 
6A7E:  BCF    1F.7
....................                            goto salir; 
6A80:  BRA    6BA8
....................                         } 
....................                      } 
6A82:  BRA    6A3E
....................  
....................                      //Convertimos los dígitos introducidos a un valor numérico 
....................                      numero = atoi(keys); 
6A84:  CLRF   xA9
6A86:  MOVLW  39
6A88:  MOVWF  xA8
6A8A:  CALL   1450
6A8E:  CLRF   03
6A90:  MOVFF  01,89
6A94:  MOVFF  03,8A
....................  
....................                      //Repetimos la operación con los dos dígitos menos significativos 
....................                      contador = 0; 
6A98:  CLRF   x87
....................                      while(contador!=2) 
....................                      { 
6A9A:  MOVF   x87,W
6A9C:  SUBLW  02
6A9E:  BZ    6AE0
....................                         key = get_key(); 
6AA0:  CALL   3216
6AA4:  MOVFF  01,38
....................                         if(isdigit(key)){ 
6AA8:  MOVF   38,W
6AAA:  SUBLW  2F
6AAC:  BC    6AD6
6AAE:  MOVF   38,W
6AB0:  SUBLW  39
6AB2:  BNC   6AD6
....................                            //Reseteamos el contador de espera 
....................                            contador_tiempo = 0; 
6AB4:  CLRF   7D
....................                            lcd_putc('*'); 
6AB6:  MOVLW  2A
6AB8:  MOVWF  xA7
6ABA:  CALL   13C0
....................                            keys[contador] = key; 
6ABE:  CLRF   03
6AC0:  MOVF   x87,W
6AC2:  ADDLW  39
6AC4:  MOVWF  FE9
6AC6:  MOVLW  00
6AC8:  ADDWFC 03,W
6ACA:  MOVWF  FEA
6ACC:  MOVFF  38,FEF
....................                            key = 'J'; 
6AD0:  MOVLW  4A
6AD2:  MOVWF  38
....................                            contador++; 
6AD4:  INCF   x87,F
....................                         } 
....................                         //Si transcurre el tiempo máximo, salimos, suprimiendo el flag 
....................                         if(timer_int){ 
6AD6:  BTFSS  1F.7
6AD8:  BRA    6ADE
....................                            timer_int = FALSE; 
6ADA:  BCF    1F.7
....................                            goto salir; 
6ADC:  BRA    6BA8
....................                         } 
....................                      } 
6ADE:  BRA    6A9A
....................  
....................                      //Deshabilitamos el control de la espera 
....................                      disable_interrupts(INT_TIMER1); 
6AE0:  BCF    F9D.0
....................  
....................                      //Construimos la clave a partir de las dos lecturas 
....................                      numero = numero*100 + atoi(keys); 
6AE2:  MOVFF  8A,B3
6AE6:  MOVFF  89,B2
6AEA:  CLRF   xB5
6AEC:  MOVLW  64
6AEE:  MOVWF  xB4
6AF0:  CALL   182C
6AF4:  MOVFF  02,96
6AF8:  MOVFF  01,95
6AFC:  CLRF   xA9
6AFE:  MOVLW  39
6B00:  MOVWF  xA8
6B02:  CALL   1450
6B06:  CLRF   03
6B08:  MOVF   01,W
6B0A:  BTFSC  FE8.7
6B0C:  DECF   03,F
6B0E:  ADDWF  x95,W
6B10:  MOVWF  01
6B12:  MOVF   x96,W
6B14:  ADDWFC 03,F
6B16:  MOVFF  01,89
6B1A:  MOVFF  03,8A
....................  
....................                      //Retardamos un poco para que el usuario pueda ver que ha introducido 4 dígitos 
....................                      delay_ms(LCD_T_RETARDO); 
6B1E:  MOVLW  02
6B20:  MOVWF  x95
6B22:  MOVLW  FA
6B24:  MOVWF  xAE
6B26:  CALL   12A8
6B2A:  DECFSZ x95,F
6B2C:  BRA    6B22
....................  
....................                      if(numero == clave) 
6B2E:  MOVF   x89,W
6B30:  SUBLW  61
6B32:  BNZ   6B6A
6B34:  MOVF   x8A,W
6B36:  SUBLW  09
6B38:  BNZ   6B6A
....................                      { 
....................                         //Si la clave es correcta, entramos en el modo revisión 
....................                         lcd_send_byte(LCD_ORDEN, LCD_CLEAR); 
6B3A:  CLRF   xAC
6B3C:  MOVLW  01
6B3E:  MOVWF  xAD
6B40:  CALL   1314
....................                         lcd_send_byte(LCD_ORDEN, LCD_NO_CURSOR); 
6B44:  CLRF   xAC
6B46:  MOVLW  0C
6B48:  MOVWF  xAD
6B4A:  CALL   1314
....................                         printf(lcd_putc, "  Modo\n  revision"); 
6B4E:  CLRF   x95
6B50:  MOVF   x95,W
6B52:  CALL   0412
6B56:  IORLW  00
6B58:  BZ    6B64
6B5A:  INCF   x95,F
6B5C:  MOVWF  xA7
6B5E:  CALL   13C0
6B62:  BRA    6B50
....................                         //Representamos el contenido de los registros y activamos la interfaz RS-232 
....................                         representar_registros(); 
6B64:  GOTO   3BCE
....................                      }else 
6B68:  BRA    6BA6
....................                      { 
....................                         //Si la clave es incorrecta, lo indicamos y salimos 
....................                         lcd_send_byte(LCD_ORDEN, LCD_CLEAR); 
6B6A:  CLRF   xAC
6B6C:  MOVLW  01
6B6E:  MOVWF  xAD
6B70:  CALL   1314
....................                         lcd_send_byte(LCD_ORDEN, LCD_NO_CURSOR); 
6B74:  CLRF   xAC
6B76:  MOVLW  0C
6B78:  MOVWF  xAD
6B7A:  CALL   1314
....................                         printf(lcd_putc, "  Clave\n  incorrecta"); 
6B7E:  CLRF   x95
6B80:  MOVF   x95,W
6B82:  CALL   043E
6B86:  IORLW  00
6B88:  BZ    6B94
6B8A:  INCF   x95,F
6B8C:  MOVWF  xA7
6B8E:  CALL   13C0
6B92:  BRA    6B80
....................                         delay_ms(LCD_T_RETARDO); 
6B94:  MOVLW  02
6B96:  MOVWF  x95
6B98:  MOVLW  FA
6B9A:  MOVWF  xAE
6B9C:  CALL   12A8
6BA0:  DECFSZ x95,F
6BA2:  BRA    6B98
....................                         goto salir; 
6BA4:  BRA    6BA8
....................                      } 
....................  
....................                      break; 
6BA6:  BRA    6BE4
....................  
....................  
....................             //Si se pulsa NO, salimos del menú de interfaz con el usuario 
....................             case 'N': 
....................                      //Aquí confluyen todas las salidas de esta rutina 
....................                      salir: 
....................                      //Se muestra un mensaje de finalización 
....................                      lcd_send_byte(LCD_ORDEN,LCD_CLEAR); 
6BA8:  CLRF   xAC
6BAA:  MOVLW  01
6BAC:  MOVWF  xAD
6BAE:  CALL   1314
....................                      lcd_send_byte(LCD_ORDEN,LCD_NO_CURSOR); 
6BB2:  CLRF   xAC
6BB4:  MOVLW  0C
6BB6:  MOVWF  xAD
6BB8:  CALL   1314
....................                      printf(lcd_putc, "  Anulando\n  operacion..."); 
6BBC:  CLRF   x95
6BBE:  MOVF   x95,W
6BC0:  CALL   046E
6BC4:  IORLW  00
6BC6:  BZ    6BD2
6BC8:  INCF   x95,F
6BCA:  MOVWF  xA7
6BCC:  CALL   13C0
6BD0:  BRA    6BBE
....................                      delay_ms(LCD_T_RETARDO); 
6BD2:  MOVLW  02
6BD4:  MOVWF  x95
6BD6:  MOVLW  FA
6BD8:  MOVWF  xAE
6BDA:  CALL   12A8
6BDE:  DECFSZ x95,F
6BE0:  BRA    6BD6
....................                      break; 
6BE2:  BRA    6BE4
....................  
....................          } 
....................  
....................          //Volvemos a habilitar las interrupciones 
....................          enable_interrupts(GLOBAL); 
6BE4:  MOVLW  C0
6BE6:  IORWF  FF2,F
....................           
....................  
....................          //Se desactiva el flag de indicación de la interrupción 
....................          led_int = FALSE; 
6BE8:  BCF    1F.5
....................       } 
....................  
....................       //Comenzamos el bloque de comprobación de parámetros y activación de los procesos necesarios. 
....................  
....................       //Comparamos primero la temperatura del agua en la caldera. Esta comprobación se 
....................       //realiza siempre, independientemente de que el sistema esté o no encendido. 
....................       if(C1OUT) 
6BEA:  BTFSS  FB4.6
6BEC:  BRA    6C0C
....................       { 
....................          //Entramos aquí si la temperatura de la caldera es menor que la necesaria 
....................          if(temperatura_caldera_superada) 
6BEE:  BTFSS  1F.0
6BF0:  BRA    6C02
....................          { 
....................             //Si la temperatura de la caldera estaba superada la última vez, tenemos en cuenta cierta histéresis 
....................             //de los valores. 
....................             if(!comp_caldera()) 
6BF2:  GOTO   5792
6BF6:  MOVF   01,F
6BF8:  BNZ   6C00
....................             { 
....................                //Si la temperatura de la caldera es menor que la necesaria, encendemos la caldera. 
....................                temperatura_caldera_superada = FALSE; 
6BFA:  BCF    1F.0
....................                encender_caldera(); 
6BFC:  CALL   5958
....................             } 
....................  
....................          } 
....................          else if(!caldera_encendida) 
6C00:  BRA    6C0A
6C02:  BTFSC  F83.5
6C04:  BRA    6C0A
....................          { 
....................             //Si no estaba encendida, la encendemos 
....................             encender_caldera(); 
6C06:  CALL   5958
....................          } 
....................       } 
....................       else 
6C0A:  BRA    6C1A
....................       { 
....................          //Si la temperatura de la caldera es mayor que la necesaria, apagamos la caldera si está encendida 
....................          //y activamos el flag correspondiente 
....................          if(!temperatura_caldera_superada) 
6C0C:  BTFSC  1F.0
6C0E:  BRA    6C12
....................             temperatura_caldera_superada = TRUE; 
6C10:  BSF    1F.0
....................          if(caldera_encendida) 
6C12:  BTFSS  F83.5
6C14:  BRA    6C1A
....................             apagar_caldera(); 
6C16:  GOTO   5972
....................       } 
....................  
....................       //Leemos el código de estado de los sensores 
....................       valor = comprobar_temperatura(); 
6C1A:  GOTO   5B10
6C1E:  MOVFF  01,84
....................  
....................       //Comprobamos que el sistema no lleve encendido más de 4 horas, ya que en ese caso hay riesgo de avería 
....................       //(en realidad esta limitación deriva de un problema propio de representación en memoria). 
....................       //Ya leimos el tiempo en comprobar_temperatura(), así que no necesitamos leerlo de nuevo. 
....................       if(sistema_encendido && diferencia_tiempo(hora_encendido, minutos_encendido, tiempo.hours, tiempo.minutes)>240) 
6C22:  BTFSS  F83.4
6C24:  BRA    6CCE
6C26:  MOVFF  62,A1
6C2A:  MOVFF  63,A2
6C2E:  MOVFF  5D,A3
6C32:  MOVFF  5C,A4
6C36:  CALL   2B1E
6C3A:  MOVFF  02,96
6C3E:  MOVFF  01,95
6C42:  MOVF   x96,F
6C44:  BNZ   6C4C
6C46:  MOVF   x95,W
6C48:  SUBLW  F0
6C4A:  BC    6CCE
....................       { 
....................          //Si la diferencia de tiempo es mayor que 4 horas, lo indicamos y apagamos los motores y el sistema 
....................          lcd_send_byte(LCD_ORDEN,LCD_CLEAR); 
6C4C:  CLRF   xAC
6C4E:  MOVLW  01
6C50:  MOVWF  xAD
6C52:  CALL   1314
....................          printf(lcd_putc, "Demasiado tiempo\nencendido!"); 
6C56:  CLRF   x95
6C58:  MOVF   x95,W
6C5A:  CALL   04A2
6C5E:  IORLW  00
6C60:  BZ    6C6C
6C62:  INCF   x95,F
6C64:  MOVWF  xA7
6C66:  CALL   13C0
6C6A:  BRA    6C58
....................          delay_ms(2*LCD_T_RETARDO); 
6C6C:  MOVLW  04
6C6E:  MOVWF  x95
6C70:  MOVLW  FA
6C72:  MOVWF  xAE
6C74:  CALL   12A8
6C78:  DECFSZ x95,F
6C7A:  BRA    6C70
....................          lcd_send_byte(LCD_ORDEN,LCD_CLEAR); 
6C7C:  CLRF   xAC
6C7E:  MOVLW  01
6C80:  MOVWF  xAD
6C82:  CALL   1314
....................          printf(lcd_putc, "  Apagando\n  sistema..."); 
6C86:  CLRF   x95
6C88:  MOVF   x95,W
6C8A:  CALL   0196
6C8E:  IORLW  00
6C90:  BZ    6C9C
6C92:  INCF   x95,F
6C94:  MOVWF  xA7
6C96:  CALL   13C0
6C9A:  BRA    6C88
....................          apagar_sistema(); 
6C9C:  CALL   2DB6
....................  
....................          motor1 = FALSE; 
6CA0:  BCF    F83.6
....................          motor2 = FALSE; 
6CA2:  BCF    F83.7
....................  
....................          //Si estaba encendido por alguna alarma, recuperamos el termostato anterior. 
....................          if(encendido_por_alarma) 
6CA4:  BTFSS  1F.3
6CA6:  BRA    6CCA
....................          { 
....................             termostato1 = termostato2 = termostato_provisional; 
6CA8:  MOVFF  2B,27
6CAC:  MOVFF  2A,26
6CB0:  MOVFF  29,25
6CB4:  MOVFF  28,24
6CB8:  MOVFF  27,23
6CBC:  MOVFF  26,22
6CC0:  MOVFF  25,21
6CC4:  MOVFF  24,20
....................             encendido_por_alarma = FALSE; 
6CC8:  BCF    1F.3
....................          } 
....................  
....................          goto inicio; 
6CCA:  GOTO   5ED4
....................  
....................       } 
....................  
....................       //Comprobamos ahora la temperatura de la vivienda. Esto se realiza sólo si el sistema está encendido 
....................       if(valor && sistema_encendido && temperatura_caldera_superada) 
6CCE:  MOVF   x84,F
6CD0:  BZ    6CF8
6CD2:  BTFSS  F83.4
6CD4:  BRA    6CF8
6CD6:  BTFSS  1F.0
6CD8:  BRA    6CF8
....................       { 
....................          //Si la temperatura es menor que la necesaria, el sistema está encendido y la temperatura del 
....................          //agua en la caldera es la adecuada, encendemos el motor de circulación del agua necesario 
....................          if(valor==1) 
6CDA:  DECFSZ x84,W
6CDC:  BRA    6CE2
....................          { 
....................             motor1 = TRUE; 
6CDE:  BSF    F83.6
....................             motor2 = FALSE; 
6CE0:  BCF    F83.7
....................          } 
....................          if(valor==2) 
6CE2:  MOVF   x84,W
6CE4:  SUBLW  02
6CE6:  BNZ   6CEC
....................          { 
....................             motor1 = FALSE; 
6CE8:  BCF    F83.6
....................             motor2 = TRUE; 
6CEA:  BSF    F83.7
....................          } 
....................          if(valor==3) 
6CEC:  MOVF   x84,W
6CEE:  SUBLW  03
6CF0:  BNZ   6CF6
....................          { 
....................             motor1 = TRUE; 
6CF2:  BSF    F83.6
....................             motor2 = TRUE; 
6CF4:  BSF    F83.7
....................          } 
....................  
....................       } 
....................       else 
6CF6:  BRA    6CFC
....................       { 
....................         //Si no se cumplen las condiciones, apagamos los motores si están encendidos 
....................         motor1 = FALSE; 
6CF8:  BCF    F83.6
....................         motor2 = FALSE; 
6CFA:  BCF    F83.7
....................       } 
....................  
....................       //Activamos el perro guardián y las interrupciones 
....................       setup_wdt(WDT_ON); 
6CFC:  BSF    FD1.0
....................       enable_interrupts(GLOBAL); 
6CFE:  MOVLW  C0
6D00:  IORWF  FF2,F
....................       //Ponemos a "dormir" al microcontrolador para que el gasto de energía sea menor 
....................       //Esto lo hacemos sólo si no se han levantado los flags de interrupción en estos segundos, 
....................       //ya que esto provocaría que se aplazase la gestión de la interrupción hasta que saltase el 
....................       //perro guardián. 
....................       if(!alarma_int && !led_int) 
6D02:  BTFSC  1F.6
6D04:  BRA    6D0C
6D06:  BTFSC  1F.5
6D08:  BRA    6D0C
....................          sleep(); 
6D0A:  SLEEP 
....................  
....................    } 
6D0C:  GOTO   5ED4
....................  
.................... } 
....................  
.................... ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 
.................... //**************************************************************************** 
.................... //    Descripción de los métodos utilizados ordenados por orden alfabético 
.................... //**************************************************************************** 
.................... //Puede verse una explicación general de su función al principio del programa 
....................  
.................... void apagar_caldera() 
.................... { 
6D10:  SLEEP 
....................    int hora, minutos, segundos; //Variables para el tiempo 
....................  
....................    //Leemos el tiempo 
....................    PCF8583_read_datetime(&tiempo); 
*
5972:  CLRF   xA2
5974:  MOVLW  5B
5976:  MOVWF  xA1
5978:  CALL   2764
....................    //Habilitamos interrupciones 
....................    //enable_interrupts(GLOBAL); 
....................  
....................    //Copiamos en las variables 
....................    hora = tiempo.hours; 
597C:  MOVFF  5D,95
....................    minutos = tiempo.minutes; 
5980:  MOVFF  5C,96
....................    segundos = tiempo.seconds; 
5984:  MOVFF  5B,97
....................  
....................    //Sumamos al tiempo total de encendido de la caldera el tiempo que ha estado encendida esta vez 
....................    t_total_caldera = t_total_caldera + diferencia_tiempo_sec(hora_caldera, minutos_caldera, segundos_caldera, hora, minutos, segundos); 
5988:  MOVFF  64,A1
598C:  MOVFF  65,A2
5990:  MOVFF  66,A3
5994:  MOVFF  95,A4
5998:  MOVFF  96,A5
599C:  MOVFF  97,A6
59A0:  CALL   2C12
59A4:  MOVF   01,W
59A6:  ADDWF  67,F
59A8:  MOVF   02,W
59AA:  ADDWFC 68,F
....................  
....................    //Apagamos la caldera 
....................    caldera_encendida = FALSE; 
59AC:  BCF    F83.5
.................... } 
59AE:  GOTO   6C1A (RETURN)
....................  
.................... //----------------------------------------------------------------------------------------------------------------------------------------- 
....................  
.................... void apagar_sistema() 
.................... { 
....................    long minutos_trans;  //Minutos transcurridos desde el encendido del sistema 
....................    int t_entera, t_decimal; //Temperatura del hogar en ese momento (parte entera y decimal) 
....................    int data[8];  //Vector para almacenar los datos a guardar 
....................  
....................    //Apagamos el sistema 
....................    sistema_encendido = FALSE; 
*
2DB6:  BCF    F83.4
....................  
....................    //Guardamos todos los datos en memoria. Esto llevará tiempo, así que apagamos también los motores 
....................    //para no esperar a la rutina de comprobación de la temperatura 
....................    motor1 = FALSE; 
2DB8:  BCF    F83.6
....................    motor2 = FALSE; 
2DBA:  BCF    F83.7
....................  
....................    //Si llegamos al límite de la memoria, se resetea el indicador 
....................    if((eeprom_registros + num_registros*2*8)>=0x1000) 
2DBC:  BCF    FD8.0
2DBE:  RLCF   69,W
2DC0:  MOVWF  xA1
2DC2:  RLCF   6A,W
2DC4:  MOVWF  xA2
2DC6:  RLCF   xA1,W
2DC8:  MOVWF  02
2DCA:  RLCF   xA2,W
2DCC:  MOVWF  03
2DCE:  RLCF   02,F
2DD0:  RLCF   03,F
2DD2:  RLCF   02,F
2DD4:  RLCF   03,F
2DD6:  MOVLW  F8
2DD8:  ANDWF  02,F
2DDA:  MOVF   02,W
2DDC:  ADDLW  50
2DDE:  MOVWF  xA3
2DE0:  MOVLW  00
2DE2:  ADDWFC 03,W
2DE4:  MOVWF  xA4
2DE6:  SUBLW  0F
2DE8:  BC    2DEE
....................       num_registros = 0; 
2DEA:  CLRF   6A
2DEC:  CLRF   69
....................  
....................    //Leemos el tiempo actual 
....................    PCF8583_read_datetime(&tiempo); 
2DEE:  CLRF   xA2
2DF0:  MOVLW  5B
2DF2:  MOVWF  xA1
2DF4:  RCALL  2764
....................    //Habilitamos interrupciones (se desactivan en el método anterior) 
....................    //enable_interrupts(GLOBAL); 
....................  
....................    //Almacenamos en el vector los valores del tiempo 
....................    data[0] = tiempo.day;                  //Día de desconexión 
2DF6:  MOVFF  5E,99
....................    data[1] = tiempo.month;                //Mes de desconexión 
2DFA:  MOVFF  5F,9A
....................    data[2] = tiempo.hours;                //Hora de desconexión 
2DFE:  MOVFF  5D,9B
....................    data[3] = tiempo.minutes;              //Minutos de desconexión 
2E02:  MOVFF  5C,9C
....................  
....................    //Leemos la temperatura de la zona 1 en ese momento 
....................    temperatura1 = ds1820_read(dir1); 
2E06:  CLRF   xA2
2E08:  MOVLW  6D
2E0A:  MOVWF  xA1
2E0C:  CALL   21B8
2E10:  MOVFF  03,2F
2E14:  MOVFF  02,2E
2E18:  MOVFF  01,2D
2E1C:  MOVFF  00,2C
....................  
....................    //Descomponemos la temperatura en su parte entera y parte decimal para almacenarla 
....................    t_entera = (int)temperatura1; 
2E20:  MOVFF  2F,A8
2E24:  MOVFF  2E,A7
2E28:  MOVFF  2D,A6
2E2C:  MOVFF  2C,A5
2E30:  CALL   17F2
2E34:  MOVFF  01,97
....................    t_decimal = (int)((temperatura1-t_entera)*100); 
2E38:  MOVLB  2
2E3A:  CLRF   xB0
2E3C:  MOVFF  97,2AF
2E40:  MOVLB  0
2E42:  RCALL  26A2
2E44:  BSF    FD8.1
2E46:  MOVFF  2F,2AC
2E4A:  MOVFF  2E,2AB
2E4E:  MOVFF  2D,2AA
2E52:  MOVFF  2C,2A9
2E56:  MOVFF  03,2B0
2E5A:  MOVFF  02,2AF
2E5E:  MOVFF  01,2AE
2E62:  MOVFF  00,2AD
2E66:  CALL   2428
2E6A:  MOVFF  00,A1
2E6E:  MOVFF  01,A2
2E72:  MOVFF  02,A3
2E76:  MOVFF  03,A4
2E7A:  MOVFF  03,2C8
2E7E:  MOVFF  02,2C7
2E82:  MOVFF  01,2C6
2E86:  MOVFF  00,2C5
2E8A:  MOVLB  2
2E8C:  CLRF   xCC
2E8E:  CLRF   xCB
2E90:  MOVLW  48
2E92:  MOVWF  xCA
2E94:  MOVLW  85
2E96:  MOVWF  xC9
2E98:  MOVLB  0
2E9A:  RCALL  29F2
2E9C:  MOVFF  03,A8
2EA0:  MOVFF  02,A7
2EA4:  MOVFF  01,A6
2EA8:  MOVFF  00,A5
2EAC:  CALL   17F2
2EB0:  MOVFF  01,98
....................  
....................    //Almacenamos los valores 
....................    data[4] = t_entera;                    //Valor entero de última temperatura medida en la zona 1 
2EB4:  MOVFF  97,9D
....................    data[5] = t_decimal;                   //Valor decimal de última temperatura medida en la zona 1 
2EB8:  MOVFF  98,9E
....................  
....................    //Repetimos el proceso con la temperatura de la zona 2 
....................    temperatura2 = ds1820_read(dir2); 
2EBC:  CLRF   xA2
2EBE:  MOVLW  75
2EC0:  MOVWF  xA1
2EC2:  CALL   21B8
2EC6:  MOVFF  03,33
2ECA:  MOVFF  02,32
2ECE:  MOVFF  01,31
2ED2:  MOVFF  00,30
....................    t_entera = (int)temperatura2; 
2ED6:  MOVFF  33,A8
2EDA:  MOVFF  32,A7
2EDE:  MOVFF  31,A6
2EE2:  MOVFF  30,A5
2EE6:  CALL   17F2
2EEA:  MOVFF  01,97
....................    t_decimal = (int)((temperatura2-t_entera)*100); 
2EEE:  MOVLB  2
2EF0:  CLRF   xB0
2EF2:  MOVFF  97,2AF
2EF6:  MOVLB  0
2EF8:  CALL   26A2
2EFC:  BSF    FD8.1
2EFE:  MOVFF  33,2AC
2F02:  MOVFF  32,2AB
2F06:  MOVFF  31,2AA
2F0A:  MOVFF  30,2A9
2F0E:  MOVFF  03,2B0
2F12:  MOVFF  02,2AF
2F16:  MOVFF  01,2AE
2F1A:  MOVFF  00,2AD
2F1E:  CALL   2428
2F22:  MOVFF  00,A1
2F26:  MOVFF  01,A2
2F2A:  MOVFF  02,A3
2F2E:  MOVFF  03,A4
2F32:  MOVFF  03,2C8
2F36:  MOVFF  02,2C7
2F3A:  MOVFF  01,2C6
2F3E:  MOVFF  00,2C5
2F42:  MOVLB  2
2F44:  CLRF   xCC
2F46:  CLRF   xCB
2F48:  MOVLW  48
2F4A:  MOVWF  xCA
2F4C:  MOVLW  85
2F4E:  MOVWF  xC9
2F50:  MOVLB  0
2F52:  RCALL  29F2
2F54:  MOVFF  03,A8
2F58:  MOVFF  02,A7
2F5C:  MOVFF  01,A6
2F60:  MOVFF  00,A5
2F64:  CALL   17F2
2F68:  MOVFF  01,98
....................  
....................    //Almacenamos 
....................    data[6] = t_entera;                    //Valor entero de última temperatura medida en la zona 2 
2F6C:  MOVFF  97,9F
....................    data[7] = t_decimal;                   //Valor decimal de última temperatura medida en la zona 2 
2F70:  MOVFF  98,A0
....................  
....................    //Grabamos los datos en memoria 
....................    graba_ee((unsigned long)eeprom_registros + num_registros*(unsigned long)2*(unsigned long)8, 8, data); 
2F74:  BCF    FD8.0
2F76:  RLCF   69,W
2F78:  MOVWF  xA1
2F7A:  RLCF   6A,W
2F7C:  MOVWF  xA2
2F7E:  RLCF   xA1,W
2F80:  MOVWF  02
2F82:  RLCF   xA2,W
2F84:  MOVWF  03
2F86:  RLCF   02,F
2F88:  RLCF   03,F
2F8A:  RLCF   02,F
2F8C:  RLCF   03,F
2F8E:  MOVLW  F8
2F90:  ANDWF  02,F
2F92:  MOVF   02,W
2F94:  ADDLW  50
2F96:  MOVWF  xA3
2F98:  MOVLW  00
2F9A:  ADDWFC 03,W
2F9C:  MOVWF  xA4
2F9E:  MOVWF  xA8
2FA0:  MOVFF  A3,A7
2FA4:  MOVLW  08
2FA6:  MOVWF  xA9
2FA8:  CLRF   xAB
2FAA:  MOVLW  99
2FAC:  MOVWF  xAA
2FAE:  CALL   184A
....................    delay_ms(LCD_T_RETARDO); 
2FB2:  MOVLW  02
2FB4:  MOVWF  xA1
2FB6:  MOVLW  FA
2FB8:  MOVWF  xAE
2FBA:  CALL   12A8
2FBE:  DECFSZ xA1,F
2FC0:  BRA    2FB6
....................  
....................    //Calculamos el año en el que nos encontramos 
....................    if(anno_actual_0_to_3 != tiempo.year) 
2FC2:  MOVF   60,W
2FC4:  SUBWF  6C,W
2FC6:  BZ    2FE8
....................    { 
....................       //Si el año que teníamos almacenado no es igual que el que marca el reloj, 
....................       //debemos de actualizar las variables correspondientes. 
....................       anno_actual++; 
2FC8:  INCF   6B,F
....................       anno_actual_0_to_3++; 
2FCA:  INCF   6C,F
....................  
....................       //Guardamos los valores en el vector data 
....................       data[0] = anno_actual; 
2FCC:  MOVFF  6B,99
....................       data[1] = anno_actual_0_to_3; 
2FD0:  MOVFF  6C,9A
....................  
....................       //Guardamos los valores en memoria 
....................       graba_ee(eeprom_anno_actual, 2, data); 
2FD4:  CLRF   xA8
2FD6:  MOVLW  14
2FD8:  MOVWF  xA7
2FDA:  MOVLW  02
2FDC:  MOVWF  xA9
2FDE:  CLRF   xAB
2FE0:  MOVLW  99
2FE2:  MOVWF  xAA
2FE4:  CALL   184A
....................    } 
....................  
....................    //Guardamos el año en el que nos encontramos 
....................    data[0] = anno_actual; 
2FE8:  MOVFF  6B,99
....................  
....................    //Calculamos los minutos transcurridos desde el encendido como una diferencia de tiempos 
....................    minutos_trans = diferencia_tiempo(hora_encendido, minutos_encendido, tiempo.hours, tiempo.minutes); 
2FEC:  MOVFF  62,A1
2FF0:  MOVFF  63,A2
2FF4:  MOVFF  5D,A3
2FF8:  MOVFF  5C,A4
2FFC:  RCALL  2B1E
2FFE:  MOVFF  02,96
3002:  MOVFF  01,95
....................  
....................    //Si la caldera estaba encendida, sumamos el último intervalo de encendido al tiempo total 
....................    if(caldera_encendida) 
3006:  BTFSS  F83.5
3008:  BRA    302C
....................       t_total_caldera = t_total_caldera + diferencia_tiempo_sec(hora_caldera, minutos_caldera, segundos_caldera, tiempo.hours, tiempo.minutes, tiempo.seconds); 
300A:  MOVFF  64,A1
300E:  MOVFF  65,A2
3012:  MOVFF  66,A3
3016:  MOVFF  5D,A4
301A:  MOVFF  5C,A5
301E:  MOVFF  5B,A6
3022:  RCALL  2C12
3024:  MOVF   01,W
3026:  ADDWF  67,F
3028:  MOVF   02,W
302A:  ADDWFC 68,F
....................  
....................    //Guardamos los dos tiempos calculados 
....................    data[1] = (unsigned int)minutos_trans;          //Minutos transcurridos desde el encendido 
302C:  MOVFF  95,9A
....................    data[2] = (unsigned int)(t_total_caldera/60);   //Tiempo total que ha estado encendida la caldera 
3030:  MOVFF  68,A2
3034:  MOVFF  67,A1
3038:  CLRF   xA4
303A:  MOVLW  3C
303C:  MOVWF  xA3
303E:  BRA    2D70
3040:  MOVFF  01,9B
....................                                                    //en este intervalo (en minutos) 
....................  
....................    //Guardamos también el valor del termostato teniendo en cuenta la histéresis 
....................    if(temp_habitacion_superada1) 
3044:  BTFSS  1F.1
3046:  BRA    3088
....................       data[3]=(int)(termostato1+histeresis_vivienda); 
3048:  BCF    FD8.1
304A:  MOVFF  23,2AC
304E:  MOVFF  22,2AB
3052:  MOVFF  21,2AA
3056:  MOVFF  20,2A9
305A:  MOVFF  37,2B0
305E:  MOVFF  36,2AF
3062:  MOVFF  35,2AE
3066:  MOVFF  34,2AD
306A:  CALL   2428
306E:  MOVFF  03,A8
3072:  MOVFF  02,A7
3076:  MOVFF  01,A6
307A:  MOVFF  00,A5
307E:  CALL   17F2
3082:  MOVFF  01,9C
....................    else 
3086:  BRA    30A0
....................       data[3]=(int)termostato1; 
3088:  MOVFF  23,A8
308C:  MOVFF  22,A7
3090:  MOVFF  21,A6
3094:  MOVFF  20,A5
3098:  CALL   17F2
309C:  MOVFF  01,9C
....................  
....................    //Grabamos esta segunda tanda de datos 
....................    graba_ee((unsigned long)eeprom_registros + num_registros*2*8 + 8, 4, data); 
30A0:  BCF    FD8.0
30A2:  RLCF   69,W
30A4:  MOVWF  xA1
30A6:  RLCF   6A,W
30A8:  MOVWF  xA2
30AA:  RLCF   xA1,W
30AC:  MOVWF  02
30AE:  RLCF   xA2,W
30B0:  MOVWF  03
30B2:  RLCF   02,F
30B4:  RLCF   03,F
30B6:  RLCF   02,F
30B8:  RLCF   03,F
30BA:  MOVLW  F8
30BC:  ANDWF  02,F
30BE:  MOVF   02,W
30C0:  ADDLW  50
30C2:  MOVWF  xA3
30C4:  MOVLW  00
30C6:  ADDWFC 03,W
30C8:  MOVWF  xA4
30CA:  MOVLW  08
30CC:  ADDWF  xA3,W
30CE:  MOVWF  xA5
30D0:  MOVLW  00
30D2:  ADDWFC xA4,W
30D4:  MOVWF  xA6
30D6:  MOVWF  xA8
30D8:  MOVFF  A5,A7
30DC:  MOVLW  04
30DE:  MOVWF  xA9
30E0:  CLRF   xAB
30E2:  MOVLW  99
30E4:  MOVWF  xAA
30E6:  CALL   184A
....................  
....................    //Aumentamos en uno el número de registros 
....................    num_registros++; 
30EA:  INCF   69,F
30EC:  BTFSC  FD8.2
30EE:  INCF   6A,F
....................  
....................    //Guardamos el número de registros en memoria (descomponiendo antes en dos int) 
....................    data[0] = (int)(num_registros/256); 
30F0:  MOVF   6A,W
30F2:  MOVWF  x99
....................    data[1] = (int)(num_registros - data[0]*256); 
30F4:  CLRF   xB3
30F6:  MOVFF  99,B2
30FA:  MOVLW  01
30FC:  MOVWF  xB5
30FE:  CLRF   xB4
3100:  CALL   182C
3104:  MOVF   01,W
3106:  SUBWF  69,W
3108:  MOVWF  00
310A:  MOVF   02,W
310C:  SUBWFB 6A,W
310E:  MOVFF  00,9A
....................  
....................    graba_ee(eeprom_num_registros, 2, data); 
3112:  CLRF   xA8
3114:  MOVLW  12
3116:  MOVWF  xA7
3118:  MOVLW  02
311A:  MOVWF  xA9
311C:  CLRF   xAB
311E:  MOVLW  99
3120:  MOVWF  xAA
3122:  CALL   184A
.................... } 
3126:  RETLW  00
....................  
.................... //----------------------------------------------------------------------------------------------------------------------------------------- 
....................  
.................... int buscar_numero(){ 
....................    //Variables auxiliares 
....................    int contador = 0; 
*
3480:  CLRF   x95
....................    int numero; 
....................  
....................    //Carácter falso para evitar confusiones 
....................    key = 'J'; 
3482:  MOVLW  4A
3484:  MOVWF  38
....................  
....................    //Habilitamos el temporizador para evitar que el usuario mantenga 
....................    //mucho tiempo el menú activo 
....................    contador_tiempo = 0; 
3486:  CLRF   7D
....................    enable_interrupts(INT_TIMER1); 
3488:  BSF    F9D.0
....................  
....................    //Se continua la búsqueda hasta que no se pulse SI o NO o hasta 
....................    //que no se introduzca un número de 2 cifras. 
....................    while(key != 'N' && key!='S' && contador!=2) 
....................    { 
348A:  MOVF   38,W
348C:  SUBLW  4E
348E:  BZ    34DC
3490:  MOVF   38,W
3492:  SUBLW  53
3494:  BZ    34DC
3496:  MOVF   x95,W
3498:  SUBLW  02
349A:  BZ    34DC
....................       key = get_key(); 
349C:  RCALL  3216
349E:  MOVFF  01,38
....................       //Si la tecla corresponde a un dígito, la imprimimos por pantalla 
....................       //y pasamos a la siguiente 
....................       if(isdigit(key)){ 
34A2:  MOVF   38,W
34A4:  SUBLW  2F
34A6:  BC    34D0
34A8:  MOVF   38,W
34AA:  SUBLW  39
34AC:  BNC   34D0
....................          //Reseteamos el contador de tiempo 
....................          contador_tiempo = 0; 
34AE:  CLRF   7D
....................          lcd_putc(key); 
34B0:  MOVFF  38,A7
34B4:  CALL   13C0
....................          keys[contador] = key; 
34B8:  CLRF   03
34BA:  MOVF   x95,W
34BC:  ADDLW  39
34BE:  MOVWF  FE9
34C0:  MOVLW  00
34C2:  ADDWFC 03,W
34C4:  MOVWF  FEA
34C6:  MOVFF  38,FEF
....................          key = 'J'; 
34CA:  MOVLW  4A
34CC:  MOVWF  38
....................          contador++; 
34CE:  INCF   x95,F
....................       } 
....................       //Si salta el tiempo previsto, devuelve el valor de anulación de la operación 
....................       if(timer_int){ 
34D0:  BTFSS  1F.7
34D2:  BRA    34DA
....................          key = 'N'; 
34D4:  MOVLW  4E
34D6:  MOVWF  38
....................          timer_int = FALSE; //Desactivamos el flag 
34D8:  BCF    1F.7
....................       } 
....................    } 
34DA:  BRA    348A
....................  
....................    //Volvemos a deshabilitar la interrupción del timer 
....................    disable_interrupts(INT_TIMER1); 
34DC:  BCF    F9D.0
....................  
....................    //Si la tecla es NO, devolvemos el código correspondiente 
....................    if(key == 'N') 
34DE:  MOVF   38,W
34E0:  SUBLW  4E
34E2:  BNZ   34EA
....................       return NO; 
34E4:  MOVLW  64
34E6:  MOVWF  01
34E8:  BRA    3508
....................  
....................    //Procedemos de la misma manera si es SÍ 
....................    if(key == 'S') 
34EA:  MOVF   38,W
34EC:  SUBLW  53
34EE:  BNZ   34F6
....................       return SI; 
34F0:  MOVLW  65
34F2:  MOVWF  01
34F4:  BRA    3508
....................  
....................    //Transformamos los caracteres a entero 
....................    numero = atoi(keys); 
34F6:  CLRF   xA9
34F8:  MOVLW  39
34FA:  MOVWF  xA8
34FC:  CALL   1450
3500:  MOVFF  01,96
....................  
....................    //Devolvemos el resultado 
....................    return numero; 
3504:  MOVFF  96,01
.................... } 
3508:  RETLW  00
....................  
.................... //----------------------------------------------------------------------------------------------------------------------------------------- 
....................  
.................... int buscar_numero_rs232(){ 
....................    char c[3]; //Cadena que contendrá los números en caracteres 
....................  
....................    //Iniciamos los caracteres a valores nulos que no se correspondan con números 
....................    //Además, esto nos servirá para que c[2] marque el fin de la cadena a la hora de aplicar 
....................    //el método atoi(). 
....................    c[0]=c[1]=c[2]='\0'; 
*
15EA:  CLRF   xA7
15EC:  MOVFF  A7,A6
15F0:  MOVFF  A6,A5
....................  
....................    //Leemos la primera cifra del número 
....................    while(!isdigit(c[0]) && c[0]!='\b') 
....................       c[0]=getch(); 
15F4:  MOVF   xA5,W
15F6:  SUBLW  2F
15F8:  BC    1600
15FA:  MOVF   xA5,W
15FC:  SUBLW  39
15FE:  BC    1610
1600:  MOVF   xA5,W
1602:  SUBLW  08
1604:  BZ    1610
1606:  BTFSS  F9E.5
1608:  BRA    1606
160A:  MOVFF  FAE,A5
160E:  BRA    15F4
....................    //Si se trata de un "backspace", devolvemos un mensaje de anulación de operación 
....................    if(c[0]=='\b') 
1610:  MOVF   xA5,W
1612:  SUBLW  08
1614:  BNZ   161C
....................       return NO; 
1616:  MOVLW  64
1618:  MOVWF  01
161A:  BRA    165E
....................    //Imprimimos la primera cifra 
....................    printf("%c", c[0]); 
161C:  MOVF   xA5,W
161E:  BTFSS  F9E.4
1620:  BRA    161E
1622:  MOVWF  FAD
....................  
....................    //Leemos la segunda cifra del número, procediendo de la misma manera 
....................    while(!isdigit(c[1]) && c[1]!='\b') 
....................       c[1]=getch(); 
1624:  MOVF   xA6,W
1626:  SUBLW  2F
1628:  BC    1630
162A:  MOVF   xA6,W
162C:  SUBLW  39
162E:  BC    1640
1630:  MOVF   xA6,W
1632:  SUBLW  08
1634:  BZ    1640
1636:  BTFSS  F9E.5
1638:  BRA    1636
163A:  MOVFF  FAE,A6
163E:  BRA    1624
....................    if(c[1]=='\b') 
1640:  MOVF   xA6,W
1642:  SUBLW  08
1644:  BNZ   164C
....................       return NO; 
1646:  MOVLW  64
1648:  MOVWF  01
164A:  BRA    165E
....................    printf("%c", c[1]); 
164C:  MOVF   xA6,W
164E:  BTFSS  F9E.4
1650:  BRA    164E
1652:  MOVWF  FAD
....................  
....................    //Transformamos a entero la cadena y la devolvemos 
....................    return atoi(c); 
1654:  CLRF   xA9
1656:  MOVLW  A5
1658:  MOVWF  xA8
165A:  RCALL  1450
165C:  MOVF   01,W
.................... } 
165E:  RETLW  00
....................  
.................... //----------------------------------------------------------------------------------------------------------------------------------------- 
....................  
.................... int comp_caldera() 
.................... { 
....................    //Suponemos una variación de la temperatura del agua en la caldera de t_max_calderaºC 
....................    //a t_min_calderaºC, con una precisión que depende del potenciómetro. 
....................  
....................    //Variables para registrar el termostato y la temperatura de la caldera 
....................    float termo, temp; 
....................  
....................    //Establecemos como entrada analógica a analizar la del termostato 
....................    set_adc_channel(termostato_caldera); 
*
5792:  MOVLW  0C
5794:  MOVWF  01
5796:  MOVF   FC2,W
5798:  ANDLW  C3
579A:  IORWF  01,W
579C:  MOVWF  FC2
....................    delay_us(10);  //Retraso para posibilitar la lectura 
579E:  CLRWDT
57A0:  MOVLW  06
57A2:  MOVWF  00
57A4:  DECFSZ 00,F
57A6:  BRA    57A4
....................    //Transformamos el valor analógico leído en la escala utilizada por el termostato 
....................    termo = t_min_caldera + ((t_max_caldera-t_min_caldera)*(float)read_adc())/AD_num_valores; 
57A8:  BSF    FC2.1
57AA:  BTFSC  FC2.1
57AC:  BRA    57AA
57AE:  MOVF   FC4,W
57B0:  MOVLB  2
57B2:  CLRF   xB0
57B4:  MOVWF  xAF
57B6:  MOVLB  0
57B8:  CALL   26A2
57BC:  MOVLB  2
57BE:  CLRF   xC8
57C0:  CLRF   xC7
57C2:  MOVLW  48
57C4:  MOVWF  xC6
57C6:  MOVLW  85
57C8:  MOVWF  xC5
57CA:  MOVFF  03,2CC
57CE:  MOVFF  02,2CB
57D2:  MOVFF  01,2CA
57D6:  MOVFF  00,2C9
57DA:  MOVLB  0
57DC:  CALL   29F2
57E0:  MOVFF  00,9D
57E4:  MOVFF  01,9E
57E8:  MOVFF  02,9F
57EC:  MOVFF  03,A0
57F0:  MOVFF  03,2B2
57F4:  MOVFF  02,2B1
57F8:  MOVFF  01,2B0
57FC:  MOVFF  00,2AF
5800:  MOVLB  2
5802:  CLRF   xB6
5804:  CLRF   xB5
5806:  MOVLW  7F
5808:  MOVWF  xB4
580A:  MOVLW  86
580C:  MOVWF  xB3
580E:  MOVLB  0
5810:  CALL   2058
5814:  BCF    FD8.1
5816:  MOVLB  2
5818:  CLRF   xAC
581A:  CLRF   xAB
581C:  CLRF   xAA
581E:  CLRF   xA9
5820:  MOVFF  03,2B0
5824:  MOVFF  02,2AF
5828:  MOVFF  01,2AE
582C:  MOVFF  00,2AD
5830:  MOVLB  0
5832:  CALL   2428
5836:  MOVFF  03,98
583A:  MOVFF  02,97
583E:  MOVFF  01,96
5842:  MOVFF  00,95
....................  
....................    //Establecemos como entrada analógica a analizar la de la temperatura del agua 
....................    set_adc_channel(temperatura_caldera); 
5846:  MOVLW  00
5848:  MOVWF  01
584A:  MOVF   FC2,W
584C:  ANDLW  C3
584E:  IORWF  01,W
5850:  MOVWF  FC2
....................    delay_us(10); //Retraso para posibilitar la lectura 
5852:  CLRWDT
5854:  MOVLW  06
5856:  MOVWF  00
5858:  DECFSZ 00,F
585A:  BRA    5858
....................    //Transformamos el valor analógico leído a la escala utlizada en la temperatura 
....................    temp = t_min_caldera + ((t_max_caldera-t_min_caldera)*(float)read_adc())/AD_num_valores; 
585C:  BSF    FC2.1
585E:  BTFSC  FC2.1
5860:  BRA    585E
5862:  MOVF   FC4,W
5864:  MOVLB  2
5866:  CLRF   xB0
5868:  MOVWF  xAF
586A:  MOVLB  0
586C:  CALL   26A2
5870:  MOVLB  2
5872:  CLRF   xC8
5874:  CLRF   xC7
5876:  MOVLW  48
5878:  MOVWF  xC6
587A:  MOVLW  85
587C:  MOVWF  xC5
587E:  MOVFF  03,2CC
5882:  MOVFF  02,2CB
5886:  MOVFF  01,2CA
588A:  MOVFF  00,2C9
588E:  MOVLB  0
5890:  CALL   29F2
5894:  MOVFF  00,9D
5898:  MOVFF  01,9E
589C:  MOVFF  02,9F
58A0:  MOVFF  03,A0
58A4:  MOVFF  03,2B2
58A8:  MOVFF  02,2B1
58AC:  MOVFF  01,2B0
58B0:  MOVFF  00,2AF
58B4:  MOVLB  2
58B6:  CLRF   xB6
58B8:  CLRF   xB5
58BA:  MOVLW  7F
58BC:  MOVWF  xB4
58BE:  MOVLW  86
58C0:  MOVWF  xB3
58C2:  MOVLB  0
58C4:  CALL   2058
58C8:  BCF    FD8.1
58CA:  MOVLB  2
58CC:  CLRF   xAC
58CE:  CLRF   xAB
58D0:  CLRF   xAA
58D2:  CLRF   xA9
58D4:  MOVFF  03,2B0
58D8:  MOVFF  02,2AF
58DC:  MOVFF  01,2AE
58E0:  MOVFF  00,2AD
58E4:  MOVLB  0
58E6:  CALL   2428
58EA:  MOVFF  03,9C
58EE:  MOVFF  02,9B
58F2:  MOVFF  01,9A
58F6:  MOVFF  00,99
....................  
....................    //Comparamos ambas temperaturas teniendo en cuenta la histéresis de la caldera 
....................    if(temp > termo-histeresis_caldera) 
58FA:  BSF    FD8.1
58FC:  MOVFF  98,2AC
5900:  MOVFF  97,2AB
5904:  MOVFF  96,2AA
5908:  MOVFF  95,2A9
590C:  MOVLB  2
590E:  CLRF   xB0
5910:  CLRF   xAF
5912:  MOVLW  20
5914:  MOVWF  xAE
5916:  MOVLW  82
5918:  MOVWF  xAD
591A:  MOVLB  0
591C:  CALL   2428
5920:  MOVFF  03,A0
5924:  MOVFF  02,9F
5928:  MOVFF  01,9E
592C:  MOVFF  00,9D
5930:  MOVFF  9C,A4
5934:  MOVFF  9B,A3
5938:  MOVFF  9A,A2
593C:  MOVFF  99,A1
5940:  CALL   23B2
5944:  BNC   594E
....................       return TRUE; 
5946:  MOVLW  01
5948:  MOVWF  01
594A:  BRA    5954
....................    else 
594C:  BRA    5954
....................       return FALSE; 
594E:  MOVLW  00
5950:  MOVWF  01
5952:  BRA    5954
.................... } 
5954:  GOTO   6BF6 (RETURN)
....................  
.................... //----------------------------------------------------------------------------------------------------------------------------------------- 
....................  
.................... int comprobar_hora(int hora1, int min1, int hora2, int min2) 
.................... { 
....................    //Si hora1 es menor, devolvemos TRUE 
....................    if(hora1 < hora2) 
*
2AEA:  MOVF   xAD,W
2AEC:  SUBWF  xAB,W
2AEE:  BC    2AF6
....................       return TRUE; 
2AF0:  MOVLW  01
2AF2:  MOVWF  01
2AF4:  BRA    2B1C
....................    //Si hora1 es mayor, devolvemos FALSE 
....................    if(hora1 > hora2) 
2AF6:  MOVF   xAB,W
2AF8:  SUBWF  xAD,W
2AFA:  BC    2B02
....................       return FALSE; 
2AFC:  MOVLW  00
2AFE:  MOVWF  01
2B00:  BRA    2B1C
....................    //Si las horas coinciden habrá que comparar los minutos 
....................    if(hora1==hora2) 
2B02:  MOVF   xAD,W
2B04:  SUBWF  xAB,W
2B06:  BNZ   2B1C
....................    { 
....................       //Se sigue el mismo criterio de antes con la comparación 
....................       //de los minutos. 
....................       if(min1 <= min2) 
2B08:  MOVF   xAC,W
2B0A:  SUBWF  xAE,W
2B0C:  BNC   2B16
....................          return TRUE; 
2B0E:  MOVLW  01
2B10:  MOVWF  01
2B12:  BRA    2B1C
....................       else 
2B14:  BRA    2B1C
....................          return FALSE; 
2B16:  MOVLW  00
2B18:  MOVWF  01
2B1A:  BRA    2B1C
....................    } 
.................... } 
2B1C:  RETLW  00
....................  
.................... //----------------------------------------------------------------------------------------------------------------------------------------- 
....................  
.................... int comprobar_temperatura() 
.................... { 
....................    //Flags auxiliares 
....................    int1 flag1, flag2; 
....................  
....................    //Leemos la temperatura 
....................    temperatura1 = ds1820_read(dir1); 
*
5B10:  CLRF   xA2
5B12:  MOVLW  6D
5B14:  MOVWF  xA1
5B16:  CALL   21B8
5B1A:  MOVFF  03,2F
5B1E:  MOVFF  02,2E
5B22:  MOVFF  01,2D
5B26:  MOVFF  00,2C
....................    temperatura2 = ds1820_read(dir2); 
5B2A:  CLRF   xA2
5B2C:  MOVLW  75
5B2E:  MOVWF  xA1
5B30:  CALL   21B8
5B34:  MOVFF  03,33
5B38:  MOVFF  02,32
5B3C:  MOVFF  01,31
5B40:  MOVFF  00,30
....................  
....................    //Mostramos la información en la pantalla lcd 
....................    mostrar_temperatura(); 
5B44:  BRA    5A2A
....................  
....................    //************************************ 
....................    //NOTA: El termostato no lo hemos implementado con la función ALARM SEARCH del ds1820 
....................    //por dos razones: por necesitar un algoritmo bastante complejo en el caso de dos dispositivos 
....................    //y por que se ha llegado a la conclusión de que consume más memoria y tiempo, ya que 
....................    //de todas formas tenemos que leer las temperaturas para mostrarlas por pantalla. Si se 
....................    //quiere ver un ejemplo de utilización de este modo de termostato del ds1820, en el prototipo 
....................    //construido para probar en la EasyPic3 se ha implementado con un único sensor. 
....................    //************************************ 
....................  
....................    //Nos centramos primero en el sensor 1 
....................    if(temperatura1 < termostato1) 
5B46:  MOVFF  2F,A0
5B4A:  MOVFF  2E,9F
5B4E:  MOVFF  2D,9E
5B52:  MOVFF  2C,9D
5B56:  MOVFF  23,A4
5B5A:  MOVFF  22,A3
5B5E:  MOVFF  21,A2
5B62:  MOVFF  20,A1
5B66:  CALL   23B2
5B6A:  BNC   5BAC
....................    { 
....................       //Si la temperatura es menor que la del termostato, devolvemos TRUE 
....................       if(temp_habitacion_superada1) 
5B6C:  BTFSS  1F.1
5B6E:  BRA    5BA8
....................       { 
....................          //Si la temperatura antes era mayor, indicamos el cambio en el flag 
....................          temp_habitacion_superada1 = FALSE; 
5B70:  BCF    1F.1
....................          //Tenemos en cuenta la histéresis para el nuevo valor del termostato 
....................          termostato1 = termostato1 + histeresis_vivienda; 
5B72:  BCF    FD8.1
5B74:  MOVFF  23,2AC
5B78:  MOVFF  22,2AB
5B7C:  MOVFF  21,2AA
5B80:  MOVFF  20,2A9
5B84:  MOVFF  37,2B0
5B88:  MOVFF  36,2AF
5B8C:  MOVFF  35,2AE
5B90:  MOVFF  34,2AD
5B94:  CALL   2428
5B98:  MOVFF  03,23
5B9C:  MOVFF  02,22
5BA0:  MOVFF  01,21
5BA4:  MOVFF  00,20
....................       } 
....................       flag1 = TRUE; 
5BA8:  BSF    x95.0
....................    } 
....................    else 
5BAA:  BRA    5BEA
....................    { 
....................       //Si la temperatura es mayor que la del termostato, devolvemos FALSE 
....................       if(!temp_habitacion_superada1) 
5BAC:  BTFSC  1F.1
5BAE:  BRA    5BE8
....................       { 
....................          //Si antes era menor, cambiamos el flag 
....................          temp_habitacion_superada1 = TRUE; 
5BB0:  BSF    1F.1
....................          //Guardamos el nuevo valor del termostato teniendo en cuenta la histéresis 
....................          termostato1 = termostato1 - histeresis_vivienda; 
5BB2:  BSF    FD8.1
5BB4:  MOVFF  23,2AC
5BB8:  MOVFF  22,2AB
5BBC:  MOVFF  21,2AA
5BC0:  MOVFF  20,2A9
5BC4:  MOVFF  37,2B0
5BC8:  MOVFF  36,2AF
5BCC:  MOVFF  35,2AE
5BD0:  MOVFF  34,2AD
5BD4:  CALL   2428
5BD8:  MOVFF  03,23
5BDC:  MOVFF  02,22
5BE0:  MOVFF  01,21
5BE4:  MOVFF  00,20
....................       } 
....................       flag1 = FALSE; 
5BE8:  BCF    x95.0
....................    } 
....................  
....................    //Repetimos las mismas operaciones para el sensor 2 
....................    if(temperatura2 < termostato2) 
5BEA:  MOVFF  33,A0
5BEE:  MOVFF  32,9F
5BF2:  MOVFF  31,9E
5BF6:  MOVFF  30,9D
5BFA:  MOVFF  27,A4
5BFE:  MOVFF  26,A3
5C02:  MOVFF  25,A2
5C06:  MOVFF  24,A1
5C0A:  CALL   23B2
5C0E:  BNC   5C50
....................    { 
....................       //Si la temperatura es menor que la del termostato, devolvemos TRUE 
....................       if(temp_habitacion_superada2) 
5C10:  BTFSS  1F.2
5C12:  BRA    5C4C
....................       { 
....................          //Si la temperatura antes era mayor, indicamos el cambio en el flag 
....................          temp_habitacion_superada2 = FALSE; 
5C14:  BCF    1F.2
....................          //Tenemos en cuenta la histéresis para el nuevo valor del termostato 
....................          termostato2 = termostato2 + histeresis_vivienda; 
5C16:  BCF    FD8.1
5C18:  MOVFF  27,2AC
5C1C:  MOVFF  26,2AB
5C20:  MOVFF  25,2AA
5C24:  MOVFF  24,2A9
5C28:  MOVFF  37,2B0
5C2C:  MOVFF  36,2AF
5C30:  MOVFF  35,2AE
5C34:  MOVFF  34,2AD
5C38:  CALL   2428
5C3C:  MOVFF  03,27
5C40:  MOVFF  02,26
5C44:  MOVFF  01,25
5C48:  MOVFF  00,24
....................       } 
....................       flag2 = TRUE; 
5C4C:  BSF    x95.1
....................    } 
....................    else 
5C4E:  BRA    5C8E
....................    { 
....................       //Si la temperatura es mayor que la del termostato, devolvemos FALSE 
....................       if(!temp_habitacion_superada2) 
5C50:  BTFSC  1F.2
5C52:  BRA    5C8C
....................       { 
....................          //Si antes era menor, cambiamos el flag 
....................          temp_habitacion_superada2 = TRUE; 
5C54:  BSF    1F.2
....................          //Guardamos el nuevo valor del termostato teniendo en cuenta la histéresis 
....................          termostato2 = termostato2 - histeresis_vivienda; 
5C56:  BSF    FD8.1
5C58:  MOVFF  27,2AC
5C5C:  MOVFF  26,2AB
5C60:  MOVFF  25,2AA
5C64:  MOVFF  24,2A9
5C68:  MOVFF  37,2B0
5C6C:  MOVFF  36,2AF
5C70:  MOVFF  35,2AE
5C74:  MOVFF  34,2AD
5C78:  CALL   2428
5C7C:  MOVFF  03,27
5C80:  MOVFF  02,26
5C84:  MOVFF  01,25
5C88:  MOVFF  00,24
....................       } 
....................       flag2 = FALSE; 
5C8C:  BCF    x95.1
....................    } 
....................  
....................    //Devolvemos el código correspondiente según se explica en la definición de la función 
....................    if(!flag1 && !flag2) 
5C8E:  BTFSC  x95.0
5C90:  BRA    5C9C
5C92:  BTFSC  x95.1
5C94:  BRA    5C9C
....................       return 0; 
5C96:  MOVLW  00
5C98:  MOVWF  01
5C9A:  BRA    5CC6
....................    if(flag1 && !flag2) 
5C9C:  BTFSS  x95.0
5C9E:  BRA    5CAA
5CA0:  BTFSC  x95.1
5CA2:  BRA    5CAA
....................       return 1; 
5CA4:  MOVLW  01
5CA6:  MOVWF  01
5CA8:  BRA    5CC6
....................    if(!flag1 && flag2) 
5CAA:  BTFSC  x95.0
5CAC:  BRA    5CB8
5CAE:  BTFSS  x95.1
5CB0:  BRA    5CB8
....................       return 2; 
5CB2:  MOVLW  02
5CB4:  MOVWF  01
5CB6:  BRA    5CC6
....................    if(flag1 && flag2) 
5CB8:  BTFSS  x95.0
5CBA:  BRA    5CC6
5CBC:  BTFSS  x95.1
5CBE:  BRA    5CC6
....................       return 3; 
5CC0:  MOVLW  03
5CC2:  MOVWF  01
5CC4:  BRA    5CC6
.................... } 
5CC6:  GOTO   6C1E (RETURN)
....................  
.................... //----------------------------------------------------------------------------------------------------------------------------------------- 
....................  
.................... long diferencia_tiempo(int hora1, int min1, int hora2, int min2) 
.................... { 
....................    long dif; 
....................  
....................    //Si hora1:min1 es menor que hora2:min2, devolvemos simplemente la diferencia en minutos 
....................    if(comprobar_hora(hora1,min1,hora2,min2)) 
*
2B1E:  MOVFF  A1,AB
2B22:  MOVFF  A2,AC
2B26:  MOVFF  A3,AD
2B2A:  MOVFF  A4,AE
2B2E:  RCALL  2AEA
2B30:  MOVF   01,F
2B32:  BZ    2B98
....................       dif = ((long)hora2*60 + (long)min2) - ((long)hora1*60 + (long)min1); 
2B34:  CLRF   xA8
2B36:  MOVFF  A3,A7
2B3A:  MOVFF  A8,B3
2B3E:  MOVFF  A3,B2
2B42:  CLRF   xB5
2B44:  MOVLW  3C
2B46:  MOVWF  xB4
2B48:  CALL   182C
2B4C:  MOVFF  02,A9
2B50:  MOVFF  01,A8
2B54:  CLRF   03
2B56:  MOVF   xA4,W
2B58:  ADDWF  01,W
2B5A:  MOVWF  xAA
2B5C:  MOVF   03,W
2B5E:  ADDWFC 02,W
2B60:  MOVWF  xAB
2B62:  CLRF   xAD
2B64:  MOVFF  A1,AC
2B68:  MOVFF  AD,B3
2B6C:  MOVFF  A1,B2
2B70:  CLRF   xB5
2B72:  MOVLW  3C
2B74:  MOVWF  xB4
2B76:  CALL   182C
2B7A:  MOVFF  01,AD
2B7E:  CLRF   03
2B80:  MOVF   xA2,W
2B82:  ADDWF  01,W
2B84:  MOVWF  01
2B86:  MOVF   02,W
2B88:  ADDWFC 03,F
2B8A:  MOVF   01,W
2B8C:  SUBWF  xAA,W
2B8E:  MOVWF  xA5
2B90:  MOVF   03,W
2B92:  SUBWFB xAB,W
2B94:  MOVWF  xA6
....................    //Si no es así, habrá que tener en cuenta que hora1:min1 se encuentra en el día anterior 
....................    //al de hora2:min2 
....................    else 
2B96:  BRA    2C08
....................       dif = (24*60-((long)hora1*60 + (long)min1)) + (long)hora2*60 + (long)min2; 
2B98:  CLRF   xA8
2B9A:  MOVFF  A1,A7
2B9E:  MOVFF  A8,B3
2BA2:  MOVFF  A1,B2
2BA6:  CLRF   xB5
2BA8:  MOVLW  3C
2BAA:  MOVWF  xB4
2BAC:  CALL   182C
2BB0:  MOVFF  02,A9
2BB4:  MOVFF  01,A8
2BB8:  CLRF   03
2BBA:  MOVF   xA2,W
2BBC:  ADDWF  01,W
2BBE:  MOVWF  01
2BC0:  MOVF   02,W
2BC2:  ADDWFC 03,F
2BC4:  MOVF   01,W
2BC6:  XORLW  FF
2BC8:  ADDLW  A1
2BCA:  MOVWF  xAA
2BCC:  MOVLW  05
2BCE:  SUBFWB 03,W
2BD0:  MOVWF  xAB
2BD2:  CLRF   xAD
2BD4:  MOVFF  A3,AC
2BD8:  MOVFF  AD,B3
2BDC:  MOVFF  A3,B2
2BE0:  CLRF   xB5
2BE2:  MOVLW  3C
2BE4:  MOVWF  xB4
2BE6:  CALL   182C
2BEA:  MOVFF  02,03
2BEE:  MOVF   01,W
2BF0:  ADDWF  xAA,W
2BF2:  MOVWF  xAD
2BF4:  MOVF   02,W
2BF6:  ADDWFC xAB,W
2BF8:  MOVWF  xAE
2BFA:  CLRF   03
2BFC:  MOVF   xA4,W
2BFE:  ADDWF  xAD,W
2C00:  MOVWF  xA5
2C02:  MOVF   03,W
2C04:  ADDWFC xAE,W
2C06:  MOVWF  xA6
....................  
....................    //Devolvemos el resultado 
....................    return dif; 
2C08:  MOVFF  A5,01
2C0C:  MOVFF  A6,02
.................... } 
2C10:  RETLW  00
....................  
.................... //----------------------------------------------------------------------------------------------------------------------------------------- 
....................  
.................... long diferencia_tiempo_sec(int hora1, int min1, int sec1, int hora2, int min2, int sec2) 
.................... { 
....................    unsigned long dif; 
....................    unsigned long dif2; 
....................  
....................    //Si hora1:min1 es menor que hora2:min2, ambas horas están en el mismo día 
....................    if(comprobar_hora(hora1,min1,hora2,min2)) 
2C12:  MOVFF  A1,AB
2C16:  MOVFF  A2,AC
2C1A:  MOVFF  A4,AD
2C1E:  MOVFF  A5,AE
2C22:  RCALL  2AEA
2C24:  MOVF   01,F
2C26:  BZ    2CCC
....................    { 
....................       //Si la hora y los minutos son iguales, devolvemos simplemente la diferencia en segundos 
....................       if(hora1==hora2 && min1==min2) 
2C28:  MOVF   xA4,W
2C2A:  SUBWF  xA1,W
2C2C:  BNZ   2C3E
2C2E:  MOVF   xA5,W
2C30:  SUBWF  xA2,W
2C32:  BNZ   2C3E
....................          dif = abs(sec2-sec1); 
2C34:  MOVF   xA3,W
2C36:  SUBWF  xA6,W
2C38:  CLRF   xA8
2C3A:  MOVWF  xA7
....................       else 
2C3C:  BRA    2CCA
....................       { 
....................          //Si no habrá que tener en cuenta también la diferencia entre horas y minutos 
....................          dif2 = ((long)hora2*60 + (long)min2) - ((long)hora1*60 + (long)min1); 
2C3E:  CLRF   xAC
2C40:  MOVFF  A4,AB
2C44:  MOVFF  AC,B3
2C48:  MOVFF  A4,B2
2C4C:  CLRF   xB5
2C4E:  MOVLW  3C
2C50:  MOVWF  xB4
2C52:  CALL   182C
2C56:  MOVFF  02,AD
2C5A:  MOVFF  01,AC
2C5E:  CLRF   03
2C60:  MOVF   xA5,W
2C62:  ADDWF  01,W
2C64:  MOVWF  xAE
2C66:  MOVF   03,W
2C68:  ADDWFC 02,W
2C6A:  MOVWF  xAF
2C6C:  CLRF   xB1
2C6E:  MOVFF  A1,B0
2C72:  MOVFF  B1,B3
2C76:  MOVFF  A1,B2
2C7A:  CLRF   xB5
2C7C:  MOVLW  3C
2C7E:  MOVWF  xB4
2C80:  CALL   182C
2C84:  MOVFF  01,B1
2C88:  CLRF   03
2C8A:  MOVF   xA2,W
2C8C:  ADDWF  01,W
2C8E:  MOVWF  01
2C90:  MOVF   02,W
2C92:  ADDWFC 03,F
2C94:  MOVF   01,W
2C96:  SUBWF  xAE,W
2C98:  MOVWF  xA9
2C9A:  MOVF   03,W
2C9C:  SUBWFB xAF,W
2C9E:  MOVWF  xAA
....................          //No hacemos la diferencia en segundos directamente porque el long no da de sí 
....................          dif = dif2*60 + sec2 - sec1; 
2CA0:  MOVFF  AA,B3
2CA4:  MOVFF  A9,B2
2CA8:  CLRF   xB5
2CAA:  MOVLW  3C
2CAC:  MOVWF  xB4
2CAE:  CALL   182C
2CB2:  MOVF   xA6,W
2CB4:  ADDWF  01,W
2CB6:  MOVWF  xAD
2CB8:  MOVLW  00
2CBA:  ADDWFC 02,W
2CBC:  MOVWF  xAE
2CBE:  MOVF   xA3,W
2CC0:  SUBWF  xAD,W
2CC2:  MOVWF  xA7
2CC4:  MOVLW  00
2CC6:  SUBWFB xAE,W
2CC8:  MOVWF  xA8
....................       } 
....................    } 
....................    else{ 
2CCA:  BRA    2D66
....................       //Si no, simplemente tenemos en cuenta que están en días diferentes y luego le añadimos la 
....................       //diferencia en segundos 
....................       dif2 = (24*60-((long)hora1*60 + (long)min1)) + (long)hora2*60 + (long)min2; 
2CCC:  CLRF   xAC
2CCE:  MOVFF  A1,AB
2CD2:  MOVFF  AC,B3
2CD6:  MOVFF  A1,B2
2CDA:  CLRF   xB5
2CDC:  MOVLW  3C
2CDE:  MOVWF  xB4
2CE0:  CALL   182C
2CE4:  MOVFF  02,AD
2CE8:  MOVFF  01,AC
2CEC:  CLRF   03
2CEE:  MOVF   xA2,W
2CF0:  ADDWF  01,W
2CF2:  MOVWF  01
2CF4:  MOVF   02,W
2CF6:  ADDWFC 03,F
2CF8:  MOVF   01,W
2CFA:  XORLW  FF
2CFC:  ADDLW  A1
2CFE:  MOVWF  xAE
2D00:  MOVLW  05
2D02:  SUBFWB 03,W
2D04:  MOVWF  xAF
2D06:  CLRF   xB1
2D08:  MOVFF  A4,B0
2D0C:  MOVFF  B1,B3
2D10:  MOVFF  A4,B2
2D14:  CLRF   xB5
2D16:  MOVLW  3C
2D18:  MOVWF  xB4
2D1A:  CALL   182C
2D1E:  MOVFF  02,03
2D22:  MOVF   01,W
2D24:  ADDWF  xAE,W
2D26:  MOVWF  xB1
2D28:  MOVF   02,W
2D2A:  ADDWFC xAF,W
2D2C:  MOVWF  xB2
2D2E:  CLRF   03
2D30:  MOVF   xA5,W
2D32:  ADDWF  xB1,W
2D34:  MOVWF  xA9
2D36:  MOVF   03,W
2D38:  ADDWFC xB2,W
2D3A:  MOVWF  xAA
....................       dif = dif2*60 + sec2 - sec1; 
2D3C:  MOVFF  AA,B3
2D40:  MOVFF  A9,B2
2D44:  CLRF   xB5
2D46:  MOVLW  3C
2D48:  MOVWF  xB4
2D4A:  CALL   182C
2D4E:  MOVF   xA6,W
2D50:  ADDWF  01,W
2D52:  MOVWF  xAD
2D54:  MOVLW  00
2D56:  ADDWFC 02,W
2D58:  MOVWF  xAE
2D5A:  MOVF   xA3,W
2D5C:  SUBWF  xAD,W
2D5E:  MOVWF  xA7
2D60:  MOVLW  00
2D62:  SUBWFB xAE,W
2D64:  MOVWF  xA8
....................    } 
....................  
....................    //Devolvemos el resultado 
....................    return dif; 
2D66:  MOVFF  A7,01
2D6A:  MOVFF  A8,02
.................... } 
2D6E:  RETLW  00
....................  
.................... //----------------------------------------------------------------------------------------------------------------------------------------- 
....................  
.................... void encender_caldera() 
.................... { 
....................    //Leemos el tiempo actual 
....................    PCF8583_read_datetime(&tiempo); 
*
5958:  CLRF   xA2
595A:  MOVLW  5B
595C:  MOVWF  xA1
595E:  CALL   2764
....................    //Habilitamos interrupciones (se desactivan en el método anterior) 
....................    //enable_interrupts(GLOBAL); 
....................  
....................    //Guardamos los datos en las variables correspondientes 
....................    hora_caldera = tiempo.hours; 
5962:  MOVFF  5D,64
....................    minutos_caldera = tiempo.minutes; 
5966:  MOVFF  5C,65
....................    segundos_caldera = tiempo.seconds; 
596A:  MOVFF  5B,66
....................  
....................    //Encendemos la caldera 
....................    caldera_encendida = TRUE; 
596E:  BSF    F83.5
.................... } 
5970:  RETLW  00
....................  
.................... //----------------------------------------------------------------------------------------------------------------------------------------- 
....................  
.................... void encender_sistema() 
.................... { 
....................    //Leemos el tiempo actual 
....................    PCF8583_read_datetime(&tiempo); 
*
28EA:  CLRF   xA2
28EC:  MOVLW  5B
28EE:  MOVWF  xA1
28F0:  RCALL  2764
....................    //Habilitamos interrupciones (se desactivan en el método anterior) 
....................    //enable_interrupts(GLOBAL); 
....................  
....................    //Registramos la hora y minutos en los que se enciende el sistema 
....................    hora_encendido    = tiempo.hours; 
28F2:  MOVFF  5D,62
....................    minutos_encendido = tiempo.minutes; 
28F6:  MOVFF  5C,63
....................  
....................    //Inicializamos a 0 el tiempo total que está encendida la caldera 
....................    t_total_caldera = 0; 
28FA:  CLRF   68
28FC:  CLRF   67
....................  
....................    //Si la caldera está encendida, inicializamos el instante de encendido a 
....................    //éste. 
....................    if(caldera_encendida) 
28FE:  BTFSS  F83.5
2900:  BRA    290E
....................    { 
....................       hora_caldera = tiempo.hours; 
2902:  MOVFF  5D,64
....................       minutos_caldera = tiempo.minutes; 
2906:  MOVFF  5C,65
....................       segundos_caldera = tiempo.seconds; 
290A:  MOVFF  5B,66
....................    } 
....................  
....................    //Encendemos el sistema 
....................    sistema_encendido = TRUE; 
290E:  BSF    F83.4
.................... } 
2910:  RETLW  00
....................  
.................... //----------------------------------------------------------------------------------------------------------------------------------------- 
....................  
.................... void grabar_programaciones() 
.................... { 
....................    int datos[5];   //Vector para contener los datos a grabar 
....................    programacion pr; //Variable temporal de programacion 
....................    int contador;   //Contador para el bucle 
....................  
....................    //Recorremos todo el vector de programaciones (hasta el número de programaciones que tengamos) 
....................    for(contador=0; contador<num_intervalos; contador++) 
*
37C8:  CLRF   x9F
37CA:  MOVF   59,W
37CC:  SUBWF  x9F,W
37CE:  BC    3838
....................    { 
....................       //Seleccionamos la programación 
....................       pr = programaciones[contador]; 
37D0:  MOVF   x9F,W
37D2:  MULLW  05
37D4:  MOVF   FF3,W
37D6:  CLRF   03
37D8:  ADDLW  3B
37DA:  MOVWF  01
37DC:  MOVLW  00
37DE:  ADDWFC 03,F
37E0:  MOVFF  01,A0
37E4:  MOVFF  03,A1
37E8:  CLRF   FEA
37EA:  MOVLW  9A
37EC:  MOVWF  FE9
37EE:  MOVFF  03,FE2
37F2:  MOVFF  01,FE1
37F6:  MOVLW  05
37F8:  MOVWF  01
37FA:  MOVFF  FE6,FEE
37FE:  DECFSZ 01,F
3800:  BRA    37FA
....................  
....................       //Almacenamos los datos en el vector 
....................       datos[0] = pr.horas_inicio; 
3802:  MOVFF  9A,95
....................       datos[1] = pr.minutos_inicio; 
3806:  MOVFF  9B,96
....................       datos[2] = pr.horas_fin; 
380A:  MOVFF  9C,97
....................       datos[3] = pr.minutos_fin; 
380E:  MOVFF  9D,98
....................       datos[4] = pr.termostato; 
3812:  MOVFF  9E,99
....................  
....................       //Guardamos los datos en la posición de memoria correspondiente de la EEPROM 
....................       graba_ee(eeprom_programaciones + (contador+1)*8, 5, datos); 
3816:  MOVLW  01
3818:  ADDWF  x9F,W
381A:  MULLW  08
381C:  MOVF   FF3,W
381E:  ADDLW  18
3820:  MOVWF  xA1
3822:  CLRF   xA8
3824:  MOVWF  xA7
3826:  MOVLW  05
3828:  MOVWF  xA9
382A:  CLRF   xAB
382C:  MOVLW  95
382E:  MOVWF  xAA
3830:  CALL   184A
....................    } 
3834:  INCF   x9F,F
3836:  BRA    37CA
....................  
....................    //Guardamos en la EEPROM en el número de intervalos 
....................    graba_ee(eeprom_num_intervalos, 1, &num_intervalos); 
3838:  CLRF   xA8
383A:  MOVLW  11
383C:  MOVWF  xA7
383E:  MOVLW  01
3840:  MOVWF  xA9
3842:  CLRF   xAB
3844:  MOVLW  59
3846:  MOVWF  xAA
3848:  CALL   184A
....................  
....................    //He optado por escribir de programación en programación porque a pesar de que 
....................    //en el datasheet aseguran que la memoria tiene una paginación de 32 bytes en la 
....................    //simulación parece tener menos, así que de este modo nos evitamos problemas 
.................... } 
384C:  GOTO   6BE4 (RETURN)
....................  
.................... //----------------------------------------------------------------------------------------------------------------------------------------- 
....................  
.................... void inicializacion() 
.................... { 
....................    //NOTA: todos los pequeños retardos introducidos en esta rutina sirven para que el técnico 
....................    //no se sienta atosigado por los continuos mensajes que le aparecen solicitándole información. 
....................  
....................  
....................    //Variables para introducir los datos de fecha y hora 
....................    int weekday, dia, mes, anno, horas, minutos; 
....................    //Variable para escritura en memoria 
....................    int data[8]; 
....................    char c[2]; //Cadena para la conversión a int 
....................  
....................    //Comenzamos pidiendo la introducción de la fecha 
....................    //Es una lástima que en RS232 no se vean bien las tildes 
....................    e1: 
....................    printf("\rInicializacion del sistema\r"); 
*
18B2:  CLRF   xA5
18B4:  MOVF   xA5,W
18B6:  CALL   04D8
18BA:  IORLW  00
18BC:  BZ    18C8
18BE:  INCF   xA5,F
18C0:  BTFSS  F9E.4
18C2:  BRA    18C0
18C4:  MOVWF  FAD
18C6:  BRA    18B4
....................    printf("**************************\r"); 
18C8:  CLRF   xA5
18CA:  MOVF   xA5,W
18CC:  CALL   0510
18D0:  IORLW  00
18D2:  BZ    18DE
18D4:  INCF   xA5,F
18D6:  BTFSS  F9E.4
18D8:  BRA    18D6
18DA:  MOVWF  FAD
18DC:  BRA    18CA
....................    //Primero solicitamos el día de la semana 
....................    printf("Dia de la semana (1->Lunes, 2->Martes, ...): LUNES    "); 
18DE:  CLRF   xA5
18E0:  MOVF   xA5,W
18E2:  CALL   0546
18E6:  IORLW  00
18E8:  BZ    18F4
18EA:  INCF   xA5,F
18EC:  BTFSS  F9E.4
18EE:  BRA    18EC
18F0:  MOVWF  FAD
18F2:  BRA    18E0
....................  
....................    //En principio se indica que es lunes 
....................    weekday = 0; 
18F4:  CLRF   x95
....................  
....................    //Inicializamos el vector de caracteres a \0 por dos motivos según la posición: 
....................    //c[0] para que no se elija un día indeseado sin intervención del técnico y c[1], 
....................    //para marcar el fin de la cadena. 
....................    c[0]=c[1]='\0'; 
18F6:  CLRF   xA4
18F8:  MOVFF  A4,A3
....................  
....................    //Iteramos en el bucle hasta que no se pulse ENTER 
....................    while(c[0]!=13){ 
18FC:  MOVF   xA3,W
18FE:  SUBLW  0D
1900:  BTFSC  FD8.2
1902:  BRA    19CE
....................       //Guardamos el caracter leído 
....................       c[0]=getch(); 
1904:  BTFSS  F9E.5
1906:  BRA    1904
1908:  MOVFF  FAE,A3
....................  
....................       //Además se asigna un valor numérico a la variable weekday para almacenarla en el reloj. 
....................       weekday=atoi(c)-1; 
190C:  CLRF   xA9
190E:  MOVLW  A3
1910:  MOVWF  xA8
1912:  RCALL  1450
1914:  MOVLW  01
1916:  SUBWF  01,W
1918:  MOVWF  x95
....................  
....................       //Según el día introducido, imprimimos un resultado u otro por pantalla, borrando el 
....................       //anterior. Para ello, todos los días ocupan el tamaño del mayor (miércoles) gracias a espacios. 
....................       switch(weekday) 
....................       { 
191A:  MOVF   x95,W
191C:  ADDLW  F9
191E:  BC    19CC
1920:  ADDLW  07
1922:  GOTO   1DBA
....................          case 0: printf("\b\b\b\b\b\b\b\b\bLUNES    "); 
1926:  CLRF   xA5
1928:  MOVF   xA5,W
192A:  CALL   0598
192E:  IORLW  00
1930:  BZ    193C
1932:  INCF   xA5,F
1934:  BTFSS  F9E.4
1936:  BRA    1934
1938:  MOVWF  FAD
193A:  BRA    1928
....................                  break; 
193C:  BRA    19CC
....................          case 1: printf("\b\b\b\b\b\b\b\b\bMARTES   "); 
193E:  CLRF   xA5
1940:  MOVF   xA5,W
1942:  CALL   05C6
1946:  IORLW  00
1948:  BZ    1954
194A:  INCF   xA5,F
194C:  BTFSS  F9E.4
194E:  BRA    194C
1950:  MOVWF  FAD
1952:  BRA    1940
....................                  break; 
1954:  BRA    19CC
....................          case 2: printf("\b\b\b\b\b\b\b\b\bMIERCOLES"); 
1956:  CLRF   xA5
1958:  MOVF   xA5,W
195A:  CALL   05F4
195E:  IORLW  00
1960:  BZ    196C
1962:  INCF   xA5,F
1964:  BTFSS  F9E.4
1966:  BRA    1964
1968:  MOVWF  FAD
196A:  BRA    1958
....................                  break; 
196C:  BRA    19CC
....................          case 3: printf("\b\b\b\b\b\b\b\b\bJUEVES   "); 
196E:  CLRF   xA5
1970:  MOVF   xA5,W
1972:  CALL   0622
1976:  IORLW  00
1978:  BZ    1984
197A:  INCF   xA5,F
197C:  BTFSS  F9E.4
197E:  BRA    197C
1980:  MOVWF  FAD
1982:  BRA    1970
....................                  break; 
1984:  BRA    19CC
....................          case 4: printf("\b\b\b\b\b\b\b\b\bVIERNES  "); 
1986:  CLRF   xA5
1988:  MOVF   xA5,W
198A:  CALL   0650
198E:  IORLW  00
1990:  BZ    199C
1992:  INCF   xA5,F
1994:  BTFSS  F9E.4
1996:  BRA    1994
1998:  MOVWF  FAD
199A:  BRA    1988
....................                  break; 
199C:  BRA    19CC
....................          case 5: printf("\b\b\b\b\b\b\b\b\bSABADO   "); 
199E:  CLRF   xA5
19A0:  MOVF   xA5,W
19A2:  CALL   067E
19A6:  IORLW  00
19A8:  BZ    19B4
19AA:  INCF   xA5,F
19AC:  BTFSS  F9E.4
19AE:  BRA    19AC
19B0:  MOVWF  FAD
19B2:  BRA    19A0
....................                  break; 
19B4:  BRA    19CC
....................          case 6: printf("\b\b\b\b\b\b\b\b\bDOMINGO  "); 
19B6:  CLRF   xA5
19B8:  MOVF   xA5,W
19BA:  CALL   06AC
19BE:  IORLW  00
19C0:  BZ    19CC
19C2:  INCF   xA5,F
19C4:  BTFSS  F9E.4
19C6:  BRA    19C4
19C8:  MOVWF  FAD
19CA:  BRA    19B8
....................       } 
....................    } 
19CC:  BRA    18FC
....................  
....................    //Pedimos la introducción de la fecha 
....................    printf("\rFECHA: "); 
19CE:  CLRF   xA5
19D0:  MOVF   xA5,W
19D2:  CALL   06DA
19D6:  IORLW  00
19D8:  BZ    19E4
19DA:  INCF   xA5,F
19DC:  BTFSS  F9E.4
19DE:  BRA    19DC
19E0:  MOVWF  FAD
19E2:  BRA    19D0
....................  
....................    //Leemos el día del mes 
....................    dia = buscar_numero_rs232(); 
19E4:  RCALL  15EA
19E6:  MOVFF  01,96
....................    //Si pulsamos "backspace", se resetea la inicialización 
....................    if(dia==NO) 
19EA:  MOVF   x96,W
19EC:  SUBLW  64
19EE:  BNZ   1A08
....................    { 
....................       printf("\rReseteando inicializacion...\r"); 
19F0:  CLRF   xA5
19F2:  MOVF   xA5,W
19F4:  CALL   06FE
19F8:  IORLW  00
19FA:  BZ    1A06
19FC:  INCF   xA5,F
19FE:  BTFSS  F9E.4
1A00:  BRA    19FE
1A02:  MOVWF  FAD
1A04:  BRA    19F2
....................       goto e1; 
1A06:  BRA    18B2
....................    } 
....................    //Si el día introducido no es válido, también reseteamos la inicialización 
....................    if(dia>31 || dia==0) 
1A08:  MOVF   x96,W
1A0A:  SUBLW  1F
1A0C:  BNC   1A12
1A0E:  MOVF   x96,F
1A10:  BNZ   1A38
....................    { 
....................       printf("\rDia incorrecto. Reseteando inicializacion...\r"); 
1A12:  CLRF   xA5
1A14:  MOVF   xA5,W
1A16:  CALL   0738
1A1A:  IORLW  00
1A1C:  BZ    1A28
1A1E:  INCF   xA5,F
1A20:  BTFSS  F9E.4
1A22:  BRA    1A20
1A24:  MOVWF  FAD
1A26:  BRA    1A14
....................       delay_ms(LCD_T_RETARDO); 
1A28:  MOVLW  02
1A2A:  MOVWF  xA5
1A2C:  MOVLW  FA
1A2E:  MOVWF  xAE
1A30:  RCALL  12A8
1A32:  DECFSZ xA5,F
1A34:  BRA    1A2C
....................       goto e1; 
1A36:  BRA    18B2
....................    } 
....................  
....................    //Leemos el mes 
....................    printf("/"); 
1A38:  CLRF   xA5
1A3A:  MOVF   xA5,W
1A3C:  CALL   0782
1A40:  IORLW  00
1A42:  BZ    1A4E
1A44:  INCF   xA5,F
1A46:  BTFSS  F9E.4
1A48:  BRA    1A46
1A4A:  MOVWF  FAD
1A4C:  BRA    1A3A
....................    mes = buscar_numero_rs232(); 
1A4E:  RCALL  15EA
1A50:  MOVFF  01,97
....................    //Si pulsamos "backspace", se resetea la inicialización 
....................    if(mes==NO) 
1A54:  MOVF   x97,W
1A56:  SUBLW  64
1A58:  BNZ   1A72
....................    { 
....................       printf("\rReseteando inicializacion...\r"); 
1A5A:  CLRF   xA5
1A5C:  MOVF   xA5,W
1A5E:  CALL   06FE
1A62:  IORLW  00
1A64:  BZ    1A70
1A66:  INCF   xA5,F
1A68:  BTFSS  F9E.4
1A6A:  BRA    1A68
1A6C:  MOVWF  FAD
1A6E:  BRA    1A5C
....................       goto e1; 
1A70:  BRA    18B2
....................    } 
....................    //Si el mes introducido no es válido, reseteamos la inicialización de igual modo 
....................    if(mes>12 || mes==0) 
1A72:  MOVF   x97,W
1A74:  SUBLW  0C
1A76:  BNC   1A7C
1A78:  MOVF   x97,F
1A7A:  BNZ   1AA2
....................    { 
....................       printf("\rMes incorrecto. Reseteando inicializacion...\r"); 
1A7C:  CLRF   xA5
1A7E:  MOVF   xA5,W
1A80:  CALL   079E
1A84:  IORLW  00
1A86:  BZ    1A92
1A88:  INCF   xA5,F
1A8A:  BTFSS  F9E.4
1A8C:  BRA    1A8A
1A8E:  MOVWF  FAD
1A90:  BRA    1A7E
....................       delay_ms(LCD_T_RETARDO); 
1A92:  MOVLW  02
1A94:  MOVWF  xA5
1A96:  MOVLW  FA
1A98:  MOVWF  xAE
1A9A:  RCALL  12A8
1A9C:  DECFSZ xA5,F
1A9E:  BRA    1A96
....................       goto e1; 
1AA0:  BRA    18B2
....................    } 
....................  
....................    //Si el día introducido no se encuentra en el mes seleccionado, mostramos un mensaje 
....................    //de error y reseteamos la operación 
....................    if((dia>29 && mes==2)||(dia==31 && (mes==4 || mes==6 || mes==9 || mes==11))) 
1AA2:  MOVF   x96,W
1AA4:  SUBLW  1D
1AA6:  BC    1AAE
1AA8:  MOVF   x97,W
1AAA:  SUBLW  02
1AAC:  BZ    1ACC
1AAE:  MOVF   x96,W
1AB0:  SUBLW  1F
1AB2:  BNZ   1AF4
1AB4:  MOVF   x97,W
1AB6:  SUBLW  04
1AB8:  BZ    1ACC
1ABA:  MOVF   x97,W
1ABC:  SUBLW  06
1ABE:  BZ    1ACC
1AC0:  MOVF   x97,W
1AC2:  SUBLW  09
1AC4:  BZ    1ACC
1AC6:  MOVF   x97,W
1AC8:  SUBLW  0B
1ACA:  BNZ   1AF4
....................    { 
....................       printf("\rError en la fecha. Reseteando inicializacion...\r"); 
1ACC:  CLRF   xA5
1ACE:  MOVF   xA5,W
1AD0:  CALL   07E8
1AD4:  IORLW  00
1AD6:  BZ    1AE2
1AD8:  INCF   xA5,F
1ADA:  BTFSS  F9E.4
1ADC:  BRA    1ADA
1ADE:  MOVWF  FAD
1AE0:  BRA    1ACE
....................       delay_ms(LCD_T_RETARDO); 
1AE2:  MOVLW  02
1AE4:  MOVWF  xA5
1AE6:  MOVLW  FA
1AE8:  MOVWF  xAE
1AEA:  CALL   12A8
1AEE:  DECFSZ xA5,F
1AF0:  BRA    1AE6
....................       goto e1; 
1AF2:  BRA    18B2
....................    } 
....................  
....................    //Leemos el año 
....................    printf("/"); 
1AF4:  CLRF   xA5
1AF6:  MOVF   xA5,W
1AF8:  CALL   0782
1AFC:  IORLW  00
1AFE:  BZ    1B0A
1B00:  INCF   xA5,F
1B02:  BTFSS  F9E.4
1B04:  BRA    1B02
1B06:  MOVWF  FAD
1B08:  BRA    1AF6
....................    anno = buscar_numero_rs232(); 
1B0A:  RCALL  15EA
1B0C:  MOVFF  01,98
....................    //Si pulsamos "backspace", se resetea la inicialización 
....................    if(anno==NO) 
1B10:  MOVF   x98,W
1B12:  SUBLW  64
1B14:  BNZ   1B3E
....................    { 
....................       printf("\rReseteando inicializacion...\r"); 
1B16:  CLRF   xA5
1B18:  MOVF   xA5,W
1B1A:  CALL   06FE
1B1E:  IORLW  00
1B20:  BZ    1B2C
1B22:  INCF   xA5,F
1B24:  BTFSS  F9E.4
1B26:  BRA    1B24
1B28:  MOVWF  FAD
1B2A:  BRA    1B18
....................       delay_ms(LCD_T_RETARDO); 
1B2C:  MOVLW  02
1B2E:  MOVWF  xA5
1B30:  MOVLW  FA
1B32:  MOVWF  xAE
1B34:  CALL   12A8
1B38:  DECFSZ xA5,F
1B3A:  BRA    1B30
....................       goto e1; 
1B3C:  BRA    18B2
....................    } 
....................    //Si el valor del año es incorrecto, reseteamos también la inicialización. 
....................    //Tampoco se permite un año menor que 2009 (año de fabricación del sistema de control) 
....................    if(anno>99 || anno<9) 
1B3E:  MOVF   x98,W
1B40:  SUBLW  63
1B42:  BNC   1B4A
1B44:  MOVF   x98,W
1B46:  SUBLW  08
1B48:  BNC   1B72
....................    { 
....................       printf("\rAnno incorrecto. Reseteando inicializacion...\r"); 
1B4A:  CLRF   xA5
1B4C:  MOVF   xA5,W
1B4E:  CALL   0834
1B52:  IORLW  00
1B54:  BZ    1B60
1B56:  INCF   xA5,F
1B58:  BTFSS  F9E.4
1B5A:  BRA    1B58
1B5C:  MOVWF  FAD
1B5E:  BRA    1B4C
....................       delay_ms(LCD_T_RETARDO); 
1B60:  MOVLW  02
1B62:  MOVWF  xA5
1B64:  MOVLW  FA
1B66:  MOVWF  xAE
1B68:  CALL   12A8
1B6C:  DECFSZ xA5,F
1B6E:  BRA    1B64
....................       goto e1; 
1B70:  BRA    18B2
....................    } 
....................  
....................  
....................    //Si el año no es bisiesto y hemos seleccionado el 29 de febrero, 
....................    //mostramos un mensaje y reseteamos la operación. 
....................    if(anno%4!=0 && mes==2 && dia==29) 
1B72:  MOVF   x98,W
1B74:  ANDLW  03
1B76:  BZ    1BAC
1B78:  MOVF   x97,W
1B7A:  SUBLW  02
1B7C:  BNZ   1BAC
1B7E:  MOVF   x96,W
1B80:  SUBLW  1D
1B82:  BNZ   1BAC
....................    { 
....................       printf("\rEl anno no es bisiesto. Reseteando inicializacion...\r"); 
1B84:  CLRF   xA5
1B86:  MOVF   xA5,W
1B88:  CALL   087E
1B8C:  IORLW  00
1B8E:  BZ    1B9A
1B90:  INCF   xA5,F
1B92:  BTFSS  F9E.4
1B94:  BRA    1B92
1B96:  MOVWF  FAD
1B98:  BRA    1B86
....................       delay_ms(LCD_T_RETARDO); 
1B9A:  MOVLW  02
1B9C:  MOVWF  xA5
1B9E:  MOVLW  FA
1BA0:  MOVWF  xAE
1BA2:  CALL   12A8
1BA6:  DECFSZ xA5,F
1BA8:  BRA    1B9E
....................       goto e1; 
1BAA:  BRA    18B2
....................    } 
....................  
....................    //Introducimos un pequeño retardo para que el técnico vea los valores introducidos 
....................    delay_ms(LCD_T_RETARDO); 
1BAC:  MOVLW  02
1BAE:  MOVWF  xA5
1BB0:  MOVLW  FA
1BB2:  MOVWF  xAE
1BB4:  CALL   12A8
1BB8:  DECFSZ xA5,F
1BBA:  BRA    1BB0
....................  
....................    //Calculamos el año en el intervalo de 0 a 3 según sean bisiesto este año 
....................    //o los anteriores. 
....................    if(anno%4==0) 
1BBC:  MOVF   x98,W
1BBE:  ANDLW  03
1BC0:  BNZ   1BC6
....................       anno_actual_0_to_3 = 0; 
1BC2:  CLRF   6C
....................    else if((anno-1)%4==0) 
1BC4:  BRA    1BEE
1BC6:  MOVLW  01
1BC8:  SUBWF  x98,W
1BCA:  ANDLW  03
1BCC:  BNZ   1BD4
....................       anno_actual_0_to_3 = 1; 
1BCE:  MOVLW  01
1BD0:  MOVWF  6C
....................    else if((anno-2)%4==0) 
1BD2:  BRA    1BEE
1BD4:  MOVLW  02
1BD6:  SUBWF  x98,W
1BD8:  ANDLW  03
1BDA:  BNZ   1BE2
....................       anno_actual_0_to_3 = 2; 
1BDC:  MOVLW  02
1BDE:  MOVWF  6C
....................    else if((anno-3)%4==0) 
1BE0:  BRA    1BEE
1BE2:  MOVLW  03
1BE4:  SUBWF  x98,W
1BE6:  ANDLW  03
1BE8:  BNZ   1BEE
....................       anno_actual_0_to_3 = 3; 
1BEA:  MOVLW  03
1BEC:  MOVWF  6C
....................  
....................    e2: 
....................    //Se pide la introducción de la hora 
....................    printf("\rHORA: "); 
1BEE:  CLRF   xA5
1BF0:  MOVF   xA5,W
1BF2:  CALL   08D0
1BF6:  IORLW  00
1BF8:  BZ    1C04
1BFA:  INCF   xA5,F
1BFC:  BTFSS  F9E.4
1BFE:  BRA    1BFC
1C00:  MOVWF  FAD
1C02:  BRA    1BF0
....................  
....................    //Leemos la hora 
....................    horas = buscar_numero_rs232(); 
1C04:  RCALL  15EA
1C06:  MOVFF  01,99
....................    //Si se pulsa "backspace", se resetea todo el proceso 
....................    if(horas==NO) 
1C0A:  MOVF   x99,W
1C0C:  SUBLW  64
1C0E:  BNZ   1C38
....................    { 
....................       printf("\rReseteando la inicializacion...\r"); 
1C10:  CLRF   xA5
1C12:  MOVF   xA5,W
1C14:  CALL   08F2
1C18:  IORLW  00
1C1A:  BZ    1C26
1C1C:  INCF   xA5,F
1C1E:  BTFSS  F9E.4
1C20:  BRA    1C1E
1C22:  MOVWF  FAD
1C24:  BRA    1C12
....................       delay_ms(LCD_T_RETARDO); 
1C26:  MOVLW  02
1C28:  MOVWF  xA5
1C2A:  MOVLW  FA
1C2C:  MOVWF  xAE
1C2E:  CALL   12A8
1C32:  DECFSZ xA5,F
1C34:  BRA    1C2A
....................       goto e1; 
1C36:  BRA    18B2
....................    } 
....................    //Si las horas son incorrectas, mostramos un mensaje de error por pantalla y 
....................    //reseteamos la introducción de la misma. 
....................    if(horas>23) 
1C38:  MOVF   x99,W
1C3A:  SUBLW  17
1C3C:  BC    1C66
....................    { 
....................       printf("  Hora incorrecta!"); 
1C3E:  CLRF   xA5
1C40:  MOVF   xA5,W
1C42:  CALL   092E
1C46:  IORLW  00
1C48:  BZ    1C54
1C4A:  INCF   xA5,F
1C4C:  BTFSS  F9E.4
1C4E:  BRA    1C4C
1C50:  MOVWF  FAD
1C52:  BRA    1C40
....................       delay_ms(LCD_T_RETARDO); 
1C54:  MOVLW  02
1C56:  MOVWF  xA5
1C58:  MOVLW  FA
1C5A:  MOVWF  xAE
1C5C:  CALL   12A8
1C60:  DECFSZ xA5,F
1C62:  BRA    1C58
....................       goto e2; 
1C64:  BRA    1BEE
....................    } 
....................  
....................  
....................    //Leemos los minutos 
....................    printf(":"); 
1C66:  CLRF   xA5
1C68:  MOVF   xA5,W
1C6A:  CALL   095C
1C6E:  IORLW  00
1C70:  BZ    1C7C
1C72:  INCF   xA5,F
1C74:  BTFSS  F9E.4
1C76:  BRA    1C74
1C78:  MOVWF  FAD
1C7A:  BRA    1C68
....................    minutos = buscar_numero_rs232(); 
1C7C:  RCALL  15EA
1C7E:  MOVFF  01,9A
....................  
....................    //Si se pulsa "backspace", reseteamos la inicialización completa 
....................    if(minutos==NO) 
1C82:  MOVF   x9A,W
1C84:  SUBLW  64
1C86:  BNZ   1CB0
....................    { 
....................       printf("\rReseteando la inicializacion...\r"); 
1C88:  CLRF   xA5
1C8A:  MOVF   xA5,W
1C8C:  CALL   08F2
1C90:  IORLW  00
1C92:  BZ    1C9E
1C94:  INCF   xA5,F
1C96:  BTFSS  F9E.4
1C98:  BRA    1C96
1C9A:  MOVWF  FAD
1C9C:  BRA    1C8A
....................       delay_ms(LCD_T_RETARDO); 
1C9E:  MOVLW  02
1CA0:  MOVWF  xA5
1CA2:  MOVLW  FA
1CA4:  MOVWF  xAE
1CA6:  CALL   12A8
1CAA:  DECFSZ xA5,F
1CAC:  BRA    1CA2
....................       goto e1; 
1CAE:  BRA    18B2
....................    } 
....................    //Si los minutos no son correctos, mostramos un mensaje de error por pantalla y 
....................    //reseteamos la introducción de los minutos 
....................    if(minutos>59) 
1CB0:  MOVF   x9A,W
1CB2:  SUBLW  3B
1CB4:  BC    1CDE
....................    { 
....................       printf("  Minutos incorrectos!"); 
1CB6:  CLRF   xA5
1CB8:  MOVF   xA5,W
1CBA:  CALL   0978
1CBE:  IORLW  00
1CC0:  BZ    1CCC
1CC2:  INCF   xA5,F
1CC4:  BTFSS  F9E.4
1CC6:  BRA    1CC4
1CC8:  MOVWF  FAD
1CCA:  BRA    1CB8
....................       delay_ms(LCD_T_RETARDO); 
1CCC:  MOVLW  02
1CCE:  MOVWF  xA5
1CD0:  MOVLW  FA
1CD2:  MOVWF  xAE
1CD4:  CALL   12A8
1CD8:  DECFSZ xA5,F
1CDA:  BRA    1CD0
....................       goto e2; 
1CDC:  BRA    1BEE
....................    } 
....................  
....................    //Introducimos un pequeño retardo para que el técnico pueda ver la hora introducida 
....................    delay_ms(LCD_T_RETARDO); 
1CDE:  MOVLW  02
1CE0:  MOVWF  xA5
1CE2:  MOVLW  FA
1CE4:  MOVWF  xAE
1CE6:  CALL   12A8
1CEA:  DECFSZ xA5,F
1CEC:  BRA    1CE2
....................  
....................    //Mostramos un mensaje de guardado de configuración 
....................    printf("\rGuardando configuracion..."); 
1CEE:  CLRF   xA5
1CF0:  MOVF   xA5,W
1CF2:  CALL   09AA
1CF6:  IORLW  00
1CF8:  BZ    1D04
1CFA:  INCF   xA5,F
1CFC:  BTFSS  F9E.4
1CFE:  BRA    1CFC
1D00:  MOVWF  FAD
1D02:  BRA    1CF0
....................  
....................    //Almacenamos todo en la estructura que contiene la información del tiempo 
....................    tiempo.month   = mes; 
1D04:  MOVFF  97,5F
....................    tiempo.day     = dia; 
1D08:  MOVFF  96,5E
....................    tiempo.year    = anno_actual_0_to_3; 
1D0C:  MOVFF  6C,60
....................    tiempo.hours   = horas; 
1D10:  MOVFF  99,5D
....................    tiempo.minutes = minutos; 
1D14:  MOVFF  9A,5C
....................    tiempo.seconds = 0x00; 
1D18:  CLRF   5B
....................    tiempo.weekday = weekday; 
1D1A:  MOVFF  95,61
....................  
....................    //Fijamos el reloj a esa fecha y hora 
....................    PCF8583_set_datetime(&tiempo); 
1D1E:  CLRF   xA6
1D20:  MOVLW  5B
1D22:  MOVWF  xA5
1D24:  BRA    16C8
....................  
....................    //Establecemos los parámetros iniciales del sistema para resetear la memoria 
....................    termostato1 = termostato2 = (float)20; 
1D26:  CLRF   27
1D28:  CLRF   26
1D2A:  MOVLW  20
1D2C:  MOVWF  25
1D2E:  MOVLW  83
1D30:  MOVWF  24
1D32:  MOVFF  27,23
1D36:  MOVFF  26,22
1D3A:  MOVFF  25,21
1D3E:  MOVFF  24,20
....................    num_intervalos = 0; 
1D42:  CLRF   59
....................    num_registros = 0; 
1D44:  CLRF   6A
1D46:  CLRF   69
....................    anno_actual = anno; 
1D48:  MOVFF  98,6B
....................  
....................    //Escribimos los datos en la EEPROM, almacenando antes en un vector para 
....................    //agilizar la escritura por ráfaga 
....................    data[0] = (int)termostato1; 
1D4C:  MOVFF  23,A8
1D50:  MOVFF  22,A7
1D54:  MOVFF  21,A6
1D58:  MOVFF  20,A5
1D5C:  RCALL  17F2
1D5E:  MOVFF  01,9B
....................    data[1] = num_intervalos; 
1D62:  MOVFF  59,9C
....................    data[2] = (int)(num_registros/256); 
1D66:  MOVF   6A,W
1D68:  MOVWF  x9D
....................    data[3] = (int)(num_registros - data[0]*256); 
1D6A:  CLRF   xB3
1D6C:  MOVFF  9B,B2
1D70:  MOVLW  01
1D72:  MOVWF  xB5
1D74:  CLRF   xB4
1D76:  RCALL  182C
1D78:  MOVF   01,W
1D7A:  SUBWF  69,W
1D7C:  MOVWF  00
1D7E:  MOVF   02,W
1D80:  SUBWFB 6A,W
1D82:  MOVFF  00,9E
....................    data[4] = anno_actual; 
1D86:  MOVFF  6B,9F
....................    data[5] = anno_actual_0_to_3; 
1D8A:  MOVFF  6C,A0
....................  
....................    graba_ee(eeprom_termostato, 6, data); 
1D8E:  CLRF   xA8
1D90:  MOVLW  10
1D92:  MOVWF  xA7
1D94:  MOVLW  06
1D96:  MOVWF  xA9
1D98:  CLRF   xAB
1D9A:  MOVLW  9B
1D9C:  MOVWF  xAA
1D9E:  RCALL  184A
....................  
....................    //Mostramos un mensaje de inicio del sistema 
....................    printf("\rIniciando sistema...\r"); 
1DA0:  CLRF   xA5
1DA2:  MOVF   xA5,W
1DA4:  CALL   09E0
1DA8:  IORLW  00
1DAA:  BZ    1DB6
1DAC:  INCF   xA5,F
1DAE:  BTFSS  F9E.4
1DB0:  BRA    1DAE
1DB2:  MOVWF  FAD
1DB4:  BRA    1DA2
....................  
.................... } 
1DB6:  GOTO   5D60 (RETURN)
....................  
.................... //----------------------------------------------------------------------------------------------------------------------------------------- 
....................  
.................... void leer_programaciones(){ 
....................    int datos[5];    //Vector para almacenar los datos recuperados 
....................    programacion pr;  //Variable temporal para guardar la programación 
....................    int contador;    //Contador del bucle 
....................  
....................    //Se supone que antes ha sido recuperado el número de intervalos 
....................    //Recorremos todas las programaciones guardadas 
....................    for(contador=0; contador<num_intervalos; contador++) 
....................    { 
....................       //Leemos de memoria 
....................       lee_ee(eeprom_programaciones + (contador+1)*8, 5, datos); 
....................  
....................       //Guardamos los datos en la programación 
....................       pr.horas_inicio   = datos[0]; 
....................       pr.minutos_inicio = datos[1]; 
....................       pr.horas_fin      = datos[2]; 
....................       pr.minutos_fin    = datos[3]; 
....................       pr.termostato     = datos[4]; 
....................  
....................       //Guardamos la programación en el vector correspondiente 
....................       programaciones[contador] = pr; 
....................  
....................    } 
....................  
.................... } 
....................  
.................... //----------------------------------------------------------------------------------------------------------------------------------------- 
....................  
.................... void mostrar_temperatura() 
.................... { 
....................    //Leemos el tiempo y lo guardamos en la variable tiempo 
....................    PCF8583_read_datetime(&tiempo); 
*
5A2A:  CLRF   xA2
5A2C:  MOVLW  5B
5A2E:  MOVWF  xA1
5A30:  CALL   2764
....................    //Activamos las interrupciones, que se desactivan dentro del método 
....................    //enable_interrupts(GLOBAL); 
....................  
....................    //Mostramos la temperatura registrada 
....................    lcd_send_byte(LCD_ORDEN, LCD_CLEAR); 
5A34:  CLRF   xAC
5A36:  MOVLW  01
5A38:  MOVWF  xAD
5A3A:  CALL   1314
....................    printf(lcd_putc, "%3.1f%cC  %3.1f%cC\nHORA - ", temperatura1, 223, temperatura2, 223); 
5A3E:  MOVLW  02
5A40:  MOVWF  FE9
5A42:  MOVFF  2F,9D
5A46:  MOVFF  2E,9C
5A4A:  MOVFF  2D,9B
5A4E:  MOVFF  2C,9A
5A52:  MOVLW  01
5A54:  MOVWF  x9E
5A56:  CALL   32F0
5A5A:  MOVLW  DF
5A5C:  MOVWF  xA7
5A5E:  CALL   13C0
5A62:  MOVLW  43
5A64:  MOVWF  xA7
5A66:  CALL   13C0
5A6A:  MOVLW  20
5A6C:  MOVWF  xA7
5A6E:  CALL   13C0
5A72:  MOVLW  20
5A74:  MOVWF  xA7
5A76:  CALL   13C0
5A7A:  MOVLW  02
5A7C:  MOVWF  FE9
5A7E:  MOVFF  33,9D
5A82:  MOVFF  32,9C
5A86:  MOVFF  31,9B
5A8A:  MOVFF  30,9A
5A8E:  MOVLW  01
5A90:  MOVWF  x9E
5A92:  CALL   32F0
5A96:  MOVLW  DF
5A98:  MOVWF  xA7
5A9A:  CALL   13C0
5A9E:  MOVLW  11
5AA0:  MOVWF  x96
5AA2:  MOVF   x96,W
5AA4:  CALL   0A12
5AA8:  INCF   x96,F
5AAA:  MOVWF  00
5AAC:  MOVWF  xA7
5AAE:  CALL   13C0
5AB2:  MOVLW  1A
5AB4:  SUBWF  x96,W
5AB6:  BNZ   5AA2
....................  
....................    //Mostramos la hora 
....................    //Comprobamos si los valores son menores que 10 para añadir un cero 
....................    //delante y que queden los valores alineados 
....................    if(tiempo.hours < 10) 
5AB8:  MOVF   5D,W
5ABA:  SUBLW  09
5ABC:  BNC   5AD4
....................       printf(lcd_putc, "0"); 
5ABE:  CLRF   x96
5AC0:  MOVF   x96,W
5AC2:  CALL   0A48
5AC6:  IORLW  00
5AC8:  BZ    5AD4
5ACA:  INCF   x96,F
5ACC:  MOVWF  xA7
5ACE:  CALL   13C0
5AD2:  BRA    5AC0
....................    printf(lcd_putc, "%u:", tiempo.hours); 
5AD4:  MOVFF  5D,96
5AD8:  MOVLW  1B
5ADA:  MOVWF  x97
5ADC:  RCALL  59B2
5ADE:  MOVLW  3A
5AE0:  MOVWF  xA7
5AE2:  CALL   13C0
....................    if(tiempo.minutes < 10) 
5AE6:  MOVF   5C,W
5AE8:  SUBLW  09
5AEA:  BNC   5B02
....................       printf(lcd_putc, "0"); 
5AEC:  CLRF   x96
5AEE:  MOVF   x96,W
5AF0:  CALL   0A48
5AF4:  IORLW  00
5AF6:  BZ    5B02
5AF8:  INCF   x96,F
5AFA:  MOVWF  xA7
5AFC:  CALL   13C0
5B00:  BRA    5AEE
....................    printf(lcd_putc, "%u", tiempo.minutes); 
5B02:  MOVFF  5C,96
5B06:  MOVLW  1B
5B08:  MOVWF  x97
5B0A:  RCALL  59B2
.................... } 
5B0C:  GOTO   5B46 (RETURN)
....................  
.................... //----------------------------------------------------------------------------------------------------------------------------------------- 
....................  
.................... void ordenar_programaciones() 
.................... { 
....................    //Variables temporales y contadores auxiliares 
....................    programacion *pr1; 
....................    programacion *pr2; 
....................    int contador1, contador2; 
....................    int h_inicio_1, min_inicio_1, h_inicio_2, min_inicio_2; 
....................  
....................    //Ambos punteros comienzan apuntando al principio de programaciones 
....................    pr1 = programaciones; 
*
360E:  CLRF   x96
3610:  MOVLW  3B
3612:  MOVWF  x95
....................    pr2 = programaciones; 
3614:  CLRF   x98
3616:  MOVWF  x97
....................  
....................  
....................    //Algoritmo de la burbuja 
....................    for(contador1=0; contador1 < num_intervalos; contador1++) 
3618:  CLRF   x99
361A:  MOVF   59,W
361C:  SUBWF  x99,W
361E:  BTFSC  FD8.0
3620:  BRA    3742
....................    { 
....................       //Apuntamos a las dos últimas posiciones del vector 
....................       pr1 = programaciones+num_intervalos-2; 
3622:  MOVF   59,W
3624:  MULLW  05
3626:  MOVF   FF3,W
3628:  ADDLW  3B
362A:  MOVWF  xA4
362C:  CLRF   xA5
362E:  BTFSC  FD8.0
3630:  INCF   xA5,F
3632:  MOVLW  0A
3634:  SUBWF  xA4,W
3636:  MOVWF  x95
3638:  MOVLW  00
363A:  SUBWFB xA5,W
363C:  MOVWF  x96
....................       pr2 = programaciones+num_intervalos-1; 
363E:  MOVF   59,W
3640:  MULLW  05
3642:  MOVF   FF3,W
3644:  ADDLW  3B
3646:  MOVWF  xA4
3648:  CLRF   xA5
364A:  BTFSC  FD8.0
364C:  INCF   xA5,F
364E:  MOVLW  05
3650:  SUBWF  xA4,W
3652:  MOVWF  x97
3654:  MOVLW  00
3656:  SUBWFB xA5,W
3658:  MOVWF  x98
....................  
....................       //Iteramos hasta llegar a la zona ordenada del vector 
....................       for(contador2=0; contador2 < num_intervalos-contador1-1; contador2++) 
365A:  CLRF   x9A
365C:  MOVF   x99,W
365E:  SUBWF  59,W
3660:  ADDLW  FF
3662:  SUBWF  x9A,W
3664:  BC    373E
....................       { 
....................          //Tomamos para la comparación los instantes de inicio 
....................          h_inicio_1   = (*pr1).horas_inicio; 
3666:  MOVFF  95,FE9
366A:  MOVFF  96,FEA
366E:  MOVFF  FEF,9B
....................          min_inicio_1 = (*pr1).minutos_inicio; 
3672:  MOVLW  01
3674:  ADDWF  x95,W
3676:  MOVWF  FE9
3678:  MOVLW  00
367A:  ADDWFC x96,W
367C:  MOVWF  FEA
367E:  MOVFF  FEF,9C
....................          h_inicio_2   = (*pr2).horas_inicio; 
3682:  MOVFF  97,FE9
3686:  MOVFF  98,FEA
368A:  MOVFF  FEF,9D
....................          min_inicio_2 = (*pr2).minutos_inicio; 
368E:  MOVLW  01
3690:  ADDWF  x97,W
3692:  MOVWF  FE9
3694:  MOVLW  00
3696:  ADDWFC x98,W
3698:  MOVWF  FEA
369A:  MOVFF  FEF,9E
....................  
....................          //Si la hora de pr2 es menor que la de pr1, habrá que intercambiar los 
....................          //valores para mover la menor a una posición más baja 
....................          if(comprobar_hora(h_inicio_2, min_inicio_2, h_inicio_1, min_inicio_1)) 
369E:  MOVFF  9D,AB
36A2:  MOVFF  9E,AC
36A6:  MOVFF  9B,AD
36AA:  MOVFF  9C,AE
36AE:  CALL   2AEA
36B2:  MOVF   01,F
36B4:  BZ    372A
....................          { 
....................             programacion temporal; 
....................             temporal = *pr1; 
36B6:  MOVFF  96,03
36BA:  MOVFF  95,A4
36BE:  MOVFF  96,A5
36C2:  CLRF   FEA
36C4:  MOVLW  9F
36C6:  MOVWF  FE9
36C8:  MOVFF  96,FE2
36CC:  MOVFF  95,FE1
36D0:  MOVLW  05
36D2:  MOVWF  01
36D4:  MOVFF  FE6,FEE
36D8:  DECFSZ 01,F
36DA:  BRA    36D4
....................             *pr1 = *pr2; 
36DC:  MOVFF  95,A6
36E0:  MOVFF  96,A7
36E4:  MOVFF  98,03
36E8:  MOVFF  97,A8
36EC:  MOVFF  98,A9
36F0:  MOVFF  96,FEA
36F4:  MOVFF  95,FE9
36F8:  MOVFF  98,FE2
36FC:  MOVFF  97,FE1
3700:  MOVLW  05
3702:  MOVWF  01
3704:  MOVFF  FE6,FEE
3708:  DECFSZ 01,F
370A:  BRA    3704
....................             *pr2 = temporal; 
370C:  MOVFF  98,03
3710:  MOVFF  97,FE9
3714:  MOVFF  03,FEA
3718:  CLRF   FE2
371A:  MOVLW  9F
371C:  MOVWF  FE1
371E:  MOVLW  05
3720:  MOVWF  01
3722:  MOVFF  FE6,FEE
3726:  DECFSZ 01,F
3728:  BRA    3722
....................          } 
....................  
....................          //Pasamos a la siguiente posición y repetimos el proceso 
....................          pr1--; 
372A:  MOVLW  FB
372C:  ADDWF  x95,F
372E:  BTFSS  FD8.0
3730:  DECF   x96,F
....................          pr2--; 
3732:  MOVLW  FB
3734:  ADDWF  x97,F
3736:  BTFSS  FD8.0
3738:  DECF   x98,F
....................       } 
373A:  INCF   x9A,F
373C:  BRA    365C
....................    } 
373E:  INCF   x99,F
3740:  BRA    361A
.................... } 
3742:  GOTO   69FC (RETURN)
....................  
.................... //----------------------------------------------------------------------------------------------------------------------------------------- 
....................  
.................... void programar_proxima_alarma() 
.................... { 
....................    //Variables auxiliares 
....................    int hora, minutos; 
....................  
....................    //Recuperamos los datos de inicio de la alarma actual 
....................    prg=programaciones[posicion_alarmas]; 
*
29AA:  MOVF   5A,W
29AC:  MULLW  05
29AE:  MOVF   FF3,W
29B0:  CLRF   03
29B2:  ADDLW  3B
29B4:  MOVWF  01
29B6:  MOVLW  00
29B8:  ADDWFC 03,F
29BA:  MOVFF  01,97
29BE:  MOVFF  03,98
29C2:  CLRF   FEA
29C4:  MOVLW  54
29C6:  MOVWF  FE9
29C8:  MOVFF  03,FE2
29CC:  MOVFF  01,FE1
29D0:  MOVLW  05
29D2:  MOVWF  01
29D4:  MOVFF  FE6,FEE
29D8:  DECFSZ 01,F
29DA:  BRA    29D4
....................    hora = prg.horas_inicio; 
29DC:  MOVFF  54,95
....................    minutos = prg.minutos_inicio; 
29E0:  MOVFF  55,96
....................  
....................    //Establecemos la alarma a ese tiempo 
....................    PCF8583_establecer_alarma(hora, minutos, 0); 
29E4:  MOVFF  95,97
29E8:  MOVFF  96,98
29EC:  CLRF   x99
29EE:  RCALL  2912
....................    //Habilitamos interrupciones (se desactivan en el método anterior) 
....................    //enable_interrupts(GLOBAL); 
.................... } 
29F0:  RETLW  00
....................  
.................... //----------------------------------------------------------------------------------------------------------------------------------------- 
....................  
.................... void representar_registros() 
.................... { 
....................    //Contadores y variables auxiliares 
....................    int contador, contador2; 
....................    unsigned int data[8], data2[4]; 
....................  
....................    float media_dia_mes[12];         //Tiempos medios en minutos que se enciende el sistema en cada mes 
....................    int dias_meses[12];              //Número de dias que tiene cada mes 
....................    float media_dia_caldera;         //Tiempo medio que se enciende la caldera cada día 
....................    float valor;                     //Tiempo medio en minutos que se enciende el sistema por día 
....................    float media_dia_mes_caldera[12]; //Tiempo medio que se enciende la caldera en cada mes 
....................  
....................    unsigned long valor_total;  //Tiempo total de encendido de la caldera 
....................    unsigned long valor_total_caldera; //Tiempo total de encendido del sistema 
....................  
....................    //Capacidad para 4 años de datos 
....................    //Vectores de almacenamiento de los datos anuales 
....................    float media_annos[4][12]; 
....................    float media_annos_caldera[4][12]; 
....................    //Número de años de los que se tienen datos 
....................    int num_annos; 
....................    //Años correspondientes 
....................    int annos[4]; 
....................  
....................    //Variables para almacenar valores provisionales 
....................    long tiempo_x_dia;         //Tiempo que se enciende cada día el sistema (minutos) 
....................    long tiempo_x_dia_caldera; //Tiempo que se enciende cada día la caldera (minutos) 
....................    int dia[3];               //Día con el que estamos trabajando (día/mes/año) 
....................    long num_dias;             //Número de días que llevamos analizados 
....................  
....................    //dias_meses = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}; 
....................    dias_meses[0] = dias_meses[2] = dias_meses[4] = dias_meses[6] = dias_meses[7] = dias_meses[9] = dias_meses[11] = 31; 
*
3BCE:  MOVLW  1F
3BD0:  MOVWF  xDE
3BD2:  MOVFF  DE,DC
3BD6:  MOVFF  DC,DA
3BDA:  MOVFF  DA,D9
3BDE:  MOVFF  D9,D7
3BE2:  MOVFF  D7,D5
3BE6:  MOVFF  D5,D3
....................    dias_meses[1] = 28; 
3BEA:  MOVLW  1C
3BEC:  MOVWF  xD4
....................    dias_meses[3] = dias_meses[5] = dias_meses[8] = dias_meses[10] = 30; 
3BEE:  MOVLW  1E
3BF0:  MOVWF  xDD
3BF2:  MOVFF  DD,DB
3BF6:  MOVFF  DB,D8
3BFA:  MOVFF  D8,D6
....................  
....................    //Inicializamos los vectores a 0 
....................    for(contador=0; contador<12;contador++) 
3BFE:  CLRF   x95
3C00:  MOVF   x95,W
3C02:  SUBLW  0B
3C04:  BNC   3C24
....................    { 
....................       media_dia_mes[contador]=0; 
3C06:  MOVF   x95,W
3C08:  MULLW  04
3C0A:  MOVF   FF3,W
3C0C:  CLRF   03
3C0E:  ADDLW  A3
3C10:  MOVWF  FE9
3C12:  MOVLW  00
3C14:  ADDWFC 03,W
3C16:  MOVWF  FEA
3C18:  CLRF   FEF
3C1A:  CLRF   FEC
3C1C:  CLRF   FEC
3C1E:  CLRF   FEC
....................    } 
3C20:  INCF   x95,F
3C22:  BRA    3C00
....................  
....................    for(contador=0; contador<12;contador++) 
3C24:  CLRF   x95
3C26:  MOVF   x95,W
3C28:  SUBLW  0B
3C2A:  BNC   3C4A
....................    { 
....................       media_dia_mes_caldera[contador]=0; 
3C2C:  MOVF   x95,W
3C2E:  MULLW  04
3C30:  MOVF   FF3,W
3C32:  CLRF   03
3C34:  ADDLW  E7
3C36:  MOVWF  FE9
3C38:  MOVLW  00
3C3A:  ADDWFC 03,W
3C3C:  MOVWF  FEA
3C3E:  CLRF   FEF
3C40:  CLRF   FEC
3C42:  CLRF   FEC
3C44:  CLRF   FEC
....................    } 
3C46:  INCF   x95,F
3C48:  BRA    3C26
....................  
....................    for(contador=0; contador<4 ;contador++) 
3C4A:  CLRF   x95
3C4C:  MOVF   x95,W
3C4E:  SUBLW  03
3C50:  BNC   3C98
....................    { 
....................       for(contador2=0; contador2<12 ;contador2++) 
3C52:  CLRF   x96
3C54:  MOVF   x96,W
3C56:  SUBLW  0B
3C58:  BNC   3C94
....................       { 
....................          media_annos[contador][contador2]=0; 
3C5A:  MOVF   x95,W
3C5C:  MULLW  30
3C5E:  MOVF   FF3,W
3C60:  MOVLB  2
3C62:  CLRF   xAA
3C64:  MOVWF  xA9
3C66:  MOVLB  0
3C68:  MOVF   x96,W
3C6A:  MULLW  04
3C6C:  MOVF   FF3,W
3C6E:  CLRF   03
3C70:  MOVLB  2
3C72:  ADDWF  xA9,W
3C74:  MOVWF  01
3C76:  MOVF   xAA,W
3C78:  ADDWFC 03,F
3C7A:  MOVF   01,W
3C7C:  ADDLW  1B
3C7E:  MOVWF  FE9
3C80:  MOVLW  01
3C82:  ADDWFC 03,W
3C84:  MOVWF  FEA
3C86:  CLRF   FEF
3C88:  CLRF   FEC
3C8A:  CLRF   FEC
3C8C:  CLRF   FEC
....................       } 
3C8E:  MOVLB  0
3C90:  INCF   x96,F
3C92:  BRA    3C54
....................    } 
3C94:  INCF   x95,F
3C96:  BRA    3C4C
....................  
....................    for(contador=0; contador<4 ;contador++) 
3C98:  CLRF   x95
3C9A:  MOVF   x95,W
3C9C:  SUBLW  03
3C9E:  BNC   3CE6
....................    { 
....................       for(contador2=0; contador2<12 ;contador2++) 
3CA0:  CLRF   x96
3CA2:  MOVF   x96,W
3CA4:  SUBLW  0B
3CA6:  BNC   3CE2
....................       { 
....................          media_annos_caldera[contador][contador2]=0; 
3CA8:  MOVF   x95,W
3CAA:  MULLW  30
3CAC:  MOVF   FF3,W
3CAE:  MOVLB  2
3CB0:  CLRF   xAA
3CB2:  MOVWF  xA9
3CB4:  MOVLB  0
3CB6:  MOVF   x96,W
3CB8:  MULLW  04
3CBA:  MOVF   FF3,W
3CBC:  CLRF   03
3CBE:  MOVLB  2
3CC0:  ADDWF  xA9,W
3CC2:  MOVWF  01
3CC4:  MOVF   xAA,W
3CC6:  ADDWFC 03,F
3CC8:  MOVF   01,W
3CCA:  ADDLW  DB
3CCC:  MOVWF  FE9
3CCE:  MOVLW  01
3CD0:  ADDWFC 03,W
3CD2:  MOVWF  FEA
3CD4:  CLRF   FEF
3CD6:  CLRF   FEC
3CD8:  CLRF   FEC
3CDA:  CLRF   FEC
....................       } 
3CDC:  MOVLB  0
3CDE:  INCF   x96,F
3CE0:  BRA    3CA2
....................    } 
3CE2:  INCF   x95,F
3CE4:  BRA    3C9A
....................  
....................    //Iniciamos a cero las otras variables 
....................    dia[0] = dia[1] = dia[2] = 0; 
3CE6:  MOVLB  2
3CE8:  CLRF   xA6
3CEA:  MOVFF  2A6,2A5
3CEE:  MOVFF  2A5,2A4
....................    num_dias = 0; 
3CF2:  CLRF   xA8
3CF4:  CLRF   xA7
....................    num_annos = 0; 
3CF6:  CLRF   x9B
....................  
....................    media_dia_caldera = 0; 
3CF8:  MOVLB  0
3CFA:  CLRF   xE2
3CFC:  CLRF   xE1
3CFE:  CLRF   xE0
3D00:  CLRF   xDF
....................    valor = 0; 
3D02:  CLRF   xE6
3D04:  CLRF   xE5
3D06:  CLRF   xE4
3D08:  CLRF   xE3
....................    valor_total = 0; 
3D0A:  MOVLB  1
3D0C:  CLRF   x18
3D0E:  CLRF   x17
....................    valor_total_caldera = 0; 
3D10:  CLRF   x1A
3D12:  CLRF   x19
....................  
....................    //Imprimimos el encabezamiento 
....................    printf("\rREGISTRO DE EVENTOS\r"); 
3D14:  MOVLB  2
3D16:  CLRF   xA9
3D18:  MOVF   xA9,W
3D1A:  MOVLB  0
3D1C:  CALL   0A64
3D20:  IORLW  00
3D22:  BZ    3D32
3D24:  MOVLB  2
3D26:  INCF   xA9,F
3D28:  BTFSS  F9E.4
3D2A:  BRA    3D28
3D2C:  MOVWF  FAD
3D2E:  BRA    3D18
3D30:  MOVLB  0
....................    printf("*******************\r"); 
3D32:  MOVLB  2
3D34:  CLRF   xA9
3D36:  MOVF   xA9,W
3D38:  MOVLB  0
3D3A:  CALL   0A94
3D3E:  IORLW  00
3D40:  BZ    3D50
3D42:  MOVLB  2
3D44:  INCF   xA9,F
3D46:  BTFSS  F9E.4
3D48:  BRA    3D46
3D4A:  MOVWF  FAD
3D4C:  BRA    3D36
3D4E:  MOVLB  0
....................    printf("Momento de apagado     Temperatura1       Temperatura2         Termostato        Minutos encendido       Minutos caldera\r"); 
3D50:  MOVLB  2
3D52:  CLRF   xA9
3D54:  MOVF   xA9,W
3D56:  MOVLB  0
3D58:  CALL   0AC4
3D5C:  IORLW  00
3D5E:  BZ    3D6E
3D60:  MOVLB  2
3D62:  INCF   xA9,F
3D64:  BTFSS  F9E.4
3D66:  BRA    3D64
3D68:  MOVWF  FAD
3D6A:  BRA    3D54
3D6C:  MOVLB  0
....................    printf("===========================================================================================================================\r"); 
3D6E:  MOVLB  2
3D70:  CLRF   xA9
3D72:  MOVF   xA9,W
3D74:  MOVLB  0
3D76:  CALL   0B58
3D7A:  IORLW  00
3D7C:  BZ    3D8C
3D7E:  MOVLB  2
3D80:  INCF   xA9,F
3D82:  BTFSS  F9E.4
3D84:  BRA    3D82
3D86:  MOVWF  FAD
3D88:  BRA    3D72
3D8A:  MOVLB  0
....................  
....................    //Recorremos todos los registros almacenados 
....................    for(contador=0; contador<num_registros; contador++) 
3D8C:  CLRF   x95
3D8E:  MOVF   6A,F
3D90:  BNZ   3D9C
3D92:  MOVF   69,W
3D94:  SUBWF  x95,W
3D96:  BTFSC  FD8.0
3D98:  GOTO   4562
....................    { 
....................       //Comenzamos leyendo los datos de memoria 
....................       lee_ee((unsigned long)eeprom_registros + (unsigned long)contador*(unsigned long)2*(unsigned long)8, 8, data); 
3D9C:  MOVLB  2
3D9E:  CLRF   xAA
3DA0:  MOVFF  95,2A9
3DA4:  BCF    FD8.0
3DA6:  RLCF   xA9,W
3DA8:  MOVWF  xAB
3DAA:  RLCF   xAA,W
3DAC:  MOVWF  xAC
3DAE:  RLCF   xAB,W
3DB0:  MOVWF  02
3DB2:  RLCF   xAC,W
3DB4:  MOVWF  03
3DB6:  RLCF   02,F
3DB8:  RLCF   03,F
3DBA:  RLCF   02,F
3DBC:  RLCF   03,F
3DBE:  MOVLW  F8
3DC0:  ANDWF  02,F
3DC2:  MOVF   02,W
3DC4:  ADDLW  50
3DC6:  MOVWF  xAD
3DC8:  MOVLW  00
3DCA:  ADDWFC 03,W
3DCC:  MOVWF  xAE
3DCE:  MOVWF  xB2
3DD0:  MOVFF  2AD,2B1
3DD4:  MOVLW  08
3DD6:  MOVWF  xB3
3DD8:  CLRF   xB5
3DDA:  MOVLW  97
3DDC:  MOVWF  xB4
3DDE:  MOVLB  0
3DE0:  RCALL  3850
....................       lee_ee((unsigned long)eeprom_registros + (unsigned long)contador*(unsigned long)2*(unsigned long)8 + (unsigned long)8, 4, data2); 
3DE2:  MOVLB  2
3DE4:  CLRF   xAA
3DE6:  MOVFF  95,2A9
3DEA:  BCF    FD8.0
3DEC:  RLCF   xA9,W
3DEE:  MOVWF  xAB
3DF0:  RLCF   xAA,W
3DF2:  MOVWF  xAC
3DF4:  RLCF   xAB,W
3DF6:  MOVWF  02
3DF8:  RLCF   xAC,W
3DFA:  MOVWF  03
3DFC:  RLCF   02,F
3DFE:  RLCF   03,F
3E00:  RLCF   02,F
3E02:  RLCF   03,F
3E04:  MOVLW  F8
3E06:  ANDWF  02,F
3E08:  MOVF   02,W
3E0A:  ADDLW  50
3E0C:  MOVWF  xAD
3E0E:  MOVLW  00
3E10:  ADDWFC 03,W
3E12:  MOVWF  xAE
3E14:  MOVLW  08
3E16:  ADDWF  xAD,W
3E18:  MOVWF  xAF
3E1A:  MOVLW  00
3E1C:  ADDWFC xAE,W
3E1E:  MOVWF  xB0
3E20:  MOVWF  xB2
3E22:  MOVFF  2AF,2B1
3E26:  MOVLW  04
3E28:  MOVWF  xB3
3E2A:  CLRF   xB5
3E2C:  MOVLW  9F
3E2E:  MOVWF  xB4
3E30:  MOVLB  0
3E32:  RCALL  3850
....................  
....................       //Si cambiamos de día debemos gestionar los datos del nuevo día y almacenar los del anterior 
....................       if(dia[0]!=data[0] || dia[1]!=data[1] || dia[2]!=data2[0]) 
3E34:  MOVF   x97,W
3E36:  MOVLB  2
3E38:  SUBWF  xA4,W
3E3A:  BNZ   3E52
3E3C:  MOVLB  0
3E3E:  MOVF   x98,W
3E40:  MOVLB  2
3E42:  SUBWF  xA5,W
3E44:  BNZ   3E52
3E46:  MOVLB  0
3E48:  MOVF   x9F,W
3E4A:  MOVLB  2
3E4C:  SUBWF  xA6,W
3E4E:  BTFSC  FD8.2
3E50:  BRA    41C8
....................       { 
....................          //Lógicamente, no tenemos en cuenta para la media los días en los que no se enciende: 
....................          //días de verano, calurosos, etc. Esta información puede visualizarse en la media 
....................          //por meses. 
....................          //Guardamos los datos del día anterior si el día no es el primero 
....................          if(dia[0]!=0) 
3E52:  MOVF   xA4,F
3E54:  BZ    3F2A
....................          { 
....................             //En la media de tiempo por día, acumulamos el tiempo que ha estado encendido el último día 
....................             valor = valor + (float)tiempo_x_dia; 
3E56:  MOVFF  2A1,2B0
3E5A:  MOVFF  2A0,2AF
3E5E:  MOVLB  0
3E60:  CALL   26A2
3E64:  BCF    FD8.1
3E66:  MOVFF  E6,2AC
3E6A:  MOVFF  E5,2AB
3E6E:  MOVFF  E4,2AA
3E72:  MOVFF  E3,2A9
3E76:  MOVFF  03,2B0
3E7A:  MOVFF  02,2AF
3E7E:  MOVFF  01,2AE
3E82:  MOVFF  00,2AD
3E86:  CALL   2428
3E8A:  MOVFF  03,E6
3E8E:  MOVFF  02,E5
3E92:  MOVFF  01,E4
3E96:  MOVFF  00,E3
....................             //Guardamos también este valor en el registro del año 
....................             media_dia_mes[dia[1]-1] = valor; 
3E9A:  MOVLW  01
3E9C:  MOVLB  2
3E9E:  SUBWF  xA5,W
3EA0:  MULLW  04
3EA2:  MOVF   FF3,W
3EA4:  CLRF   03
3EA6:  ADDLW  A3
3EA8:  MOVWF  FE9
3EAA:  MOVLW  00
3EAC:  ADDWFC 03,W
3EAE:  MOVWF  FEA
3EB0:  MOVFF  E3,FEF
3EB4:  MOVFF  E4,FEC
3EB8:  MOVFF  E5,FEC
3EBC:  MOVFF  E6,FEC
....................             //Realizamos la misma operación con la media de encendido de la caldera 
....................             media_dia_caldera = media_dia_caldera + (float)tiempo_x_dia_caldera; 
3EC0:  MOVFF  2A3,2B0
3EC4:  MOVFF  2A2,2AF
3EC8:  MOVLB  0
3ECA:  CALL   26A2
3ECE:  BCF    FD8.1
3ED0:  MOVFF  E2,2AC
3ED4:  MOVFF  E1,2AB
3ED8:  MOVFF  E0,2AA
3EDC:  MOVFF  DF,2A9
3EE0:  MOVFF  03,2B0
3EE4:  MOVFF  02,2AF
3EE8:  MOVFF  01,2AE
3EEC:  MOVFF  00,2AD
3EF0:  CALL   2428
3EF4:  MOVFF  03,E2
3EF8:  MOVFF  02,E1
3EFC:  MOVFF  01,E0
3F00:  MOVFF  00,DF
....................             media_dia_mes_caldera[dia[1]-1] = media_dia_caldera; 
3F04:  MOVLW  01
3F06:  MOVLB  2
3F08:  SUBWF  xA5,W
3F0A:  MULLW  04
3F0C:  MOVF   FF3,W
3F0E:  CLRF   03
3F10:  ADDLW  E7
3F12:  MOVWF  FE9
3F14:  MOVLW  00
3F16:  ADDWFC 03,W
3F18:  MOVWF  FEA
3F1A:  MOVFF  DF,FEF
3F1E:  MOVFF  E0,FEC
3F22:  MOVFF  E1,FEC
3F26:  MOVFF  E2,FEC
....................          } 
....................          //La sumatoria podría alcanzar un valor muy alto. El sistema no está preparado para estas eventualidades 
....................          //y debería ser reseteado cada cierto tiempo. Si el sistema va a utilizarse mucho (zonas muy frías o mal 
....................          //aisladas), el usuario debería informar al fabricante para aumentar la memoria de almacenamiento y el 
....................          //tamaño de las variables 
....................  
....................          //Si cambiamos de año, habrá que guardar los datos anuales 
....................          if(dia[2]!=data2[0]) 
3F2A:  MOVLB  0
3F2C:  MOVF   x9F,W
3F2E:  MOVLB  2
3F30:  SUBWF  xA6,W
3F32:  BTFSC  FD8.2
3F34:  BRA    41AE
....................          { 
....................             //Comprobamos que no nos encontrabamos en el año introducido por defecto 
....................             if(dia[2]!=0) 
3F36:  MOVF   xA6,F
3F38:  BTFSC  FD8.2
3F3A:  BRA    419A
....................             { 
....................                //En ese caso, guardamos los datos de todo el año 
....................                for(contador2=0; contador2<12; contador2++) 
3F3C:  MOVLB  0
3F3E:  CLRF   x96
3F40:  MOVF   x96,W
3F42:  SUBLW  0B
3F44:  BTFSS  FD8.0
3F46:  BRA    4184
....................                { 
....................                   media_dia_mes[contador2] = media_dia_mes[contador2]/(float)dias_meses[contador2]; 
3F48:  MOVF   x96,W
3F4A:  MULLW  04
3F4C:  MOVF   FF3,W
3F4E:  CLRF   03
3F50:  ADDLW  A3
3F52:  MOVWF  01
3F54:  MOVLW  00
3F56:  ADDWFC 03,F
3F58:  MOVFF  01,2A9
3F5C:  MOVFF  03,2AA
3F60:  MOVLB  0
3F62:  MOVF   x96,W
3F64:  MULLW  04
3F66:  MOVF   FF3,W
3F68:  CLRF   03
3F6A:  ADDLW  A3
3F6C:  MOVWF  FE9
3F6E:  MOVLW  00
3F70:  ADDWFC 03,W
3F72:  MOVWF  FEA
3F74:  MOVFF  FEF,2AB
3F78:  MOVFF  FEC,2AC
3F7C:  MOVFF  FEC,2AD
3F80:  MOVFF  FEC,2AE
3F84:  CLRF   03
3F86:  MOVF   x96,W
3F88:  ADDLW  D3
3F8A:  MOVWF  FE9
3F8C:  MOVLW  00
3F8E:  ADDWFC 03,W
3F90:  MOVWF  FEA
3F92:  MOVF   FEF,W
3F94:  MOVLB  2
3F96:  CLRF   xB0
3F98:  MOVWF  xAF
3F9A:  MOVLB  0
3F9C:  CALL   26A2
3FA0:  MOVFF  2AE,2B2
3FA4:  MOVFF  2AD,2B1
3FA8:  MOVFF  2AC,2B0
3FAC:  MOVFF  2AB,2AF
3FB0:  MOVFF  03,2B6
3FB4:  MOVFF  02,2B5
3FB8:  MOVFF  01,2B4
3FBC:  MOVFF  00,2B3
3FC0:  CALL   2058
3FC4:  MOVFF  2AA,FEA
3FC8:  MOVFF  2A9,FE9
3FCC:  MOVFF  00,FEF
3FD0:  MOVFF  01,FEC
3FD4:  MOVFF  02,FEC
3FD8:  MOVFF  03,FEC
....................                   media_dia_mes_caldera[contador2] = media_dia_mes_caldera[contador2]/(float)dias_meses[contador2]; 
3FDC:  MOVF   x96,W
3FDE:  MULLW  04
3FE0:  MOVF   FF3,W
3FE2:  CLRF   03
3FE4:  ADDLW  E7
3FE6:  MOVWF  01
3FE8:  MOVLW  00
3FEA:  ADDWFC 03,F
3FEC:  MOVFF  01,2A9
3FF0:  MOVFF  03,2AA
3FF4:  MOVLB  0
3FF6:  MOVF   x96,W
3FF8:  MULLW  04
3FFA:  MOVF   FF3,W
3FFC:  CLRF   03
3FFE:  ADDLW  E7
4000:  MOVWF  FE9
4002:  MOVLW  00
4004:  ADDWFC 03,W
4006:  MOVWF  FEA
4008:  MOVFF  FEF,2AB
400C:  MOVFF  FEC,2AC
4010:  MOVFF  FEC,2AD
4014:  MOVFF  FEC,2AE
4018:  CLRF   03
401A:  MOVF   x96,W
401C:  ADDLW  D3
401E:  MOVWF  FE9
4020:  MOVLW  00
4022:  ADDWFC 03,W
4024:  MOVWF  FEA
4026:  MOVF   FEF,W
4028:  MOVLB  2
402A:  CLRF   xB0
402C:  MOVWF  xAF
402E:  MOVLB  0
4030:  CALL   26A2
4034:  MOVFF  2AE,2B2
4038:  MOVFF  2AD,2B1
403C:  MOVFF  2AC,2B0
4040:  MOVFF  2AB,2AF
4044:  MOVFF  03,2B6
4048:  MOVFF  02,2B5
404C:  MOVFF  01,2B4
4050:  MOVFF  00,2B3
4054:  CALL   2058
4058:  MOVFF  2AA,FEA
405C:  MOVFF  2A9,FE9
4060:  MOVFF  00,FEF
4064:  MOVFF  01,FEC
4068:  MOVFF  02,FEC
406C:  MOVFF  03,FEC
....................                   media_annos[num_annos][contador2] = media_dia_mes[contador2]; 
4070:  MOVLB  2
4072:  MOVF   x9B,W
4074:  MULLW  30
4076:  MOVF   FF3,W
4078:  CLRF   xAA
407A:  MOVWF  xA9
407C:  MOVLB  0
407E:  MOVF   x96,W
4080:  MULLW  04
4082:  MOVF   FF3,W
4084:  CLRF   03
4086:  MOVLB  2
4088:  ADDWF  xA9,W
408A:  MOVWF  01
408C:  MOVF   xAA,W
408E:  ADDWFC 03,F
4090:  MOVF   01,W
4092:  ADDLW  1B
4094:  MOVWF  01
4096:  MOVLW  01
4098:  ADDWFC 03,F
409A:  MOVFF  01,2AB
409E:  MOVFF  03,2AC
40A2:  MOVLB  0
40A4:  MOVF   x96,W
40A6:  MULLW  04
40A8:  MOVF   FF3,W
40AA:  CLRF   03
40AC:  ADDLW  A3
40AE:  MOVWF  FE9
40B0:  MOVLW  00
40B2:  ADDWFC 03,W
40B4:  MOVWF  FEA
40B6:  MOVFF  FEF,00
40BA:  MOVFF  FEC,01
40BE:  MOVFF  FEC,02
40C2:  MOVFF  FEC,03
40C6:  MOVFF  2AC,FEA
40CA:  MOVFF  2AB,FE9
40CE:  MOVFF  00,FEF
40D2:  MOVFF  01,FEC
40D6:  MOVFF  02,FEC
40DA:  MOVFF  03,FEC
....................                   media_annos_caldera[num_annos][contador2] = media_dia_mes_caldera[contador2]; 
40DE:  MOVLB  2
40E0:  MOVF   x9B,W
40E2:  MULLW  30
40E4:  MOVF   FF3,W
40E6:  CLRF   xAA
40E8:  MOVWF  xA9
40EA:  MOVLB  0
40EC:  MOVF   x96,W
40EE:  MULLW  04
40F0:  MOVF   FF3,W
40F2:  CLRF   03
40F4:  MOVLB  2
40F6:  ADDWF  xA9,W
40F8:  MOVWF  01
40FA:  MOVF   xAA,W
40FC:  ADDWFC 03,F
40FE:  MOVF   01,W
4100:  ADDLW  DB
4102:  MOVWF  01
4104:  MOVLW  01
4106:  ADDWFC 03,F
4108:  MOVFF  01,2AB
410C:  MOVFF  03,2AC
4110:  MOVLB  0
4112:  MOVF   x96,W
4114:  MULLW  04
4116:  MOVF   FF3,W
4118:  CLRF   03
411A:  ADDLW  E7
411C:  MOVWF  FE9
411E:  MOVLW  00
4120:  ADDWFC 03,W
4122:  MOVWF  FEA
4124:  MOVFF  FEF,00
4128:  MOVFF  FEC,01
412C:  MOVFF  FEC,02
4130:  MOVFF  FEC,03
4134:  MOVFF  2AC,FEA
4138:  MOVFF  2AB,FE9
413C:  MOVFF  00,FEF
4140:  MOVFF  01,FEC
4144:  MOVFF  02,FEC
4148:  MOVFF  03,FEC
....................                   //Volvemos a inicializar los contenedores de información anual 
....................                   media_dia_mes[contador2]=0; 
414C:  MOVF   x96,W
414E:  MULLW  04
4150:  MOVF   FF3,W
4152:  CLRF   03
4154:  ADDLW  A3
4156:  MOVWF  FE9
4158:  MOVLW  00
415A:  ADDWFC 03,W
415C:  MOVWF  FEA
415E:  CLRF   FEF
4160:  CLRF   FEC
4162:  CLRF   FEC
4164:  CLRF   FEC
....................                   media_dia_mes_caldera[contador2]=0; 
4166:  MOVF   x96,W
4168:  MULLW  04
416A:  MOVF   FF3,W
416C:  CLRF   03
416E:  ADDLW  E7
4170:  MOVWF  FE9
4172:  MOVLW  00
4174:  ADDWFC 03,W
4176:  MOVWF  FEA
4178:  CLRF   FEF
417A:  CLRF   FEC
417C:  CLRF   FEC
417E:  CLRF   FEC
....................                } 
4180:  INCF   x96,F
4182:  BRA    3F40
....................  
....................                //Guardamos el año del que se trata 
....................                annos[num_annos]=dia[2]; 
4184:  CLRF   03
4186:  MOVLB  2
4188:  MOVF   x9B,W
418A:  ADDLW  9C
418C:  MOVWF  FE9
418E:  MOVLW  02
4190:  ADDWFC 03,W
4192:  MOVWF  FEA
4194:  MOVFF  2A6,FEF
....................  
....................                //Aumentamos en 1 el número de años 
....................                num_annos++; 
4198:  INCF   x9B,F
....................             } 
....................  
....................             //COMPROBAR BISIESTO 
....................             //En realidad, un año será bisiesto si es divisible por 4 y no lo es por 100, 
....................             //excepto si este último lo es por 400. Sin embargo, dado que trabajamos con las 
....................             //dos últimas cifras y que el próximo año divisible por 4 que no lo es por 100 
....................             //es el 2100, mejor nos limitaremos a la divisibilidad por 4. 
....................             //Dependiendo si el año es bisiesto o no, le damos a febrero 29 o 28 días. 
....................             if(data2[0]%4 == 0) 
419A:  MOVLB  0
419C:  MOVF   x9F,W
419E:  ANDLW  03
41A0:  BNZ   41A8
....................                dias_meses[1] = 29; 
41A2:  MOVLW  1D
41A4:  MOVWF  xD4
....................             else 
41A6:  BRA    41AC
....................                dias_meses[1] = 28; 
41A8:  MOVLW  1C
41AA:  MOVWF  xD4
41AC:  MOVLB  2
....................          } 
....................  
....................          //Modificamos la información del día 
....................          dia[0] = data[0]; 
41AE:  MOVFF  97,2A4
....................          dia[1] = data[1]; 
41B2:  MOVFF  98,2A5
....................          dia[2] = data2[0]; 
41B6:  MOVFF  9F,2A6
....................  
....................          //Aumentamos en 1 el número de días 
....................          num_dias++; 
41BA:  INCF   xA7,F
41BC:  BTFSC  FD8.2
41BE:  INCF   xA8,F
....................  
....................          //Reseteamos las variables acumulativas de tiempo por día 
....................          tiempo_x_dia = 0; 
41C0:  CLRF   xA1
41C2:  CLRF   xA0
....................          tiempo_x_dia_caldera = 0; 
41C4:  CLRF   xA3
41C6:  CLRF   xA2
....................       } 
....................  
....................       //Le sumamos al tiempo de encendido de sistema y caldera el correspondiente de este registro 
....................       tiempo_x_dia = tiempo_x_dia + data2[1]; 
41C8:  MOVLB  0
41CA:  MOVF   xA0,W
41CC:  MOVLB  2
41CE:  ADDWF  xA0,F
41D0:  MOVLW  00
41D2:  ADDWFC xA1,F
....................       tiempo_x_dia_caldera = tiempo_x_dia_caldera + data2[2]; 
41D4:  MOVLB  0
41D6:  MOVF   xA1,W
41D8:  MOVLB  2
41DA:  ADDWF  xA2,F
41DC:  MOVLW  00
41DE:  ADDWFC xA3,F
....................       //También incrementamos los tiempos totales 
....................       valor_total = valor_total + data2[1]; 
41E0:  MOVLB  0
41E2:  MOVF   xA0,W
41E4:  MOVLB  1
41E6:  ADDWF  x17,F
41E8:  MOVLW  00
41EA:  ADDWFC x18,F
....................       valor_total_caldera = valor_total_caldera + data2[2]; 
41EC:  MOVLB  0
41EE:  MOVF   xA1,W
41F0:  MOVLB  1
41F2:  ADDWF  x19,F
41F4:  MOVLW  00
41F6:  ADDWFC x1A,F
....................  
....................       //Representamos todos los datos, teniendo en cuenta algunos requisitos representativos 
....................       //para que los datos queden alineados (número menores que 10, que 100, etc). 
....................       if(data[0]<10) 
41F8:  MOVLB  0
41FA:  MOVF   x97,W
41FC:  SUBLW  09
41FE:  BNC   421E
....................          printf(" "); 
4200:  MOVLB  2
4202:  CLRF   xA9
4204:  MOVF   xA9,W
4206:  MOVLB  0
4208:  CALL   0BF0
420C:  IORLW  00
420E:  BZ    421E
4210:  MOVLB  2
4212:  INCF   xA9,F
4214:  BTFSS  F9E.4
4216:  BRA    4214
4218:  MOVWF  FAD
421A:  BRA    4204
421C:  MOVLB  0
....................  
....................       printf("%u/", data[0]); 
421E:  MOVFF  97,2AA
4222:  MOVLW  1B
4224:  MOVLB  2
4226:  MOVWF  xAB
4228:  MOVLB  0
422A:  CALL   3900
422E:  MOVLW  2F
4230:  BTFSS  F9E.4
4232:  BRA    4230
4234:  MOVWF  FAD
....................  
....................       if(data[1]<10) 
4236:  MOVF   x98,W
4238:  SUBLW  09
423A:  BNC   425A
....................          printf("0"); 
423C:  MOVLB  2
423E:  CLRF   xA9
4240:  MOVF   xA9,W
4242:  MOVLB  0
4244:  CALL   0A48
4248:  IORLW  00
424A:  BZ    425A
424C:  MOVLB  2
424E:  INCF   xA9,F
4250:  BTFSS  F9E.4
4252:  BRA    4250
4254:  MOVWF  FAD
4256:  BRA    4240
4258:  MOVLB  0
....................  
....................       printf("%u/", data[1]); 
425A:  MOVFF  98,2AA
425E:  MOVLW  1B
4260:  MOVLB  2
4262:  MOVWF  xAB
4264:  MOVLB  0
4266:  CALL   3900
426A:  MOVLW  2F
426C:  BTFSS  F9E.4
426E:  BRA    426C
4270:  MOVWF  FAD
....................  
....................       if(data2[0]<10) 
4272:  MOVF   x9F,W
4274:  SUBLW  09
4276:  BNC   4296
....................          printf("0"); 
4278:  MOVLB  2
427A:  CLRF   xA9
427C:  MOVF   xA9,W
427E:  MOVLB  0
4280:  CALL   0A48
4284:  IORLW  00
4286:  BZ    4296
4288:  MOVLB  2
428A:  INCF   xA9,F
428C:  BTFSS  F9E.4
428E:  BRA    428C
4290:  MOVWF  FAD
4292:  BRA    427C
4294:  MOVLB  0
....................  
....................       printf("%u  ", data2[0]); 
4296:  MOVFF  9F,2AA
429A:  MOVLW  1B
429C:  MOVLB  2
429E:  MOVWF  xAB
42A0:  MOVLB  0
42A2:  CALL   3900
42A6:  MOVLW  20
42A8:  BTFSS  F9E.4
42AA:  BRA    42A8
42AC:  MOVWF  FAD
42AE:  MOVLW  20
42B0:  BTFSS  F9E.4
42B2:  BRA    42B0
42B4:  MOVWF  FAD
....................  
....................       if(data[2]<10) 
42B6:  MOVF   x99,W
42B8:  SUBLW  09
42BA:  BNC   42DA
....................          printf("0"); 
42BC:  MOVLB  2
42BE:  CLRF   xA9
42C0:  MOVF   xA9,W
42C2:  MOVLB  0
42C4:  CALL   0A48
42C8:  IORLW  00
42CA:  BZ    42DA
42CC:  MOVLB  2
42CE:  INCF   xA9,F
42D0:  BTFSS  F9E.4
42D2:  BRA    42D0
42D4:  MOVWF  FAD
42D6:  BRA    42C0
42D8:  MOVLB  0
....................  
....................       printf("%u:", data[2]); 
42DA:  MOVFF  99,2AA
42DE:  MOVLW  1B
42E0:  MOVLB  2
42E2:  MOVWF  xAB
42E4:  MOVLB  0
42E6:  CALL   3900
42EA:  MOVLW  3A
42EC:  BTFSS  F9E.4
42EE:  BRA    42EC
42F0:  MOVWF  FAD
....................  
....................       if(data[3]<10) 
42F2:  MOVF   x9A,W
42F4:  SUBLW  09
42F6:  BNC   4316
....................          printf("0"); 
42F8:  MOVLB  2
42FA:  CLRF   xA9
42FC:  MOVF   xA9,W
42FE:  MOVLB  0
4300:  CALL   0A48
4304:  IORLW  00
4306:  BZ    4316
4308:  MOVLB  2
430A:  INCF   xA9,F
430C:  BTFSS  F9E.4
430E:  BRA    430C
4310:  MOVWF  FAD
4312:  BRA    42FC
4314:  MOVLB  0
....................  
....................       printf("%u          ", data[3]); 
4316:  MOVFF  9A,2AA
431A:  MOVLW  1B
431C:  MOVLB  2
431E:  MOVWF  xAB
4320:  MOVLB  0
4322:  CALL   3900
4326:  MOVLW  0A
4328:  MOVLB  2
432A:  MOVWF  xA9
432C:  MOVLW  20
432E:  BTFSS  F9E.4
4330:  BRA    432E
4332:  MOVWF  FAD
4334:  DECFSZ xA9,F
4336:  BRA    432C
....................  
....................       if(data[4]<10) 
4338:  MOVLB  0
433A:  MOVF   x9B,W
433C:  SUBLW  09
433E:  BNC   435E
....................          printf(" "); 
4340:  MOVLB  2
4342:  CLRF   xA9
4344:  MOVF   xA9,W
4346:  MOVLB  0
4348:  CALL   0BF0
434C:  IORLW  00
434E:  BZ    435E
4350:  MOVLB  2
4352:  INCF   xA9,F
4354:  BTFSS  F9E.4
4356:  BRA    4354
4358:  MOVWF  FAD
435A:  BRA    4344
435C:  MOVLB  0
....................  
....................       printf("%u.", data[4]); 
435E:  MOVFF  9B,2AA
4362:  MOVLW  1B
4364:  MOVLB  2
4366:  MOVWF  xAB
4368:  MOVLB  0
436A:  CALL   3900
436E:  MOVLW  2E
4370:  BTFSS  F9E.4
4372:  BRA    4370
4374:  MOVWF  FAD
....................  
....................       if(data[5]<10) 
4376:  MOVF   x9C,W
4378:  SUBLW  09
437A:  BNC   439A
....................          printf("0"); 
437C:  MOVLB  2
437E:  CLRF   xA9
4380:  MOVF   xA9,W
4382:  MOVLB  0
4384:  CALL   0A48
4388:  IORLW  00
438A:  BZ    439A
438C:  MOVLB  2
438E:  INCF   xA9,F
4390:  BTFSS  F9E.4
4392:  BRA    4390
4394:  MOVWF  FAD
4396:  BRA    4380
4398:  MOVLB  0
....................  
....................       printf("%u%cC             ", data[5], 223); 
439A:  MOVFF  9C,2AA
439E:  MOVLW  1B
43A0:  MOVLB  2
43A2:  MOVWF  xAB
43A4:  MOVLB  0
43A6:  CALL   3900
43AA:  MOVLW  DF
43AC:  BTFSS  F9E.4
43AE:  BRA    43AC
43B0:  MOVWF  FAD
43B2:  MOVLW  43
43B4:  BTFSS  F9E.4
43B6:  BRA    43B4
43B8:  MOVWF  FAD
43BA:  MOVLW  0D
43BC:  MOVLB  2
43BE:  MOVWF  xA9
43C0:  MOVLW  20
43C2:  BTFSS  F9E.4
43C4:  BRA    43C2
43C6:  MOVWF  FAD
43C8:  DECFSZ xA9,F
43CA:  BRA    43C0
....................  
....................       if(data[6]<10) 
43CC:  MOVLB  0
43CE:  MOVF   x9D,W
43D0:  SUBLW  09
43D2:  BNC   43F2
....................          printf(" "); 
43D4:  MOVLB  2
43D6:  CLRF   xA9
43D8:  MOVF   xA9,W
43DA:  MOVLB  0
43DC:  CALL   0BF0
43E0:  IORLW  00
43E2:  BZ    43F2
43E4:  MOVLB  2
43E6:  INCF   xA9,F
43E8:  BTFSS  F9E.4
43EA:  BRA    43E8
43EC:  MOVWF  FAD
43EE:  BRA    43D8
43F0:  MOVLB  0
....................  
....................       printf("%u.", data[6]); 
43F2:  MOVFF  9D,2AA
43F6:  MOVLW  1B
43F8:  MOVLB  2
43FA:  MOVWF  xAB
43FC:  MOVLB  0
43FE:  CALL   3900
4402:  MOVLW  2E
4404:  BTFSS  F9E.4
4406:  BRA    4404
4408:  MOVWF  FAD
....................  
....................       if(data[7]<10) 
440A:  MOVF   x9E,W
440C:  SUBLW  09
440E:  BNC   442E
....................          printf("0"); 
4410:  MOVLB  2
4412:  CLRF   xA9
4414:  MOVF   xA9,W
4416:  MOVLB  0
4418:  CALL   0A48
441C:  IORLW  00
441E:  BZ    442E
4420:  MOVLB  2
4422:  INCF   xA9,F
4424:  BTFSS  F9E.4
4426:  BRA    4424
4428:  MOVWF  FAD
442A:  BRA    4414
442C:  MOVLB  0
....................  
....................       printf("%u%cC              %u%cC                  ", data[7], 223, data2[3], 223); 
442E:  MOVFF  9E,2AA
4432:  MOVLW  1B
4434:  MOVLB  2
4436:  MOVWF  xAB
4438:  MOVLB  0
443A:  CALL   3900
443E:  MOVLW  DF
4440:  BTFSS  F9E.4
4442:  BRA    4440
4444:  MOVWF  FAD
4446:  MOVLW  43
4448:  BTFSS  F9E.4
444A:  BRA    4448
444C:  MOVWF  FAD
444E:  MOVLW  0E
4450:  MOVLB  2
4452:  MOVWF  xA9
4454:  MOVLW  20
4456:  BTFSS  F9E.4
4458:  BRA    4456
445A:  MOVWF  FAD
445C:  DECFSZ xA9,F
445E:  BRA    4454
4460:  MOVFF  A2,2AA
4464:  MOVLW  1B
4466:  MOVWF  xAB
4468:  MOVLB  0
446A:  CALL   3900
446E:  MOVLW  DF
4470:  BTFSS  F9E.4
4472:  BRA    4470
4474:  MOVWF  FAD
4476:  MOVLW  43
4478:  BTFSS  F9E.4
447A:  BRA    4478
447C:  MOVWF  FAD
447E:  MOVLW  12
4480:  MOVLB  2
4482:  MOVWF  xAA
4484:  MOVLW  20
4486:  BTFSS  F9E.4
4488:  BRA    4486
448A:  MOVWF  FAD
448C:  DECFSZ xAA,F
448E:  BRA    4484
....................  
....................       if(data2[1]<100) 
4490:  MOVLB  0
4492:  MOVF   xA0,W
4494:  SUBLW  63
4496:  BNC   44B6
....................          printf(" "); 
4498:  MOVLB  2
449A:  CLRF   xA9
449C:  MOVF   xA9,W
449E:  MOVLB  0
44A0:  CALL   0BF0
44A4:  IORLW  00
44A6:  BZ    44B6
44A8:  MOVLB  2
44AA:  INCF   xA9,F
44AC:  BTFSS  F9E.4
44AE:  BRA    44AC
44B0:  MOVWF  FAD
44B2:  BRA    449C
44B4:  MOVLB  0
....................       if(data2[1]<10) 
44B6:  MOVF   xA0,W
44B8:  SUBLW  09
44BA:  BNC   44DA
....................          printf(" "); 
44BC:  MOVLB  2
44BE:  CLRF   xA9
44C0:  MOVF   xA9,W
44C2:  MOVLB  0
44C4:  CALL   0BF0
44C8:  IORLW  00
44CA:  BZ    44DA
44CC:  MOVLB  2
44CE:  INCF   xA9,F
44D0:  BTFSS  F9E.4
44D2:  BRA    44D0
44D4:  MOVWF  FAD
44D6:  BRA    44C0
44D8:  MOVLB  0
....................  
....................       printf("%u                    ", data2[1]); 
44DA:  MOVFF  A0,2AA
44DE:  MOVLW  1B
44E0:  MOVLB  2
44E2:  MOVWF  xAB
44E4:  MOVLB  0
44E6:  CALL   3900
44EA:  MOVLW  14
44EC:  MOVLB  2
44EE:  MOVWF  xA9
44F0:  MOVLW  20
44F2:  BTFSS  F9E.4
44F4:  BRA    44F2
44F6:  MOVWF  FAD
44F8:  DECFSZ xA9,F
44FA:  BRA    44F0
....................  
....................       if(data2[2]<100) 
44FC:  MOVLB  0
44FE:  MOVF   xA1,W
4500:  SUBLW  63
4502:  BNC   4522
....................          printf(" "); 
4504:  MOVLB  2
4506:  CLRF   xA9
4508:  MOVF   xA9,W
450A:  MOVLB  0
450C:  CALL   0BF0
4510:  IORLW  00
4512:  BZ    4522
4514:  MOVLB  2
4516:  INCF   xA9,F
4518:  BTFSS  F9E.4
451A:  BRA    4518
451C:  MOVWF  FAD
451E:  BRA    4508
4520:  MOVLB  0
....................       if(data2[2]<10) 
4522:  MOVF   xA1,W
4524:  SUBLW  09
4526:  BNC   4546
....................          printf(" "); 
4528:  MOVLB  2
452A:  CLRF   xA9
452C:  MOVF   xA9,W
452E:  MOVLB  0
4530:  CALL   0BF0
4534:  IORLW  00
4536:  BZ    4546
4538:  MOVLB  2
453A:  INCF   xA9,F
453C:  BTFSS  F9E.4
453E:  BRA    453C
4540:  MOVWF  FAD
4542:  BRA    452C
4544:  MOVLB  0
....................  
....................       printf("%u\r", data2[2]); 
4546:  MOVFF  A1,2AA
454A:  MOVLW  1B
454C:  MOVLB  2
454E:  MOVWF  xAB
4550:  MOVLB  0
4552:  CALL   3900
4556:  MOVLW  0D
4558:  BTFSS  F9E.4
455A:  BRA    4558
455C:  MOVWF  FAD
....................  
....................    } 
455E:  INCF   x95,F
4560:  BRA    3D8E
....................  
....................    //Debemos realizar la operación de guardado para el último día. El proceso es el mismo 
....................    //que hemos seguido arriba. 
....................    if(dia[0]!=0) 
4562:  MOVLB  2
4564:  MOVF   xA4,F
4566:  BZ    463C
....................    { 
....................       valor = valor + (float)tiempo_x_dia; 
4568:  MOVFF  2A1,2B0
456C:  MOVFF  2A0,2AF
4570:  MOVLB  0
4572:  CALL   26A2
4576:  BCF    FD8.1
4578:  MOVFF  E6,2AC
457C:  MOVFF  E5,2AB
4580:  MOVFF  E4,2AA
4584:  MOVFF  E3,2A9
4588:  MOVFF  03,2B0
458C:  MOVFF  02,2AF
4590:  MOVFF  01,2AE
4594:  MOVFF  00,2AD
4598:  CALL   2428
459C:  MOVFF  03,E6
45A0:  MOVFF  02,E5
45A4:  MOVFF  01,E4
45A8:  MOVFF  00,E3
....................       media_dia_mes[dia[1]-1] = valor; 
45AC:  MOVLW  01
45AE:  MOVLB  2
45B0:  SUBWF  xA5,W
45B2:  MULLW  04
45B4:  MOVF   FF3,W
45B6:  CLRF   03
45B8:  ADDLW  A3
45BA:  MOVWF  FE9
45BC:  MOVLW  00
45BE:  ADDWFC 03,W
45C0:  MOVWF  FEA
45C2:  MOVFF  E3,FEF
45C6:  MOVFF  E4,FEC
45CA:  MOVFF  E5,FEC
45CE:  MOVFF  E6,FEC
....................       media_dia_caldera = media_dia_caldera + (float)tiempo_x_dia_caldera; 
45D2:  MOVFF  2A3,2B0
45D6:  MOVFF  2A2,2AF
45DA:  MOVLB  0
45DC:  CALL   26A2
45E0:  BCF    FD8.1
45E2:  MOVFF  E2,2AC
45E6:  MOVFF  E1,2AB
45EA:  MOVFF  E0,2AA
45EE:  MOVFF  DF,2A9
45F2:  MOVFF  03,2B0
45F6:  MOVFF  02,2AF
45FA:  MOVFF  01,2AE
45FE:  MOVFF  00,2AD
4602:  CALL   2428
4606:  MOVFF  03,E2
460A:  MOVFF  02,E1
460E:  MOVFF  01,E0
4612:  MOVFF  00,DF
....................       media_dia_mes_caldera[dia[1]-1] = media_dia_caldera; 
4616:  MOVLW  01
4618:  MOVLB  2
461A:  SUBWF  xA5,W
461C:  MULLW  04
461E:  MOVF   FF3,W
4620:  CLRF   03
4622:  ADDLW  E7
4624:  MOVWF  FE9
4626:  MOVLW  00
4628:  ADDWFC 03,W
462A:  MOVWF  FEA
462C:  MOVFF  DF,FEF
4630:  MOVFF  E0,FEC
4634:  MOVFF  E1,FEC
4638:  MOVFF  E2,FEC
....................    } 
....................  
....................    //Comprobamos que no nos encontrabamos en el año introducido por defecto 
....................    if(dia[2]!=0) 
463C:  MOVF   xA6,F
463E:  BTFSC  FD8.2
4640:  BRA    486C
....................    { 
....................       for(contador2=0; contador2<12; contador2++) 
4642:  MOVLB  0
4644:  CLRF   x96
4646:  MOVF   x96,W
4648:  SUBLW  0B
464A:  BTFSS  FD8.0
464C:  BRA    4856
....................       { 
....................          media_dia_mes[contador2] = media_dia_mes[contador2]/(float)dias_meses[contador2]; 
464E:  MOVF   x96,W
4650:  MULLW  04
4652:  MOVF   FF3,W
4654:  CLRF   03
4656:  ADDLW  A3
4658:  MOVWF  01
465A:  MOVLW  00
465C:  ADDWFC 03,F
465E:  MOVFF  01,2A9
4662:  MOVFF  03,2AA
4666:  MOVLB  0
4668:  MOVF   x96,W
466A:  MULLW  04
466C:  MOVF   FF3,W
466E:  CLRF   03
4670:  ADDLW  A3
4672:  MOVWF  FE9
4674:  MOVLW  00
4676:  ADDWFC 03,W
4678:  MOVWF  FEA
467A:  MOVFF  FEF,2AB
467E:  MOVFF  FEC,2AC
4682:  MOVFF  FEC,2AD
4686:  MOVFF  FEC,2AE
468A:  CLRF   03
468C:  MOVF   x96,W
468E:  ADDLW  D3
4690:  MOVWF  FE9
4692:  MOVLW  00
4694:  ADDWFC 03,W
4696:  MOVWF  FEA
4698:  MOVF   FEF,W
469A:  MOVLB  2
469C:  CLRF   xB0
469E:  MOVWF  xAF
46A0:  MOVLB  0
46A2:  CALL   26A2
46A6:  MOVFF  2AE,2B2
46AA:  MOVFF  2AD,2B1
46AE:  MOVFF  2AC,2B0
46B2:  MOVFF  2AB,2AF
46B6:  MOVFF  03,2B6
46BA:  MOVFF  02,2B5
46BE:  MOVFF  01,2B4
46C2:  MOVFF  00,2B3
46C6:  CALL   2058
46CA:  MOVFF  2AA,FEA
46CE:  MOVFF  2A9,FE9
46D2:  MOVFF  00,FEF
46D6:  MOVFF  01,FEC
46DA:  MOVFF  02,FEC
46DE:  MOVFF  03,FEC
....................          media_dia_mes_caldera[contador2] = media_dia_mes_caldera[contador2]/(float)dias_meses[contador2]; 
46E2:  MOVF   x96,W
46E4:  MULLW  04
46E6:  MOVF   FF3,W
46E8:  CLRF   03
46EA:  ADDLW  E7
46EC:  MOVWF  01
46EE:  MOVLW  00
46F0:  ADDWFC 03,F
46F2:  MOVFF  01,2A9
46F6:  MOVFF  03,2AA
46FA:  MOVLB  0
46FC:  MOVF   x96,W
46FE:  MULLW  04
4700:  MOVF   FF3,W
4702:  CLRF   03
4704:  ADDLW  E7
4706:  MOVWF  FE9
4708:  MOVLW  00
470A:  ADDWFC 03,W
470C:  MOVWF  FEA
470E:  MOVFF  FEF,2AB
4712:  MOVFF  FEC,2AC
4716:  MOVFF  FEC,2AD
471A:  MOVFF  FEC,2AE
471E:  CLRF   03
4720:  MOVF   x96,W
4722:  ADDLW  D3
4724:  MOVWF  FE9
4726:  MOVLW  00
4728:  ADDWFC 03,W
472A:  MOVWF  FEA
472C:  MOVF   FEF,W
472E:  MOVLB  2
4730:  CLRF   xB0
4732:  MOVWF  xAF
4734:  MOVLB  0
4736:  CALL   26A2
473A:  MOVFF  2AE,2B2
473E:  MOVFF  2AD,2B1
4742:  MOVFF  2AC,2B0
4746:  MOVFF  2AB,2AF
474A:  MOVFF  03,2B6
474E:  MOVFF  02,2B5
4752:  MOVFF  01,2B4
4756:  MOVFF  00,2B3
475A:  CALL   2058
475E:  MOVFF  2AA,FEA
4762:  MOVFF  2A9,FE9
4766:  MOVFF  00,FEF
476A:  MOVFF  01,FEC
476E:  MOVFF  02,FEC
4772:  MOVFF  03,FEC
....................          media_annos[num_annos][contador2] = media_dia_mes[contador2]; 
4776:  MOVLB  2
4778:  MOVF   x9B,W
477A:  MULLW  30
477C:  MOVF   FF3,W
477E:  CLRF   xAA
4780:  MOVWF  xA9
4782:  MOVLB  0
4784:  MOVF   x96,W
4786:  MULLW  04
4788:  MOVF   FF3,W
478A:  CLRF   03
478C:  MOVLB  2
478E:  ADDWF  xA9,W
4790:  MOVWF  01
4792:  MOVF   xAA,W
4794:  ADDWFC 03,F
4796:  MOVF   01,W
4798:  ADDLW  1B
479A:  MOVWF  01
479C:  MOVLW  01
479E:  ADDWFC 03,F
47A0:  MOVFF  01,2AB
47A4:  MOVFF  03,2AC
47A8:  MOVLB  0
47AA:  MOVF   x96,W
47AC:  MULLW  04
47AE:  MOVF   FF3,W
47B0:  CLRF   03
47B2:  ADDLW  A3
47B4:  MOVWF  FE9
47B6:  MOVLW  00
47B8:  ADDWFC 03,W
47BA:  MOVWF  FEA
47BC:  MOVFF  FEF,00
47C0:  MOVFF  FEC,01
47C4:  MOVFF  FEC,02
47C8:  MOVFF  FEC,03
47CC:  MOVFF  2AC,FEA
47D0:  MOVFF  2AB,FE9
47D4:  MOVFF  00,FEF
47D8:  MOVFF  01,FEC
47DC:  MOVFF  02,FEC
47E0:  MOVFF  03,FEC
....................          media_annos_caldera[num_annos][contador2] = media_dia_mes_caldera[contador2]; 
47E4:  MOVLB  2
47E6:  MOVF   x9B,W
47E8:  MULLW  30
47EA:  MOVF   FF3,W
47EC:  CLRF   xAA
47EE:  MOVWF  xA9
47F0:  MOVLB  0
47F2:  MOVF   x96,W
47F4:  MULLW  04
47F6:  MOVF   FF3,W
47F8:  CLRF   03
47FA:  MOVLB  2
47FC:  ADDWF  xA9,W
47FE:  MOVWF  01
4800:  MOVF   xAA,W
4802:  ADDWFC 03,F
4804:  MOVF   01,W
4806:  ADDLW  DB
4808:  MOVWF  01
480A:  MOVLW  01
480C:  ADDWFC 03,F
480E:  MOVFF  01,2AB
4812:  MOVFF  03,2AC
4816:  MOVLB  0
4818:  MOVF   x96,W
481A:  MULLW  04
481C:  MOVF   FF3,W
481E:  CLRF   03
4820:  ADDLW  E7
4822:  MOVWF  FE9
4824:  MOVLW  00
4826:  ADDWFC 03,W
4828:  MOVWF  FEA
482A:  MOVFF  FEF,00
482E:  MOVFF  FEC,01
4832:  MOVFF  FEC,02
4836:  MOVFF  FEC,03
483A:  MOVFF  2AC,FEA
483E:  MOVFF  2AB,FE9
4842:  MOVFF  00,FEF
4846:  MOVFF  01,FEC
484A:  MOVFF  02,FEC
484E:  MOVFF  03,FEC
....................       } 
4852:  INCF   x96,F
4854:  BRA    4646
....................  
....................       annos[num_annos]=dia[2]; 
4856:  CLRF   03
4858:  MOVLB  2
485A:  MOVF   x9B,W
485C:  ADDLW  9C
485E:  MOVWF  FE9
4860:  MOVLW  02
4862:  ADDWFC 03,W
4864:  MOVWF  FEA
4866:  MOVFF  2A6,FEF
....................  
....................       num_annos++; 
486A:  INCF   x9B,F
....................    } 
....................  
....................    //Calculamos la media como el cociente entre los valore de tiempo calculados y el número de 
....................    //días en los que se ha encendido la caldera 
....................    valor = valor/(float)num_dias; 
486C:  MOVFF  2A8,2B0
4870:  MOVFF  2A7,2AF
4874:  MOVLB  0
4876:  CALL   26A2
487A:  MOVFF  E6,2B2
487E:  MOVFF  E5,2B1
4882:  MOVFF  E4,2B0
4886:  MOVFF  E3,2AF
488A:  MOVFF  03,2B6
488E:  MOVFF  02,2B5
4892:  MOVFF  01,2B4
4896:  MOVFF  00,2B3
489A:  CALL   2058
489E:  MOVFF  03,E6
48A2:  MOVFF  02,E5
48A6:  MOVFF  01,E4
48AA:  MOVFF  00,E3
....................    media_dia_caldera = media_dia_caldera/(float)num_dias; 
48AE:  MOVFF  2A8,2B0
48B2:  MOVFF  2A7,2AF
48B6:  CALL   26A2
48BA:  MOVFF  E2,2B2
48BE:  MOVFF  E1,2B1
48C2:  MOVFF  E0,2B0
48C6:  MOVFF  DF,2AF
48CA:  MOVFF  03,2B6
48CE:  MOVFF  02,2B5
48D2:  MOVFF  01,2B4
48D6:  MOVFF  00,2B3
48DA:  CALL   2058
48DE:  MOVFF  03,E2
48E2:  MOVFF  02,E1
48E6:  MOVFF  01,E0
48EA:  MOVFF  00,DF
....................  
....................    repetir: 
....................    //Menú para mostrar los datos 
....................    printf("\r===========================================================================================================================\r"); 
48EE:  MOVLB  2
48F0:  CLRF   xA9
48F2:  MOVF   xA9,W
48F4:  MOVLB  0
48F6:  CALL   0C0C
48FA:  IORLW  00
48FC:  BZ    490C
48FE:  MOVLB  2
4900:  INCF   xA9,F
4902:  BTFSS  F9E.4
4904:  BRA    4902
4906:  MOVWF  FAD
4908:  BRA    48F2
490A:  MOVLB  0
....................    printf("¿Que operacion desea realizar?\r"); 
490C:  MOVLB  2
490E:  CLRF   xA9
4910:  MOVF   xA9,W
4912:  MOVLB  0
4914:  CALL   0CA4
4918:  IORLW  00
491A:  BZ    492A
491C:  MOVLB  2
491E:  INCF   xA9,F
4920:  BTFSS  F9E.4
4922:  BRA    4920
4924:  MOVWF  FAD
4926:  BRA    4910
4928:  MOVLB  0
....................    printf("0. Salir\r"); 
492A:  MOVLB  2
492C:  CLRF   xA9
492E:  MOVF   xA9,W
4930:  MOVLB  0
4932:  CALL   0CDE
4936:  IORLW  00
4938:  BZ    4948
493A:  MOVLB  2
493C:  INCF   xA9,F
493E:  BTFSS  F9E.4
4940:  BRA    493E
4942:  MOVWF  FAD
4944:  BRA    492E
4946:  MOVLB  0
....................    printf("1. Extraer tiempos medios por dia\r"); 
4948:  MOVLB  2
494A:  CLRF   xA9
494C:  MOVF   xA9,W
494E:  MOVLB  0
4950:  CALL   0D02
4954:  IORLW  00
4956:  BZ    4966
4958:  MOVLB  2
495A:  INCF   xA9,F
495C:  BTFSS  F9E.4
495E:  BRA    495C
4960:  MOVWF  FAD
4962:  BRA    494C
4964:  MOVLB  0
....................    printf("2. Extraer tiempos totales\r"); 
4966:  MOVLB  2
4968:  CLRF   xA9
496A:  MOVF   xA9,W
496C:  MOVLB  0
496E:  CALL   0D40
4972:  IORLW  00
4974:  BZ    4984
4976:  MOVLB  2
4978:  INCF   xA9,F
497A:  BTFSS  F9E.4
497C:  BRA    497A
497E:  MOVWF  FAD
4980:  BRA    496A
4982:  MOVLB  0
....................    printf("3. Extraer datos mensuales\r"); 
4984:  MOVLB  2
4986:  CLRF   xA9
4988:  MOVF   xA9,W
498A:  MOVLB  0
498C:  CALL   0D76
4990:  IORLW  00
4992:  BZ    49A2
4994:  MOVLB  2
4996:  INCF   xA9,F
4998:  BTFSS  F9E.4
499A:  BRA    4998
499C:  MOVWF  FAD
499E:  BRA    4988
49A0:  MOVLB  0
....................    printf("===========================================================================================================================\r"); 
49A2:  MOVLB  2
49A4:  CLRF   xA9
49A6:  MOVF   xA9,W
49A8:  MOVLB  0
49AA:  CALL   0B58
49AE:  IORLW  00
49B0:  BZ    49C0
49B2:  MOVLB  2
49B4:  INCF   xA9,F
49B6:  BTFSS  F9E.4
49B8:  BRA    49B6
49BA:  MOVWF  FAD
49BC:  BRA    49A6
49BE:  MOVLB  0
....................  
....................    //Esperamos la introducción de una de las opciones por parte del técnico 
....................    while(key!='1' && key!='2' && key!='3' && key!='0'){ 
49C0:  MOVF   38,W
49C2:  SUBLW  31
49C4:  BZ    49E2
49C6:  MOVF   38,W
49C8:  SUBLW  32
49CA:  BZ    49E2
49CC:  MOVF   38,W
49CE:  SUBLW  33
49D0:  BZ    49E2
49D2:  MOVF   38,W
49D4:  SUBLW  30
49D6:  BZ    49E2
....................       key=getch(); 
49D8:  BTFSS  F9E.5
49DA:  BRA    49D8
49DC:  MOVFF  FAE,38
....................    } 
49E0:  BRA    49C0
....................  
....................    switch(key) 
....................    { 
49E2:  MOVLW  30
49E4:  SUBWF  38,W
49E6:  ADDLW  FC
49E8:  BTFSC  FD8.0
49EA:  GOTO   5762
49EE:  ADDLW  04
49F0:  GOTO   5766
....................       //En el caso 0, se sale del sistema 
....................       case '0': 
....................                //Se indica la salida mediante un mensaje 
....................                printf("\rSaliendo...\r"); 
49F4:  MOVLB  2
49F6:  CLRF   xA9
49F8:  MOVF   xA9,W
49FA:  MOVLB  0
49FC:  CALL   0DAC
4A00:  IORLW  00
4A02:  BZ    4A12
4A04:  MOVLB  2
4A06:  INCF   xA9,F
4A08:  BTFSS  F9E.4
4A0A:  BRA    4A08
4A0C:  MOVWF  FAD
4A0E:  BRA    49F8
4A10:  MOVLB  0
....................                break; 
4A12:  GOTO   5762
....................  
....................       //En el caso 1, se muestran los valores medios 
....................       case '1': 
....................                key = 'J';  //Utilizamos este carácter para evitar la elección errónea de la misma acción 
4A16:  MOVLW  4A
4A18:  MOVWF  38
....................                printf("\rTiempo medio de encendido del sistema por dia: %3.2f minutos\r\r", valor); 
4A1A:  MOVLB  2
4A1C:  CLRF   xA9
4A1E:  MOVF   xA9,W
4A20:  MOVLB  0
4A22:  CALL   0DD4
4A26:  MOVLB  2
4A28:  INCF   xA9,F
4A2A:  MOVWF  00
4A2C:  MOVF   00,W
4A2E:  BTFSS  F9E.4
4A30:  BRA    4A2E
4A32:  MOVWF  FAD
4A34:  MOVLW  30
4A36:  SUBWF  xA9,W
4A38:  BNZ   4A1E
4A3A:  MOVLW  02
4A3C:  MOVWF  FE9
4A3E:  MOVFF  E6,2BB
4A42:  MOVFF  E5,2BA
4A46:  MOVFF  E4,2B9
4A4A:  MOVFF  E3,2B8
4A4E:  MOVWF  xBC
4A50:  MOVLB  0
4A52:  CALL   397E
4A56:  MOVLW  35
4A58:  MOVLB  2
4A5A:  MOVWF  xAA
4A5C:  MOVF   xAA,W
4A5E:  MOVLB  0
4A60:  CALL   0DD4
4A64:  MOVLB  2
4A66:  INCF   xAA,F
4A68:  MOVWF  00
4A6A:  MOVF   00,W
4A6C:  BTFSS  F9E.4
4A6E:  BRA    4A6C
4A70:  MOVWF  FAD
4A72:  MOVLW  3F
4A74:  SUBWF  xAA,W
4A76:  BNZ   4A5C
....................                printf("Tiempo medio de encendido de la caldera por dia: %3.2f minutos\r\r", media_dia_caldera); 
4A78:  CLRF   xA9
4A7A:  MOVF   xA9,W
4A7C:  MOVLB  0
4A7E:  CALL   0E2E
4A82:  MOVLB  2
4A84:  INCF   xA9,F
4A86:  MOVWF  00
4A88:  MOVF   00,W
4A8A:  BTFSS  F9E.4
4A8C:  BRA    4A8A
4A8E:  MOVWF  FAD
4A90:  MOVLW  31
4A92:  SUBWF  xA9,W
4A94:  BNZ   4A7A
4A96:  MOVLW  02
4A98:  MOVWF  FE9
4A9A:  MOVFF  E2,2BB
4A9E:  MOVFF  E1,2BA
4AA2:  MOVFF  E0,2B9
4AA6:  MOVFF  DF,2B8
4AAA:  MOVWF  xBC
4AAC:  MOVLB  0
4AAE:  CALL   397E
4AB2:  MOVLW  36
4AB4:  MOVLB  2
4AB6:  MOVWF  xAA
4AB8:  MOVF   xAA,W
4ABA:  MOVLB  0
4ABC:  CALL   0E2E
4AC0:  MOVLB  2
4AC2:  INCF   xAA,F
4AC4:  MOVWF  00
4AC6:  MOVF   00,W
4AC8:  BTFSS  F9E.4
4ACA:  BRA    4AC8
4ACC:  MOVWF  FAD
4ACE:  MOVLW  40
4AD0:  SUBWF  xAA,W
4AD2:  BNZ   4AB8
....................                goto repetir; 
4AD4:  MOVLB  0
4AD6:  BRA    48EE
....................                break; 
4AD8:  GOTO   5762
....................  
....................       //En el caso 2, se muestran los valores totales 
....................       case '2': 
....................                key = 'J'; //Ídem 
4ADC:  MOVLW  4A
4ADE:  MOVWF  38
....................                printf("\rTiempo total de encendido del sistema: %lu minutos\r\r", valor_total); 
4AE0:  MOVLB  2
4AE2:  CLRF   xA9
4AE4:  MOVF   xA9,W
4AE6:  MOVLB  0
4AE8:  CALL   0E8A
4AEC:  MOVLB  2
4AEE:  INCF   xA9,F
4AF0:  MOVWF  00
4AF2:  MOVF   00,W
4AF4:  BTFSS  F9E.4
4AF6:  BRA    4AF4
4AF8:  MOVWF  FAD
4AFA:  MOVLW  28
4AFC:  SUBWF  xA9,W
4AFE:  BNZ   4AE4
4B00:  MOVLW  10
4B02:  MOVWF  FE9
4B04:  MOVFF  118,2AB
4B08:  MOVFF  117,2AA
4B0C:  MOVLB  0
4B0E:  CALL   3B24
4B12:  MOVLW  2B
4B14:  MOVLB  2
4B16:  MOVWF  xAA
4B18:  MOVF   xAA,W
4B1A:  MOVLB  0
4B1C:  CALL   0E8A
4B20:  MOVLB  2
4B22:  INCF   xAA,F
4B24:  MOVWF  00
4B26:  MOVF   00,W
4B28:  BTFSS  F9E.4
4B2A:  BRA    4B28
4B2C:  MOVWF  FAD
4B2E:  MOVLW  35
4B30:  SUBWF  xAA,W
4B32:  BNZ   4B18
....................                printf("Tiempo total de encendido de la caldera: %lu minutos\r\r", valor_total_caldera); 
4B34:  CLRF   xA9
4B36:  MOVF   xA9,W
4B38:  MOVLB  0
4B3A:  CALL   0EDA
4B3E:  MOVLB  2
4B40:  INCF   xA9,F
4B42:  MOVWF  00
4B44:  MOVF   00,W
4B46:  BTFSS  F9E.4
4B48:  BRA    4B46
4B4A:  MOVWF  FAD
4B4C:  MOVLW  29
4B4E:  SUBWF  xA9,W
4B50:  BNZ   4B36
4B52:  MOVLW  10
4B54:  MOVWF  FE9
4B56:  MOVFF  11A,2AB
4B5A:  MOVFF  119,2AA
4B5E:  MOVLB  0
4B60:  CALL   3B24
4B64:  MOVLW  2C
4B66:  MOVLB  2
4B68:  MOVWF  xAA
4B6A:  MOVF   xAA,W
4B6C:  MOVLB  0
4B6E:  CALL   0EDA
4B72:  MOVLB  2
4B74:  INCF   xAA,F
4B76:  MOVWF  00
4B78:  MOVF   00,W
4B7A:  BTFSS  F9E.4
4B7C:  BRA    4B7A
4B7E:  MOVWF  FAD
4B80:  MOVLW  36
4B82:  SUBWF  xAA,W
4B84:  BNZ   4B6A
....................                goto repetir; 
4B86:  MOVLB  0
4B88:  BRA    48EE
....................                break; 
4B8A:  GOTO   5762
....................  
....................       //En el caso 3, se muestran todos los valores medios por meses y años 
....................       case '3': 
....................                key = 'J'; //Ídem 
4B8E:  MOVLW  4A
4B90:  MOVWF  38
....................                //Se representan todos los años de los que se tiene registro 
....................                for(contador=0; contador<num_annos; contador++) 
4B92:  CLRF   x95
4B94:  MOVLB  2
4B96:  MOVF   x9B,W
4B98:  MOVLB  0
4B9A:  SUBWF  x95,W
4B9C:  BTFSC  FD8.0
4B9E:  GOTO   575C
....................                { 
....................                   //Imprimimos el año en el que nos encontramos 
....................                   printf("\r20"); 
4BA2:  MOVLB  2
4BA4:  CLRF   xA9
4BA6:  MOVF   xA9,W
4BA8:  MOVLB  0
4BAA:  CALL   0F2C
4BAE:  IORLW  00
4BB0:  BZ    4BC0
4BB2:  MOVLB  2
4BB4:  INCF   xA9,F
4BB6:  BTFSS  F9E.4
4BB8:  BRA    4BB6
4BBA:  MOVWF  FAD
4BBC:  BRA    4BA6
4BBE:  MOVLB  0
....................                   if(annos[contador]<10) 
4BC0:  CLRF   03
4BC2:  MOVF   x95,W
4BC4:  ADDLW  9C
4BC6:  MOVWF  FE9
4BC8:  MOVLW  02
4BCA:  ADDWFC 03,W
4BCC:  MOVWF  FEA
4BCE:  MOVF   FEF,W
4BD0:  SUBLW  09
4BD2:  BNC   4BF2
....................                      printf("0"); 
4BD4:  MOVLB  2
4BD6:  CLRF   xA9
4BD8:  MOVF   xA9,W
4BDA:  MOVLB  0
4BDC:  CALL   0A48
4BE0:  IORLW  00
4BE2:  BZ    4BF2
4BE4:  MOVLB  2
4BE6:  INCF   xA9,F
4BE8:  BTFSS  F9E.4
4BEA:  BRA    4BE8
4BEC:  MOVWF  FAD
4BEE:  BRA    4BD8
4BF0:  MOVLB  0
....................                   printf("%u\r", annos[contador]); 
4BF2:  CLRF   03
4BF4:  MOVF   x95,W
4BF6:  ADDLW  9C
4BF8:  MOVWF  FE9
4BFA:  MOVLW  02
4BFC:  ADDWFC 03,W
4BFE:  MOVWF  FEA
4C00:  MOVFF  FEF,2A9
4C04:  MOVFF  2A9,2AA
4C08:  MOVLW  1B
4C0A:  MOVLB  2
4C0C:  MOVWF  xAB
4C0E:  MOVLB  0
4C10:  CALL   3900
4C14:  MOVLW  0D
4C16:  BTFSS  F9E.4
4C18:  BRA    4C16
4C1A:  MOVWF  FAD
....................                   printf("--------------------------------------------------------------------------------------------------------------------\r"); 
4C1C:  MOVLB  2
4C1E:  CLRF   xA9
4C20:  MOVF   xA9,W
4C22:  MOVLB  0
4C24:  CALL   0F4A
4C28:  IORLW  00
4C2A:  BZ    4C3A
4C2C:  MOVLB  2
4C2E:  INCF   xA9,F
4C30:  BTFSS  F9E.4
4C32:  BRA    4C30
4C34:  MOVWF  FAD
4C36:  BRA    4C20
4C38:  MOVLB  0
....................                   printf("              Tiempo medio de encendido del sistema (min/dia)      Tiempo medio de encendido de la caldera (min/dia)\r"); 
4C3A:  MOVLB  2
4C3C:  CLRF   xA9
4C3E:  MOVF   xA9,W
4C40:  MOVLB  0
4C42:  CALL   0FDA
4C46:  IORLW  00
4C48:  BZ    4C58
4C4A:  MOVLB  2
4C4C:  INCF   xA9,F
4C4E:  BTFSS  F9E.4
4C50:  BRA    4C4E
4C52:  MOVWF  FAD
4C54:  BRA    4C3E
4C56:  MOVLB  0
....................                   printf("ENERO                              %3.2f                                                     %3.2f\r", media_annos[contador][0], media_annos_caldera[contador][0]); 
4C58:  MOVF   x95,W
4C5A:  MULLW  30
4C5C:  MOVF   FF3,W
4C5E:  MOVLB  2
4C60:  CLRF   xAA
4C62:  MOVWF  xA9
4C64:  MOVLW  1B
4C66:  ADDWF  xA9,W
4C68:  MOVWF  FE9
4C6A:  MOVLW  01
4C6C:  ADDWFC xAA,W
4C6E:  MOVWF  FEA
4C70:  MOVFF  FEF,2AB
4C74:  MOVFF  FEC,2AC
4C78:  MOVFF  FEC,2AD
4C7C:  MOVFF  FEC,2AE
4C80:  MOVLB  0
4C82:  MOVF   x95,W
4C84:  MULLW  30
4C86:  MOVF   FF3,W
4C88:  MOVLB  2
4C8A:  CLRF   xB0
4C8C:  MOVWF  xAF
4C8E:  MOVLW  DB
4C90:  ADDWF  xAF,W
4C92:  MOVWF  FE9
4C94:  MOVLW  01
4C96:  ADDWFC xB0,W
4C98:  MOVWF  FEA
4C9A:  MOVFF  FEF,2B1
4C9E:  MOVFF  FEC,2B2
4CA2:  MOVFF  FEC,2B3
4CA6:  MOVFF  FEC,2B4
4CAA:  CLRF   xB5
4CAC:  MOVF   xB5,W
4CAE:  MOVLB  0
4CB0:  CALL   106A
4CB4:  MOVLB  2
4CB6:  INCF   xB5,F
4CB8:  MOVWF  00
4CBA:  MOVF   00,W
4CBC:  BTFSS  F9E.4
4CBE:  BRA    4CBC
4CC0:  MOVWF  FAD
4CC2:  MOVLW  05
4CC4:  SUBWF  xB5,W
4CC6:  BNZ   4CAC
4CC8:  MOVLW  1E
4CCA:  MOVWF  xB6
4CCC:  MOVLW  20
4CCE:  BTFSS  F9E.4
4CD0:  BRA    4CCE
4CD2:  MOVWF  FAD
4CD4:  DECFSZ xB6,F
4CD6:  BRA    4CCC
4CD8:  MOVLW  02
4CDA:  MOVWF  FE9
4CDC:  MOVFF  2AE,2BB
4CE0:  MOVFF  2AD,2BA
4CE4:  MOVFF  2AC,2B9
4CE8:  MOVFF  2AB,2B8
4CEC:  MOVWF  xBC
4CEE:  MOVLB  0
4CF0:  CALL   397E
4CF4:  MOVLW  35
4CF6:  MOVLB  2
4CF8:  MOVWF  xB7
4CFA:  MOVLW  20
4CFC:  BTFSS  F9E.4
4CFE:  BRA    4CFC
4D00:  MOVWF  FAD
4D02:  DECFSZ xB7,F
4D04:  BRA    4CFA
4D06:  MOVLW  02
4D08:  MOVWF  FE9
4D0A:  MOVFF  2B4,2BB
4D0E:  MOVFF  2B3,2BA
4D12:  MOVFF  2B2,2B9
4D16:  MOVFF  2B1,2B8
4D1A:  MOVWF  xBC
4D1C:  MOVLB  0
4D1E:  CALL   397E
4D22:  MOVLW  0D
4D24:  BTFSS  F9E.4
4D26:  BRA    4D24
4D28:  MOVWF  FAD
....................                   printf("FEBRERO                            %3.2f                                                     %3.2f\r", media_annos[contador][1], media_annos_caldera[contador][1]); 
4D2A:  MOVF   x95,W
4D2C:  MULLW  30
4D2E:  MOVF   FF3,W
4D30:  MOVLB  2
4D32:  CLRF   xAA
4D34:  MOVWF  xA9
4D36:  MOVLW  04
4D38:  ADDWF  xA9,W
4D3A:  MOVWF  01
4D3C:  MOVLW  00
4D3E:  ADDWFC xAA,W
4D40:  MOVWF  03
4D42:  MOVF   01,W
4D44:  ADDLW  1B
4D46:  MOVWF  FE9
4D48:  MOVLW  01
4D4A:  ADDWFC 03,W
4D4C:  MOVWF  FEA
4D4E:  MOVFF  FEF,2AB
4D52:  MOVFF  FEC,2AC
4D56:  MOVFF  FEC,2AD
4D5A:  MOVFF  FEC,2AE
4D5E:  MOVLB  0
4D60:  MOVF   x95,W
4D62:  MULLW  30
4D64:  MOVF   FF3,W
4D66:  MOVLB  2
4D68:  CLRF   xB0
4D6A:  MOVWF  xAF
4D6C:  MOVLW  04
4D6E:  ADDWF  xAF,W
4D70:  MOVWF  01
4D72:  MOVLW  00
4D74:  ADDWFC xB0,W
4D76:  MOVWF  03
4D78:  MOVF   01,W
4D7A:  ADDLW  DB
4D7C:  MOVWF  FE9
4D7E:  MOVLW  01
4D80:  ADDWFC 03,W
4D82:  MOVWF  FEA
4D84:  MOVFF  FEF,2B1
4D88:  MOVFF  FEC,2B2
4D8C:  MOVFF  FEC,2B3
4D90:  MOVFF  FEC,2B4
4D94:  CLRF   xB5
4D96:  MOVF   xB5,W
4D98:  MOVLB  0
4D9A:  CALL   1096
4D9E:  MOVLB  2
4DA0:  INCF   xB5,F
4DA2:  MOVWF  00
4DA4:  MOVF   00,W
4DA6:  BTFSS  F9E.4
4DA8:  BRA    4DA6
4DAA:  MOVWF  FAD
4DAC:  MOVLW  07
4DAE:  SUBWF  xB5,W
4DB0:  BNZ   4D96
4DB2:  MOVLW  1C
4DB4:  MOVWF  xB6
4DB6:  MOVLW  20
4DB8:  BTFSS  F9E.4
4DBA:  BRA    4DB8
4DBC:  MOVWF  FAD
4DBE:  DECFSZ xB6,F
4DC0:  BRA    4DB6
4DC2:  MOVLW  02
4DC4:  MOVWF  FE9
4DC6:  MOVFF  2AE,2BB
4DCA:  MOVFF  2AD,2BA
4DCE:  MOVFF  2AC,2B9
4DD2:  MOVFF  2AB,2B8
4DD6:  MOVWF  xBC
4DD8:  MOVLB  0
4DDA:  CALL   397E
4DDE:  MOVLW  35
4DE0:  MOVLB  2
4DE2:  MOVWF  xB7
4DE4:  MOVLW  20
4DE6:  BTFSS  F9E.4
4DE8:  BRA    4DE6
4DEA:  MOVWF  FAD
4DEC:  DECFSZ xB7,F
4DEE:  BRA    4DE4
4DF0:  MOVLW  02
4DF2:  MOVWF  FE9
4DF4:  MOVFF  2B4,2BB
4DF8:  MOVFF  2B3,2BA
4DFC:  MOVFF  2B2,2B9
4E00:  MOVFF  2B1,2B8
4E04:  MOVWF  xBC
4E06:  MOVLB  0
4E08:  CALL   397E
4E0C:  MOVLW  0D
4E0E:  BTFSS  F9E.4
4E10:  BRA    4E0E
4E12:  MOVWF  FAD
....................                   printf("MARZO                              %3.2f                                                     %3.2f\r", media_annos[contador][2], media_annos_caldera[contador][2]); 
4E14:  MOVF   x95,W
4E16:  MULLW  30
4E18:  MOVF   FF3,W
4E1A:  MOVLB  2
4E1C:  CLRF   xAA
4E1E:  MOVWF  xA9
4E20:  MOVLW  08
4E22:  ADDWF  xA9,W
4E24:  MOVWF  01
4E26:  MOVLW  00
4E28:  ADDWFC xAA,W
4E2A:  MOVWF  03
4E2C:  MOVF   01,W
4E2E:  ADDLW  1B
4E30:  MOVWF  FE9
4E32:  MOVLW  01
4E34:  ADDWFC 03,W
4E36:  MOVWF  FEA
4E38:  MOVFF  FEF,2AB
4E3C:  MOVFF  FEC,2AC
4E40:  MOVFF  FEC,2AD
4E44:  MOVFF  FEC,2AE
4E48:  MOVLB  0
4E4A:  MOVF   x95,W
4E4C:  MULLW  30
4E4E:  MOVF   FF3,W
4E50:  MOVLB  2
4E52:  CLRF   xB0
4E54:  MOVWF  xAF
4E56:  MOVLW  08
4E58:  ADDWF  xAF,W
4E5A:  MOVWF  01
4E5C:  MOVLW  00
4E5E:  ADDWFC xB0,W
4E60:  MOVWF  03
4E62:  MOVF   01,W
4E64:  ADDLW  DB
4E66:  MOVWF  FE9
4E68:  MOVLW  01
4E6A:  ADDWFC 03,W
4E6C:  MOVWF  FEA
4E6E:  MOVFF  FEF,2B1
4E72:  MOVFF  FEC,2B2
4E76:  MOVFF  FEC,2B3
4E7A:  MOVFF  FEC,2B4
4E7E:  CLRF   xB5
4E80:  MOVF   xB5,W
4E82:  MOVLB  0
4E84:  CALL   10C4
4E88:  MOVLB  2
4E8A:  INCF   xB5,F
4E8C:  MOVWF  00
4E8E:  MOVF   00,W
4E90:  BTFSS  F9E.4
4E92:  BRA    4E90
4E94:  MOVWF  FAD
4E96:  MOVLW  05
4E98:  SUBWF  xB5,W
4E9A:  BNZ   4E80
4E9C:  MOVLW  1E
4E9E:  MOVWF  xB6
4EA0:  MOVLW  20
4EA2:  BTFSS  F9E.4
4EA4:  BRA    4EA2
4EA6:  MOVWF  FAD
4EA8:  DECFSZ xB6,F
4EAA:  BRA    4EA0
4EAC:  MOVLW  02
4EAE:  MOVWF  FE9
4EB0:  MOVFF  2AE,2BB
4EB4:  MOVFF  2AD,2BA
4EB8:  MOVFF  2AC,2B9
4EBC:  MOVFF  2AB,2B8
4EC0:  MOVWF  xBC
4EC2:  MOVLB  0
4EC4:  CALL   397E
4EC8:  MOVLW  35
4ECA:  MOVLB  2
4ECC:  MOVWF  xB7
4ECE:  MOVLW  20
4ED0:  BTFSS  F9E.4
4ED2:  BRA    4ED0
4ED4:  MOVWF  FAD
4ED6:  DECFSZ xB7,F
4ED8:  BRA    4ECE
4EDA:  MOVLW  02
4EDC:  MOVWF  FE9
4EDE:  MOVFF  2B4,2BB
4EE2:  MOVFF  2B3,2BA
4EE6:  MOVFF  2B2,2B9
4EEA:  MOVFF  2B1,2B8
4EEE:  MOVWF  xBC
4EF0:  MOVLB  0
4EF2:  CALL   397E
4EF6:  MOVLW  0D
4EF8:  BTFSS  F9E.4
4EFA:  BRA    4EF8
4EFC:  MOVWF  FAD
....................                   printf("ABRIL                              %3.2f                                                     %3.2f\r", media_annos[contador][3], media_annos_caldera[contador][3]); 
4EFE:  MOVF   x95,W
4F00:  MULLW  30
4F02:  MOVF   FF3,W
4F04:  MOVLB  2
4F06:  CLRF   xAA
4F08:  MOVWF  xA9
4F0A:  MOVLW  0C
4F0C:  ADDWF  xA9,W
4F0E:  MOVWF  01
4F10:  MOVLW  00
4F12:  ADDWFC xAA,W
4F14:  MOVWF  03
4F16:  MOVF   01,W
4F18:  ADDLW  1B
4F1A:  MOVWF  FE9
4F1C:  MOVLW  01
4F1E:  ADDWFC 03,W
4F20:  MOVWF  FEA
4F22:  MOVFF  FEF,2AB
4F26:  MOVFF  FEC,2AC
4F2A:  MOVFF  FEC,2AD
4F2E:  MOVFF  FEC,2AE
4F32:  MOVLB  0
4F34:  MOVF   x95,W
4F36:  MULLW  30
4F38:  MOVF   FF3,W
4F3A:  MOVLB  2
4F3C:  CLRF   xB0
4F3E:  MOVWF  xAF
4F40:  MOVLW  0C
4F42:  ADDWF  xAF,W
4F44:  MOVWF  01
4F46:  MOVLW  00
4F48:  ADDWFC xB0,W
4F4A:  MOVWF  03
4F4C:  MOVF   01,W
4F4E:  ADDLW  DB
4F50:  MOVWF  FE9
4F52:  MOVLW  01
4F54:  ADDWFC 03,W
4F56:  MOVWF  FEA
4F58:  MOVFF  FEF,2B1
4F5C:  MOVFF  FEC,2B2
4F60:  MOVFF  FEC,2B3
4F64:  MOVFF  FEC,2B4
4F68:  CLRF   xB5
4F6A:  MOVF   xB5,W
4F6C:  MOVLB  0
4F6E:  CALL   10F0
4F72:  MOVLB  2
4F74:  INCF   xB5,F
4F76:  MOVWF  00
4F78:  MOVF   00,W
4F7A:  BTFSS  F9E.4
4F7C:  BRA    4F7A
4F7E:  MOVWF  FAD
4F80:  MOVLW  05
4F82:  SUBWF  xB5,W
4F84:  BNZ   4F6A
4F86:  MOVLW  1E
4F88:  MOVWF  xB6
4F8A:  MOVLW  20
4F8C:  BTFSS  F9E.4
4F8E:  BRA    4F8C
4F90:  MOVWF  FAD
4F92:  DECFSZ xB6,F
4F94:  BRA    4F8A
4F96:  MOVLW  02
4F98:  MOVWF  FE9
4F9A:  MOVFF  2AE,2BB
4F9E:  MOVFF  2AD,2BA
4FA2:  MOVFF  2AC,2B9
4FA6:  MOVFF  2AB,2B8
4FAA:  MOVWF  xBC
4FAC:  MOVLB  0
4FAE:  CALL   397E
4FB2:  MOVLW  35
4FB4:  MOVLB  2
4FB6:  MOVWF  xB7
4FB8:  MOVLW  20
4FBA:  BTFSS  F9E.4
4FBC:  BRA    4FBA
4FBE:  MOVWF  FAD
4FC0:  DECFSZ xB7,F
4FC2:  BRA    4FB8
4FC4:  MOVLW  02
4FC6:  MOVWF  FE9
4FC8:  MOVFF  2B4,2BB
4FCC:  MOVFF  2B3,2BA
4FD0:  MOVFF  2B2,2B9
4FD4:  MOVFF  2B1,2B8
4FD8:  MOVWF  xBC
4FDA:  MOVLB  0
4FDC:  CALL   397E
4FE0:  MOVLW  0D
4FE2:  BTFSS  F9E.4
4FE4:  BRA    4FE2
4FE6:  MOVWF  FAD
....................                   printf("MAYO                               %3.2f                                                     %3.2f\r", media_annos[contador][4], media_annos_caldera[contador][4]); 
4FE8:  MOVF   x95,W
4FEA:  MULLW  30
4FEC:  MOVF   FF3,W
4FEE:  MOVLB  2
4FF0:  CLRF   xAA
4FF2:  MOVWF  xA9
4FF4:  MOVLW  10
4FF6:  ADDWF  xA9,W
4FF8:  MOVWF  01
4FFA:  MOVLW  00
4FFC:  ADDWFC xAA,W
4FFE:  MOVWF  03
5000:  MOVF   01,W
5002:  ADDLW  1B
5004:  MOVWF  FE9
5006:  MOVLW  01
5008:  ADDWFC 03,W
500A:  MOVWF  FEA
500C:  MOVFF  FEF,2AB
5010:  MOVFF  FEC,2AC
5014:  MOVFF  FEC,2AD
5018:  MOVFF  FEC,2AE
501C:  MOVLB  0
501E:  MOVF   x95,W
5020:  MULLW  30
5022:  MOVF   FF3,W
5024:  MOVLB  2
5026:  CLRF   xB0
5028:  MOVWF  xAF
502A:  MOVLW  10
502C:  ADDWF  xAF,W
502E:  MOVWF  01
5030:  MOVLW  00
5032:  ADDWFC xB0,W
5034:  MOVWF  03
5036:  MOVF   01,W
5038:  ADDLW  DB
503A:  MOVWF  FE9
503C:  MOVLW  01
503E:  ADDWFC 03,W
5040:  MOVWF  FEA
5042:  MOVFF  FEF,2B1
5046:  MOVFF  FEC,2B2
504A:  MOVFF  FEC,2B3
504E:  MOVFF  FEC,2B4
5052:  CLRF   xB5
5054:  MOVF   xB5,W
5056:  MOVLB  0
5058:  CALL   111C
505C:  MOVLB  2
505E:  INCF   xB5,F
5060:  MOVWF  00
5062:  MOVF   00,W
5064:  BTFSS  F9E.4
5066:  BRA    5064
5068:  MOVWF  FAD
506A:  MOVLW  04
506C:  SUBWF  xB5,W
506E:  BNZ   5054
5070:  MOVLW  1F
5072:  MOVWF  xB6
5074:  MOVLW  20
5076:  BTFSS  F9E.4
5078:  BRA    5076
507A:  MOVWF  FAD
507C:  DECFSZ xB6,F
507E:  BRA    5074
5080:  MOVLW  02
5082:  MOVWF  FE9
5084:  MOVFF  2AE,2BB
5088:  MOVFF  2AD,2BA
508C:  MOVFF  2AC,2B9
5090:  MOVFF  2AB,2B8
5094:  MOVWF  xBC
5096:  MOVLB  0
5098:  CALL   397E
509C:  MOVLW  35
509E:  MOVLB  2
50A0:  MOVWF  xB7
50A2:  MOVLW  20
50A4:  BTFSS  F9E.4
50A6:  BRA    50A4
50A8:  MOVWF  FAD
50AA:  DECFSZ xB7,F
50AC:  BRA    50A2
50AE:  MOVLW  02
50B0:  MOVWF  FE9
50B2:  MOVFF  2B4,2BB
50B6:  MOVFF  2B3,2BA
50BA:  MOVFF  2B2,2B9
50BE:  MOVFF  2B1,2B8
50C2:  MOVWF  xBC
50C4:  MOVLB  0
50C6:  CALL   397E
50CA:  MOVLW  0D
50CC:  BTFSS  F9E.4
50CE:  BRA    50CC
50D0:  MOVWF  FAD
....................                   printf("JUNIO                              %3.2f                                                     %3.2f\r", media_annos[contador][5], media_annos_caldera[contador][5]); 
50D2:  MOVF   x95,W
50D4:  MULLW  30
50D6:  MOVF   FF3,W
50D8:  MOVLB  2
50DA:  CLRF   xAA
50DC:  MOVWF  xA9
50DE:  MOVLW  14
50E0:  ADDWF  xA9,W
50E2:  MOVWF  01
50E4:  MOVLW  00
50E6:  ADDWFC xAA,W
50E8:  MOVWF  03
50EA:  MOVF   01,W
50EC:  ADDLW  1B
50EE:  MOVWF  FE9
50F0:  MOVLW  01
50F2:  ADDWFC 03,W
50F4:  MOVWF  FEA
50F6:  MOVFF  FEF,2AB
50FA:  MOVFF  FEC,2AC
50FE:  MOVFF  FEC,2AD
5102:  MOVFF  FEC,2AE
5106:  MOVLB  0
5108:  MOVF   x95,W
510A:  MULLW  30
510C:  MOVF   FF3,W
510E:  MOVLB  2
5110:  CLRF   xB0
5112:  MOVWF  xAF
5114:  MOVLW  14
5116:  ADDWF  xAF,W
5118:  MOVWF  01
511A:  MOVLW  00
511C:  ADDWFC xB0,W
511E:  MOVWF  03
5120:  MOVF   01,W
5122:  ADDLW  DB
5124:  MOVWF  FE9
5126:  MOVLW  01
5128:  ADDWFC 03,W
512A:  MOVWF  FEA
512C:  MOVFF  FEF,2B1
5130:  MOVFF  FEC,2B2
5134:  MOVFF  FEC,2B3
5138:  MOVFF  FEC,2B4
513C:  CLRF   xB5
513E:  MOVF   xB5,W
5140:  MOVLB  0
5142:  CALL   1146
5146:  MOVLB  2
5148:  INCF   xB5,F
514A:  MOVWF  00
514C:  MOVF   00,W
514E:  BTFSS  F9E.4
5150:  BRA    514E
5152:  MOVWF  FAD
5154:  MOVLW  05
5156:  SUBWF  xB5,W
5158:  BNZ   513E
515A:  MOVLW  1E
515C:  MOVWF  xB6
515E:  MOVLW  20
5160:  BTFSS  F9E.4
5162:  BRA    5160
5164:  MOVWF  FAD
5166:  DECFSZ xB6,F
5168:  BRA    515E
516A:  MOVLW  02
516C:  MOVWF  FE9
516E:  MOVFF  2AE,2BB
5172:  MOVFF  2AD,2BA
5176:  MOVFF  2AC,2B9
517A:  MOVFF  2AB,2B8
517E:  MOVWF  xBC
5180:  MOVLB  0
5182:  CALL   397E
5186:  MOVLW  35
5188:  MOVLB  2
518A:  MOVWF  xB7
518C:  MOVLW  20
518E:  BTFSS  F9E.4
5190:  BRA    518E
5192:  MOVWF  FAD
5194:  DECFSZ xB7,F
5196:  BRA    518C
5198:  MOVLW  02
519A:  MOVWF  FE9
519C:  MOVFF  2B4,2BB
51A0:  MOVFF  2B3,2BA
51A4:  MOVFF  2B2,2B9
51A8:  MOVFF  2B1,2B8
51AC:  MOVWF  xBC
51AE:  MOVLB  0
51B0:  CALL   397E
51B4:  MOVLW  0D
51B6:  BTFSS  F9E.4
51B8:  BRA    51B6
51BA:  MOVWF  FAD
....................                   printf("JULIO                              %3.2f                                                     %3.2f\r", media_annos[contador][6], media_annos_caldera[contador][6]); 
51BC:  MOVF   x95,W
51BE:  MULLW  30
51C0:  MOVF   FF3,W
51C2:  MOVLB  2
51C4:  CLRF   xAA
51C6:  MOVWF  xA9
51C8:  MOVLW  18
51CA:  ADDWF  xA9,W
51CC:  MOVWF  01
51CE:  MOVLW  00
51D0:  ADDWFC xAA,W
51D2:  MOVWF  03
51D4:  MOVF   01,W
51D6:  ADDLW  1B
51D8:  MOVWF  FE9
51DA:  MOVLW  01
51DC:  ADDWFC 03,W
51DE:  MOVWF  FEA
51E0:  MOVFF  FEF,2AB
51E4:  MOVFF  FEC,2AC
51E8:  MOVFF  FEC,2AD
51EC:  MOVFF  FEC,2AE
51F0:  MOVLB  0
51F2:  MOVF   x95,W
51F4:  MULLW  30
51F6:  MOVF   FF3,W
51F8:  MOVLB  2
51FA:  CLRF   xB0
51FC:  MOVWF  xAF
51FE:  MOVLW  18
5200:  ADDWF  xAF,W
5202:  MOVWF  01
5204:  MOVLW  00
5206:  ADDWFC xB0,W
5208:  MOVWF  03
520A:  MOVF   01,W
520C:  ADDLW  DB
520E:  MOVWF  FE9
5210:  MOVLW  01
5212:  ADDWFC 03,W
5214:  MOVWF  FEA
5216:  MOVFF  FEF,2B1
521A:  MOVFF  FEC,2B2
521E:  MOVFF  FEC,2B3
5222:  MOVFF  FEC,2B4
5226:  CLRF   xB5
5228:  MOVF   xB5,W
522A:  MOVLB  0
522C:  CALL   1172
5230:  MOVLB  2
5232:  INCF   xB5,F
5234:  MOVWF  00
5236:  MOVF   00,W
5238:  BTFSS  F9E.4
523A:  BRA    5238
523C:  MOVWF  FAD
523E:  MOVLW  05
5240:  SUBWF  xB5,W
5242:  BNZ   5228
5244:  MOVLW  1E
5246:  MOVWF  xB6
5248:  MOVLW  20
524A:  BTFSS  F9E.4
524C:  BRA    524A
524E:  MOVWF  FAD
5250:  DECFSZ xB6,F
5252:  BRA    5248
5254:  MOVLW  02
5256:  MOVWF  FE9
5258:  MOVFF  2AE,2BB
525C:  MOVFF  2AD,2BA
5260:  MOVFF  2AC,2B9
5264:  MOVFF  2AB,2B8
5268:  MOVWF  xBC
526A:  MOVLB  0
526C:  CALL   397E
5270:  MOVLW  35
5272:  MOVLB  2
5274:  MOVWF  xB7
5276:  MOVLW  20
5278:  BTFSS  F9E.4
527A:  BRA    5278
527C:  MOVWF  FAD
527E:  DECFSZ xB7,F
5280:  BRA    5276
5282:  MOVLW  02
5284:  MOVWF  FE9
5286:  MOVFF  2B4,2BB
528A:  MOVFF  2B3,2BA
528E:  MOVFF  2B2,2B9
5292:  MOVFF  2B1,2B8
5296:  MOVWF  xBC
5298:  MOVLB  0
529A:  CALL   397E
529E:  MOVLW  0D
52A0:  BTFSS  F9E.4
52A2:  BRA    52A0
52A4:  MOVWF  FAD
....................                   printf("AGOSTO                             %3.2f                                                     %3.2f\r", media_annos[contador][7], media_annos_caldera[contador][7]); 
52A6:  MOVF   x95,W
52A8:  MULLW  30
52AA:  MOVF   FF3,W
52AC:  MOVLB  2
52AE:  CLRF   xAA
52B0:  MOVWF  xA9
52B2:  MOVLW  1C
52B4:  ADDWF  xA9,W
52B6:  MOVWF  01
52B8:  MOVLW  00
52BA:  ADDWFC xAA,W
52BC:  MOVWF  03
52BE:  MOVF   01,W
52C0:  ADDLW  1B
52C2:  MOVWF  FE9
52C4:  MOVLW  01
52C6:  ADDWFC 03,W
52C8:  MOVWF  FEA
52CA:  MOVFF  FEF,2AB
52CE:  MOVFF  FEC,2AC
52D2:  MOVFF  FEC,2AD
52D6:  MOVFF  FEC,2AE
52DA:  MOVLB  0
52DC:  MOVF   x95,W
52DE:  MULLW  30
52E0:  MOVF   FF3,W
52E2:  MOVLB  2
52E4:  CLRF   xB0
52E6:  MOVWF  xAF
52E8:  MOVLW  1C
52EA:  ADDWF  xAF,W
52EC:  MOVWF  01
52EE:  MOVLW  00
52F0:  ADDWFC xB0,W
52F2:  MOVWF  03
52F4:  MOVF   01,W
52F6:  ADDLW  DB
52F8:  MOVWF  FE9
52FA:  MOVLW  01
52FC:  ADDWFC 03,W
52FE:  MOVWF  FEA
5300:  MOVFF  FEF,2B1
5304:  MOVFF  FEC,2B2
5308:  MOVFF  FEC,2B3
530C:  MOVFF  FEC,2B4
5310:  CLRF   xB5
5312:  MOVF   xB5,W
5314:  MOVLB  0
5316:  CALL   119E
531A:  MOVLB  2
531C:  INCF   xB5,F
531E:  MOVWF  00
5320:  MOVF   00,W
5322:  BTFSS  F9E.4
5324:  BRA    5322
5326:  MOVWF  FAD
5328:  MOVLW  06
532A:  SUBWF  xB5,W
532C:  BNZ   5312
532E:  MOVLW  1D
5330:  MOVWF  xB6
5332:  MOVLW  20
5334:  BTFSS  F9E.4
5336:  BRA    5334
5338:  MOVWF  FAD
533A:  DECFSZ xB6,F
533C:  BRA    5332
533E:  MOVLW  02
5340:  MOVWF  FE9
5342:  MOVFF  2AE,2BB
5346:  MOVFF  2AD,2BA
534A:  MOVFF  2AC,2B9
534E:  MOVFF  2AB,2B8
5352:  MOVWF  xBC
5354:  MOVLB  0
5356:  CALL   397E
535A:  MOVLW  35
535C:  MOVLB  2
535E:  MOVWF  xB7
5360:  MOVLW  20
5362:  BTFSS  F9E.4
5364:  BRA    5362
5366:  MOVWF  FAD
5368:  DECFSZ xB7,F
536A:  BRA    5360
536C:  MOVLW  02
536E:  MOVWF  FE9
5370:  MOVFF  2B4,2BB
5374:  MOVFF  2B3,2BA
5378:  MOVFF  2B2,2B9
537C:  MOVFF  2B1,2B8
5380:  MOVWF  xBC
5382:  MOVLB  0
5384:  CALL   397E
5388:  MOVLW  0D
538A:  BTFSS  F9E.4
538C:  BRA    538A
538E:  MOVWF  FAD
....................                   printf("SEPTIEMBRE                         %3.2f                                                     %3.2f\r", media_annos[contador][8], media_annos_caldera[contador][8]); 
5390:  MOVF   x95,W
5392:  MULLW  30
5394:  MOVF   FF3,W
5396:  MOVLB  2
5398:  CLRF   xAA
539A:  MOVWF  xA9
539C:  MOVLW  20
539E:  ADDWF  xA9,W
53A0:  MOVWF  01
53A2:  MOVLW  00
53A4:  ADDWFC xAA,W
53A6:  MOVWF  03
53A8:  MOVF   01,W
53AA:  ADDLW  1B
53AC:  MOVWF  FE9
53AE:  MOVLW  01
53B0:  ADDWFC 03,W
53B2:  MOVWF  FEA
53B4:  MOVFF  FEF,2AB
53B8:  MOVFF  FEC,2AC
53BC:  MOVFF  FEC,2AD
53C0:  MOVFF  FEC,2AE
53C4:  MOVLB  0
53C6:  MOVF   x95,W
53C8:  MULLW  30
53CA:  MOVF   FF3,W
53CC:  MOVLB  2
53CE:  CLRF   xB0
53D0:  MOVWF  xAF
53D2:  MOVLW  20
53D4:  ADDWF  xAF,W
53D6:  MOVWF  01
53D8:  MOVLW  00
53DA:  ADDWFC xB0,W
53DC:  MOVWF  03
53DE:  MOVF   01,W
53E0:  ADDLW  DB
53E2:  MOVWF  FE9
53E4:  MOVLW  01
53E6:  ADDWFC 03,W
53E8:  MOVWF  FEA
53EA:  MOVFF  FEF,2B1
53EE:  MOVFF  FEC,2B2
53F2:  MOVFF  FEC,2B3
53F6:  MOVFF  FEC,2B4
53FA:  CLRF   xB5
53FC:  MOVF   xB5,W
53FE:  MOVLB  0
5400:  CALL   11CA
5404:  MOVLB  2
5406:  INCF   xB5,F
5408:  MOVWF  00
540A:  MOVF   00,W
540C:  BTFSS  F9E.4
540E:  BRA    540C
5410:  MOVWF  FAD
5412:  MOVLW  0A
5414:  SUBWF  xB5,W
5416:  BNZ   53FC
5418:  MOVLW  19
541A:  MOVWF  xB6
541C:  MOVLW  20
541E:  BTFSS  F9E.4
5420:  BRA    541E
5422:  MOVWF  FAD
5424:  DECFSZ xB6,F
5426:  BRA    541C
5428:  MOVLW  02
542A:  MOVWF  FE9
542C:  MOVFF  2AE,2BB
5430:  MOVFF  2AD,2BA
5434:  MOVFF  2AC,2B9
5438:  MOVFF  2AB,2B8
543C:  MOVWF  xBC
543E:  MOVLB  0
5440:  CALL   397E
5444:  MOVLW  35
5446:  MOVLB  2
5448:  MOVWF  xB7
544A:  MOVLW  20
544C:  BTFSS  F9E.4
544E:  BRA    544C
5450:  MOVWF  FAD
5452:  DECFSZ xB7,F
5454:  BRA    544A
5456:  MOVLW  02
5458:  MOVWF  FE9
545A:  MOVFF  2B4,2BB
545E:  MOVFF  2B3,2BA
5462:  MOVFF  2B2,2B9
5466:  MOVFF  2B1,2B8
546A:  MOVWF  xBC
546C:  MOVLB  0
546E:  CALL   397E
5472:  MOVLW  0D
5474:  BTFSS  F9E.4
5476:  BRA    5474
5478:  MOVWF  FAD
....................                   printf("OCTUBRE                            %3.2f                                                     %3.2f\r", media_annos[contador][9], media_annos_caldera[contador][9]); 
547A:  MOVF   x95,W
547C:  MULLW  30
547E:  MOVF   FF3,W
5480:  MOVLB  2
5482:  CLRF   xAA
5484:  MOVWF  xA9
5486:  MOVLW  24
5488:  ADDWF  xA9,W
548A:  MOVWF  01
548C:  MOVLW  00
548E:  ADDWFC xAA,W
5490:  MOVWF  03
5492:  MOVF   01,W
5494:  ADDLW  1B
5496:  MOVWF  FE9
5498:  MOVLW  01
549A:  ADDWFC 03,W
549C:  MOVWF  FEA
549E:  MOVFF  FEF,2AB
54A2:  MOVFF  FEC,2AC
54A6:  MOVFF  FEC,2AD
54AA:  MOVFF  FEC,2AE
54AE:  MOVLB  0
54B0:  MOVF   x95,W
54B2:  MULLW  30
54B4:  MOVF   FF3,W
54B6:  MOVLB  2
54B8:  CLRF   xB0
54BA:  MOVWF  xAF
54BC:  MOVLW  24
54BE:  ADDWF  xAF,W
54C0:  MOVWF  01
54C2:  MOVLW  00
54C4:  ADDWFC xB0,W
54C6:  MOVWF  03
54C8:  MOVF   01,W
54CA:  ADDLW  DB
54CC:  MOVWF  FE9
54CE:  MOVLW  01
54D0:  ADDWFC 03,W
54D2:  MOVWF  FEA
54D4:  MOVFF  FEF,2B1
54D8:  MOVFF  FEC,2B2
54DC:  MOVFF  FEC,2B3
54E0:  MOVFF  FEC,2B4
54E4:  CLRF   xB5
54E6:  MOVF   xB5,W
54E8:  MOVLB  0
54EA:  CALL   11FA
54EE:  MOVLB  2
54F0:  INCF   xB5,F
54F2:  MOVWF  00
54F4:  MOVF   00,W
54F6:  BTFSS  F9E.4
54F8:  BRA    54F6
54FA:  MOVWF  FAD
54FC:  MOVLW  07
54FE:  SUBWF  xB5,W
5500:  BNZ   54E6
5502:  MOVLW  1C
5504:  MOVWF  xB6
5506:  MOVLW  20
5508:  BTFSS  F9E.4
550A:  BRA    5508
550C:  MOVWF  FAD
550E:  DECFSZ xB6,F
5510:  BRA    5506
5512:  MOVLW  02
5514:  MOVWF  FE9
5516:  MOVFF  2AE,2BB
551A:  MOVFF  2AD,2BA
551E:  MOVFF  2AC,2B9
5522:  MOVFF  2AB,2B8
5526:  MOVWF  xBC
5528:  MOVLB  0
552A:  CALL   397E
552E:  MOVLW  35
5530:  MOVLB  2
5532:  MOVWF  xB7
5534:  MOVLW  20
5536:  BTFSS  F9E.4
5538:  BRA    5536
553A:  MOVWF  FAD
553C:  DECFSZ xB7,F
553E:  BRA    5534
5540:  MOVLW  02
5542:  MOVWF  FE9
5544:  MOVFF  2B4,2BB
5548:  MOVFF  2B3,2BA
554C:  MOVFF  2B2,2B9
5550:  MOVFF  2B1,2B8
5554:  MOVWF  xBC
5556:  MOVLB  0
5558:  CALL   397E
555C:  MOVLW  0D
555E:  BTFSS  F9E.4
5560:  BRA    555E
5562:  MOVWF  FAD
....................                   printf("NOVIEMBRE                          %3.2f                                                     %3.2f\r", media_annos[contador][10], media_annos_caldera[contador][10]); 
5564:  MOVF   x95,W
5566:  MULLW  30
5568:  MOVF   FF3,W
556A:  MOVLB  2
556C:  CLRF   xAA
556E:  MOVWF  xA9
5570:  MOVLW  28
5572:  ADDWF  xA9,W
5574:  MOVWF  01
5576:  MOVLW  00
5578:  ADDWFC xAA,W
557A:  MOVWF  03
557C:  MOVF   01,W
557E:  ADDLW  1B
5580:  MOVWF  FE9
5582:  MOVLW  01
5584:  ADDWFC 03,W
5586:  MOVWF  FEA
5588:  MOVFF  FEF,2AB
558C:  MOVFF  FEC,2AC
5590:  MOVFF  FEC,2AD
5594:  MOVFF  FEC,2AE
5598:  MOVLB  0
559A:  MOVF   x95,W
559C:  MULLW  30
559E:  MOVF   FF3,W
55A0:  MOVLB  2
55A2:  CLRF   xB0
55A4:  MOVWF  xAF
55A6:  MOVLW  28
55A8:  ADDWF  xAF,W
55AA:  MOVWF  01
55AC:  MOVLW  00
55AE:  ADDWFC xB0,W
55B0:  MOVWF  03
55B2:  MOVF   01,W
55B4:  ADDLW  DB
55B6:  MOVWF  FE9
55B8:  MOVLW  01
55BA:  ADDWFC 03,W
55BC:  MOVWF  FEA
55BE:  MOVFF  FEF,2B1
55C2:  MOVFF  FEC,2B2
55C6:  MOVFF  FEC,2B3
55CA:  MOVFF  FEC,2B4
55CE:  CLRF   xB5
55D0:  MOVF   xB5,W
55D2:  MOVLB  0
55D4:  CALL   1228
55D8:  MOVLB  2
55DA:  INCF   xB5,F
55DC:  MOVWF  00
55DE:  MOVF   00,W
55E0:  BTFSS  F9E.4
55E2:  BRA    55E0
55E4:  MOVWF  FAD
55E6:  MOVLW  09
55E8:  SUBWF  xB5,W
55EA:  BNZ   55D0
55EC:  MOVLW  1A
55EE:  MOVWF  xB6
55F0:  MOVLW  20
55F2:  BTFSS  F9E.4
55F4:  BRA    55F2
55F6:  MOVWF  FAD
55F8:  DECFSZ xB6,F
55FA:  BRA    55F0
55FC:  MOVLW  02
55FE:  MOVWF  FE9
5600:  MOVFF  2AE,2BB
5604:  MOVFF  2AD,2BA
5608:  MOVFF  2AC,2B9
560C:  MOVFF  2AB,2B8
5610:  MOVWF  xBC
5612:  MOVLB  0
5614:  CALL   397E
5618:  MOVLW  35
561A:  MOVLB  2
561C:  MOVWF  xB7
561E:  MOVLW  20
5620:  BTFSS  F9E.4
5622:  BRA    5620
5624:  MOVWF  FAD
5626:  DECFSZ xB7,F
5628:  BRA    561E
562A:  MOVLW  02
562C:  MOVWF  FE9
562E:  MOVFF  2B4,2BB
5632:  MOVFF  2B3,2BA
5636:  MOVFF  2B2,2B9
563A:  MOVFF  2B1,2B8
563E:  MOVWF  xBC
5640:  MOVLB  0
5642:  CALL   397E
5646:  MOVLW  0D
5648:  BTFSS  F9E.4
564A:  BRA    5648
564C:  MOVWF  FAD
....................                   printf("DICIEMBRE                          %3.2f                                                     %3.2f\r", media_annos[contador][11], media_annos_caldera[contador][11]); 
564E:  MOVF   x95,W
5650:  MULLW  30
5652:  MOVF   FF3,W
5654:  MOVLB  2
5656:  CLRF   xAA
5658:  MOVWF  xA9
565A:  MOVLW  2C
565C:  ADDWF  xA9,W
565E:  MOVWF  01
5660:  MOVLW  00
5662:  ADDWFC xAA,W
5664:  MOVWF  03
5666:  MOVF   01,W
5668:  ADDLW  1B
566A:  MOVWF  FE9
566C:  MOVLW  01
566E:  ADDWFC 03,W
5670:  MOVWF  FEA
5672:  MOVFF  FEF,2AB
5676:  MOVFF  FEC,2AC
567A:  MOVFF  FEC,2AD
567E:  MOVFF  FEC,2AE
5682:  MOVLB  0
5684:  MOVF   x95,W
5686:  MULLW  30
5688:  MOVF   FF3,W
568A:  MOVLB  2
568C:  CLRF   xB0
568E:  MOVWF  xAF
5690:  MOVLW  2C
5692:  ADDWF  xAF,W
5694:  MOVWF  01
5696:  MOVLW  00
5698:  ADDWFC xB0,W
569A:  MOVWF  03
569C:  MOVF   01,W
569E:  ADDLW  DB
56A0:  MOVWF  FE9
56A2:  MOVLW  01
56A4:  ADDWFC 03,W
56A6:  MOVWF  FEA
56A8:  MOVFF  FEF,2B1
56AC:  MOVFF  FEC,2B2
56B0:  MOVFF  FEC,2B3
56B4:  MOVFF  FEC,2B4
56B8:  CLRF   xB5
56BA:  MOVF   xB5,W
56BC:  MOVLB  0
56BE:  CALL   1258
56C2:  MOVLB  2
56C4:  INCF   xB5,F
56C6:  MOVWF  00
56C8:  MOVF   00,W
56CA:  BTFSS  F9E.4
56CC:  BRA    56CA
56CE:  MOVWF  FAD
56D0:  MOVLW  09
56D2:  SUBWF  xB5,W
56D4:  BNZ   56BA
56D6:  MOVLW  1A
56D8:  MOVWF  xB6
56DA:  MOVLW  20
56DC:  BTFSS  F9E.4
56DE:  BRA    56DC
56E0:  MOVWF  FAD
56E2:  DECFSZ xB6,F
56E4:  BRA    56DA
56E6:  MOVLW  02
56E8:  MOVWF  FE9
56EA:  MOVFF  2AE,2BB
56EE:  MOVFF  2AD,2BA
56F2:  MOVFF  2AC,2B9
56F6:  MOVFF  2AB,2B8
56FA:  MOVWF  xBC
56FC:  MOVLB  0
56FE:  CALL   397E
5702:  MOVLW  35
5704:  MOVLB  2
5706:  MOVWF  xB7
5708:  MOVLW  20
570A:  BTFSS  F9E.4
570C:  BRA    570A
570E:  MOVWF  FAD
5710:  DECFSZ xB7,F
5712:  BRA    5708
5714:  MOVLW  02
5716:  MOVWF  FE9
5718:  MOVFF  2B4,2BB
571C:  MOVFF  2B3,2BA
5720:  MOVFF  2B2,2B9
5724:  MOVFF  2B1,2B8
5728:  MOVWF  xBC
572A:  MOVLB  0
572C:  CALL   397E
5730:  MOVLW  0D
5732:  BTFSS  F9E.4
5734:  BRA    5732
5736:  MOVWF  FAD
....................                   printf("--------------------------------------------------------------------------------------------------------------------\r"); 
5738:  MOVLB  2
573A:  CLRF   xA9
573C:  MOVF   xA9,W
573E:  MOVLB  0
5740:  CALL   0F4A
5744:  IORLW  00
5746:  BZ    5756
5748:  MOVLB  2
574A:  INCF   xA9,F
574C:  BTFSS  F9E.4
574E:  BRA    574C
5750:  MOVWF  FAD
5752:  BRA    573C
5754:  MOVLB  0
....................                } 
5756:  INCF   x95,F
5758:  GOTO   4B94
....................  
....................                goto repetir; 
575C:  GOTO   48EE
....................                break; 
5760:  BRA    5762
....................  
....................       //En los tres casos, vuelve a mostrarse el menú tras imprimir las estadísticas 
....................    } 
.................... } 
5762:  GOTO   6B68 (RETURN)
....................  
.................... //----------------------------------------------------------------------------------------------------------------------------------------- 
....................  
.................... void seleccionar_alarma() 
.................... { 
....................    //Contador y variables auxiliares 
....................    int contador; 
....................    int hora, minutos, hora_p, min_p; 
....................  
....................    //Ponemos la posición en el vector de alarmas incialmente a 0 
....................    posicion_alarmas = 0; 
*
3746:  CLRF   5A
....................  
....................    //Leemos el tiempo actual 
....................    PCF8583_read_datetime(&tiempo); 
3748:  CLRF   xA2
374A:  MOVLW  5B
374C:  MOVWF  xA1
374E:  CALL   2764
....................    //Habilitamos interrupciones (se desactivan en el método anterior) 
....................    //enable_interrupts(GLOBAL); 
....................    hora = tiempo.hours; 
3752:  MOVFF  5D,96
....................    minutos = tiempo.minutes; 
3756:  MOVFF  5C,97
....................  
....................    //Recorremos todas las programaciones 
....................    for(contador=0; contador<num_intervalos; contador++) 
375A:  CLRF   x95
375C:  MOVF   59,W
375E:  SUBWF  x95,W
3760:  BC    37C4
....................    { 
....................        hora_p = programaciones[contador].horas_inicio; 
3762:  MOVF   x95,W
3764:  MULLW  05
3766:  MOVF   FF3,W
3768:  CLRF   x9B
376A:  MOVWF  x9A
376C:  MOVLW  3B
376E:  ADDWF  x9A,W
3770:  MOVWF  FE9
3772:  MOVLW  00
3774:  ADDWFC x9B,W
3776:  MOVWF  FEA
3778:  MOVFF  FEF,98
....................        min_p  = programaciones[contador].minutos_inicio; 
377C:  MOVF   x95,W
377E:  MULLW  05
3780:  MOVF   FF3,W
3782:  CLRF   x9B
3784:  MOVWF  x9A
3786:  MOVLW  01
3788:  ADDWF  x9A,W
378A:  MOVWF  01
378C:  MOVLW  00
378E:  ADDWFC x9B,W
3790:  MOVWF  03
3792:  MOVF   01,W
3794:  ADDLW  3B
3796:  MOVWF  FE9
3798:  MOVLW  00
379A:  ADDWFC 03,W
379C:  MOVWF  FEA
379E:  MOVFF  FEF,99
....................  
....................        //Comprobamos las horas y tomamos la primera programación que tenga una 
....................        //hora mayor que la actual 
....................        if(!comprobar_hora(hora_p, min_p, hora, minutos)) 
37A2:  MOVFF  98,AB
37A6:  MOVFF  99,AC
37AA:  MOVFF  96,AD
37AE:  MOVFF  97,AE
37B2:  CALL   2AEA
37B6:  MOVF   01,F
37B8:  BNZ   37C0
....................        { 
....................            //Guardamos la posición de esta programación y salimos 
....................            posicion_alarmas = contador; 
37BA:  MOVFF  95,5A
....................            break; 
37BE:  BRA    37C4
....................        } 
....................    } 
37C0:  INCF   x95,F
37C2:  BRA    375C
.................... } 
37C4:  GOTO   6A00 (RETURN)

Configuration Fuses:
   Word  1: 0200   HS NOIESO NOFCMEN RESERVED
   Word  2: 181E   BROWNOUT NOWDT BORV25 PUT WDT4096
   Word  3: 8300   PBADEN CCP2C1 NOLPT1OSC MCLR RESERVED
   Word  4: 0081   STVREN NODEBUG NOLVP NOXINST RESERVED
   Word  5: C00F   NOPROTECT NOCPD NOCPB
   Word  6: E00F   NOWRT NOWRTD NOWRTC NOWRTB
   Word  7: 400F   NOEBTR NOEBTRB
