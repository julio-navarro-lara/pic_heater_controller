CCS PCH C Compiler, Version 3.249, 28193               26-feb-10 13:01

               Filename: E:\programming\sed\Proyecto 1\Prototipo 1 optimizado\proyecto1.lst

               ROM used: 27902 bytes (85%)
                         Largest free fragment is 4862
               RAM used: 138 (9%) at main() level
                         722 (47%) worst case
               Stack:    8 worst case (7 in main + 1 for interrupts)

*
0000:  GOTO   5CBA
*
0008:  MOVWF  05
000A:  MOVFF  FD8,06
000E:  MOVFF  FE0,07
0012:  MOVLB  0
0014:  MOVFF  FE9,0D
0018:  MOVFF  FEA,08
001C:  MOVFF  FE1,09
0020:  MOVFF  FE2,0A
0024:  MOVFF  FD9,0B
0028:  MOVFF  FDA,0C
002C:  MOVFF  FF3,14
0030:  MOVFF  FF4,15
0034:  MOVFF  FFA,16
0038:  MOVFF  00,0F
003C:  MOVFF  01,10
0040:  MOVFF  02,11
0044:  MOVFF  03,12
0048:  MOVFF  04,13
004C:  BTFSS  F9D.0
004E:  GOTO   0058
0052:  BTFSC  F9E.0
0054:  GOTO   1298
0058:  BTFSS  FF2.4
005A:  GOTO   0064
005E:  BTFSC  FF2.1
0060:  GOTO   1288
0064:  BTFSS  FF0.3
0066:  GOTO   0070
006A:  BTFSC  FF0.0
006C:  GOTO   1290
0070:  MOVFF  0F,00
0074:  MOVFF  10,01
0078:  MOVFF  11,02
007C:  MOVFF  12,03
0080:  MOVFF  13,04
0084:  MOVFF  0D,FE9
0088:  MOVFF  08,FEA
008C:  MOVFF  09,FE1
0090:  MOVFF  0A,FE2
0094:  MOVFF  0B,FD9
0098:  MOVFF  0C,FDA
009C:  MOVFF  14,FF3
00A0:  MOVFF  15,FF4
00A4:  MOVFF  16,FFA
00A8:  MOVF   05,W
00AA:  MOVFF  07,FE0
00AE:  MOVFF  06,FD8
00B2:  RETFIE 0
.................... //***************************************************************** 
.................... //***   PROYECTO 1: Control de un sistema de calefacción de una *** 
.................... //***   vivienda utilizando un microcontrolador PIC18F4520      *** 
.................... //***************************************************************** 
.................... //Author: Julio Navarro Lara        2010 
....................  
....................  
....................  
.................... #include "18F4520.H" 
.................... //////// Standard Header file for the PIC18F4520 device //////////////// 
.................... #DEVICE PIC18F4520 //Aunque el convertidor A/D es de 10 bits, con esta directiva 
00B4:  MOVFF  FF2,0E
00B8:  BCF    FF2.7
00BA:  CLRF   FF7
00BC:  ADDLW  CE
00BE:  MOVWF  FF6
00C0:  MOVLW  00
00C2:  ADDWFC FF7,F
00C4:  TBLRD*+
00C6:  MOVF   FF5,W
00C8:  BTFSC  0E.7
00CA:  BSF    FF2.7
00CC:  RETURN 0
00CE:  DATA 2C,0F
00D0:  DATA 01,06
00D2:  MOVFF  FF2,0E
00D6:  BCF    FF2.7
00D8:  CLRF   FF7
00DA:  ADDLW  EC
00DC:  MOVWF  FF6
00DE:  MOVLW  00
00E0:  ADDWFC FF7,F
00E2:  TBLRD*+
00E4:  MOVF   FF5,W
00E6:  BTFSC  0E.7
00E8:  BSF    FF2.7
00EA:  RETURN 0
00EC:  DATA 31,32
00EE:  DATA 33,34
00F0:  DATA 35,36
00F2:  DATA 37,38
00F4:  DATA 39,53
00F6:  DATA 30,4E
00F8:  MOVFF  FF2,0E
00FC:  BCF    FF2.7
00FE:  CLRF   FF7
0100:  ADDLW  12
0102:  MOVWF  FF6
0104:  MOVLW  01
0106:  ADDWFC FF7,F
0108:  TBLRD*+
010A:  MOVF   FF5,W
010C:  BTFSC  0E.7
010E:  BSF    FF2.7
0110:  RETURN 0
0112:  DATA 49,6E
0114:  DATA 69,63
0116:  DATA 69,61
0118:  DATA 6C,69
011A:  DATA 7A,61
011C:  DATA 6E,64
011E:  DATA 6F,2E
0120:  DATA 2E,2E
0122:  DATA 00,00
0124:  MOVFF  FF2,0E
0128:  BCF    FF2.7
012A:  CLRF   FF7
012C:  ADDLW  3E
012E:  MOVWF  FF6
0130:  MOVLW  01
0132:  ADDWFC FF7,F
0134:  TBLRD*+
0136:  MOVF   FF5,W
0138:  BTFSC  0E.7
013A:  BSF    FF2.7
013C:  RETURN 0
013E:  DATA 53,69
0140:  DATA 73,74
0142:  DATA 65,6D
0144:  DATA 61,20
0146:  DATA 69,6E
0148:  DATA 69,63
014A:  DATA 69,61
014C:  DATA 6C,69
014E:  DATA 7A,61
0150:  DATA 64,6F
0152:  DATA 20,63
0154:  DATA 6F,6E
0156:  DATA 20,65
0158:  DATA 78,69
015A:  DATA 74,6F
015C:  DATA 21,0D
015E:  DATA 00,00
0160:  MOVFF  FF2,0E
0164:  BCF    FF2.7
0166:  CLRF   FF7
0168:  ADDLW  7A
016A:  MOVWF  FF6
016C:  MOVLW  01
016E:  ADDWFC FF7,F
0170:  TBLRD*+
0172:  MOVF   FF5,W
0174:  BTFSC  0E.7
0176:  BSF    FF2.7
0178:  RETURN 0
017A:  DATA 20,20
017C:  DATA 45,6E
017E:  DATA 63,65
0180:  DATA 6E,64
0182:  DATA 69,65
0184:  DATA 6E,64
0186:  DATA 6F,0A
0188:  DATA 20,20
018A:  DATA 73,69
018C:  DATA 73,74
018E:  DATA 65,6D
0190:  DATA 61,2E
0192:  DATA 2E,2E
0194:  DATA 00,00
0196:  MOVFF  FF2,0E
019A:  BCF    FF2.7
019C:  CLRF   FF7
019E:  ADDLW  B0
01A0:  MOVWF  FF6
01A2:  MOVLW  01
01A4:  ADDWFC FF7,F
01A6:  TBLRD*+
01A8:  MOVF   FF5,W
01AA:  BTFSC  0E.7
01AC:  BSF    FF2.7
01AE:  RETURN 0
01B0:  DATA 20,20
01B2:  DATA 41,70
01B4:  DATA 61,67
01B6:  DATA 61,6E
01B8:  DATA 64,6F
01BA:  DATA 0A,20
01BC:  DATA 20,73
01BE:  DATA 69,73
01C0:  DATA 74,65
01C2:  DATA 6D,61
01C4:  DATA 2E,2E
01C6:  DATA 2E,00
01C8:  MOVFF  FF2,0E
01CC:  BCF    FF2.7
01CE:  CLRF   FF7
01D0:  ADDLW  E2
01D2:  MOVWF  FF6
01D4:  MOVLW  01
01D6:  ADDWFC FF7,F
01D8:  TBLRD*+
01DA:  MOVF   FF5,W
01DC:  BTFSC  0E.7
01DE:  BSF    FF2.7
01E0:  RETURN 0
01E2:  DATA 20,20
01E4:  DATA 49,6E
01E6:  DATA 64,69
01E8:  DATA 71,75
01EA:  DATA 65,20
01EC:  DATA 6C,61
01EE:  DATA 20,0A
01F0:  DATA 20,20
01F2:  DATA 6F,70
01F4:  DATA 65,72
01F6:  DATA 61,63
01F8:  DATA 69,6F
01FA:  DATA 6E,00
01FC:  MOVFF  FF2,0E
0200:  BCF    FF2.7
0202:  CLRF   FF7
0204:  ADDLW  16
0206:  MOVWF  FF6
0208:  MOVLW  02
020A:  ADDWFC FF7,F
020C:  TBLRD*+
020E:  MOVF   FF5,W
0210:  BTFSC  0E.7
0212:  BSF    FF2.7
0214:  RETURN 0
0216:  DATA 4D,6F
0218:  DATA 64,69
021A:  DATA 66,69
021C:  DATA 63,61
021E:  DATA 72,0A
0220:  DATA 74,65
0222:  DATA 72,6D
0224:  DATA 6F,73
0226:  DATA 74,61
0228:  DATA 74,6F
022A:  DATA 20,25
022C:  DATA 2E,30
022E:  DATA 66,25
0230:  DATA 63,43
0232:  DATA 00,00
0234:  MOVFF  FF2,0E
0238:  BCF    FF2.7
023A:  CLRF   FF7
023C:  ADDLW  4E
023E:  MOVWF  FF6
0240:  MOVLW  02
0242:  ADDWFC FF7,F
0244:  TBLRD*+
0246:  MOVF   FF5,W
0248:  BTFSC  0E.7
024A:  BSF    FF2.7
024C:  RETURN 0
024E:  DATA 4E,75
0250:  DATA 65,76
0252:  DATA 6F,20
0254:  DATA 76,61
0256:  DATA 6C,6F
0258:  DATA 72,3A
025A:  DATA 0A,25
025C:  DATA 63,43
025E:  DATA 00,00
0260:  MOVFF  FF2,0E
0264:  BCF    FF2.7
0266:  CLRF   FF7
0268:  ADDLW  7A
026A:  MOVWF  FF6
026C:  MOVLW  02
026E:  ADDWFC FF7,F
0270:  TBLRD*+
0272:  MOVF   FF5,W
0274:  BTFSC  0E.7
0276:  BSF    FF2.7
0278:  RETURN 0
027A:  DATA 20,20
027C:  DATA 41,70
027E:  DATA 6C,69
0280:  DATA 63,61
0282:  DATA 6E,64
0284:  DATA 6F,0A
0286:  DATA 20,20
0288:  DATA 63,61
028A:  DATA 6D,62
028C:  DATA 69,6F
028E:  DATA 73,2E
0290:  DATA 2E,2E
0292:  DATA 00,00
0294:  MOVFF  FF2,0E
0298:  BCF    FF2.7
029A:  CLRF   FF7
029C:  ADDLW  AE
029E:  MOVWF  FF6
02A0:  MOVLW  02
02A2:  ADDWFC FF7,F
02A4:  TBLRD*+
02A6:  MOVF   FF5,W
02A8:  BTFSC  0E.7
02AA:  BSF    FF2.7
02AC:  RETURN 0
02AE:  DATA 20,20
02B0:  DATA 20,56
02B2:  DATA 61,6C
02B4:  DATA 6F,72
02B6:  DATA 0A,20
02B8:  DATA 20,20
02BA:  DATA 69,6E
02BC:  DATA 63,6F
02BE:  DATA 72,72
02C0:  DATA 65,63
02C2:  DATA 74,6F
02C4:  DATA 00,00
02C6:  MOVFF  FF2,0E
02CA:  BCF    FF2.7
02CC:  CLRF   FF7
02CE:  ADDLW  E0
02D0:  MOVWF  FF6
02D2:  MOVLW  02
02D4:  ADDWFC FF7,F
02D6:  TBLRD*+
02D8:  MOVF   FF5,W
02DA:  BTFSC  0E.7
02DC:  BSF    FF2.7
02DE:  RETURN 0
02E0:  DATA 20,50
02E2:  DATA 72,6F
02E4:  DATA 67,72
02E6:  DATA 61,6D
02E8:  DATA 61,72
02EA:  DATA 0A,20
02EC:  DATA 73,69
02EE:  DATA 73,74
02F0:  DATA 65,6D
02F2:  DATA 61,00
02F4:  MOVFF  FF2,0E
02F8:  BCF    FF2.7
02FA:  CLRF   FF7
02FC:  ADDLW  0E
02FE:  MOVWF  FF6
0300:  MOVLW  03
0302:  ADDWFC FF7,F
0304:  TBLRD*+
0306:  MOVF   FF5,W
0308:  BTFSC  0E.7
030A:  BSF    FF2.7
030C:  RETURN 0
030E:  DATA 20,49
0310:  DATA 4E,54
0312:  DATA 45,52
0314:  DATA 56,41
0316:  DATA 4C,4F
0318:  DATA 20,25
031A:  DATA 69,0A
031C:  DATA 3A,3A
031E:  DATA 00,00
0320:  MOVFF  FF2,0E
0324:  BCF    FF2.7
0326:  CLRF   FF7
0328:  ADDLW  3A
032A:  MOVWF  FF6
032C:  MOVLW  03
032E:  ADDWFC FF7,F
0330:  TBLRD*+
0332:  MOVF   FF5,W
0334:  BTFSC  0E.7
0336:  BSF    FF2.7
0338:  RETURN 0
033A:  DATA 20,20
033C:  DATA 20,56
033E:  DATA 61,6C
0340:  DATA 6F,72
0342:  DATA 65,73
0344:  DATA 0A,20
0346:  DATA 20,20
0348:  DATA 69,6E
034A:  DATA 63,6F
034C:  DATA 72,72
034E:  DATA 65,63
0350:  DATA 74,6F
0352:  DATA 73,00
0354:  MOVFF  FF2,0E
0358:  BCF    FF2.7
035A:  CLRF   FF7
035C:  ADDLW  6E
035E:  MOVWF  FF6
0360:  MOVLW  03
0362:  ADDWFC FF7,F
0364:  TBLRD*+
0366:  MOVF   FF5,W
0368:  BTFSC  0E.7
036A:  BSF    FF2.7
036C:  RETURN 0
036E:  DATA 49,6E
0370:  DATA 74,65
0372:  DATA 72,76
0374:  DATA 61,6C
0376:  DATA 6F,20
0378:  DATA 6C,69
037A:  DATA 6D,69
037C:  DATA 74,65
037E:  DATA 0A,64
0380:  DATA 65,20
0382:  DATA 34,20
0384:  DATA 68,6F
0386:  DATA 72,61
0388:  DATA 73,00
038A:  MOVFF  FF2,0E
038E:  BCF    FF2.7
0390:  CLRF   FF7
0392:  ADDLW  A4
0394:  MOVWF  FF6
0396:  MOVLW  03
0398:  ADDWFC FF7,F
039A:  TBLRD*+
039C:  MOVF   FF5,W
039E:  BTFSC  0E.7
03A0:  BSF    FF2.7
03A2:  RETURN 0
03A4:  DATA 54,65
03A6:  DATA 72,6D
03A8:  DATA 6F,73
03AA:  DATA 74,61
03AC:  DATA 74,6F
03AE:  DATA 20,25
03B0:  DATA 69,0A
03B2:  DATA 25,63
03B4:  DATA 43,00
03B6:  MOVFF  FF2,0E
03BA:  BCF    FF2.7
03BC:  CLRF   FF7
03BE:  ADDLW  D0
03C0:  MOVWF  FF6
03C2:  MOVLW  03
03C4:  ADDWFC FF7,F
03C6:  TBLRD*+
03C8:  MOVF   FF5,W
03CA:  BTFSC  0E.7
03CC:  BSF    FF2.7
03CE:  RETURN 0
03D0:  DATA 53,6F
03D2:  DATA 6C,61
03D4:  DATA 70,61
03D6:  DATA 6D,69
03D8:  DATA 65,6E
03DA:  DATA 74,6F
03DC:  DATA 0A,64
03DE:  DATA 65,20
03E0:  DATA 69,6E
03E2:  DATA 74,65
03E4:  DATA 72,76
03E6:  DATA 61,6C
03E8:  DATA 6F,73
03EA:  DATA 21,00
03EC:  MOVFF  FF2,0E
03F0:  BCF    FF2.7
03F2:  CLRF   FF7
03F4:  ADDLW  06
03F6:  MOVWF  FF6
03F8:  MOVLW  04
03FA:  ADDWFC FF7,F
03FC:  TBLRD*+
03FE:  MOVF   FF5,W
0400:  BTFSC  0E.7
0402:  BSF    FF2.7
0404:  RETURN 0
0406:  DATA 20,20
0408:  DATA 43,4C
040A:  DATA 41,56
040C:  DATA 45,3A
040E:  DATA 0A,20
0410:  DATA 20,00
0412:  MOVFF  FF2,0E
0416:  BCF    FF2.7
0418:  CLRF   FF7
041A:  ADDLW  2C
041C:  MOVWF  FF6
041E:  MOVLW  04
0420:  ADDWFC FF7,F
0422:  TBLRD*+
0424:  MOVF   FF5,W
0426:  BTFSC  0E.7
0428:  BSF    FF2.7
042A:  RETURN 0
042C:  DATA 20,20
042E:  DATA 4D,6F
0430:  DATA 64,6F
0432:  DATA 0A,20
0434:  DATA 20,72
0436:  DATA 65,76
0438:  DATA 69,73
043A:  DATA 69,6F
043C:  DATA 6E,00
043E:  MOVFF  FF2,0E
0442:  BCF    FF2.7
0444:  CLRF   FF7
0446:  ADDLW  58
0448:  MOVWF  FF6
044A:  MOVLW  04
044C:  ADDWFC FF7,F
044E:  TBLRD*+
0450:  MOVF   FF5,W
0452:  BTFSC  0E.7
0454:  BSF    FF2.7
0456:  RETURN 0
0458:  DATA 20,20
045A:  DATA 43,6C
045C:  DATA 61,76
045E:  DATA 65,0A
0460:  DATA 20,20
0462:  DATA 69,6E
0464:  DATA 63,6F
0466:  DATA 72,72
0468:  DATA 65,63
046A:  DATA 74,61
046C:  DATA 00,00
046E:  MOVFF  FF2,0E
0472:  BCF    FF2.7
0474:  CLRF   FF7
0476:  ADDLW  88
0478:  MOVWF  FF6
047A:  MOVLW  04
047C:  ADDWFC FF7,F
047E:  TBLRD*+
0480:  MOVF   FF5,W
0482:  BTFSC  0E.7
0484:  BSF    FF2.7
0486:  RETURN 0
0488:  DATA 20,20
048A:  DATA 41,6E
048C:  DATA 75,6C
048E:  DATA 61,6E
0490:  DATA 64,6F
0492:  DATA 0A,20
0494:  DATA 20,6F
0496:  DATA 70,65
0498:  DATA 72,61
049A:  DATA 63,69
049C:  DATA 6F,6E
049E:  DATA 2E,2E
04A0:  DATA 2E,00
04A2:  MOVFF  FF2,0E
04A6:  BCF    FF2.7
04A8:  CLRF   FF7
04AA:  ADDLW  BC
04AC:  MOVWF  FF6
04AE:  MOVLW  04
04B0:  ADDWFC FF7,F
04B2:  TBLRD*+
04B4:  MOVF   FF5,W
04B6:  BTFSC  0E.7
04B8:  BSF    FF2.7
04BA:  RETURN 0
04BC:  DATA 44,65
04BE:  DATA 6D,61
04C0:  DATA 73,69
04C2:  DATA 61,64
04C4:  DATA 6F,20
04C6:  DATA 74,69
04C8:  DATA 65,6D
04CA:  DATA 70,6F
04CC:  DATA 0A,65
04CE:  DATA 6E,63
04D0:  DATA 65,6E
04D2:  DATA 64,69
04D4:  DATA 64,6F
04D6:  DATA 21,00
04D8:  MOVFF  FF2,0E
04DC:  BCF    FF2.7
04DE:  CLRF   FF7
04E0:  ADDLW  F2
04E2:  MOVWF  FF6
04E4:  MOVLW  04
04E6:  ADDWFC FF7,F
04E8:  TBLRD*+
04EA:  MOVF   FF5,W
04EC:  BTFSC  0E.7
04EE:  BSF    FF2.7
04F0:  RETURN 0
04F2:  DATA 0D,49
04F4:  DATA 6E,69
04F6:  DATA 63,69
04F8:  DATA 61,6C
04FA:  DATA 69,7A
04FC:  DATA 61,63
04FE:  DATA 69,6F
0500:  DATA 6E,20
0502:  DATA 64,65
0504:  DATA 6C,20
0506:  DATA 73,69
0508:  DATA 73,74
050A:  DATA 65,6D
050C:  DATA 61,0D
050E:  DATA 00,00
0510:  MOVFF  FF2,0E
0514:  BCF    FF2.7
0516:  CLRF   FF7
0518:  ADDLW  2A
051A:  MOVWF  FF6
051C:  MOVLW  05
051E:  ADDWFC FF7,F
0520:  TBLRD*+
0522:  MOVF   FF5,W
0524:  BTFSC  0E.7
0526:  BSF    FF2.7
0528:  RETURN 0
052A:  DATA 2A,2A
052C:  DATA 2A,2A
052E:  DATA 2A,2A
0530:  DATA 2A,2A
0532:  DATA 2A,2A
0534:  DATA 2A,2A
0536:  DATA 2A,2A
0538:  DATA 2A,2A
053A:  DATA 2A,2A
053C:  DATA 2A,2A
053E:  DATA 2A,2A
0540:  DATA 2A,2A
0542:  DATA 2A,2A
0544:  DATA 0D,00
0546:  MOVFF  FF2,0E
054A:  BCF    FF2.7
054C:  CLRF   FF7
054E:  ADDLW  60
0550:  MOVWF  FF6
0552:  MOVLW  05
0554:  ADDWFC FF7,F
0556:  TBLRD*+
0558:  MOVF   FF5,W
055A:  BTFSC  0E.7
055C:  BSF    FF2.7
055E:  RETURN 0
0560:  DATA 44,69
0562:  DATA 61,20
0564:  DATA 64,65
0566:  DATA 20,6C
0568:  DATA 61,20
056A:  DATA 73,65
056C:  DATA 6D,61
056E:  DATA 6E,61
0570:  DATA 20,28
0572:  DATA 31,2D
0574:  DATA 3E,4C
0576:  DATA 75,6E
0578:  DATA 65,73
057A:  DATA 2C,20
057C:  DATA 32,2D
057E:  DATA 3E,4D
0580:  DATA 61,72
0582:  DATA 74,65
0584:  DATA 73,2C
0586:  DATA 20,2E
0588:  DATA 2E,2E
058A:  DATA 29,3A
058C:  DATA 20,4C
058E:  DATA 55,4E
0590:  DATA 45,53
0592:  DATA 20,20
0594:  DATA 20,20
0596:  DATA 00,00
0598:  MOVFF  FF2,0E
059C:  BCF    FF2.7
059E:  CLRF   FF7
05A0:  ADDLW  B2
05A2:  MOVWF  FF6
05A4:  MOVLW  05
05A6:  ADDWFC FF7,F
05A8:  TBLRD*+
05AA:  MOVF   FF5,W
05AC:  BTFSC  0E.7
05AE:  BSF    FF2.7
05B0:  RETURN 0
05B2:  DATA 08,08
05B4:  DATA 08,08
05B6:  DATA 08,08
05B8:  DATA 08,08
05BA:  DATA 08,4C
05BC:  DATA 55,4E
05BE:  DATA 45,53
05C0:  DATA 20,20
05C2:  DATA 20,20
05C4:  DATA 00,00
05C6:  MOVFF  FF2,0E
05CA:  BCF    FF2.7
05CC:  CLRF   FF7
05CE:  ADDLW  E0
05D0:  MOVWF  FF6
05D2:  MOVLW  05
05D4:  ADDWFC FF7,F
05D6:  TBLRD*+
05D8:  MOVF   FF5,W
05DA:  BTFSC  0E.7
05DC:  BSF    FF2.7
05DE:  RETURN 0
05E0:  DATA 08,08
05E2:  DATA 08,08
05E4:  DATA 08,08
05E6:  DATA 08,08
05E8:  DATA 08,4D
05EA:  DATA 41,52
05EC:  DATA 54,45
05EE:  DATA 53,20
05F0:  DATA 20,20
05F2:  DATA 00,00
05F4:  MOVFF  FF2,0E
05F8:  BCF    FF2.7
05FA:  CLRF   FF7
05FC:  ADDLW  0E
05FE:  MOVWF  FF6
0600:  MOVLW  06
0602:  ADDWFC FF7,F
0604:  TBLRD*+
0606:  MOVF   FF5,W
0608:  BTFSC  0E.7
060A:  BSF    FF2.7
060C:  RETURN 0
060E:  DATA 08,08
0610:  DATA 08,08
0612:  DATA 08,08
0614:  DATA 08,08
0616:  DATA 08,4D
0618:  DATA 49,45
061A:  DATA 52,43
061C:  DATA 4F,4C
061E:  DATA 45,53
0620:  DATA 00,00
0622:  MOVFF  FF2,0E
0626:  BCF    FF2.7
0628:  CLRF   FF7
062A:  ADDLW  3C
062C:  MOVWF  FF6
062E:  MOVLW  06
0630:  ADDWFC FF7,F
0632:  TBLRD*+
0634:  MOVF   FF5,W
0636:  BTFSC  0E.7
0638:  BSF    FF2.7
063A:  RETURN 0
063C:  DATA 08,08
063E:  DATA 08,08
0640:  DATA 08,08
0642:  DATA 08,08
0644:  DATA 08,4A
0646:  DATA 55,45
0648:  DATA 56,45
064A:  DATA 53,20
064C:  DATA 20,20
064E:  DATA 00,00
0650:  MOVFF  FF2,0E
0654:  BCF    FF2.7
0656:  CLRF   FF7
0658:  ADDLW  6A
065A:  MOVWF  FF6
065C:  MOVLW  06
065E:  ADDWFC FF7,F
0660:  TBLRD*+
0662:  MOVF   FF5,W
0664:  BTFSC  0E.7
0666:  BSF    FF2.7
0668:  RETURN 0
066A:  DATA 08,08
066C:  DATA 08,08
066E:  DATA 08,08
0670:  DATA 08,08
0672:  DATA 08,56
0674:  DATA 49,45
0676:  DATA 52,4E
0678:  DATA 45,53
067A:  DATA 20,20
067C:  DATA 00,00
067E:  MOVFF  FF2,0E
0682:  BCF    FF2.7
0684:  CLRF   FF7
0686:  ADDLW  98
0688:  MOVWF  FF6
068A:  MOVLW  06
068C:  ADDWFC FF7,F
068E:  TBLRD*+
0690:  MOVF   FF5,W
0692:  BTFSC  0E.7
0694:  BSF    FF2.7
0696:  RETURN 0
0698:  DATA 08,08
069A:  DATA 08,08
069C:  DATA 08,08
069E:  DATA 08,08
06A0:  DATA 08,53
06A2:  DATA 41,42
06A4:  DATA 41,44
06A6:  DATA 4F,20
06A8:  DATA 20,20
06AA:  DATA 00,00
06AC:  MOVFF  FF2,0E
06B0:  BCF    FF2.7
06B2:  CLRF   FF7
06B4:  ADDLW  C6
06B6:  MOVWF  FF6
06B8:  MOVLW  06
06BA:  ADDWFC FF7,F
06BC:  TBLRD*+
06BE:  MOVF   FF5,W
06C0:  BTFSC  0E.7
06C2:  BSF    FF2.7
06C4:  RETURN 0
06C6:  DATA 08,08
06C8:  DATA 08,08
06CA:  DATA 08,08
06CC:  DATA 08,08
06CE:  DATA 08,44
06D0:  DATA 4F,4D
06D2:  DATA 49,4E
06D4:  DATA 47,4F
06D6:  DATA 20,20
06D8:  DATA 00,00
06DA:  MOVFF  FF2,0E
06DE:  BCF    FF2.7
06E0:  CLRF   FF7
06E2:  ADDLW  F4
06E4:  MOVWF  FF6
06E6:  MOVLW  06
06E8:  ADDWFC FF7,F
06EA:  TBLRD*+
06EC:  MOVF   FF5,W
06EE:  BTFSC  0E.7
06F0:  BSF    FF2.7
06F2:  RETURN 0
06F4:  DATA 0D,46
06F6:  DATA 45,43
06F8:  DATA 48,41
06FA:  DATA 3A,20
06FC:  DATA 00,00
06FE:  MOVFF  FF2,0E
0702:  BCF    FF2.7
0704:  CLRF   FF7
0706:  ADDLW  18
0708:  MOVWF  FF6
070A:  MOVLW  07
070C:  ADDWFC FF7,F
070E:  TBLRD*+
0710:  MOVF   FF5,W
0712:  BTFSC  0E.7
0714:  BSF    FF2.7
0716:  RETURN 0
0718:  DATA 0D,52
071A:  DATA 65,73
071C:  DATA 65,74
071E:  DATA 65,61
0720:  DATA 6E,64
0722:  DATA 6F,20
0724:  DATA 69,6E
0726:  DATA 69,63
0728:  DATA 69,61
072A:  DATA 6C,69
072C:  DATA 7A,61
072E:  DATA 63,69
0730:  DATA 6F,6E
0732:  DATA 2E,2E
0734:  DATA 2E,0D
0736:  DATA 00,00
0738:  MOVFF  FF2,0E
073C:  BCF    FF2.7
073E:  CLRF   FF7
0740:  ADDLW  52
0742:  MOVWF  FF6
0744:  MOVLW  07
0746:  ADDWFC FF7,F
0748:  TBLRD*+
074A:  MOVF   FF5,W
074C:  BTFSC  0E.7
074E:  BSF    FF2.7
0750:  RETURN 0
0752:  DATA 0D,44
0754:  DATA 69,61
0756:  DATA 20,69
0758:  DATA 6E,63
075A:  DATA 6F,72
075C:  DATA 72,65
075E:  DATA 63,74
0760:  DATA 6F,2E
0762:  DATA 20,52
0764:  DATA 65,73
0766:  DATA 65,74
0768:  DATA 65,61
076A:  DATA 6E,64
076C:  DATA 6F,20
076E:  DATA 69,6E
0770:  DATA 69,63
0772:  DATA 69,61
0774:  DATA 6C,69
0776:  DATA 7A,61
0778:  DATA 63,69
077A:  DATA 6F,6E
077C:  DATA 2E,2E
077E:  DATA 2E,0D
0780:  DATA 00,00
0782:  MOVFF  FF2,0E
0786:  BCF    FF2.7
0788:  CLRF   FF7
078A:  ADDLW  9C
078C:  MOVWF  FF6
078E:  MOVLW  07
0790:  ADDWFC FF7,F
0792:  TBLRD*+
0794:  MOVF   FF5,W
0796:  BTFSC  0E.7
0798:  BSF    FF2.7
079A:  RETURN 0
079C:  DATA 2F,00
079E:  MOVFF  FF2,0E
07A2:  BCF    FF2.7
07A4:  CLRF   FF7
07A6:  ADDLW  B8
07A8:  MOVWF  FF6
07AA:  MOVLW  07
07AC:  ADDWFC FF7,F
07AE:  TBLRD*+
07B0:  MOVF   FF5,W
07B2:  BTFSC  0E.7
07B4:  BSF    FF2.7
07B6:  RETURN 0
07B8:  DATA 0D,4D
07BA:  DATA 65,73
07BC:  DATA 20,69
07BE:  DATA 6E,63
07C0:  DATA 6F,72
07C2:  DATA 72,65
07C4:  DATA 63,74
07C6:  DATA 6F,2E
07C8:  DATA 20,52
07CA:  DATA 65,73
07CC:  DATA 65,74
07CE:  DATA 65,61
07D0:  DATA 6E,64
07D2:  DATA 6F,20
07D4:  DATA 69,6E
07D6:  DATA 69,63
07D8:  DATA 69,61
07DA:  DATA 6C,69
07DC:  DATA 7A,61
07DE:  DATA 63,69
07E0:  DATA 6F,6E
07E2:  DATA 2E,2E
07E4:  DATA 2E,0D
07E6:  DATA 00,00
07E8:  MOVFF  FF2,0E
07EC:  BCF    FF2.7
07EE:  CLRF   FF7
07F0:  ADDLW  02
07F2:  MOVWF  FF6
07F4:  MOVLW  08
07F6:  ADDWFC FF7,F
07F8:  TBLRD*+
07FA:  MOVF   FF5,W
07FC:  BTFSC  0E.7
07FE:  BSF    FF2.7
0800:  RETURN 0
0802:  DATA 0D,45
0804:  DATA 72,72
0806:  DATA 6F,72
0808:  DATA 20,65
080A:  DATA 6E,20
080C:  DATA 6C,61
080E:  DATA 20,66
0810:  DATA 65,63
0812:  DATA 68,61
0814:  DATA 2E,20
0816:  DATA 52,65
0818:  DATA 73,65
081A:  DATA 74,65
081C:  DATA 61,6E
081E:  DATA 64,6F
0820:  DATA 20,69
0822:  DATA 6E,69
0824:  DATA 63,69
0826:  DATA 61,6C
0828:  DATA 69,7A
082A:  DATA 61,63
082C:  DATA 69,6F
082E:  DATA 6E,2E
0830:  DATA 2E,2E
0832:  DATA 0D,00
0834:  MOVFF  FF2,0E
0838:  BCF    FF2.7
083A:  CLRF   FF7
083C:  ADDLW  4E
083E:  MOVWF  FF6
0840:  MOVLW  08
0842:  ADDWFC FF7,F
0844:  TBLRD*+
0846:  MOVF   FF5,W
0848:  BTFSC  0E.7
084A:  BSF    FF2.7
084C:  RETURN 0
084E:  DATA 0D,41
0850:  DATA 6E,6E
0852:  DATA 6F,20
0854:  DATA 69,6E
0856:  DATA 63,6F
0858:  DATA 72,72
085A:  DATA 65,63
085C:  DATA 74,6F
085E:  DATA 2E,20
0860:  DATA 52,65
0862:  DATA 73,65
0864:  DATA 74,65
0866:  DATA 61,6E
0868:  DATA 64,6F
086A:  DATA 20,69
086C:  DATA 6E,69
086E:  DATA 63,69
0870:  DATA 61,6C
0872:  DATA 69,7A
0874:  DATA 61,63
0876:  DATA 69,6F
0878:  DATA 6E,2E
087A:  DATA 2E,2E
087C:  DATA 0D,00
087E:  MOVFF  FF2,0E
0882:  BCF    FF2.7
0884:  CLRF   FF7
0886:  ADDLW  98
0888:  MOVWF  FF6
088A:  MOVLW  08
088C:  ADDWFC FF7,F
088E:  TBLRD*+
0890:  MOVF   FF5,W
0892:  BTFSC  0E.7
0894:  BSF    FF2.7
0896:  RETURN 0
0898:  DATA 0D,45
089A:  DATA 6C,20
089C:  DATA 61,6E
089E:  DATA 6E,6F
08A0:  DATA 20,6E
08A2:  DATA 6F,20
08A4:  DATA 65,73
08A6:  DATA 20,62
08A8:  DATA 69,73
08AA:  DATA 69,65
08AC:  DATA 73,74
08AE:  DATA 6F,2E
08B0:  DATA 20,52
08B2:  DATA 65,73
08B4:  DATA 65,74
08B6:  DATA 65,61
08B8:  DATA 6E,64
08BA:  DATA 6F,20
08BC:  DATA 69,6E
08BE:  DATA 69,63
08C0:  DATA 69,61
08C2:  DATA 6C,69
08C4:  DATA 7A,61
08C6:  DATA 63,69
08C8:  DATA 6F,6E
08CA:  DATA 2E,2E
08CC:  DATA 2E,0D
08CE:  DATA 00,00
08D0:  MOVFF  FF2,0E
08D4:  BCF    FF2.7
08D6:  CLRF   FF7
08D8:  ADDLW  EA
08DA:  MOVWF  FF6
08DC:  MOVLW  08
08DE:  ADDWFC FF7,F
08E0:  TBLRD*+
08E2:  MOVF   FF5,W
08E4:  BTFSC  0E.7
08E6:  BSF    FF2.7
08E8:  RETURN 0
08EA:  DATA 0D,48
08EC:  DATA 4F,52
08EE:  DATA 41,3A
08F0:  DATA 20,00
08F2:  MOVFF  FF2,0E
08F6:  BCF    FF2.7
08F8:  CLRF   FF7
08FA:  ADDLW  0C
08FC:  MOVWF  FF6
08FE:  MOVLW  09
0900:  ADDWFC FF7,F
0902:  TBLRD*+
0904:  MOVF   FF5,W
0906:  BTFSC  0E.7
0908:  BSF    FF2.7
090A:  RETURN 0
090C:  DATA 0D,52
090E:  DATA 65,73
0910:  DATA 65,74
0912:  DATA 65,61
0914:  DATA 6E,64
0916:  DATA 6F,20
0918:  DATA 6C,61
091A:  DATA 20,69
091C:  DATA 6E,69
091E:  DATA 63,69
0920:  DATA 61,6C
0922:  DATA 69,7A
0924:  DATA 61,63
0926:  DATA 69,6F
0928:  DATA 6E,2E
092A:  DATA 2E,2E
092C:  DATA 0D,00
092E:  MOVFF  FF2,0E
0932:  BCF    FF2.7
0934:  CLRF   FF7
0936:  ADDLW  48
0938:  MOVWF  FF6
093A:  MOVLW  09
093C:  ADDWFC FF7,F
093E:  TBLRD*+
0940:  MOVF   FF5,W
0942:  BTFSC  0E.7
0944:  BSF    FF2.7
0946:  RETURN 0
0948:  DATA 20,20
094A:  DATA 48,6F
094C:  DATA 72,61
094E:  DATA 20,69
0950:  DATA 6E,63
0952:  DATA 6F,72
0954:  DATA 72,65
0956:  DATA 63,74
0958:  DATA 61,21
095A:  DATA 00,00
095C:  MOVFF  FF2,0E
0960:  BCF    FF2.7
0962:  CLRF   FF7
0964:  ADDLW  76
0966:  MOVWF  FF6
0968:  MOVLW  09
096A:  ADDWFC FF7,F
096C:  TBLRD*+
096E:  MOVF   FF5,W
0970:  BTFSC  0E.7
0972:  BSF    FF2.7
0974:  RETURN 0
0976:  DATA 3A,00
0978:  MOVFF  FF2,0E
097C:  BCF    FF2.7
097E:  CLRF   FF7
0980:  ADDLW  92
0982:  MOVWF  FF6
0984:  MOVLW  09
0986:  ADDWFC FF7,F
0988:  TBLRD*+
098A:  MOVF   FF5,W
098C:  BTFSC  0E.7
098E:  BSF    FF2.7
0990:  RETURN 0
0992:  DATA 20,20
0994:  DATA 4D,69
0996:  DATA 6E,75
0998:  DATA 74,6F
099A:  DATA 73,20
099C:  DATA 69,6E
099E:  DATA 63,6F
09A0:  DATA 72,72
09A2:  DATA 65,63
09A4:  DATA 74,6F
09A6:  DATA 73,21
09A8:  DATA 00,00
09AA:  MOVFF  FF2,0E
09AE:  BCF    FF2.7
09B0:  CLRF   FF7
09B2:  ADDLW  C4
09B4:  MOVWF  FF6
09B6:  MOVLW  09
09B8:  ADDWFC FF7,F
09BA:  TBLRD*+
09BC:  MOVF   FF5,W
09BE:  BTFSC  0E.7
09C0:  BSF    FF2.7
09C2:  RETURN 0
09C4:  DATA 0D,47
09C6:  DATA 75,61
09C8:  DATA 72,64
09CA:  DATA 61,6E
09CC:  DATA 64,6F
09CE:  DATA 20,63
09D0:  DATA 6F,6E
09D2:  DATA 66,69
09D4:  DATA 67,75
09D6:  DATA 72,61
09D8:  DATA 63,69
09DA:  DATA 6F,6E
09DC:  DATA 2E,2E
09DE:  DATA 2E,00
09E0:  MOVFF  FF2,0E
09E4:  BCF    FF2.7
09E6:  CLRF   FF7
09E8:  ADDLW  FA
09EA:  MOVWF  FF6
09EC:  MOVLW  09
09EE:  ADDWFC FF7,F
09F0:  TBLRD*+
09F2:  MOVF   FF5,W
09F4:  BTFSC  0E.7
09F6:  BSF    FF2.7
09F8:  RETURN 0
09FA:  DATA 0D,49
09FC:  DATA 6E,69
09FE:  DATA 63,69
0A00:  DATA 61,6E
0A02:  DATA 64,6F
0A04:  DATA 20,73
0A06:  DATA 69,73
0A08:  DATA 74,65
0A0A:  DATA 6D,61
0A0C:  DATA 2E,2E
0A0E:  DATA 2E,0D
0A10:  DATA 00,00
0A12:  MOVFF  FF2,0E
0A16:  BCF    FF2.7
0A18:  CLRF   FF7
0A1A:  ADDLW  2C
0A1C:  MOVWF  FF6
0A1E:  MOVLW  0A
0A20:  ADDWFC FF7,F
0A22:  TBLRD*+
0A24:  MOVF   FF5,W
0A26:  BTFSC  0E.7
0A28:  BSF    FF2.7
0A2A:  RETURN 0
0A2C:  DATA 25,33
0A2E:  DATA 2E,31
0A30:  DATA 66,25
0A32:  DATA 63,43
0A34:  DATA 20,20
0A36:  DATA 25,33
0A38:  DATA 2E,31
0A3A:  DATA 66,25
0A3C:  DATA 63,43
0A3E:  DATA 0A,48
0A40:  DATA 4F,52
0A42:  DATA 41,20
0A44:  DATA 2D,20
0A46:  DATA 00,00
0A48:  MOVFF  FF2,0E
0A4C:  BCF    FF2.7
0A4E:  CLRF   FF7
0A50:  ADDLW  62
0A52:  MOVWF  FF6
0A54:  MOVLW  0A
0A56:  ADDWFC FF7,F
0A58:  TBLRD*+
0A5A:  MOVF   FF5,W
0A5C:  BTFSC  0E.7
0A5E:  BSF    FF2.7
0A60:  RETURN 0
0A62:  DATA 30,00
0A64:  MOVFF  FF2,0E
0A68:  BCF    FF2.7
0A6A:  CLRF   FF7
0A6C:  ADDLW  7E
0A6E:  MOVWF  FF6
0A70:  MOVLW  0A
0A72:  ADDWFC FF7,F
0A74:  TBLRD*+
0A76:  MOVF   FF5,W
0A78:  BTFSC  0E.7
0A7A:  BSF    FF2.7
0A7C:  RETURN 0
0A7E:  DATA 0D,52
0A80:  DATA 45,47
0A82:  DATA 49,53
0A84:  DATA 54,52
0A86:  DATA 4F,20
0A88:  DATA 44,45
0A8A:  DATA 20,45
0A8C:  DATA 56,45
0A8E:  DATA 4E,54
0A90:  DATA 4F,53
0A92:  DATA 0D,00
0A94:  MOVFF  FF2,0E
0A98:  BCF    FF2.7
0A9A:  CLRF   FF7
0A9C:  ADDLW  AE
0A9E:  MOVWF  FF6
0AA0:  MOVLW  0A
0AA2:  ADDWFC FF7,F
0AA4:  TBLRD*+
0AA6:  MOVF   FF5,W
0AA8:  BTFSC  0E.7
0AAA:  BSF    FF2.7
0AAC:  RETURN 0
0AAE:  DATA 2A,2A
0AB0:  DATA 2A,2A
0AB2:  DATA 2A,2A
0AB4:  DATA 2A,2A
0AB6:  DATA 2A,2A
0AB8:  DATA 2A,2A
0ABA:  DATA 2A,2A
0ABC:  DATA 2A,2A
0ABE:  DATA 2A,2A
0AC0:  DATA 2A,0D
0AC2:  DATA 00,00
0AC4:  MOVFF  FF2,0E
0AC8:  BCF    FF2.7
0ACA:  CLRF   FF7
0ACC:  ADDLW  DE
0ACE:  MOVWF  FF6
0AD0:  MOVLW  0A
0AD2:  ADDWFC FF7,F
0AD4:  TBLRD*+
0AD6:  MOVF   FF5,W
0AD8:  BTFSC  0E.7
0ADA:  BSF    FF2.7
0ADC:  RETURN 0
0ADE:  DATA 4D,6F
0AE0:  DATA 6D,65
0AE2:  DATA 6E,74
0AE4:  DATA 6F,20
0AE6:  DATA 64,65
0AE8:  DATA 20,61
0AEA:  DATA 70,61
0AEC:  DATA 67,61
0AEE:  DATA 64,6F
0AF0:  DATA 20,20
0AF2:  DATA 20,20
0AF4:  DATA 20,54
0AF6:  DATA 65,6D
0AF8:  DATA 70,65
0AFA:  DATA 72,61
0AFC:  DATA 74,75
0AFE:  DATA 72,61
0B00:  DATA 31,20
0B02:  DATA 20,20
0B04:  DATA 20,20
0B06:  DATA 20,20
0B08:  DATA 54,65
0B0A:  DATA 6D,70
0B0C:  DATA 65,72
0B0E:  DATA 61,74
0B10:  DATA 75,72
0B12:  DATA 61,32
0B14:  DATA 20,20
0B16:  DATA 20,20
0B18:  DATA 20,20
0B1A:  DATA 20,20
0B1C:  DATA 20,54
0B1E:  DATA 65,72
0B20:  DATA 6D,6F
0B22:  DATA 73,74
0B24:  DATA 61,74
0B26:  DATA 6F,20
0B28:  DATA 20,20
0B2A:  DATA 20,20
0B2C:  DATA 20,20
0B2E:  DATA 20,4D
0B30:  DATA 69,6E
0B32:  DATA 75,74
0B34:  DATA 6F,73
0B36:  DATA 20,65
0B38:  DATA 6E,63
0B3A:  DATA 65,6E
0B3C:  DATA 64,69
0B3E:  DATA 64,6F
0B40:  DATA 20,20
0B42:  DATA 20,20
0B44:  DATA 20,20
0B46:  DATA 20,4D
0B48:  DATA 69,6E
0B4A:  DATA 75,74
0B4C:  DATA 6F,73
0B4E:  DATA 20,63
0B50:  DATA 61,6C
0B52:  DATA 64,65
0B54:  DATA 72,61
0B56:  DATA 0D,00
0B58:  MOVFF  FF2,0E
0B5C:  BCF    FF2.7
0B5E:  CLRF   FF7
0B60:  ADDLW  72
0B62:  MOVWF  FF6
0B64:  MOVLW  0B
0B66:  ADDWFC FF7,F
0B68:  TBLRD*+
0B6A:  MOVF   FF5,W
0B6C:  BTFSC  0E.7
0B6E:  BSF    FF2.7
0B70:  RETURN 0
0B72:  DATA 3D,3D
0B74:  DATA 3D,3D
0B76:  DATA 3D,3D
0B78:  DATA 3D,3D
0B7A:  DATA 3D,3D
0B7C:  DATA 3D,3D
0B7E:  DATA 3D,3D
0B80:  DATA 3D,3D
0B82:  DATA 3D,3D
0B84:  DATA 3D,3D
0B86:  DATA 3D,3D
0B88:  DATA 3D,3D
0B8A:  DATA 3D,3D
0B8C:  DATA 3D,3D
0B8E:  DATA 3D,3D
0B90:  DATA 3D,3D
0B92:  DATA 3D,3D
0B94:  DATA 3D,3D
0B96:  DATA 3D,3D
0B98:  DATA 3D,3D
0B9A:  DATA 3D,3D
0B9C:  DATA 3D,3D
0B9E:  DATA 3D,3D
0BA0:  DATA 3D,3D
0BA2:  DATA 3D,3D
0BA4:  DATA 3D,3D
0BA6:  DATA 3D,3D
0BA8:  DATA 3D,3D
0BAA:  DATA 3D,3D
0BAC:  DATA 3D,3D
0BAE:  DATA 3D,3D
0BB0:  DATA 3D,3D
0BB2:  DATA 3D,3D
0BB4:  DATA 3D,3D
0BB6:  DATA 3D,3D
0BB8:  DATA 3D,3D
0BBA:  DATA 3D,3D
0BBC:  DATA 3D,3D
0BBE:  DATA 3D,3D
0BC0:  DATA 3D,3D
0BC2:  DATA 3D,3D
0BC4:  DATA 3D,3D
0BC6:  DATA 3D,3D
0BC8:  DATA 3D,3D
0BCA:  DATA 3D,3D
0BCC:  DATA 3D,3D
0BCE:  DATA 3D,3D
0BD0:  DATA 3D,3D
0BD2:  DATA 3D,3D
0BD4:  DATA 3D,3D
0BD6:  DATA 3D,3D
0BD8:  DATA 3D,3D
0BDA:  DATA 3D,3D
0BDC:  DATA 3D,3D
0BDE:  DATA 3D,3D
0BE0:  DATA 3D,3D
0BE2:  DATA 3D,3D
0BE4:  DATA 3D,3D
0BE6:  DATA 3D,3D
0BE8:  DATA 3D,3D
0BEA:  DATA 3D,3D
0BEC:  DATA 3D,0D
0BEE:  DATA 00,00
0BF0:  MOVFF  FF2,0E
0BF4:  BCF    FF2.7
0BF6:  CLRF   FF7
0BF8:  ADDLW  0A
0BFA:  MOVWF  FF6
0BFC:  MOVLW  0C
0BFE:  ADDWFC FF7,F
0C00:  TBLRD*+
0C02:  MOVF   FF5,W
0C04:  BTFSC  0E.7
0C06:  BSF    FF2.7
0C08:  RETURN 0
0C0A:  DATA 20,00
0C0C:  MOVFF  FF2,0E
0C10:  BCF    FF2.7
0C12:  CLRF   FF7
0C14:  ADDLW  26
0C16:  MOVWF  FF6
0C18:  MOVLW  0C
0C1A:  ADDWFC FF7,F
0C1C:  TBLRD*+
0C1E:  MOVF   FF5,W
0C20:  BTFSC  0E.7
0C22:  BSF    FF2.7
0C24:  RETURN 0
0C26:  DATA 0D,3D
0C28:  DATA 3D,3D
0C2A:  DATA 3D,3D
0C2C:  DATA 3D,3D
0C2E:  DATA 3D,3D
0C30:  DATA 3D,3D
0C32:  DATA 3D,3D
0C34:  DATA 3D,3D
0C36:  DATA 3D,3D
0C38:  DATA 3D,3D
0C3A:  DATA 3D,3D
0C3C:  DATA 3D,3D
0C3E:  DATA 3D,3D
0C40:  DATA 3D,3D
0C42:  DATA 3D,3D
0C44:  DATA 3D,3D
0C46:  DATA 3D,3D
0C48:  DATA 3D,3D
0C4A:  DATA 3D,3D
0C4C:  DATA 3D,3D
0C4E:  DATA 3D,3D
0C50:  DATA 3D,3D
0C52:  DATA 3D,3D
0C54:  DATA 3D,3D
0C56:  DATA 3D,3D
0C58:  DATA 3D,3D
0C5A:  DATA 3D,3D
0C5C:  DATA 3D,3D
0C5E:  DATA 3D,3D
0C60:  DATA 3D,3D
0C62:  DATA 3D,3D
0C64:  DATA 3D,3D
0C66:  DATA 3D,3D
0C68:  DATA 3D,3D
0C6A:  DATA 3D,3D
0C6C:  DATA 3D,3D
0C6E:  DATA 3D,3D
0C70:  DATA 3D,3D
0C72:  DATA 3D,3D
0C74:  DATA 3D,3D
0C76:  DATA 3D,3D
0C78:  DATA 3D,3D
0C7A:  DATA 3D,3D
0C7C:  DATA 3D,3D
0C7E:  DATA 3D,3D
0C80:  DATA 3D,3D
0C82:  DATA 3D,3D
0C84:  DATA 3D,3D
0C86:  DATA 3D,3D
0C88:  DATA 3D,3D
0C8A:  DATA 3D,3D
0C8C:  DATA 3D,3D
0C8E:  DATA 3D,3D
0C90:  DATA 3D,3D
0C92:  DATA 3D,3D
0C94:  DATA 3D,3D
0C96:  DATA 3D,3D
0C98:  DATA 3D,3D
0C9A:  DATA 3D,3D
0C9C:  DATA 3D,3D
0C9E:  DATA 3D,3D
0CA0:  DATA 3D,3D
0CA2:  DATA 0D,00
0CA4:  MOVFF  FF2,0E
0CA8:  BCF    FF2.7
0CAA:  CLRF   FF7
0CAC:  ADDLW  BE
0CAE:  MOVWF  FF6
0CB0:  MOVLW  0C
0CB2:  ADDWFC FF7,F
0CB4:  TBLRD*+
0CB6:  MOVF   FF5,W
0CB8:  BTFSC  0E.7
0CBA:  BSF    FF2.7
0CBC:  RETURN 0
0CBE:  DATA BF,51
0CC0:  DATA 75,65
0CC2:  DATA 20,6F
0CC4:  DATA 70,65
0CC6:  DATA 72,61
0CC8:  DATA 63,69
0CCA:  DATA 6F,6E
0CCC:  DATA 20,64
0CCE:  DATA 65,73
0CD0:  DATA 65,61
0CD2:  DATA 20,72
0CD4:  DATA 65,61
0CD6:  DATA 6C,69
0CD8:  DATA 7A,61
0CDA:  DATA 72,3F
0CDC:  DATA 0D,00
0CDE:  MOVFF  FF2,0E
0CE2:  BCF    FF2.7
0CE4:  CLRF   FF7
0CE6:  ADDLW  F8
0CE8:  MOVWF  FF6
0CEA:  MOVLW  0C
0CEC:  ADDWFC FF7,F
0CEE:  TBLRD*+
0CF0:  MOVF   FF5,W
0CF2:  BTFSC  0E.7
0CF4:  BSF    FF2.7
0CF6:  RETURN 0
0CF8:  DATA 30,2E
0CFA:  DATA 20,53
0CFC:  DATA 61,6C
0CFE:  DATA 69,72
0D00:  DATA 0D,00
0D02:  MOVFF  FF2,0E
0D06:  BCF    FF2.7
0D08:  CLRF   FF7
0D0A:  ADDLW  1C
0D0C:  MOVWF  FF6
0D0E:  MOVLW  0D
0D10:  ADDWFC FF7,F
0D12:  TBLRD*+
0D14:  MOVF   FF5,W
0D16:  BTFSC  0E.7
0D18:  BSF    FF2.7
0D1A:  RETURN 0
0D1C:  DATA 31,2E
0D1E:  DATA 20,45
0D20:  DATA 78,74
0D22:  DATA 72,61
0D24:  DATA 65,72
0D26:  DATA 20,74
0D28:  DATA 69,65
0D2A:  DATA 6D,70
0D2C:  DATA 6F,73
0D2E:  DATA 20,6D
0D30:  DATA 65,64
0D32:  DATA 69,6F
0D34:  DATA 73,20
0D36:  DATA 70,6F
0D38:  DATA 72,20
0D3A:  DATA 64,69
0D3C:  DATA 61,0D
0D3E:  DATA 00,00
0D40:  MOVFF  FF2,0E
0D44:  BCF    FF2.7
0D46:  CLRF   FF7
0D48:  ADDLW  5A
0D4A:  MOVWF  FF6
0D4C:  MOVLW  0D
0D4E:  ADDWFC FF7,F
0D50:  TBLRD*+
0D52:  MOVF   FF5,W
0D54:  BTFSC  0E.7
0D56:  BSF    FF2.7
0D58:  RETURN 0
0D5A:  DATA 32,2E
0D5C:  DATA 20,45
0D5E:  DATA 78,74
0D60:  DATA 72,61
0D62:  DATA 65,72
0D64:  DATA 20,74
0D66:  DATA 69,65
0D68:  DATA 6D,70
0D6A:  DATA 6F,73
0D6C:  DATA 20,74
0D6E:  DATA 6F,74
0D70:  DATA 61,6C
0D72:  DATA 65,73
0D74:  DATA 0D,00
0D76:  MOVFF  FF2,0E
0D7A:  BCF    FF2.7
0D7C:  CLRF   FF7
0D7E:  ADDLW  90
0D80:  MOVWF  FF6
0D82:  MOVLW  0D
0D84:  ADDWFC FF7,F
0D86:  TBLRD*+
0D88:  MOVF   FF5,W
0D8A:  BTFSC  0E.7
0D8C:  BSF    FF2.7
0D8E:  RETURN 0
0D90:  DATA 33,2E
0D92:  DATA 20,45
0D94:  DATA 78,74
0D96:  DATA 72,61
0D98:  DATA 65,72
0D9A:  DATA 20,64
0D9C:  DATA 61,74
0D9E:  DATA 6F,73
0DA0:  DATA 20,6D
0DA2:  DATA 65,6E
0DA4:  DATA 73,75
0DA6:  DATA 61,6C
0DA8:  DATA 65,73
0DAA:  DATA 0D,00
0DAC:  MOVFF  FF2,0E
0DB0:  BCF    FF2.7
0DB2:  CLRF   FF7
0DB4:  ADDLW  C6
0DB6:  MOVWF  FF6
0DB8:  MOVLW  0D
0DBA:  ADDWFC FF7,F
0DBC:  TBLRD*+
0DBE:  MOVF   FF5,W
0DC0:  BTFSC  0E.7
0DC2:  BSF    FF2.7
0DC4:  RETURN 0
0DC6:  DATA 0D,53
0DC8:  DATA 61,6C
0DCA:  DATA 69,65
0DCC:  DATA 6E,64
0DCE:  DATA 6F,2E
0DD0:  DATA 2E,2E
0DD2:  DATA 0D,00
0DD4:  MOVFF  FF2,0E
0DD8:  BCF    FF2.7
0DDA:  CLRF   FF7
0DDC:  ADDLW  EE
0DDE:  MOVWF  FF6
0DE0:  MOVLW  0D
0DE2:  ADDWFC FF7,F
0DE4:  TBLRD*+
0DE6:  MOVF   FF5,W
0DE8:  BTFSC  0E.7
0DEA:  BSF    FF2.7
0DEC:  RETURN 0
0DEE:  DATA 0D,54
0DF0:  DATA 69,65
0DF2:  DATA 6D,70
0DF4:  DATA 6F,20
0DF6:  DATA 6D,65
0DF8:  DATA 64,69
0DFA:  DATA 6F,20
0DFC:  DATA 64,65
0DFE:  DATA 20,65
0E00:  DATA 6E,63
0E02:  DATA 65,6E
0E04:  DATA 64,69
0E06:  DATA 64,6F
0E08:  DATA 20,64
0E0A:  DATA 65,6C
0E0C:  DATA 20,73
0E0E:  DATA 69,73
0E10:  DATA 74,65
0E12:  DATA 6D,61
0E14:  DATA 20,70
0E16:  DATA 6F,72
0E18:  DATA 20,64
0E1A:  DATA 69,61
0E1C:  DATA 3A,20
0E1E:  DATA 25,33
0E20:  DATA 2E,32
0E22:  DATA 66,20
0E24:  DATA 6D,69
0E26:  DATA 6E,75
0E28:  DATA 74,6F
0E2A:  DATA 73,0D
0E2C:  DATA 0D,00
0E2E:  MOVFF  FF2,0E
0E32:  BCF    FF2.7
0E34:  CLRF   FF7
0E36:  ADDLW  48
0E38:  MOVWF  FF6
0E3A:  MOVLW  0E
0E3C:  ADDWFC FF7,F
0E3E:  TBLRD*+
0E40:  MOVF   FF5,W
0E42:  BTFSC  0E.7
0E44:  BSF    FF2.7
0E46:  RETURN 0
0E48:  DATA 54,69
0E4A:  DATA 65,6D
0E4C:  DATA 70,6F
0E4E:  DATA 20,6D
0E50:  DATA 65,64
0E52:  DATA 69,6F
0E54:  DATA 20,64
0E56:  DATA 65,20
0E58:  DATA 65,6E
0E5A:  DATA 63,65
0E5C:  DATA 6E,64
0E5E:  DATA 69,64
0E60:  DATA 6F,20
0E62:  DATA 64,65
0E64:  DATA 20,6C
0E66:  DATA 61,20
0E68:  DATA 63,61
0E6A:  DATA 6C,64
0E6C:  DATA 65,72
0E6E:  DATA 61,20
0E70:  DATA 70,6F
0E72:  DATA 72,20
0E74:  DATA 64,69
0E76:  DATA 61,3A
0E78:  DATA 20,25
0E7A:  DATA 33,2E
0E7C:  DATA 32,66
0E7E:  DATA 20,6D
0E80:  DATA 69,6E
0E82:  DATA 75,74
0E84:  DATA 6F,73
0E86:  DATA 0D,0D
0E88:  DATA 00,00
0E8A:  MOVFF  FF2,0E
0E8E:  BCF    FF2.7
0E90:  CLRF   FF7
0E92:  ADDLW  A4
0E94:  MOVWF  FF6
0E96:  MOVLW  0E
0E98:  ADDWFC FF7,F
0E9A:  TBLRD*+
0E9C:  MOVF   FF5,W
0E9E:  BTFSC  0E.7
0EA0:  BSF    FF2.7
0EA2:  RETURN 0
0EA4:  DATA 0D,54
0EA6:  DATA 69,65
0EA8:  DATA 6D,70
0EAA:  DATA 6F,20
0EAC:  DATA 74,6F
0EAE:  DATA 74,61
0EB0:  DATA 6C,20
0EB2:  DATA 64,65
0EB4:  DATA 20,65
0EB6:  DATA 6E,63
0EB8:  DATA 65,6E
0EBA:  DATA 64,69
0EBC:  DATA 64,6F
0EBE:  DATA 20,64
0EC0:  DATA 65,6C
0EC2:  DATA 20,73
0EC4:  DATA 69,73
0EC6:  DATA 74,65
0EC8:  DATA 6D,61
0ECA:  DATA 3A,20
0ECC:  DATA 25,6C
0ECE:  DATA 75,20
0ED0:  DATA 6D,69
0ED2:  DATA 6E,75
0ED4:  DATA 74,6F
0ED6:  DATA 73,0D
0ED8:  DATA 0D,00
0EDA:  MOVFF  FF2,0E
0EDE:  BCF    FF2.7
0EE0:  CLRF   FF7
0EE2:  ADDLW  F4
0EE4:  MOVWF  FF6
0EE6:  MOVLW  0E
0EE8:  ADDWFC FF7,F
0EEA:  TBLRD*+
0EEC:  MOVF   FF5,W
0EEE:  BTFSC  0E.7
0EF0:  BSF    FF2.7
0EF2:  RETURN 0
0EF4:  DATA 54,69
0EF6:  DATA 65,6D
0EF8:  DATA 70,6F
0EFA:  DATA 20,74
0EFC:  DATA 6F,74
0EFE:  DATA 61,6C
0F00:  DATA 20,64
0F02:  DATA 65,20
0F04:  DATA 65,6E
0F06:  DATA 63,65
0F08:  DATA 6E,64
0F0A:  DATA 69,64
0F0C:  DATA 6F,20
0F0E:  DATA 64,65
0F10:  DATA 20,6C
0F12:  DATA 61,20
0F14:  DATA 63,61
0F16:  DATA 6C,64
0F18:  DATA 65,72
0F1A:  DATA 61,3A
0F1C:  DATA 20,25
0F1E:  DATA 6C,75
0F20:  DATA 20,6D
0F22:  DATA 69,6E
0F24:  DATA 75,74
0F26:  DATA 6F,73
0F28:  DATA 0D,0D
0F2A:  DATA 00,00
0F2C:  MOVFF  FF2,0E
0F30:  BCF    FF2.7
0F32:  CLRF   FF7
0F34:  ADDLW  46
0F36:  MOVWF  FF6
0F38:  MOVLW  0F
0F3A:  ADDWFC FF7,F
0F3C:  TBLRD*+
0F3E:  MOVF   FF5,W
0F40:  BTFSC  0E.7
0F42:  BSF    FF2.7
0F44:  RETURN 0
0F46:  DATA 0D,32
0F48:  DATA 30,00
0F4A:  MOVFF  FF2,0E
0F4E:  BCF    FF2.7
0F50:  CLRF   FF7
0F52:  ADDLW  64
0F54:  MOVWF  FF6
0F56:  MOVLW  0F
0F58:  ADDWFC FF7,F
0F5A:  TBLRD*+
0F5C:  MOVF   FF5,W
0F5E:  BTFSC  0E.7
0F60:  BSF    FF2.7
0F62:  RETURN 0
0F64:  DATA 2D,2D
0F66:  DATA 2D,2D
0F68:  DATA 2D,2D
0F6A:  DATA 2D,2D
0F6C:  DATA 2D,2D
0F6E:  DATA 2D,2D
0F70:  DATA 2D,2D
0F72:  DATA 2D,2D
0F74:  DATA 2D,2D
0F76:  DATA 2D,2D
0F78:  DATA 2D,2D
0F7A:  DATA 2D,2D
0F7C:  DATA 2D,2D
0F7E:  DATA 2D,2D
0F80:  DATA 2D,2D
0F82:  DATA 2D,2D
0F84:  DATA 2D,2D
0F86:  DATA 2D,2D
0F88:  DATA 2D,2D
0F8A:  DATA 2D,2D
0F8C:  DATA 2D,2D
0F8E:  DATA 2D,2D
0F90:  DATA 2D,2D
0F92:  DATA 2D,2D
0F94:  DATA 2D,2D
0F96:  DATA 2D,2D
0F98:  DATA 2D,2D
0F9A:  DATA 2D,2D
0F9C:  DATA 2D,2D
0F9E:  DATA 2D,2D
0FA0:  DATA 2D,2D
0FA2:  DATA 2D,2D
0FA4:  DATA 2D,2D
0FA6:  DATA 2D,2D
0FA8:  DATA 2D,2D
0FAA:  DATA 2D,2D
0FAC:  DATA 2D,2D
0FAE:  DATA 2D,2D
0FB0:  DATA 2D,2D
0FB2:  DATA 2D,2D
0FB4:  DATA 2D,2D
0FB6:  DATA 2D,2D
0FB8:  DATA 2D,2D
0FBA:  DATA 2D,2D
0FBC:  DATA 2D,2D
0FBE:  DATA 2D,2D
0FC0:  DATA 2D,2D
0FC2:  DATA 2D,2D
0FC4:  DATA 2D,2D
0FC6:  DATA 2D,2D
0FC8:  DATA 2D,2D
0FCA:  DATA 2D,2D
0FCC:  DATA 2D,2D
0FCE:  DATA 2D,2D
0FD0:  DATA 2D,2D
0FD2:  DATA 2D,2D
0FD4:  DATA 2D,2D
0FD6:  DATA 2D,2D
0FD8:  DATA 0D,00
0FDA:  MOVFF  FF2,0E
0FDE:  BCF    FF2.7
0FE0:  CLRF   FF7
0FE2:  ADDLW  F4
0FE4:  MOVWF  FF6
0FE6:  MOVLW  0F
0FE8:  ADDWFC FF7,F
0FEA:  TBLRD*+
0FEC:  MOVF   FF5,W
0FEE:  BTFSC  0E.7
0FF0:  BSF    FF2.7
0FF2:  RETURN 0
0FF4:  DATA 20,20
0FF6:  DATA 20,20
0FF8:  DATA 20,20
0FFA:  DATA 20,20
0FFC:  DATA 20,20
0FFE:  DATA 20,20
1000:  DATA 20,20
1002:  DATA 54,69
1004:  DATA 65,6D
1006:  DATA 70,6F
1008:  DATA 20,6D
100A:  DATA 65,64
100C:  DATA 69,6F
100E:  DATA 20,64
1010:  DATA 65,20
1012:  DATA 65,6E
1014:  DATA 63,65
1016:  DATA 6E,64
1018:  DATA 69,64
101A:  DATA 6F,20
101C:  DATA 64,65
101E:  DATA 6C,20
1020:  DATA 73,69
1022:  DATA 73,74
1024:  DATA 65,6D
1026:  DATA 61,20
1028:  DATA 28,6D
102A:  DATA 69,6E
102C:  DATA 2F,64
102E:  DATA 69,61
1030:  DATA 29,20
1032:  DATA 20,20
1034:  DATA 20,20
1036:  DATA 20,54
1038:  DATA 69,65
103A:  DATA 6D,70
103C:  DATA 6F,20
103E:  DATA 6D,65
1040:  DATA 64,69
1042:  DATA 6F,20
1044:  DATA 64,65
1046:  DATA 20,65
1048:  DATA 6E,63
104A:  DATA 65,6E
104C:  DATA 64,69
104E:  DATA 64,6F
1050:  DATA 20,64
1052:  DATA 65,20
1054:  DATA 6C,61
1056:  DATA 20,63
1058:  DATA 61,6C
105A:  DATA 64,65
105C:  DATA 72,61
105E:  DATA 20,28
1060:  DATA 6D,69
1062:  DATA 6E,2F
1064:  DATA 64,69
1066:  DATA 61,29
1068:  DATA 0D,00
106A:  MOVFF  FF2,0E
106E:  BCF    FF2.7
1070:  CLRF   FF7
1072:  ADDLW  84
1074:  MOVWF  FF6
1076:  MOVLW  10
1078:  ADDWFC FF7,F
107A:  TBLRD*+
107C:  MOVF   FF5,W
107E:  BTFSC  0E.7
1080:  BSF    FF2.7
1082:  RETURN 0
1084:  DATA 45,4E
1086:  DATA 45,52
1088:  DATA 4F,25
108A:  DATA 33,2E
108C:  DATA 32,66
108E:  DATA 25,33
1090:  DATA 2E,32
1092:  DATA 66,0D
1094:  DATA 00,00
1096:  MOVFF  FF2,0E
109A:  BCF    FF2.7
109C:  CLRF   FF7
109E:  ADDLW  B0
10A0:  MOVWF  FF6
10A2:  MOVLW  10
10A4:  ADDWFC FF7,F
10A6:  TBLRD*+
10A8:  MOVF   FF5,W
10AA:  BTFSC  0E.7
10AC:  BSF    FF2.7
10AE:  RETURN 0
10B0:  DATA 46,45
10B2:  DATA 42,52
10B4:  DATA 45,52
10B6:  DATA 4F,25
10B8:  DATA 33,2E
10BA:  DATA 32,66
10BC:  DATA 25,33
10BE:  DATA 2E,32
10C0:  DATA 66,0D
10C2:  DATA 00,00
10C4:  MOVFF  FF2,0E
10C8:  BCF    FF2.7
10CA:  CLRF   FF7
10CC:  ADDLW  DE
10CE:  MOVWF  FF6
10D0:  MOVLW  10
10D2:  ADDWFC FF7,F
10D4:  TBLRD*+
10D6:  MOVF   FF5,W
10D8:  BTFSC  0E.7
10DA:  BSF    FF2.7
10DC:  RETURN 0
10DE:  DATA 4D,41
10E0:  DATA 52,5A
10E2:  DATA 4F,25
10E4:  DATA 33,2E
10E6:  DATA 32,66
10E8:  DATA 25,33
10EA:  DATA 2E,32
10EC:  DATA 66,0D
10EE:  DATA 00,00
10F0:  MOVFF  FF2,0E
10F4:  BCF    FF2.7
10F6:  CLRF   FF7
10F8:  ADDLW  0A
10FA:  MOVWF  FF6
10FC:  MOVLW  11
10FE:  ADDWFC FF7,F
1100:  TBLRD*+
1102:  MOVF   FF5,W
1104:  BTFSC  0E.7
1106:  BSF    FF2.7
1108:  RETURN 0
110A:  DATA 41,42
110C:  DATA 52,49
110E:  DATA 4C,25
1110:  DATA 33,2E
1112:  DATA 32,66
1114:  DATA 25,33
1116:  DATA 2E,32
1118:  DATA 66,0D
111A:  DATA 00,00
111C:  MOVFF  FF2,0E
1120:  BCF    FF2.7
1122:  CLRF   FF7
1124:  ADDLW  36
1126:  MOVWF  FF6
1128:  MOVLW  11
112A:  ADDWFC FF7,F
112C:  TBLRD*+
112E:  MOVF   FF5,W
1130:  BTFSC  0E.7
1132:  BSF    FF2.7
1134:  RETURN 0
1136:  DATA 4D,41
1138:  DATA 59,4F
113A:  DATA 25,33
113C:  DATA 2E,32
113E:  DATA 66,25
1140:  DATA 33,2E
1142:  DATA 32,66
1144:  DATA 0D,00
1146:  MOVFF  FF2,0E
114A:  BCF    FF2.7
114C:  CLRF   FF7
114E:  ADDLW  60
1150:  MOVWF  FF6
1152:  MOVLW  11
1154:  ADDWFC FF7,F
1156:  TBLRD*+
1158:  MOVF   FF5,W
115A:  BTFSC  0E.7
115C:  BSF    FF2.7
115E:  RETURN 0
1160:  DATA 4A,55
1162:  DATA 4E,49
1164:  DATA 4F,25
1166:  DATA 33,2E
1168:  DATA 32,66
116A:  DATA 25,33
116C:  DATA 2E,32
116E:  DATA 66,0D
1170:  DATA 00,00
1172:  MOVFF  FF2,0E
1176:  BCF    FF2.7
1178:  CLRF   FF7
117A:  ADDLW  8C
117C:  MOVWF  FF6
117E:  MOVLW  11
1180:  ADDWFC FF7,F
1182:  TBLRD*+
1184:  MOVF   FF5,W
1186:  BTFSC  0E.7
1188:  BSF    FF2.7
118A:  RETURN 0
118C:  DATA 4A,55
118E:  DATA 4C,49
1190:  DATA 4F,25
1192:  DATA 33,2E
1194:  DATA 32,66
1196:  DATA 25,33
1198:  DATA 2E,32
119A:  DATA 66,0D
119C:  DATA 00,00
119E:  MOVFF  FF2,0E
11A2:  BCF    FF2.7
11A4:  CLRF   FF7
11A6:  ADDLW  B8
11A8:  MOVWF  FF6
11AA:  MOVLW  11
11AC:  ADDWFC FF7,F
11AE:  TBLRD*+
11B0:  MOVF   FF5,W
11B2:  BTFSC  0E.7
11B4:  BSF    FF2.7
11B6:  RETURN 0
11B8:  DATA 41,47
11BA:  DATA 4F,53
11BC:  DATA 54,4F
11BE:  DATA 25,33
11C0:  DATA 2E,32
11C2:  DATA 66,25
11C4:  DATA 33,2E
11C6:  DATA 32,66
11C8:  DATA 0D,00
11CA:  MOVFF  FF2,0E
11CE:  BCF    FF2.7
11D0:  CLRF   FF7
11D2:  ADDLW  E4
11D4:  MOVWF  FF6
11D6:  MOVLW  11
11D8:  ADDWFC FF7,F
11DA:  TBLRD*+
11DC:  MOVF   FF5,W
11DE:  BTFSC  0E.7
11E0:  BSF    FF2.7
11E2:  RETURN 0
11E4:  DATA 53,45
11E6:  DATA 50,54
11E8:  DATA 49,45
11EA:  DATA 4D,42
11EC:  DATA 52,45
11EE:  DATA 25,33
11F0:  DATA 2E,32
11F2:  DATA 66,25
11F4:  DATA 33,2E
11F6:  DATA 32,66
11F8:  DATA 0D,00
11FA:  MOVFF  FF2,0E
11FE:  BCF    FF2.7
1200:  CLRF   FF7
1202:  ADDLW  14
1204:  MOVWF  FF6
1206:  MOVLW  12
1208:  ADDWFC FF7,F
120A:  TBLRD*+
120C:  MOVF   FF5,W
120E:  BTFSC  0E.7
1210:  BSF    FF2.7
1212:  RETURN 0
1214:  DATA 4F,43
1216:  DATA 54,55
1218:  DATA 42,52
121A:  DATA 45,25
121C:  DATA 33,2E
121E:  DATA 32,66
1220:  DATA 25,33
1222:  DATA 2E,32
1224:  DATA 66,0D
1226:  DATA 00,00
1228:  MOVFF  FF2,0E
122C:  BCF    FF2.7
122E:  CLRF   FF7
1230:  ADDLW  42
1232:  MOVWF  FF6
1234:  MOVLW  12
1236:  ADDWFC FF7,F
1238:  TBLRD*+
123A:  MOVF   FF5,W
123C:  BTFSC  0E.7
123E:  BSF    FF2.7
1240:  RETURN 0
1242:  DATA 4E,4F
1244:  DATA 56,49
1246:  DATA 45,4D
1248:  DATA 42,52
124A:  DATA 45,25
124C:  DATA 33,2E
124E:  DATA 32,66
1250:  DATA 25,33
1252:  DATA 2E,32
1254:  DATA 66,0D
1256:  DATA 00,00
1258:  MOVFF  FF2,0E
125C:  BCF    FF2.7
125E:  CLRF   FF7
1260:  ADDLW  72
1262:  MOVWF  FF6
1264:  MOVLW  12
1266:  ADDWFC FF7,F
1268:  TBLRD*+
126A:  MOVF   FF5,W
126C:  BTFSC  0E.7
126E:  BSF    FF2.7
1270:  RETURN 0
1272:  DATA 44,49
1274:  DATA 43,49
1276:  DATA 45,4D
1278:  DATA 42,52
127A:  DATA 45,25
127C:  DATA 33,2E
127E:  DATA 32,66
1280:  DATA 25,33
1282:  DATA 2E,32
1284:  DATA 66,0D
1286:  DATA 00,00
*
1404:  CLRF   00
1406:  CLRF   01
1408:  MOVF   xAF,W
140A:  BCF    FD8.0
140C:  BTFSC  xB0.0
140E:  ADDWF  00,F
1410:  RRCF   00,F
1412:  RRCF   01,F
1414:  BTFSC  xB0.1
1416:  ADDWF  00,F
1418:  RRCF   00,F
141A:  RRCF   01,F
141C:  BTFSC  xB0.2
141E:  ADDWF  00,F
1420:  RRCF   00,F
1422:  RRCF   01,F
1424:  BTFSC  xB0.3
1426:  ADDWF  00,F
1428:  RRCF   00,F
142A:  RRCF   01,F
142C:  BTFSC  xB0.4
142E:  ADDWF  00,F
1430:  RRCF   00,F
1432:  RRCF   01,F
1434:  BTFSC  xB0.5
1436:  ADDWF  00,F
1438:  RRCF   00,F
143A:  RRCF   01,F
143C:  BTFSC  xB0.6
143E:  ADDWF  00,F
1440:  RRCF   00,F
1442:  RRCF   01,F
1444:  BTFSC  xB0.7
1446:  ADDWF  00,F
1448:  RRCF   00,F
144A:  RRCF   01,F
144C:  GOTO   1528 (RETURN)
*
17F2:  MOVLW  8E
17F4:  MOVWF  00
17F6:  MOVF   xA5,W
17F8:  SUBWF  00,F
17FA:  MOVFF  A6,02
17FE:  MOVFF  A7,01
1802:  BSF    02.7
1804:  MOVF   00,F
1806:  BZ    181A
1808:  BCF    FD8.0
180A:  MOVF   02,F
180C:  BNZ   1812
180E:  MOVF   01,F
1810:  BZ    181A
1812:  RRCF   02,F
1814:  RRCF   01,F
1816:  DECFSZ 00,F
1818:  BRA    1808
181A:  BTFSS  xA6.7
181C:  BRA    1828
181E:  COMF   01,F
1820:  COMF   02,F
1822:  INCF   01,F
1824:  BTFSC  FD8.2
1826:  INCF   02,F
1828:  NOP   
182A:  RETLW  00
182C:  MOVF   xB2,W
182E:  MULWF  xB4
1830:  MOVFF  FF3,01
1834:  MOVFF  FF4,00
1838:  MULWF  xB5
183A:  MOVF   FF3,W
183C:  ADDWF  00,F
183E:  MOVF   xB3,W
1840:  MULWF  xB4
1842:  MOVF   FF3,W
1844:  ADDWFC 00,W
1846:  MOVWF  02
1848:  RETLW  00
*
1DBA:  MOVFF  FF2,0E
1DBE:  BCF    FF2.7
1DC0:  ADDWF  FE8,W
1DC2:  ADDLW  DF
1DC4:  MOVWF  FF6
1DC6:  MOVLW  1D
1DC8:  MOVWF  FF7
1DCA:  BTFSC  FD8.0
1DCC:  INCF   FF7,F
1DCE:  TBLRD*-
1DD0:  MOVF   FF5,W
1DD2:  MOVWF  FFA
1DD4:  TBLRD*
1DD6:  MOVF   FF5,W
1DD8:  BTFSC  0E.7
1DDA:  BSF    FF2.7
1DDC:  MOVWF  FF9
1DDE:  DATA 26,19
1DE0:  DATA 3E,19
1DE2:  DATA 56,19
1DE4:  DATA 6E,19
1DE6:  DATA 86,19
1DE8:  DATA 9E,19
1DEA:  DATA B6,19
*
200C:  MOVLW  8E
200E:  MOVWF  00
2010:  MOVFF  AD,01
2014:  MOVFF  AC,02
2018:  CLRF   03
201A:  BTFSS  xAD.7
201C:  BRA    2028
201E:  COMF   01,F
2020:  COMF   02,F
2022:  INCF   02,F
2024:  BNZ   2028
2026:  INCF   01,F
2028:  MOVF   01,F
202A:  BNZ   203E
202C:  MOVFF  02,01
2030:  CLRF   02
2032:  MOVLW  08
2034:  SUBWF  00,F
2036:  MOVF   01,F
2038:  BNZ   203E
203A:  CLRF   00
203C:  BRA    2052
203E:  BCF    FD8.0
2040:  BTFSC  01.7
2042:  BRA    204C
2044:  RLCF   02,F
2046:  RLCF   01,F
2048:  DECF   00,F
204A:  BRA    203E
204C:  BTFSC  xAD.7
204E:  BRA    2052
2050:  BCF    01.7
2052:  NOP   
2054:  GOTO   2358 (RETURN)
2058:  MOVLB  2
205A:  MOVF   xAF,W
205C:  BTFSC  FD8.2
205E:  BRA    21AA
2060:  MOVWF  xBB
2062:  MOVF   xB3,W
2064:  BTFSC  FD8.2
2066:  BRA    21AA
2068:  SUBWF  xBB,F
206A:  BNC   2076
206C:  MOVLW  7F
206E:  ADDWF  xBB,F
2070:  BTFSC  FD8.0
2072:  BRA    21AA
2074:  BRA    2082
2076:  MOVLW  81
2078:  SUBWF  xBB,F
207A:  BTFSS  FD8.0
207C:  BRA    21AA
207E:  BTFSC  FD8.2
2080:  BRA    21AA
2082:  MOVFF  2BB,00
2086:  CLRF   01
2088:  CLRF   02
208A:  CLRF   03
208C:  CLRF   xBA
208E:  MOVFF  2B0,2B9
2092:  BSF    xB9.7
2094:  MOVFF  2B1,2B8
2098:  MOVFF  2B2,2B7
209C:  MOVLW  19
209E:  MOVWF  xBB
20A0:  MOVF   xB6,W
20A2:  SUBWF  xB7,F
20A4:  BC    20C0
20A6:  MOVLW  01
20A8:  SUBWF  xB8,F
20AA:  BC    20C0
20AC:  SUBWF  xB9,F
20AE:  BC    20C0
20B0:  SUBWF  xBA,F
20B2:  BC    20C0
20B4:  INCF   xBA,F
20B6:  INCF   xB9,F
20B8:  INCF   xB8,F
20BA:  MOVF   xB6,W
20BC:  ADDWF  xB7,F
20BE:  BRA    2110
20C0:  MOVF   xB5,W
20C2:  SUBWF  xB8,F
20C4:  BC    20EA
20C6:  MOVLW  01
20C8:  SUBWF  xB9,F
20CA:  BC    20EA
20CC:  SUBWF  xBA,F
20CE:  BC    20EA
20D0:  INCF   xBA,F
20D2:  INCF   xB9,F
20D4:  MOVF   xB5,W
20D6:  ADDWF  xB8,F
20D8:  MOVF   xB6,W
20DA:  ADDWF  xB7,F
20DC:  BNC   2110
20DE:  INCF   xB8,F
20E0:  BNZ   2110
20E2:  INCF   xB9,F
20E4:  BNZ   2110
20E6:  INCF   xBA,F
20E8:  BRA    2110
20EA:  MOVF   xB4,W
20EC:  IORLW  80
20EE:  SUBWF  xB9,F
20F0:  BC    210E
20F2:  MOVLW  01
20F4:  SUBWF  xBA,F
20F6:  BC    210E
20F8:  INCF   xBA,F
20FA:  MOVF   xB4,W
20FC:  IORLW  80
20FE:  ADDWF  xB9,F
2100:  MOVF   xB5,W
2102:  ADDWF  xB8,F
2104:  BNC   20D8
2106:  INCF   xB9,F
2108:  BNZ   20D8
210A:  INCF   xBA,F
210C:  BRA    20D8
210E:  BSF    03.0
2110:  DECFSZ xBB,F
2112:  BRA    2116
2114:  BRA    212C
2116:  BCF    FD8.0
2118:  RLCF   xB7,F
211A:  RLCF   xB8,F
211C:  RLCF   xB9,F
211E:  RLCF   xBA,F
2120:  BCF    FD8.0
2122:  RLCF   03,F
2124:  RLCF   02,F
2126:  RLCF   01,F
2128:  RLCF   xBC,F
212A:  BRA    20A0
212C:  BTFSS  xBC.0
212E:  BRA    213C
2130:  BCF    FD8.0
2132:  RRCF   01,F
2134:  RRCF   02,F
2136:  RRCF   03,F
2138:  RRCF   xBC,F
213A:  BRA    2140
213C:  DECF   00,F
213E:  BZ    21AA
2140:  BTFSC  xBC.7
2142:  BRA    2180
2144:  BCF    FD8.0
2146:  RLCF   xB7,F
2148:  RLCF   xB8,F
214A:  RLCF   xB9,F
214C:  RLCF   xBA,F
214E:  MOVF   xB6,W
2150:  SUBWF  xB7,F
2152:  BC    2162
2154:  MOVLW  01
2156:  SUBWF  xB8,F
2158:  BC    2162
215A:  SUBWF  xB9,F
215C:  BC    2162
215E:  SUBWF  xBA,F
2160:  BNC   2196
2162:  MOVF   xB5,W
2164:  SUBWF  xB8,F
2166:  BC    2172
2168:  MOVLW  01
216A:  SUBWF  xB9,F
216C:  BC    2172
216E:  SUBWF  xBA,F
2170:  BNC   2196
2172:  MOVF   xB4,W
2174:  IORLW  80
2176:  SUBWF  xB9,F
2178:  BC    2180
217A:  MOVLW  01
217C:  SUBWF  xBA,F
217E:  BNC   2196
2180:  INCF   03,F
2182:  BNZ   2196
2184:  INCF   02,F
2186:  BNZ   2196
2188:  INCF   01,F
218A:  BNZ   2196
218C:  INCF   00,F
218E:  BZ    21AA
2190:  RRCF   01,F
2192:  RRCF   02,F
2194:  RRCF   03,F
2196:  MOVFF  2B0,2BB
219A:  MOVF   xB4,W
219C:  XORWF  xBB,F
219E:  BTFSS  xBB.7
21A0:  BRA    21A6
21A2:  BSF    01.7
21A4:  BRA    21B2
21A6:  BCF    01.7
21A8:  BRA    21B2
21AA:  CLRF   00
21AC:  CLRF   01
21AE:  CLRF   02
21B0:  CLRF   03
21B2:  NOP   
21B4:  MOVLB  0
21B6:  RETLW  00
*
23B2:  MOVFF  9E,A5
23B6:  MOVF   xA2,W
23B8:  XORWF  xA5,F
23BA:  BTFSS  xA5.7
23BC:  BRA    23C8
23BE:  BCF    FD8.2
23C0:  BCF    FD8.0
23C2:  BTFSC  x9E.7
23C4:  BSF    FD8.0
23C6:  BRA    2426
23C8:  MOVFF  9E,A5
23CC:  MOVFF  A1,A6
23D0:  MOVF   x9D,W
23D2:  SUBWF  xA6,F
23D4:  BZ    23E2
23D6:  BTFSS  xA5.7
23D8:  BRA    2426
23DA:  MOVF   FD8,W
23DC:  XORLW  01
23DE:  MOVWF  FD8
23E0:  BRA    2426
23E2:  MOVFF  A2,A6
23E6:  MOVF   x9E,W
23E8:  SUBWF  xA6,F
23EA:  BZ    23F8
23EC:  BTFSS  xA5.7
23EE:  BRA    2426
23F0:  MOVF   FD8,W
23F2:  XORLW  01
23F4:  MOVWF  FD8
23F6:  BRA    2426
23F8:  MOVFF  A3,A6
23FC:  MOVF   x9F,W
23FE:  SUBWF  xA6,F
2400:  BZ    240E
2402:  BTFSS  xA5.7
2404:  BRA    2426
2406:  MOVF   FD8,W
2408:  XORLW  01
240A:  MOVWF  FD8
240C:  BRA    2426
240E:  MOVFF  A4,A6
2412:  MOVF   xA0,W
2414:  SUBWF  xA6,F
2416:  BZ    2424
2418:  BTFSS  xA5.7
241A:  BRA    2426
241C:  MOVF   FD8,W
241E:  XORLW  01
2420:  MOVWF  FD8
2422:  BRA    2426
2424:  BCF    FD8.0
2426:  RETLW  00
2428:  MOVLW  80
242A:  BTFSS  FD8.1
242C:  BRA    2432
242E:  MOVLB  2
2430:  XORWF  xAE,F
2432:  MOVLB  2
2434:  CLRF   xB3
2436:  CLRF   xB4
2438:  MOVFF  2AA,2B2
243C:  MOVF   xAE,W
243E:  XORWF  xB2,F
2440:  MOVF   xA9,W
2442:  BTFSC  FD8.2
2444:  BRA    2604
2446:  MOVWF  xB1
2448:  MOVWF  00
244A:  MOVF   xAD,W
244C:  BTFSC  FD8.2
244E:  BRA    2616
2450:  SUBWF  xB1,F
2452:  BTFSC  FD8.2
2454:  BRA    255C
2456:  BNC   24D4
2458:  MOVFF  2AE,2B7
245C:  BSF    xB7.7
245E:  MOVFF  2AF,2B6
2462:  MOVFF  2B0,2B5
2466:  CLRF   xB4
2468:  BCF    FD8.0
246A:  RRCF   xB7,F
246C:  RRCF   xB6,F
246E:  RRCF   xB5,F
2470:  RRCF   xB4,F
2472:  DECFSZ xB1,F
2474:  BRA    2466
2476:  BTFSS  xB2.7
2478:  BRA    2480
247A:  BSF    xB3.0
247C:  BRA    263E
247E:  BCF    xB3.0
2480:  BCF    xB1.0
2482:  BSF    xB3.4
2484:  MOVLW  02
2486:  MOVWF  FEA
2488:  MOVLW  AC
248A:  MOVWF  FE9
248C:  BRA    2664
248E:  BCF    xB3.4
2490:  BTFSC  xB2.7
2492:  BRA    24A8
2494:  BTFSS  xB1.0
2496:  BRA    24BE
2498:  RRCF   xB7,F
249A:  RRCF   xB6,F
249C:  RRCF   xB5,F
249E:  RRCF   xB4,F
24A0:  INCF   00,F
24A2:  BTFSC  FD8.2
24A4:  BRA    2634
24A6:  BRA    24BE
24A8:  BTFSC  xB7.7
24AA:  BRA    24C4
24AC:  BCF    FD8.0
24AE:  RLCF   xB4,F
24B0:  RLCF   xB5,F
24B2:  RLCF   xB6,F
24B4:  RLCF   xB7,F
24B6:  DECF   00,F
24B8:  BTFSC  FD8.2
24BA:  BRA    2634
24BC:  BRA    24A8
24BE:  BSF    xB3.6
24C0:  BRA    259C
24C2:  BCF    xB3.6
24C4:  MOVFF  2AA,2B2
24C8:  BTFSS  xAA.7
24CA:  BRA    24D0
24CC:  BSF    xB7.7
24CE:  BRA    2626
24D0:  BCF    xB7.7
24D2:  BRA    2626
24D4:  MOVFF  2AD,2B1
24D8:  MOVFF  2AD,00
24DC:  MOVF   xA9,W
24DE:  SUBWF  xB1,F
24E0:  MOVFF  2AA,2B7
24E4:  BSF    xB7.7
24E6:  MOVFF  2AB,2B6
24EA:  MOVFF  2AC,2B5
24EE:  CLRF   xB4
24F0:  BCF    FD8.0
24F2:  RRCF   xB7,F
24F4:  RRCF   xB6,F
24F6:  RRCF   xB5,F
24F8:  RRCF   xB4,F
24FA:  DECFSZ xB1,F
24FC:  BRA    24EE
24FE:  BTFSS  xB2.7
2500:  BRA    2508
2502:  BSF    xB3.1
2504:  BRA    263E
2506:  BCF    xB3.1
2508:  BCF    xB1.0
250A:  BSF    xB3.5
250C:  MOVLW  02
250E:  MOVWF  FEA
2510:  MOVLW  B0
2512:  MOVWF  FE9
2514:  BRA    2664
2516:  BCF    xB3.5
2518:  BTFSC  xB2.7
251A:  BRA    2530
251C:  BTFSS  xB1.0
251E:  BRA    2546
2520:  RRCF   xB7,F
2522:  RRCF   xB6,F
2524:  RRCF   xB5,F
2526:  RRCF   xB4,F
2528:  INCF   00,F
252A:  BTFSC  FD8.2
252C:  BRA    2634
252E:  BRA    2546
2530:  BTFSC  xB7.7
2532:  BRA    254C
2534:  BCF    FD8.0
2536:  RLCF   xB4,F
2538:  RLCF   xB5,F
253A:  RLCF   xB6,F
253C:  RLCF   xB7,F
253E:  DECF   00,F
2540:  BTFSC  FD8.2
2542:  BRA    2634
2544:  BRA    2530
2546:  BSF    xB3.7
2548:  BRA    259C
254A:  BCF    xB3.7
254C:  MOVFF  2AE,2B2
2550:  BTFSS  xAE.7
2552:  BRA    2558
2554:  BSF    xB7.7
2556:  BRA    2626
2558:  BCF    xB7.7
255A:  BRA    2626
255C:  MOVFF  2AE,2B7
2560:  BSF    xB7.7
2562:  MOVFF  2AF,2B6
2566:  MOVFF  2B0,2B5
256A:  BTFSS  xB2.7
256C:  BRA    2576
256E:  BCF    xB7.7
2570:  BSF    xB3.2
2572:  BRA    263E
2574:  BCF    xB3.2
2576:  CLRF   xB4
2578:  BCF    xB1.0
257A:  MOVLW  02
257C:  MOVWF  FEA
257E:  MOVLW  AC
2580:  MOVWF  FE9
2582:  BRA    2664
2584:  BTFSC  xB2.7
2586:  BRA    25C0
2588:  MOVFF  2AA,2B2
258C:  BTFSS  xB1.0
258E:  BRA    259C
2590:  RRCF   xB7,F
2592:  RRCF   xB6,F
2594:  RRCF   xB5,F
2596:  RRCF   xB4,F
2598:  INCF   00,F
259A:  BZ    2634
259C:  BTFSS  xB4.7
259E:  BRA    25B6
25A0:  INCF   xB5,F
25A2:  BNZ   25B6
25A4:  INCF   xB6,F
25A6:  BNZ   25B6
25A8:  INCF   xB7,F
25AA:  BNZ   25B6
25AC:  RRCF   xB7,F
25AE:  RRCF   xB6,F
25B0:  RRCF   xB5,F
25B2:  INCF   00,F
25B4:  BZ    2634
25B6:  BTFSC  xB3.6
25B8:  BRA    24C2
25BA:  BTFSC  xB3.7
25BC:  BRA    254A
25BE:  BRA    25F8
25C0:  MOVLW  80
25C2:  XORWF  xB7,F
25C4:  BTFSS  xB7.7
25C6:  BRA    25D0
25C8:  BRA    263E
25CA:  MOVFF  2AE,2B2
25CE:  BRA    25E4
25D0:  MOVFF  2AA,2B2
25D4:  MOVF   xB7,F
25D6:  BNZ   25E4
25D8:  MOVF   xB6,F
25DA:  BNZ   25E4
25DC:  MOVF   xB5,F
25DE:  BNZ   25E4
25E0:  CLRF   00
25E2:  BRA    2626
25E4:  BTFSC  xB7.7
25E6:  BRA    25F8
25E8:  BCF    FD8.0
25EA:  RLCF   xB4,F
25EC:  RLCF   xB5,F
25EE:  RLCF   xB6,F
25F0:  RLCF   xB7,F
25F2:  DECFSZ 00,F
25F4:  BRA    25E4
25F6:  BRA    2634
25F8:  BTFSS  xB2.7
25FA:  BRA    2600
25FC:  BSF    xB7.7
25FE:  BRA    2626
2600:  BCF    xB7.7
2602:  BRA    2626
2604:  MOVFF  2AD,00
2608:  MOVFF  2AE,2B7
260C:  MOVFF  2AF,2B6
2610:  MOVFF  2B0,2B5
2614:  BRA    2626
2616:  MOVFF  2A9,00
261A:  MOVFF  2AA,2B7
261E:  MOVFF  2AB,2B6
2622:  MOVFF  2AC,2B5
2626:  MOVFF  2B7,01
262A:  MOVFF  2B6,02
262E:  MOVFF  2B5,03
2632:  BRA    269C
2634:  CLRF   00
2636:  CLRF   01
2638:  CLRF   02
263A:  CLRF   03
263C:  BRA    269C
263E:  CLRF   xB4
2640:  COMF   xB5,F
2642:  COMF   xB6,F
2644:  COMF   xB7,F
2646:  COMF   xB4,F
2648:  INCF   xB4,F
264A:  BNZ   2656
264C:  INCF   xB5,F
264E:  BNZ   2656
2650:  INCF   xB6,F
2652:  BNZ   2656
2654:  INCF   xB7,F
2656:  BTFSC  xB3.0
2658:  BRA    247E
265A:  BTFSC  xB3.1
265C:  BRA    2506
265E:  BTFSC  xB3.2
2660:  BRA    2574
2662:  BRA    25CA
2664:  MOVF   FEF,W
2666:  ADDWF  xB5,F
2668:  BNC   2674
266A:  INCF   xB6,F
266C:  BNZ   2674
266E:  INCF   xB7,F
2670:  BTFSC  FD8.2
2672:  BSF    xB1.0
2674:  MOVF   FED,F
2676:  MOVF   FEF,W
2678:  ADDWF  xB6,F
267A:  BNC   2682
267C:  INCF   xB7,F
267E:  BTFSC  FD8.2
2680:  BSF    xB1.0
2682:  MOVF   FED,F
2684:  MOVF   FEF,W
2686:  BTFSC  FEF.7
2688:  BRA    268C
268A:  XORLW  80
268C:  ADDWF  xB7,F
268E:  BTFSC  FD8.0
2690:  BSF    xB1.0
2692:  BTFSC  xB3.4
2694:  BRA    248E
2696:  BTFSC  xB3.5
2698:  BRA    2516
269A:  BRA    2584
269C:  NOP   
269E:  MOVLB  0
26A0:  RETLW  00
26A2:  MOVLW  8E
26A4:  MOVWF  00
26A6:  MOVFF  2B0,01
26AA:  MOVFF  2AF,02
26AE:  CLRF   03
26B0:  MOVF   01,F
26B2:  BNZ   26C6
26B4:  MOVFF  02,01
26B8:  CLRF   02
26BA:  MOVLW  08
26BC:  SUBWF  00,F
26BE:  MOVF   01,F
26C0:  BNZ   26C6
26C2:  CLRF   00
26C4:  BRA    26D6
26C6:  BCF    FD8.0
26C8:  BTFSC  01.7
26CA:  BRA    26D4
26CC:  RLCF   02,F
26CE:  RLCF   01,F
26D0:  DECF   00,F
26D2:  BRA    26C6
26D4:  BCF    01.7
26D6:  NOP   
26D8:  RETLW  00
*
29F2:  MOVLB  2
29F4:  MOVF   xC5,W
29F6:  BTFSC  FD8.2
29F8:  BRA    2ADC
29FA:  MOVWF  00
29FC:  MOVF   xC9,W
29FE:  BTFSC  FD8.2
2A00:  BRA    2ADC
2A02:  ADDWF  00,F
2A04:  BNC   2A0E
2A06:  MOVLW  81
2A08:  ADDWF  00,F
2A0A:  BC    2ADC
2A0C:  BRA    2A16
2A0E:  MOVLW  7F
2A10:  SUBWF  00,F
2A12:  BNC   2ADC
2A14:  BZ    2ADC
2A16:  MOVFF  2C6,2CD
2A1A:  MOVF   xCA,W
2A1C:  XORWF  xCD,F
2A1E:  BSF    xC6.7
2A20:  BSF    xCA.7
2A22:  MOVF   xC8,W
2A24:  MULWF  xCC
2A26:  MOVFF  FF4,2CF
2A2A:  MOVF   xC7,W
2A2C:  MULWF  xCB
2A2E:  MOVFF  FF4,03
2A32:  MOVFF  FF3,2CE
2A36:  MULWF  xCC
2A38:  MOVF   FF3,W
2A3A:  ADDWF  xCF,F
2A3C:  MOVF   FF4,W
2A3E:  ADDWFC xCE,F
2A40:  MOVLW  00
2A42:  ADDWFC 03,F
2A44:  MOVF   xC8,W
2A46:  MULWF  xCB
2A48:  MOVF   FF3,W
2A4A:  ADDWF  xCF,F
2A4C:  MOVF   FF4,W
2A4E:  ADDWFC xCE,F
2A50:  MOVLW  00
2A52:  CLRF   02
2A54:  ADDWFC 03,F
2A56:  ADDWFC 02,F
2A58:  MOVF   xC6,W
2A5A:  MULWF  xCC
2A5C:  MOVF   FF3,W
2A5E:  ADDWF  xCE,F
2A60:  MOVF   FF4,W
2A62:  ADDWFC 03,F
2A64:  MOVLW  00
2A66:  ADDWFC 02,F
2A68:  MOVF   xC6,W
2A6A:  MULWF  xCB
2A6C:  MOVF   FF3,W
2A6E:  ADDWF  03,F
2A70:  MOVF   FF4,W
2A72:  ADDWFC 02,F
2A74:  MOVLW  00
2A76:  CLRF   01
2A78:  ADDWFC 01,F
2A7A:  MOVF   xC8,W
2A7C:  MULWF  xCA
2A7E:  MOVF   FF3,W
2A80:  ADDWF  xCE,F
2A82:  MOVF   FF4,W
2A84:  ADDWFC 03,F
2A86:  MOVLW  00
2A88:  ADDWFC 02,F
2A8A:  ADDWFC 01,F
2A8C:  MOVF   xC7,W
2A8E:  MULWF  xCA
2A90:  MOVF   FF3,W
2A92:  ADDWF  03,F
2A94:  MOVF   FF4,W
2A96:  ADDWFC 02,F
2A98:  MOVLW  00
2A9A:  ADDWFC 01,F
2A9C:  MOVF   xC6,W
2A9E:  MULWF  xCA
2AA0:  MOVF   FF3,W
2AA2:  ADDWF  02,F
2AA4:  MOVF   FF4,W
2AA6:  ADDWFC 01,F
2AA8:  INCF   00,F
2AAA:  BTFSC  01.7
2AAC:  BRA    2AB8
2AAE:  RLCF   xCE,F
2AB0:  RLCF   03,F
2AB2:  RLCF   02,F
2AB4:  RLCF   01,F
2AB6:  DECF   00,F
2AB8:  MOVLW  00
2ABA:  BTFSS  xCE.7
2ABC:  BRA    2AD2
2ABE:  INCF   03,F
2AC0:  ADDWFC 02,F
2AC2:  ADDWFC 01,F
2AC4:  MOVF   01,W
2AC6:  BNZ   2AD2
2AC8:  MOVF   02,W
2ACA:  BNZ   2AD2
2ACC:  MOVF   03,W
2ACE:  BNZ   2AD2
2AD0:  INCF   00,F
2AD2:  BTFSC  xCD.7
2AD4:  BSF    01.7
2AD6:  BTFSS  xCD.7
2AD8:  BCF    01.7
2ADA:  BRA    2AE4
2ADC:  CLRF   00
2ADE:  CLRF   01
2AE0:  CLRF   02
2AE2:  CLRF   03
2AE4:  NOP   
2AE6:  MOVLB  0
2AE8:  RETLW  00
*
2D70:  CLRF   01
2D72:  CLRF   02
2D74:  CLRF   00
2D76:  CLRF   03
2D78:  MOVF   xA4,W
2D7A:  BNZ   2D80
2D7C:  MOVF   xA3,W
2D7E:  BZ    2DB0
2D80:  MOVLW  10
2D82:  MOVWF  xA5
2D84:  BCF    FD8.0
2D86:  RLCF   xA1,F
2D88:  RLCF   xA2,F
2D8A:  RLCF   00,F
2D8C:  RLCF   03,F
2D8E:  MOVF   xA4,W
2D90:  SUBWF  03,W
2D92:  BNZ   2D98
2D94:  MOVF   xA3,W
2D96:  SUBWF  00,W
2D98:  BNC   2DA8
2D9A:  MOVF   xA3,W
2D9C:  SUBWF  00,F
2D9E:  BTFSS  FD8.0
2DA0:  DECF   03,F
2DA2:  MOVF   xA4,W
2DA4:  SUBWF  03,F
2DA6:  BSF    FD8.0
2DA8:  RLCF   01,F
2DAA:  RLCF   02,F
2DAC:  DECFSZ xA5,F
2DAE:  BRA    2D84
2DB0:  NOP   
2DB2:  GOTO   3030 (RETURN)
*
321C:  MOVLB  2
321E:  MOVF   xC5,W
3220:  SUBLW  B6
3222:  MOVWF  xC5
3224:  CLRF   03
3226:  MOVFF  2C6,2C9
322A:  BSF    xC6.7
322C:  BCF    FD8.0
322E:  RRCF   xC6,F
3230:  RRCF   xC7,F
3232:  RRCF   xC8,F
3234:  RRCF   03,F
3236:  RRCF   02,F
3238:  RRCF   01,F
323A:  RRCF   00,F
323C:  DECFSZ xC5,F
323E:  BRA    322C
3240:  BTFSS  xC9.7
3242:  BRA    325A
3244:  COMF   00,F
3246:  COMF   01,F
3248:  COMF   02,F
324A:  COMF   03,F
324C:  INCF   00,F
324E:  BTFSC  FD8.2
3250:  INCF   01,F
3252:  BTFSC  FD8.2
3254:  INCF   02,F
3256:  BTFSC  FD8.2
3258:  INCF   03,F
325A:  MOVLB  0
325C:  RETLW  00
325E:  CLRF   00
3260:  CLRF   01
3262:  CLRF   02
3264:  CLRF   03
3266:  MOVLB  2
3268:  CLRF   xCD
326A:  CLRF   xCE
326C:  CLRF   xCF
326E:  CLRF   xD0
3270:  MOVF   xCC,W
3272:  IORWF  xCB,W
3274:  IORWF  xCA,W
3276:  IORWF  xC9,W
3278:  BZ    32D2
327A:  MOVLW  20
327C:  MOVWF  xD1
327E:  BCF    FD8.0
3280:  RLCF   xC5,F
3282:  RLCF   xC6,F
3284:  RLCF   xC7,F
3286:  RLCF   xC8,F
3288:  RLCF   xCD,F
328A:  RLCF   xCE,F
328C:  RLCF   xCF,F
328E:  RLCF   xD0,F
3290:  MOVF   xCC,W
3292:  SUBWF  xD0,W
3294:  BNZ   32A6
3296:  MOVF   xCB,W
3298:  SUBWF  xCF,W
329A:  BNZ   32A6
329C:  MOVF   xCA,W
329E:  SUBWF  xCE,W
32A0:  BNZ   32A6
32A2:  MOVF   xC9,W
32A4:  SUBWF  xCD,W
32A6:  BNC   32C6
32A8:  MOVF   xC9,W
32AA:  SUBWF  xCD,F
32AC:  MOVF   xCA,W
32AE:  BTFSS  FD8.0
32B0:  INCFSZ xCA,W
32B2:  SUBWF  xCE,F
32B4:  MOVF   xCB,W
32B6:  BTFSS  FD8.0
32B8:  INCFSZ xCB,W
32BA:  SUBWF  xCF,F
32BC:  MOVF   xCC,W
32BE:  BTFSS  FD8.0
32C0:  INCFSZ xCC,W
32C2:  SUBWF  xD0,F
32C4:  BSF    FD8.0
32C6:  RLCF   00,F
32C8:  RLCF   01,F
32CA:  RLCF   02,F
32CC:  RLCF   03,F
32CE:  DECFSZ xD1,F
32D0:  BRA    327E
32D2:  NOP   
32D4:  MOVLW  02
32D6:  MOVWF  FEA
32D8:  MOVLW  CD
32DA:  MOVWF  FE9
32DC:  MOVLB  0
32DE:  RETLW  00
32E0:  MOVF   FE9,W
32E2:  MOVWF  x9F
32E4:  MOVF   x9E,W
32E6:  MOVWF  xA1
32E8:  BZ    3322
32EA:  MOVFF  9D,2C8
32EE:  MOVFF  9C,2C7
32F2:  MOVFF  9B,2C6
32F6:  MOVFF  9A,2C5
32FA:  MOVLB  2
32FC:  CLRF   xCC
32FE:  CLRF   xCB
3300:  MOVLW  20
3302:  MOVWF  xCA
3304:  MOVLW  82
3306:  MOVWF  xC9
3308:  MOVLB  0
330A:  CALL   29F2
330E:  MOVFF  03,9D
3312:  MOVFF  02,9C
3316:  MOVFF  01,9B
331A:  MOVFF  00,9A
331E:  DECFSZ xA1,F
3320:  BRA    32EA
3322:  MOVFF  9D,2C8
3326:  MOVFF  9C,2C7
332A:  MOVFF  9B,2C6
332E:  MOVFF  9A,2C5
3332:  RCALL  321C
3334:  MOVFF  03,9D
3338:  MOVFF  02,9C
333C:  MOVFF  01,9B
3340:  MOVFF  00,9A
3344:  BTFSS  x9D.7
3346:  BRA    3362
3348:  DECF   x9F,F
334A:  BSF    x9F.5
334C:  COMF   x9A,F
334E:  COMF   x9B,F
3350:  COMF   x9C,F
3352:  COMF   x9D,F
3354:  INCF   x9A,F
3356:  BTFSC  FD8.2
3358:  INCF   x9B,F
335A:  BTFSC  FD8.2
335C:  INCF   x9C,F
335E:  BTFSC  FD8.2
3360:  INCF   x9D,F
3362:  MOVLW  3B
3364:  MOVWF  xA6
3366:  MOVLW  9A
3368:  MOVWF  xA5
336A:  MOVLW  CA
336C:  MOVWF  xA4
336E:  CLRF   xA3
3370:  MOVLW  0A
3372:  MOVWF  xA1
3374:  MOVF   x9E,W
3376:  BTFSC  FD8.2
3378:  INCF   x9F,F
337A:  MOVFF  9D,2C8
337E:  MOVFF  9C,2C7
3382:  MOVFF  9B,2C6
3386:  MOVFF  9A,2C5
338A:  MOVFF  A6,2CC
338E:  MOVFF  A5,2CB
3392:  MOVFF  A4,2CA
3396:  MOVFF  A3,2C9
339A:  RCALL  325E
339C:  MOVF   01,W
339E:  MOVFF  FEF,9A
33A2:  MOVFF  FEC,9B
33A6:  MOVFF  FEC,9C
33AA:  MOVFF  FEC,9D
33AE:  MOVF   00,F
33B0:  BNZ   33D0
33B2:  INCF   x9E,W
33B4:  SUBWF  xA1,W
33B6:  BZ    33D0
33B8:  MOVF   x9F,W
33BA:  BZ    33D4
33BC:  ANDLW  0F
33BE:  SUBWF  xA1,W
33C0:  BZ    33C4
33C2:  BC    343A
33C4:  BTFSC  x9F.7
33C6:  BRA    343A
33C8:  BTFSC  x9F.6
33CA:  BRA    33D4
33CC:  MOVLW  20
33CE:  BRA    3430
33D0:  MOVLW  20
33D2:  ANDWF  x9F,F
33D4:  BTFSS  x9F.5
33D6:  BRA    33F2
33D8:  BCF    x9F.5
33DA:  MOVF   x9E,W
33DC:  BTFSS  FD8.2
33DE:  DECF   x9F,F
33E0:  MOVF   00,W
33E2:  MOVWF  x9F
33E4:  MOVLW  2D
33E6:  MOVWF  xA7
33E8:  CALL   13C0
33EC:  MOVF   x9F,W
33EE:  MOVWF  00
33F0:  CLRF   x9F
33F2:  MOVF   x9E,W
33F4:  SUBWF  xA1,W
33F6:  BNZ   340E
33F8:  MOVF   00,W
33FA:  MOVWF  x9F
33FC:  MOVLW  2E
33FE:  MOVWF  xA7
3400:  CALL   13C0
3404:  MOVF   x9F,W
3406:  MOVWF  00
3408:  MOVLW  20
340A:  ANDWF  x9F,F
340C:  MOVLW  00
340E:  MOVLW  30
3410:  BTFSS  x9F.5
3412:  BRA    3430
3414:  BCF    x9F.5
3416:  MOVF   x9E,W
3418:  BTFSS  FD8.2
341A:  DECF   x9F,F
341C:  MOVF   00,W
341E:  MOVWF  x9F
3420:  MOVLW  2D
3422:  MOVWF  xA7
3424:  CALL   13C0
3428:  MOVF   x9F,W
342A:  MOVWF  00
342C:  CLRF   x9F
342E:  MOVLW  30
3430:  ADDWF  00,F
3432:  MOVFF  00,A7
3436:  CALL   13C0
343A:  MOVFF  A6,2C8
343E:  MOVFF  A5,2C7
3442:  MOVFF  A4,2C6
3446:  MOVFF  A3,2C5
344A:  MOVLB  2
344C:  CLRF   xCC
344E:  CLRF   xCB
3450:  CLRF   xCA
3452:  MOVLW  0A
3454:  MOVWF  xC9
3456:  MOVLB  0
3458:  RCALL  325E
345A:  MOVFF  03,A6
345E:  MOVFF  02,A5
3462:  MOVFF  01,A4
3466:  MOVFF  00,A3
346A:  DECFSZ xA1,F
346C:  BRA    337A
346E:  RETLW  00
*
34FA:  MOVLB  2
34FC:  MOVF   xAD,W
34FE:  CLRF   01
3500:  SUBWF  xAC,W
3502:  BC    350A
3504:  MOVFF  2AC,00
3508:  BRA    3522
350A:  CLRF   00
350C:  MOVLW  08
350E:  MOVWF  xAE
3510:  RLCF   xAC,F
3512:  RLCF   00,F
3514:  MOVF   xAD,W
3516:  SUBWF  00,W
3518:  BTFSC  FD8.0
351A:  MOVWF  00
351C:  RLCF   01,F
351E:  DECFSZ xAE,F
3520:  BRA    3510
3522:  MOVLB  0
3524:  RETLW  00
3526:  MOVLW  20
3528:  BTFSS  x98.4
352A:  MOVLW  30
352C:  MOVWF  x99
352E:  MOVFF  97,00
3532:  BTFSS  x97.7
3534:  BRA    3544
3536:  COMF   00,F
3538:  INCF   00,F
353A:  MOVFF  00,97
353E:  MOVLW  2D
3540:  MOVWF  x99
3542:  BSF    x98.7
3544:  MOVF   01,W
3546:  MOVFF  97,2AC
354A:  MOVLW  64
354C:  MOVLB  2
354E:  MOVWF  xAD
3550:  MOVLB  0
3552:  RCALL  34FA
3554:  MOVFF  00,97
3558:  MOVLW  30
355A:  ADDWF  01,W
355C:  MOVWF  x9A
355E:  MOVFF  97,2AC
3562:  MOVLW  0A
3564:  MOVLB  2
3566:  MOVWF  xAD
3568:  MOVLB  0
356A:  RCALL  34FA
356C:  MOVLW  30
356E:  ADDWF  00,W
3570:  MOVWF  x9C
3572:  MOVLW  30
3574:  ADDWF  01,W
3576:  MOVWF  x9B
3578:  MOVFF  99,00
357C:  BTFSS  x98.3
357E:  BRA    3584
3580:  BTFSS  x98.7
3582:  BCF    x98.2
3584:  BTFSC  x98.4
3586:  BRA    359E
3588:  BTFSS  x98.7
358A:  BRA    35D0
358C:  BTFSC  x98.2
358E:  BRA    35D0
3590:  MOVFF  00,9A
3594:  BTFSC  x98.1
3596:  BRA    35D0
3598:  MOVFF  00,9B
359C:  BRA    35D0
359E:  MOVLW  30
35A0:  SUBWF  x9A,W
35A2:  BNZ   35D0
35A4:  MOVFF  00,9A
35A8:  MOVLW  20
35AA:  MOVWF  x99
35AC:  BTFSS  x98.3
35AE:  BRA    35B8
35B0:  BCF    x98.2
35B2:  BSF    x98.1
35B4:  BTFSS  x98.7
35B6:  BCF    x98.1
35B8:  MOVLW  30
35BA:  SUBWF  x9B,W
35BC:  BNZ   35D0
35BE:  MOVFF  00,9B
35C2:  MOVLW  20
35C4:  MOVWF  x9A
35C6:  BTFSS  x98.3
35C8:  BRA    35B8
35CA:  BCF    x98.1
35CC:  BTFSS  x98.7
35CE:  BCF    x98.0
35D0:  BTFSS  x98.2
35D2:  BRA    35DC
35D4:  MOVFF  99,A7
35D8:  CALL   13C0
35DC:  BTFSS  x98.1
35DE:  BRA    35E8
35E0:  MOVFF  9A,A7
35E4:  CALL   13C0
35E8:  BTFSS  x98.0
35EA:  BRA    35F4
35EC:  MOVFF  9B,A7
35F0:  CALL   13C0
35F4:  MOVFF  9C,A7
35F8:  CALL   13C0
35FC:  RETLW  00
*
38F0:  MOVF   01,W
38F2:  MOVFF  2AA,2AC
38F6:  MOVLW  64
38F8:  MOVLB  2
38FA:  MOVWF  xAD
38FC:  MOVLB  0
38FE:  RCALL  34FA
3900:  MOVFF  00,2AA
3904:  MOVF   01,W
3906:  MOVLW  30
3908:  BNZ   391A
390A:  MOVLB  2
390C:  BTFSS  xAB.1
390E:  BRA    392C
3910:  BTFSC  xAB.3
3912:  BRA    392C
3914:  BTFSC  xAB.4
3916:  MOVLW  20
3918:  BRA    3922
391A:  MOVLB  2
391C:  BCF    xAB.3
391E:  BCF    xAB.4
3920:  BSF    xAB.0
3922:  ADDWF  01,F
3924:  MOVF   01,W
3926:  BTFSS  F9E.4
3928:  BRA    3926
392A:  MOVWF  FAD
392C:  MOVFF  2AA,2AC
3930:  MOVLW  0A
3932:  MOVWF  xAD
3934:  MOVLB  0
3936:  RCALL  34FA
3938:  MOVFF  00,2AA
393C:  MOVF   01,W
393E:  MOVLW  30
3940:  BNZ   3952
3942:  MOVLB  2
3944:  BTFSC  xAB.3
3946:  BRA    395E
3948:  BTFSS  xAB.0
394A:  BRA    395E
394C:  BTFSC  xAB.4
394E:  MOVLW  20
3950:  MOVLB  0
3952:  ADDWF  01,F
3954:  MOVF   01,W
3956:  BTFSS  F9E.4
3958:  BRA    3956
395A:  MOVWF  FAD
395C:  MOVLB  2
395E:  MOVLW  30
3960:  ADDWF  xAA,F
3962:  MOVF   xAA,W
3964:  BTFSS  F9E.4
3966:  BRA    3964
3968:  MOVWF  FAD
396A:  MOVLB  0
396C:  RETLW  00
396E:  MOVF   FE9,W
3970:  MOVLB  2
3972:  MOVWF  xBD
3974:  MOVF   xBC,W
3976:  MOVWF  xBF
3978:  BZ    39B2
397A:  MOVFF  2BB,2C8
397E:  MOVFF  2BA,2C7
3982:  MOVFF  2B9,2C6
3986:  MOVFF  2B8,2C5
398A:  CLRF   xCC
398C:  CLRF   xCB
398E:  MOVLW  20
3990:  MOVWF  xCA
3992:  MOVLW  82
3994:  MOVWF  xC9
3996:  MOVLB  0
3998:  CALL   29F2
399C:  MOVFF  03,2BB
39A0:  MOVFF  02,2BA
39A4:  MOVFF  01,2B9
39A8:  MOVFF  00,2B8
39AC:  MOVLB  2
39AE:  DECFSZ xBF,F
39B0:  BRA    397A
39B2:  MOVFF  2BB,2C8
39B6:  MOVFF  2BA,2C7
39BA:  MOVFF  2B9,2C6
39BE:  MOVFF  2B8,2C5
39C2:  MOVLB  0
39C4:  RCALL  321C
39C6:  MOVFF  03,2BB
39CA:  MOVFF  02,2BA
39CE:  MOVFF  01,2B9
39D2:  MOVFF  00,2B8
39D6:  MOVLB  2
39D8:  BTFSS  xBB.7
39DA:  BRA    39F6
39DC:  DECF   xBD,F
39DE:  BSF    xBD.5
39E0:  COMF   xB8,F
39E2:  COMF   xB9,F
39E4:  COMF   xBA,F
39E6:  COMF   xBB,F
39E8:  INCF   xB8,F
39EA:  BTFSC  FD8.2
39EC:  INCF   xB9,F
39EE:  BTFSC  FD8.2
39F0:  INCF   xBA,F
39F2:  BTFSC  FD8.2
39F4:  INCF   xBB,F
39F6:  MOVLW  3B
39F8:  MOVWF  xC4
39FA:  MOVLW  9A
39FC:  MOVWF  xC3
39FE:  MOVLW  CA
3A00:  MOVWF  xC2
3A02:  CLRF   xC1
3A04:  MOVLW  0A
3A06:  MOVWF  xBF
3A08:  MOVF   xBC,W
3A0A:  BTFSC  FD8.2
3A0C:  INCF   xBD,F
3A0E:  MOVFF  2BB,2C8
3A12:  MOVFF  2BA,2C7
3A16:  MOVFF  2B9,2C6
3A1A:  MOVFF  2B8,2C5
3A1E:  MOVFF  2C4,2CC
3A22:  MOVFF  2C3,2CB
3A26:  MOVFF  2C2,2CA
3A2A:  MOVFF  2C1,2C9
3A2E:  MOVLB  0
3A30:  RCALL  325E
3A32:  MOVF   01,W
3A34:  MOVFF  FEF,2B8
3A38:  MOVFF  FEC,2B9
3A3C:  MOVFF  FEC,2BA
3A40:  MOVFF  FEC,2BB
3A44:  MOVF   00,F
3A46:  BNZ   3A6E
3A48:  MOVLB  2
3A4A:  INCF   xBC,W
3A4C:  SUBWF  xBF,W
3A4E:  BTFSS  FD8.2
3A50:  BRA    3A56
3A52:  MOVLB  0
3A54:  BRA    3A6E
3A56:  MOVF   xBD,W
3A58:  BZ    3A74
3A5A:  ANDLW  0F
3A5C:  SUBWF  xBF,W
3A5E:  BZ    3A62
3A60:  BC    3ADA
3A62:  BTFSC  xBD.7
3A64:  BRA    3ADA
3A66:  BTFSC  xBD.6
3A68:  BRA    3A74
3A6A:  MOVLW  20
3A6C:  BRA    3AD0
3A6E:  MOVLW  20
3A70:  MOVLB  2
3A72:  ANDWF  xBD,F
3A74:  BTFSS  xBD.5
3A76:  BRA    3A92
3A78:  BCF    xBD.5
3A7A:  MOVF   xBC,W
3A7C:  BTFSS  FD8.2
3A7E:  DECF   xBD,F
3A80:  MOVF   00,W
3A82:  MOVWF  xBD
3A84:  MOVLW  2D
3A86:  BTFSS  F9E.4
3A88:  BRA    3A86
3A8A:  MOVWF  FAD
3A8C:  MOVF   xBD,W
3A8E:  MOVWF  00
3A90:  CLRF   xBD
3A92:  MOVF   xBC,W
3A94:  SUBWF  xBF,W
3A96:  BNZ   3AAE
3A98:  MOVF   00,W
3A9A:  MOVWF  xBD
3A9C:  MOVLW  2E
3A9E:  BTFSS  F9E.4
3AA0:  BRA    3A9E
3AA2:  MOVWF  FAD
3AA4:  MOVF   xBD,W
3AA6:  MOVWF  00
3AA8:  MOVLW  20
3AAA:  ANDWF  xBD,F
3AAC:  MOVLW  00
3AAE:  MOVLW  30
3AB0:  BTFSS  xBD.5
3AB2:  BRA    3AD0
3AB4:  BCF    xBD.5
3AB6:  MOVF   xBC,W
3AB8:  BTFSS  FD8.2
3ABA:  DECF   xBD,F
3ABC:  MOVF   00,W
3ABE:  MOVWF  xBD
3AC0:  MOVLW  2D
3AC2:  BTFSS  F9E.4
3AC4:  BRA    3AC2
3AC6:  MOVWF  FAD
3AC8:  MOVF   xBD,W
3ACA:  MOVWF  00
3ACC:  CLRF   xBD
3ACE:  MOVLW  30
3AD0:  ADDWF  00,F
3AD2:  MOVF   00,W
3AD4:  BTFSS  F9E.4
3AD6:  BRA    3AD4
3AD8:  MOVWF  FAD
3ADA:  MOVFF  2C4,2C8
3ADE:  MOVFF  2C3,2C7
3AE2:  MOVFF  2C2,2C6
3AE6:  MOVFF  2C1,2C5
3AEA:  CLRF   xCC
3AEC:  CLRF   xCB
3AEE:  CLRF   xCA
3AF0:  MOVLW  0A
3AF2:  MOVWF  xC9
3AF4:  MOVLB  0
3AF6:  CALL   325E
3AFA:  MOVFF  03,2C4
3AFE:  MOVFF  02,2C3
3B02:  MOVFF  01,2C2
3B06:  MOVFF  00,2C1
3B0A:  MOVLB  2
3B0C:  DECFSZ xBF,F
3B0E:  BRA    3A0E
3B10:  MOVLB  0
3B12:  RETLW  00
3B14:  MOVFF  FEA,2B2
3B18:  MOVFF  FE9,2B1
3B1C:  MOVLB  2
3B1E:  SWAPF  xAB,W
3B20:  IORLW  F0
3B22:  MOVWF  xAD
3B24:  ADDWF  xAD,F
3B26:  ADDLW  E2
3B28:  MOVWF  xAE
3B2A:  ADDLW  32
3B2C:  MOVWF  xB0
3B2E:  MOVF   xAB,W
3B30:  ANDLW  0F
3B32:  ADDWF  xAE,F
3B34:  ADDWF  xAE,F
3B36:  ADDWF  xB0,F
3B38:  ADDLW  E9
3B3A:  MOVWF  xAF
3B3C:  ADDWF  xAF,F
3B3E:  ADDWF  xAF,F
3B40:  SWAPF  xAA,W
3B42:  ANDLW  0F
3B44:  ADDWF  xAF,F
3B46:  ADDWF  xB0,F
3B48:  RLCF   xAF,F
3B4A:  RLCF   xB0,F
3B4C:  COMF   xB0,F
3B4E:  RLCF   xB0,F
3B50:  MOVF   xAA,W
3B52:  ANDLW  0F
3B54:  ADDWF  xB0,F
3B56:  RLCF   xAD,F
3B58:  MOVLW  07
3B5A:  MOVWF  xAC
3B5C:  MOVLW  0A
3B5E:  DECF   xAF,F
3B60:  ADDWF  xB0,F
3B62:  BNC   3B5E
3B64:  DECF   xAE,F
3B66:  ADDWF  xAF,F
3B68:  BNC   3B64
3B6A:  DECF   xAD,F
3B6C:  ADDWF  xAE,F
3B6E:  BNC   3B6A
3B70:  DECF   xAC,F
3B72:  ADDWF  xAD,F
3B74:  BNC   3B70
3B76:  MOVLW  02
3B78:  MOVWF  FEA
3B7A:  MOVLW  AC
3B7C:  MOVWF  FE9
3B7E:  MOVLW  07
3B80:  ANDWF  xB1,W
3B82:  BCF    xB1.6
3B84:  ADDWF  FE9,F
3B86:  MOVLW  B0
3B88:  SUBWF  FE9,W
3B8A:  BTFSC  FD8.2
3B8C:  BSF    xB1.6
3B8E:  MOVF   FEF,W
3B90:  MOVWF  00
3B92:  BNZ   3BA4
3B94:  BTFSC  xB1.6
3B96:  BRA    3BA4
3B98:  BTFSC  xB1.4
3B9A:  BRA    3BB4
3B9C:  BTFSC  xB1.3
3B9E:  BRA    3BA4
3BA0:  MOVLW  20
3BA2:  BRA    3BAA
3BA4:  BSF    xB1.3
3BA6:  BCF    xB1.4
3BA8:  MOVLW  30
3BAA:  ADDWF  00,F
3BAC:  MOVF   00,W
3BAE:  BTFSS  F9E.4
3BB0:  BRA    3BAE
3BB2:  MOVWF  FAD
3BB4:  MOVF   FEE,W
3BB6:  BTFSS  xB1.6
3BB8:  BRA    3B86
3BBA:  MOVLB  0
3BBC:  RETLW  00
*
5756:  MOVFF  FF2,0E
575A:  BCF    FF2.7
575C:  ADDWF  FE8,W
575E:  ADDLW  7B
5760:  MOVWF  FF6
5762:  MOVLW  57
5764:  MOVWF  FF7
5766:  BTFSC  FD8.0
5768:  INCF   FF7,F
576A:  TBLRD*-
576C:  MOVF   FF5,W
576E:  MOVWF  FFA
5770:  TBLRD*
5772:  MOVF   FF5,W
5774:  BTFSC  0E.7
5776:  BSF    FF2.7
5778:  MOVWF  FF9
577A:  DATA E4,49
577C:  DATA 06,4A
577E:  DATA CC,4A
5780:  DATA 7E,4B
*
59A2:  MOVF   01,W
59A4:  MOVFF  96,2AC
59A8:  MOVLW  64
59AA:  MOVLB  2
59AC:  MOVWF  xAD
59AE:  MOVLB  0
59B0:  CALL   34FA
59B4:  MOVFF  00,96
59B8:  MOVF   01,W
59BA:  MOVLW  30
59BC:  BNZ   59CC
59BE:  BTFSS  x97.1
59C0:  BRA    59DC
59C2:  BTFSC  x97.3
59C4:  BRA    59DC
59C6:  BTFSC  x97.4
59C8:  MOVLW  20
59CA:  BRA    59D2
59CC:  BCF    x97.3
59CE:  BCF    x97.4
59D0:  BSF    x97.0
59D2:  ADDWF  01,F
59D4:  MOVFF  01,A7
59D8:  CALL   13C0
59DC:  MOVFF  96,2AC
59E0:  MOVLW  0A
59E2:  MOVLB  2
59E4:  MOVWF  xAD
59E6:  MOVLB  0
59E8:  CALL   34FA
59EC:  MOVFF  00,96
59F0:  MOVF   01,W
59F2:  MOVLW  30
59F4:  BNZ   5A02
59F6:  BTFSC  x97.3
59F8:  BRA    5A0C
59FA:  BTFSS  x97.0
59FC:  BRA    5A0C
59FE:  BTFSC  x97.4
5A00:  MOVLW  20
5A02:  ADDWF  01,F
5A04:  MOVFF  01,A7
5A08:  CALL   13C0
5A0C:  MOVLW  30
5A0E:  ADDWF  x96,F
5A10:  MOVFF  96,A7
5A14:  CALL   13C0
5A18:  RETLW  00
....................                   //fijamos que el valor leído esté representado con 8 bits 
....................                   //(es decir de 00 a FF). 
....................                   //Para cambiar el rango de salida usamos: ADC=10 (000 a 3FF) 
....................                   //                                      ó ADC=16 (0000 a FFC0) 
.................... #list 
....................  
.................... #include "proyecto1.h" 
.................... //****************************************** 
.................... //Archivo de cabecera del Proyecto 1 
.................... //****************************************** 
.................... //Author: Julio Navarro Lara         2010 
....................  
.................... //Definimos los puertos del microcontrolador 
.................... #byte port_a = 0xF80 
.................... #byte port_b = 0xF81 
.................... #byte port_c = 0xF82 
.................... #byte port_d = 0xF83 
.................... #byte port_e = 0xF84 
....................  
.................... #bit sistema_encendido = 0xF83.4    //Pin que indica el encendido del sistema con un valor alto 
.................... #bit caldera_encendida = 0xF83.5    //Pin que indica el encendido de la caldera con un valor alto 
.................... #bit motor1 = 0xF83.6               //Pines que indican el encendido de los motores de circulación del agua con un valor alto 
.................... #bit motor2 = 0xF83.7               //El motor1 se refiere a la circulación del agua por los radiadores de la habitación 1, mientras 
....................                                     //que el motor2, a los radiadores de la habitación 2 
.................... #bit teclado1 = 0xF81.4             //Pines para gestionar la entrada del teclado 
.................... #bit teclado2 = 0xF81.5             //'' 
.................... #bit teclado3 = 0xF81.6             //'' 
.................... #bit teclado4 = 0xF81.7             //'' 
.................... #bit lcd_rs   = 0xF81.2             //Pin que controla la entrada RS de la pantalla LCD 
....................  
.................... //Parámetros de la pantalla LCD 
.................... #define LCD_ORDEN       0    //Código para enviar un orden 
.................... #define LCD_DATO        1    //Código para enviar un dato 
....................  
.................... #define LCD_CLEAR       0x01  //Orden para borrar la pantalla 
.................... #define LCD_NO_CURSOR   0x0C  //Orden para eliminar el cursor de la pantalla 
.................... #define LCD_CURSOR      0x0E  //Orden para visualizar el cursor en la pantalla 
.................... #define LCD_APAGAR      0x08  //Orden para apagar la pantalla 
....................  
.................... //Tiempo que se mantienen los mensajes temporales en pantalla (ms) 
.................... #define LCD_T_RETARDO   500 
....................  
.................... //Clave de acceso 
.................... #define clave           2401 
....................  
....................  
.................... //Parámetros del teclado 
.................... #define NUM_COLUMNAS 3     //Número de columnas del teclado matricial 
.................... #define NUM_FILAS    4     //Número de filas del teclado matricial 
.................... #define NO           100  //Codificación del NO en el método buscar_numero() 
.................... #define SI           101  //Codificación del SI en el método buscar_numero() 
....................  
.................... //Parámetros del conversor AD 
.................... #define termostato_caldera   3   //Entrada AD que se refiere a la temperatura de referencia de la caldera 
.................... #define temperatura_caldera  0   //Entrada AD que se refiere a la temperatura del agua en la caldera 
.................... #define histeresis_caldera   10   //Diferencia de histéresis para el agua de la caldera 
.................... //La histéresis es tan grande debido a que los potenciómetros incluidos en la simulación de PROTEUS no tienen 
.................... //más sensibilidad. Lo normal sería poner una histéresis de unos 5 ºC. 
.................... #define t_max_caldera        100  //Temperatura máxima a la que puede regularse la caldera 
.................... #define t_min_caldera        0  //Temperatura mínima a la que puede regularse la caldera 
.................... #define AD_num_valores       255 //Número de valores de escala del conversor (sensibilidad de los potenciómetros) 
....................  
.................... //Parámetros de control de temperatura 
.................... //Datos suministrados por el aparato de aire acondicionado (con bomba de calor) de mi casa 
.................... #define temp_max          32  //Temperatura máxima de regulación del termostato 
.................... #define temp_min          16  //Temperatura mínima de regulación del termostato 
....................  
....................  
.................... //Direcciones para la EEPROM 
.................... #define eeprom_termostato        0x10  //Valor del termostato 
.................... #define eeprom_num_intervalos    0x11  //Número de intervalos de programación de los que disponemos 
.................... #define eeprom_num_registros     0x12  //Número de registros de desconexión de los que se disponen 
.................... #define eeprom_anno_actual       0x14  //Año en el que nos encontramos 
.................... #define eeprom_anno_1_to_3       0x15  //Año en el que nos encontramos medido de 0 a 3 (llamado 1_to_3 por razones "históricas") 
.................... #define eeprom_programaciones    0x18  //Posición a partir de la cual se almacenan las programaciones de alarmas 
.................... #define eeprom_registros         0x50  //Posición a partir de la cual se almacenan los registros 
....................  
.................... #fuses HS, NOPROTECT, BROWNOUT, PUT, NOLVP, NOXINST, WDT4096, NOWDT 
.................... //El watchdog-timer salta cada 16.384 segundos, aproximadamente 
.................... #use delay(clock=8000000, restart_wdt) 
*
12A8:  CLRF   FEA
12AA:  MOVLW  AE
12AC:  MOVWF  FE9
12AE:  MOVF   FEF,W
12B0:  BZ    12D6
12B2:  MOVLW  02
12B4:  MOVWF  01
12B6:  MOVLW  BF
12B8:  MOVWF  00
12BA:  CLRWDT
12BC:  DECFSZ 00,F
12BE:  BRA    12BA
12C0:  DECFSZ 01,F
12C2:  BRA    12B6
12C4:  MOVLW  96
12C6:  MOVWF  00
12C8:  DECFSZ 00,F
12CA:  BRA    12C8
12CC:  NOP   
12CE:  NOP   
12D0:  CLRWDT
12D2:  DECFSZ FEF,F
12D4:  BRA    12B2
12D6:  RETLW  00
*
12F6:  MOVLW  09
12F8:  SUBWF  xAF,F
12FA:  BNC   1312
12FC:  CLRF   FEA
12FE:  MOVLW  AF
1300:  MOVWF  FE9
1302:  BCF    FD8.0
1304:  RRCF   FEF,F
1306:  MOVF   FEF,W
1308:  BZ    1312
130A:  BRA    130E
130C:  CLRWDT
130E:  DECFSZ FEF,F
1310:  BRA    130C
1312:  RETLW  00
.................... #use rs232(baud=4800, xmit=PIN_C6,rcv=PIN_C7) 
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  (x==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  (x<' ') 
.................... #define isprint(x)  (x>=' ') 
.................... #define isgraph(x)  (x>' ') 
.................... #define ispunct(x)  ((x>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(int *)==1 
.................... #define ptrdiff_t int 
.................... #else 
.................... #define ptrdiff_t long 
.................... #endif 
....................  
.................... #define size_t int 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: float atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... float atof(char * s); 
....................  
.................... /* Standard template: float atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... float atoe(char * s); 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int32 atoi32(char *s); 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, int8 base, char * s); 
....................  
.................... /* Standard template: signed long  atol(char * s) 
....................  * converts the initial portion of the string s to a signed long 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: float strtol(char * s,char *endptr) 
....................  * converts the initial portion of the string s to a float 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... float strtod(char *s,char *endptr); 
....................  
.................... /* Standard template: long strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr,signed int base); 
....................  
.................... /* Standard template: long strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... long strtoul(char *s,char *endptr,signed int base); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... long rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer,signed int denom); 
.................... ldiv_t ldiv(signed long numer,signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(int *)==1 
.................... #define ptrdiff_t int 
.................... #else 
.................... #define ptrdiff_t long 
.................... #endif 
....................  
.................... #define size_t int 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(int *)==1 
.................... #define ptrdiff_t int 
.................... #else 
.................... #define ptrdiff_t long 
.................... #endif 
....................  
.................... #define size_t int 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  (x==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  (x<' ') 
.................... #define isprint(x)  (x>=' ') 
.................... #define isgraph(x)  (x>' ') 
.................... #define ispunct(x)  ((x>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* compiler ignored the name 'strcpy()'; perhaps, it's reserved? 
....................    Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1*/ 
....................  
.................... char *strcopy(char *s1, char *s2) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; *s2 != 0; s++, s2++) { 
.................... 	  *s = *s2; 
....................   } 
....................   *s = *s2; 
....................   return(s1); 
.................... } 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   int n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,int c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, int c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... int *strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, int c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... int *strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
.................... 	 if (*sc2 == '\0') 
.................... 	    return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
.................... 	char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
.................... 	while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && *s == *t; ++s, ++t); 
....................  
.................... 		if (*t == '\0') 
.................... 			return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
.................... 	} 
.................... 	return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(int errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... int *strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer,signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer,signed long denom) 
.................... { 
....................    ldiv_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... float atof(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int sign = 0; 
....................    char c; 
....................    int ptr = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
....................  
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int sign = 0; 
....................    int expsign = 0; 
....................    char c; 
....................    int ptr = 0; 
....................    int i; 
....................    float exp = 1.0; 
....................    int expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
1450:  CLRF   xAD
....................    sign = 0; 
1452:  CLRF   xAB
....................    base = 10; 
1454:  MOVLW  0A
1456:  MOVWF  xAC
....................    result = 0; 
1458:  CLRF   xAA
....................  
....................    if (!s) 
145A:  MOVF   xA8,W
145C:  IORWF  xA9,W
145E:  BNZ   1466
....................       return 0; 
1460:  MOVLW  00
1462:  MOVWF  01
1464:  BRA    15E8
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
1466:  MOVF   xAD,W
1468:  INCF   xAD,F
146A:  CLRF   03
146C:  ADDWF  xA8,W
146E:  MOVWF  FE9
1470:  MOVF   xA9,W
1472:  ADDWFC 03,W
1474:  MOVWF  FEA
1476:  MOVFF  FEF,AE
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
147A:  MOVF   xAE,W
147C:  SUBLW  2D
147E:  BNZ   149A
....................    { 
....................       sign = 1;         // Set the sign to negative 
1480:  MOVLW  01
1482:  MOVWF  xAB
....................       c = s[index++]; 
1484:  MOVF   xAD,W
1486:  INCF   xAD,F
1488:  CLRF   03
148A:  ADDWF  xA8,W
148C:  MOVWF  FE9
148E:  MOVF   xA9,W
1490:  ADDWFC 03,W
1492:  MOVWF  FEA
1494:  MOVFF  FEF,AE
....................    } 
....................    else if (c == '+') 
1498:  BRA    14B4
149A:  MOVF   xAE,W
149C:  SUBLW  2B
149E:  BNZ   14B4
....................    { 
....................       c = s[index++]; 
14A0:  MOVF   xAD,W
14A2:  INCF   xAD,F
14A4:  CLRF   03
14A6:  ADDWF  xA8,W
14A8:  MOVWF  FE9
14AA:  MOVF   xA9,W
14AC:  ADDWFC 03,W
14AE:  MOVWF  FEA
14B0:  MOVFF  FEF,AE
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
14B4:  MOVF   xAE,W
14B6:  SUBLW  2F
14B8:  BTFSC  FD8.0
14BA:  BRA    15D8
14BC:  MOVF   xAE,W
14BE:  SUBLW  39
14C0:  BTFSS  FD8.0
14C2:  BRA    15D8
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
14C4:  MOVF   xAE,W
14C6:  SUBLW  30
14C8:  BNZ   150C
14CA:  CLRF   03
14CC:  MOVF   xAD,W
14CE:  ADDWF  xA8,W
14D0:  MOVWF  FE9
14D2:  MOVF   xA9,W
14D4:  ADDWFC 03,W
14D6:  MOVWF  FEA
14D8:  MOVF   FEF,W
14DA:  SUBLW  78
14DC:  BZ    14F2
14DE:  CLRF   03
14E0:  MOVF   xAD,W
14E2:  ADDWF  xA8,W
14E4:  MOVWF  FE9
14E6:  MOVF   xA9,W
14E8:  ADDWFC 03,W
14EA:  MOVWF  FEA
14EC:  MOVF   FEF,W
14EE:  SUBLW  58
14F0:  BNZ   150C
....................       { 
....................          base = 16; 
14F2:  MOVLW  10
14F4:  MOVWF  xAC
....................          index++; 
14F6:  INCF   xAD,F
....................          c = s[index++]; 
14F8:  MOVF   xAD,W
14FA:  INCF   xAD,F
14FC:  CLRF   03
14FE:  ADDWF  xA8,W
1500:  MOVWF  FE9
1502:  MOVF   xA9,W
1504:  ADDWFC 03,W
1506:  MOVWF  FEA
1508:  MOVFF  FEF,AE
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
150C:  MOVF   xAC,W
150E:  SUBLW  0A
1510:  BNZ   1548
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
1512:  MOVF   xAE,W
1514:  SUBLW  2F
1516:  BC    1546
1518:  MOVF   xAE,W
151A:  SUBLW  39
151C:  BNC   1546
....................             result = 10*result + (c - '0'); 
151E:  MOVLW  0A
1520:  MOVWF  xAF
1522:  MOVFF  AA,B0
1526:  BRA    1404
1528:  MOVLW  30
152A:  SUBWF  xAE,W
152C:  ADDWF  01,W
152E:  MOVWF  xAA
....................             c = s[index++]; 
1530:  MOVF   xAD,W
1532:  INCF   xAD,F
1534:  CLRF   03
1536:  ADDWF  xA8,W
1538:  MOVWF  FE9
153A:  MOVF   xA9,W
153C:  ADDWFC 03,W
153E:  MOVWF  FEA
1540:  MOVFF  FEF,AE
....................          } 
1544:  BRA    1512
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
1546:  BRA    15D8
1548:  MOVF   xAC,W
154A:  SUBLW  10
154C:  BNZ   15D8
....................       { 
....................          c = toupper(c); 
154E:  MOVF   xAE,W
1550:  SUBLW  60
1552:  BC    1560
1554:  MOVF   xAE,W
1556:  SUBLW  7A
1558:  BNC   1560
155A:  MOVF   xAE,W
155C:  ANDLW  DF
155E:  BRA    1562
1560:  MOVF   xAE,W
1562:  MOVWF  xAE
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
1564:  MOVF   xAE,W
1566:  SUBLW  2F
1568:  BC    1570
156A:  MOVF   xAE,W
156C:  SUBLW  39
156E:  BC    157C
1570:  MOVF   xAE,W
1572:  SUBLW  40
1574:  BC    15D8
1576:  MOVF   xAE,W
1578:  SUBLW  46
157A:  BNC   15D8
....................             if (c >= '0' && c <= '9') 
157C:  MOVF   xAE,W
157E:  SUBLW  2F
1580:  BC    159A
1582:  MOVF   xAE,W
1584:  SUBLW  39
1586:  BNC   159A
....................                result = (result << 4) + (c - '0'); 
1588:  SWAPF  xAA,W
158A:  MOVWF  xAF
158C:  MOVLW  F0
158E:  ANDWF  xAF,F
1590:  MOVLW  30
1592:  SUBWF  xAE,W
1594:  ADDWF  xAF,W
1596:  MOVWF  xAA
....................             else 
1598:  BRA    15AC
....................                result = (result << 4) + (c - 'A' + 10); 
159A:  SWAPF  xAA,W
159C:  MOVWF  xAF
159E:  MOVLW  F0
15A0:  ANDWF  xAF,F
15A2:  MOVLW  41
15A4:  SUBWF  xAE,W
15A6:  ADDLW  0A
15A8:  ADDWF  xAF,W
15AA:  MOVWF  xAA
....................  
....................             c = s[index++]; 
15AC:  MOVF   xAD,W
15AE:  INCF   xAD,F
15B0:  CLRF   03
15B2:  ADDWF  xA8,W
15B4:  MOVWF  FE9
15B6:  MOVF   xA9,W
15B8:  ADDWFC 03,W
15BA:  MOVWF  FEA
15BC:  MOVFF  FEF,AE
....................             c = toupper(c); 
15C0:  MOVF   xAE,W
15C2:  SUBLW  60
15C4:  BC    15D2
15C6:  MOVF   xAE,W
15C8:  SUBLW  7A
15CA:  BNC   15D2
15CC:  MOVF   xAE,W
15CE:  ANDLW  DF
15D0:  BRA    15D4
15D2:  MOVF   xAE,W
15D4:  MOVWF  xAE
....................          } 
15D6:  BRA    1564
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
15D8:  DECFSZ xAB,W
15DA:  BRA    15E4
15DC:  MOVF   xAC,W
15DE:  SUBLW  0A
15E0:  BNZ   15E4
....................        result = -result; 
15E2:  NEGF   xAA
....................  
....................    return(result); 
15E4:  MOVFF  AA,01
.................... } 
15E8:  RETLW  00
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... char * itoa(signed int32 num, int8 base, char *s) 
.................... { 
....................      int32 temp=1; 
....................      int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... float strtod(char *s,char *endptr) { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int sign = 0, point = 0; 
....................    char c; 
....................    int ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c=s[ptr++]; 
....................  
....................  
....................    while((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 0) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          point = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 1) { 
....................          pow10 = pow10*10; 
....................          result += (c - '0')/pow10; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '+') { 
....................          c = s[ptr++]; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................          *((char *)endptr)=s+ptr; 
....................       } 
....................       else 
....................          *((char *)endptr)=s; 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... long strtoul(char *s,char *endptr,signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-') 
....................    { 
....................       if (endptr) 
....................       { 
....................         *((char *)endptr)=s; 
....................       } 
....................       return 0; 
....................    } 
....................  
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    { 
....................       if (endptr) 
....................       { 
....................         *((char *)endptr)=s; 
....................       } 
....................       return 0; 
....................    } 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................       if (endptr) 
....................       { 
....................         *((char *)endptr)=s; 
....................       } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................         *((char *)endptr)=sc; 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr,signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    { 
....................       if (endptr) 
....................       { 
....................         *((char *)endptr)=s; 
....................       } 
....................       return 0; 
....................    } 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................       if (endptr) 
....................       { 
....................         *((char *)endptr)=s; 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................         *((char *)endptr)=sc; 
....................    return x; 
.................... } 
....................  
.................... signed int system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed = 1; 
....................  
.................... long rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned long)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... typedef signed int (*_Cmpfun)(char * p1,char * p2); 
....................  
.................... void qsort(char * qdata, int qitems, int qsize, _Cmpfun cmp) { 
....................    int m,j,i,l; 
....................    short done; 
....................    BYTE t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=TRUE; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = FALSE; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include "PCF8583.c" 
.................... // Funciones para el RTC I2c: PCF8583 
.................... // Este código no procede de CCS (no está totalmente verificado) 
.................... // Inluye funciones de conversión BCD-Binario 
.................... // y de lectura/escritura a través de I2C. 
....................  
.................... //Vamos a eliminar todos los casos en los que se habiliten las interrupciones globales 
.................... //Estas sentencias nos impedían utilizar estos métodos en las interrupciones 
....................  
.................... #ifndef PCF8583_SDA 
.................... #define PCF8583_SDA  PIN_C4 
.................... #define PCF8583_SCL  PIN_C3 
.................... #endif 
....................  
.................... #use i2c(master, sda=PCF8583_SDA, scl=PCF8583_SCL, NOFORCE_SW) 
*
1680:  BCF    FC6.7
1682:  BCF    F9E.3
1684:  MOVFF  2BA,FC9
1688:  MOVLW  02
168A:  BTFSC  FC6.7
168C:  BRA    1698
168E:  BTFSS  F9E.3
1690:  BRA    168E
1692:  MOVLW  00
1694:  BTFSC  FC5.6
1696:  MOVLW  01
1698:  MOVWF  01
169A:  RETLW  00
*
26DA:  BSF    FC5.3
26DC:  BTFSC  FC5.3
26DE:  BRA    26DC
26E0:  BTFSC  00.0
26E2:  BCF    FC5.5
26E4:  BTFSS  00.0
26E6:  BSF    FC5.5
26E8:  BSF    FC5.4
26EA:  BTFSC  FC5.4
26EC:  BRA    26EA
26EE:  MOVFF  FC9,01
26F2:  RETLW  00
....................  
.................... #ifndef PCF8583_WRITE_ADDRESS 
.................... #define PCF8583_WRITE_ADDRESS 0xA0 
.................... #define PCF8583_READ_ADDRESS  0xA1 
.................... #endif 
....................  
.................... // Register addresses 
.................... #define PCF8583_CTRL_STATUS_REG    0x00 
.................... #define PCF8583_100S_REG           0x01 
.................... #define PCF8583_SECONDS_REG        0x02 
.................... #define PCF8583_MINUTES_REG        0x03 
.................... #define PCF8583_HOURS_REG          0x04 
.................... #define PCF8583_DATE_REG           0x05 
.................... #define PCF8583_MONTHS_REG         0x06 
.................... #define PCF8583_TIMER_REG          0x07 
....................  
.................... #define PCF8583_ALARM_CONTROL_REG  0x08 
.................... #define PCF8583_ALARM_100S_REG     0x09 
.................... #define PCF8583_ALARM_SECS_REG     0x0A 
.................... #define PCF8583_ALARM_MINS_REG     0x0B 
.................... #define PCF8583_ALARM_HOURS_REG    0x0C 
.................... #define PCF8583_ALARM_DATE_REG     0x0D 
.................... #define PCF8583_ALARM_MONTHS_REG   0x0E 
.................... #define PCF8583_ALARM_TIMER_REG    0x0F 
....................  
.................... // Use the first NVRAM address for the year byte. 
.................... #define PCF8583_YEAR_REG           0x10 
....................  
....................  
.................... // Commands for the Control/Status register. 
.................... #define PCF8583_START_COUNTING     0x00 
.................... #define PCF8583_STOP_COUNTING      0x80 
.................... #define PCF8583_ACTIVAR_ALARMA     0b00000100  //Palabra de activación de la alarma 
.................... #define PCF8583_DEFINIR_ALARMA     0b10010000  //Palabra para definir el comportamiento 
....................                                                //de la alarma en su registro 
....................  
.................... #define PCF8583_DESACTIVAR_INT     0b00010000 
....................  
....................  
.................... int8 alarma_activada=0; 
....................  
....................  
.................... char const weekday_names[7][10] = 
.................... { 
.................... {"DOM"}, 
.................... {"LUN"}, 
.................... {"MAR"}, 
.................... {"MIE"}, 
.................... {"JUE"}, 
.................... {"VIE"}, 
.................... {"SAB"} 
.................... }; 
....................  
.................... // This structure defines the user's date and time data. 
.................... // The values are stored as unsigned integers.  The user 
.................... // should declare a structure of this type in the application 
.................... // program. Then the address of the structure should be 
.................... // passed to the PCF8583 read/write functions in this 
.................... // driver, whenever you want to talk to the chip. 
.................... typedef struct 
.................... { 
.................... int8 seconds;    // 0 to 59 
.................... int8 minutes;    // 0 to 59 
.................... int8 hours;      // 0 to 23  (24-hour time) 
.................... int8 day;        // 1 to 31 
.................... int8 month;      // 1 to 12 
.................... int8 year;       // 00 to 99 
.................... int8 weekday;    // 0 = Sunday, 1 = Monday, etc. 
.................... }date_time_t; 
....................  
....................  
.................... //---------------------------------------------- 
.................... void PCF8583_write_byte(int8 address, int8 data) 
.................... { 
.................... disable_interrupts(GLOBAL); 
*
169C:  BCF    FF2.6
169E:  BCF    FF2.7
16A0:  BTFSC  FF2.7
16A2:  BRA    169E
.................... i2c_start(); 
16A4:  BSF    FC5.0
16A6:  BTFSC  FC5.0
16A8:  BRA    16A6
.................... i2c_write(PCF8583_WRITE_ADDRESS); 
16AA:  MOVLW  A0
16AC:  MOVLB  2
16AE:  MOVWF  xBA
16B0:  MOVLB  0
16B2:  RCALL  1680
.................... i2c_write(address); 
16B4:  MOVFF  AD,2BA
16B8:  RCALL  1680
.................... i2c_write(data); 
16BA:  MOVFF  AE,2BA
16BE:  RCALL  1680
.................... i2c_stop(); 
16C0:  BSF    FC5.2
16C2:  BTFSC  FC5.2
16C4:  BRA    16C2
.................... } 
16C6:  RETLW  00
....................  
.................... //---------------------------------------------- 
.................... int8 PCF8583_read_byte(int8 address) 
.................... { 
.................... int8 retval; 
....................  
.................... disable_interrupts(GLOBAL); 
*
271A:  BCF    FF2.6
271C:  BCF    FF2.7
271E:  BTFSC  FF2.7
2720:  BRA    271C
.................... i2c_start(); 
2722:  BSF    FC5.0
2724:  BTFSC  FC5.0
2726:  BRA    2724
.................... i2c_write(PCF8583_WRITE_ADDRESS); 
2728:  MOVLW  A0
272A:  MOVLB  2
272C:  MOVWF  xBA
272E:  MOVLB  0
2730:  CALL   1680
.................... i2c_write(address); 
2734:  MOVFF  AA,2BA
2738:  CALL   1680
.................... i2c_start(); 
273C:  BSF    FC5.1
273E:  BTFSC  FC5.1
2740:  BRA    273E
.................... i2c_write(PCF8583_READ_ADDRESS); 
2742:  MOVLW  A1
2744:  MOVLB  2
2746:  MOVWF  xBA
2748:  MOVLB  0
274A:  CALL   1680
.................... retval = i2c_read(0); 
274E:  CLRF   00
2750:  RCALL  26DA
2752:  MOVFF  01,AB
.................... i2c_stop(); 
2756:  BSF    FC5.2
2758:  BTFSC  FC5.2
275A:  BRA    2758
....................  
.................... return(retval); 
275C:  MOVFF  AB,01
.................... } 
2760:  GOTO   28BC (RETURN)
....................  
....................  
.................... void PCF8583_init(void) 
.................... { 
.................... PCF8583_write_byte(PCF8583_CTRL_STATUS_REG, 
....................                               PCF8583_START_COUNTING); 
.................... } 
....................  
.................... //---------------------------------------------- 
.................... // This function converts an 8 bit binary value 
.................... // to an 8 bit BCD value. 
.................... // The input range must be from 0 to 99. 
....................  
.................... int8 bin2bcd(int8 value) 
.................... { 
.................... char retval; 
....................  
.................... retval = 0; 
*
1660:  CLRF   xAE
....................  
.................... while(1) 
....................   { 
....................    // Get the tens digit by doing multiple subtraction 
....................    // of 10 from the binary value. 
....................    if(value >= 10) 
1662:  MOVF   xAD,W
1664:  SUBLW  09
1666:  BC    1672
....................      { 
....................       value -= 10; 
1668:  MOVLW  0A
166A:  SUBWF  xAD,F
....................       retval += 0x10; 
166C:  MOVLW  10
166E:  ADDWF  xAE,F
....................      } 
....................    else // Get the ones digit by adding the remainder. 
1670:  BRA    1678
....................      { 
....................       retval += value; 
1672:  MOVF   xAD,W
1674:  ADDWF  xAE,F
....................       break; 
1676:  BRA    167A
....................      } 
....................    } 
1678:  BRA    1662
....................  
.................... return(retval); 
167A:  MOVFF  AE,01
.................... } 
167E:  RETLW  00
....................  
.................... //---------------------------------------------- 
.................... // This function converts an 8 bit BCD value to 
.................... // an 8 bit binary value. 
.................... // The input range must be from 00 to 99. 
....................  
.................... char bcd2bin(char bcd_value) 
.................... { 
.................... char temp; 
....................  
.................... temp = bcd_value; 
*
26F4:  MOVFF  AD,AE
....................  
.................... // Shifting the upper digit right by 1 is 
.................... // the same as multiplying it by 8. 
.................... temp >>= 1; 
26F8:  BCF    FD8.0
26FA:  RRCF   xAE,F
....................  
.................... // Isolate the bits for the upper digit. 
.................... temp &= 0x78; 
26FC:  MOVLW  78
26FE:  ANDWF  xAE,F
....................  
.................... // Now return: (Tens * 8) + (Tens * 2) + Ones 
.................... return(temp + (temp >> 2) + (bcd_value & 0x0f)); 
2700:  RRCF   xAE,W
2702:  MOVWF  00
2704:  RRCF   00,F
2706:  MOVLW  3F
2708:  ANDWF  00,F
270A:  MOVF   00,W
270C:  ADDWF  xAE,W
270E:  MOVWF  xAF
2710:  MOVF   xAD,W
2712:  ANDLW  0F
2714:  ADDWF  xAF,W
2716:  MOVWF  01
....................  
.................... } 
2718:  RETLW  00
....................  
.................... //---------------------------------------------- 
.................... void PCF8583_set_datetime(date_time_t *dt) 
.................... { 
.................... int8 bcd_sec; 
.................... int8 bcd_min; 
.................... int8 bcd_hrs; 
.................... int8 bcd_day; 
.................... int8 bcd_mon; 
....................  
.................... // Convert the input date/time into BCD values 
.................... // that are formatted for the PCF8583 registers. 
.................... bcd_sec = bin2bcd(dt->seconds); 
*
16C8:  MOVF   xA5,W
16CA:  MOVWF  FE9
16CC:  MOVFF  A6,FEA
16D0:  MOVFF  FEF,AC
16D4:  MOVFF  AC,AD
16D8:  RCALL  1660
16DA:  MOVFF  01,A7
.................... bcd_min = bin2bcd(dt->minutes); 
16DE:  MOVLW  01
16E0:  ADDWF  xA5,W
16E2:  MOVWF  FE9
16E4:  MOVLW  00
16E6:  ADDWFC xA6,W
16E8:  MOVWF  FEA
16EA:  MOVFF  FEF,AC
16EE:  MOVFF  AC,AD
16F2:  RCALL  1660
16F4:  MOVFF  01,A8
.................... bcd_hrs = bin2bcd(dt->hours); 
16F8:  MOVLW  02
16FA:  ADDWF  xA5,W
16FC:  MOVWF  FE9
16FE:  MOVLW  00
1700:  ADDWFC xA6,W
1702:  MOVWF  FEA
1704:  MOVFF  FEF,AC
1708:  MOVFF  AC,AD
170C:  RCALL  1660
170E:  MOVFF  01,A9
.................... bcd_day = bin2bcd(dt->day) | (dt->year << 6); 
1712:  MOVLW  03
1714:  ADDWF  xA5,W
1716:  MOVWF  FE9
1718:  MOVLW  00
171A:  ADDWFC xA6,W
171C:  MOVWF  FEA
171E:  MOVFF  FEF,AC
1722:  MOVFF  AC,AD
1726:  RCALL  1660
1728:  MOVLW  05
172A:  ADDWF  xA5,W
172C:  MOVWF  FE9
172E:  MOVLW  00
1730:  ADDWFC xA6,W
1732:  MOVWF  FEA
1734:  SWAPF  FEF,W
1736:  MOVWF  00
1738:  RLCF   00,F
173A:  RLCF   00,F
173C:  MOVLW  C0
173E:  ANDWF  00,F
1740:  MOVF   00,W
1742:  IORWF  01,W
1744:  MOVWF  xAA
.................... bcd_mon = bin2bcd(dt->month) | (dt->weekday << 5); 
1746:  MOVLW  04
1748:  ADDWF  xA5,W
174A:  MOVWF  FE9
174C:  MOVLW  00
174E:  ADDWFC xA6,W
1750:  MOVWF  FEA
1752:  MOVFF  FEF,AC
1756:  MOVFF  AC,AD
175A:  RCALL  1660
175C:  MOVLW  06
175E:  ADDWF  xA5,W
1760:  MOVWF  FE9
1762:  MOVLW  00
1764:  ADDWFC xA6,W
1766:  MOVWF  FEA
1768:  SWAPF  FEF,W
176A:  MOVWF  00
176C:  RLCF   00,F
176E:  MOVLW  E0
1770:  ANDWF  00,F
1772:  MOVF   00,W
1774:  IORWF  01,W
1776:  MOVWF  xAB
....................  
.................... // Stop the RTC from counting, before we write to 
.................... // the date and time registers. 
.................... PCF8583_write_byte(PCF8583_CTRL_STATUS_REG, 
....................                               PCF8583_STOP_COUNTING); 
1778:  CLRF   xAD
177A:  MOVLW  80
177C:  MOVWF  xAE
177E:  RCALL  169C
....................  
.................... // Write to the date and time registers.  Disable interrupts 
.................... // so they can't disrupt the i2c operations. 
.................... disable_interrupts(GLOBAL); 
1780:  BCF    FF2.6
1782:  BCF    FF2.7
1784:  BTFSC  FF2.7
1786:  BRA    1782
.................... i2c_start(); 
1788:  BSF    FC5.0
178A:  BTFSC  FC5.0
178C:  BRA    178A
.................... i2c_write(PCF8583_WRITE_ADDRESS); 
178E:  MOVLW  A0
1790:  MOVLB  2
1792:  MOVWF  xBA
1794:  MOVLB  0
1796:  RCALL  1680
.................... i2c_write(PCF8583_100S_REG);   // Start at 100's reg. 
1798:  MOVLW  01
179A:  MOVLB  2
179C:  MOVWF  xBA
179E:  MOVLB  0
17A0:  RCALL  1680
.................... i2c_write(0x00);               // Set 100's reg = 0 
17A2:  MOVLB  2
17A4:  CLRF   xBA
17A6:  MOVLB  0
17A8:  RCALL  1680
.................... i2c_write(bcd_sec); 
17AA:  MOVFF  A7,2BA
17AE:  RCALL  1680
.................... i2c_write(bcd_min); 
17B0:  MOVFF  A8,2BA
17B4:  RCALL  1680
.................... i2c_write(bcd_hrs); 
17B6:  MOVFF  A9,2BA
17BA:  RCALL  1680
.................... i2c_write(bcd_day); 
17BC:  MOVFF  AA,2BA
17C0:  RCALL  1680
.................... i2c_write(bcd_mon); 
17C2:  MOVFF  AB,2BA
17C6:  RCALL  1680
.................... i2c_stop(); 
17C8:  BSF    FC5.2
17CA:  BTFSC  FC5.2
17CC:  BRA    17CA
....................  
.................... // Write the year byte to the first NVRAM location. 
.................... // Leave it in binary format. 
.................... PCF8583_write_byte(PCF8583_YEAR_REG, dt->year); 
17CE:  MOVLW  05
17D0:  ADDWF  xA5,W
17D2:  MOVWF  FE9
17D4:  MOVLW  00
17D6:  ADDWFC xA6,W
17D8:  MOVWF  FEA
17DA:  MOVFF  FEF,AC
17DE:  MOVLW  10
17E0:  MOVWF  xAD
17E2:  MOVFF  AC,AE
17E6:  RCALL  169C
....................  
.................... // Now allow the PCF8583 to start counting again. 
.................... PCF8583_write_byte(PCF8583_CTRL_STATUS_REG, 
....................                               PCF8583_START_COUNTING); 
17E8:  CLRF   xAD
17EA:  CLRF   xAE
17EC:  RCALL  169C
.................... } 
17EE:  GOTO   1D26 (RETURN)
....................  
.................... //---------------------------------------------- 
.................... // Read the Date and Time from the hardware registers 
.................... // in the PCF8583.   We don't have to disable counting 
.................... // during read operations, because according to the data 
.................... // sheet, if any of the lower registers (1 to 7) is read, 
.................... // all of them are loaded into "capture" registers. 
.................... // All further reading within that cycle is done from 
.................... // those registers. 
....................  
.................... void PCF8583_read_datetime(date_time_t *dt) 
.................... { 
.................... int8 year_bits; 
.................... int8 year; 
....................  
.................... int8 bcd_sec; 
.................... int8 bcd_min; 
.................... int8 bcd_hrs; 
.................... int8 bcd_day; 
.................... int8 bcd_mon; 
....................  
.................... // Disable interrupts so the i2c process is not disrupted. 
.................... disable_interrupts(GLOBAL); 
*
2764:  BCF    FF2.6
2766:  BCF    FF2.7
2768:  BTFSC  FF2.7
276A:  BRA    2766
....................  
.................... // Read the date/time registers inside the PCF8583. 
.................... i2c_start(); 
276C:  BSF    FC5.0
276E:  BTFSC  FC5.0
2770:  BRA    276E
.................... i2c_write(PCF8583_WRITE_ADDRESS); 
2772:  MOVLW  A0
2774:  MOVLB  2
2776:  MOVWF  xBA
2778:  MOVLB  0
277A:  CALL   1680
.................... i2c_write(PCF8583_SECONDS_REG);   // Start at seconds reg. 
277E:  MOVLW  02
2780:  MOVLB  2
2782:  MOVWF  xBA
2784:  MOVLB  0
2786:  CALL   1680
.................... i2c_start(); 
278A:  BSF    FC5.1
278C:  BTFSC  FC5.1
278E:  BRA    278C
.................... i2c_write(PCF8583_READ_ADDRESS); 
2790:  MOVLW  A1
2792:  MOVLB  2
2794:  MOVWF  xBA
2796:  MOVLB  0
2798:  CALL   1680
....................  
.................... bcd_sec = i2c_read(); 
279C:  MOVLW  01
279E:  MOVWF  00
27A0:  RCALL  26DA
27A2:  MOVFF  01,A5
.................... bcd_min = i2c_read(); 
27A6:  MOVLW  01
27A8:  MOVWF  00
27AA:  RCALL  26DA
27AC:  MOVFF  01,A6
.................... bcd_hrs = i2c_read(); 
27B0:  MOVLW  01
27B2:  MOVWF  00
27B4:  RCALL  26DA
27B6:  MOVFF  01,A7
.................... bcd_day = i2c_read(); 
27BA:  MOVLW  01
27BC:  MOVWF  00
27BE:  RCALL  26DA
27C0:  MOVFF  01,A8
.................... bcd_mon = i2c_read(0); 
27C4:  CLRF   00
27C6:  RCALL  26DA
27C8:  MOVFF  01,A9
.................... i2c_stop(); 
27CC:  BSF    FC5.2
27CE:  BTFSC  FC5.2
27D0:  BRA    27CE
....................  
....................  
.................... // Convert the date/time values from BCD to 
.................... // unsigned 8-bit integers.  Unpack the bits 
.................... // in the PCF8583 registers where required. 
.................... dt->seconds = bcd2bin(bcd_sec); 
27D2:  MOVFF  A1,01
27D6:  MOVFF  A2,03
27DA:  MOVFF  A1,AA
27DE:  MOVFF  A2,AB
27E2:  MOVFF  A5,AD
27E6:  RCALL  26F4
27E8:  MOVFF  AB,FEA
27EC:  MOVFF  AA,FE9
27F0:  MOVFF  01,FEF
.................... dt->minutes = bcd2bin(bcd_min); 
27F4:  MOVLW  01
27F6:  ADDWF  xA1,W
27F8:  MOVWF  01
27FA:  MOVLW  00
27FC:  ADDWFC xA2,W
27FE:  MOVWF  03
2800:  MOVFF  01,AA
2804:  MOVWF  xAB
2806:  MOVFF  A6,AD
280A:  RCALL  26F4
280C:  MOVFF  AB,FEA
2810:  MOVFF  AA,FE9
2814:  MOVFF  01,FEF
.................... dt->hours   = bcd2bin(bcd_hrs & 0x3F); 
2818:  MOVLW  02
281A:  ADDWF  xA1,W
281C:  MOVWF  01
281E:  MOVLW  00
2820:  ADDWFC xA2,W
2822:  MOVWF  03
2824:  MOVFF  01,AA
2828:  MOVWF  xAB
282A:  MOVF   xA7,W
282C:  ANDLW  3F
282E:  MOVWF  xAC
2830:  MOVWF  xAD
2832:  RCALL  26F4
2834:  MOVFF  AB,FEA
2838:  MOVFF  AA,FE9
283C:  MOVFF  01,FEF
.................... dt->day     = bcd2bin(bcd_day & 0x3F); 
2840:  MOVLW  03
2842:  ADDWF  xA1,W
2844:  MOVWF  01
2846:  MOVLW  00
2848:  ADDWFC xA2,W
284A:  MOVWF  03
284C:  MOVFF  01,AA
2850:  MOVWF  xAB
2852:  MOVF   xA8,W
2854:  ANDLW  3F
2856:  MOVWF  xAC
2858:  MOVWF  xAD
285A:  RCALL  26F4
285C:  MOVFF  AB,FEA
2860:  MOVFF  AA,FE9
2864:  MOVFF  01,FEF
.................... dt->month   = bcd2bin(bcd_mon & 0x1F); 
2868:  MOVLW  04
286A:  ADDWF  xA1,W
286C:  MOVWF  01
286E:  MOVLW  00
2870:  ADDWFC xA2,W
2872:  MOVWF  03
2874:  MOVFF  01,AA
2878:  MOVWF  xAB
287A:  MOVF   xA9,W
287C:  ANDLW  1F
287E:  MOVWF  xAC
2880:  MOVWF  xAD
2882:  RCALL  26F4
2884:  MOVFF  AB,FEA
2888:  MOVFF  AA,FE9
288C:  MOVFF  01,FEF
.................... dt->weekday = bcd_mon >> 5; 
2890:  MOVLW  06
2892:  ADDWF  xA1,W
2894:  MOVWF  FE9
2896:  MOVLW  00
2898:  ADDWFC xA2,W
289A:  MOVWF  FEA
289C:  SWAPF  xA9,W
289E:  MOVWF  00
28A0:  RRCF   00,F
28A2:  MOVLW  07
28A4:  ANDWF  00,F
28A6:  MOVFF  00,FEF
.................... year_bits   = bcd_day >> 6; 
28AA:  SWAPF  xA8,W
28AC:  MOVWF  xA3
28AE:  RRCF   xA3,F
28B0:  RRCF   xA3,F
28B2:  MOVLW  03
28B4:  ANDWF  xA3,F
....................  
.................... // Read the year byte from NVRAM. 
.................... // This is an added feature of this driver. 
.................... year = PCF8583_read_byte(PCF8583_YEAR_REG); 
28B6:  MOVLW  10
28B8:  MOVWF  xAA
28BA:  BRA    271A
28BC:  MOVFF  01,A4
....................  
.................... // Check if the two "year bits" were incremented by 
.................... // the PCF8583.  If so, increment the 8-bit year 
.................... // byte (read from NVRAM) by the same amount. 
.................... while(year_bits != (year & 3)) 
....................       year++; 
28C0:  MOVF   xA4,W
28C2:  ANDLW  03
28C4:  SUBWF  xA3,W
28C6:  BZ    28CC
28C8:  INCF   xA4,F
28CA:  BRA    28C0
....................  
.................... dt->year = year; 
28CC:  MOVLW  05
28CE:  ADDWF  xA1,W
28D0:  MOVWF  FE9
28D2:  MOVLW  00
28D4:  ADDWFC xA2,W
28D6:  MOVWF  FEA
28D8:  MOVFF  A4,FEF
....................  
.................... // Now update the year byte in the NVRAM 
.................... // inside the PCF8583. 
.................... PCF8583_write_byte(PCF8583_YEAR_REG, year); 
28DC:  MOVLW  10
28DE:  MOVWF  xAD
28E0:  MOVFF  A4,AE
28E4:  CALL   169C
....................  
.................... } 
28E8:  RETLW  00
....................  
.................... //Método que permite establecer una alarma, dados horas, minutos y segundos 
.................... //Author: Julio Navarro Lara 
.................... void PCF8583_establecer_alarma(int8 horas, int8 minutos, int8 segundos){ 
....................    int8 bcd_horas; 
....................    int8 bcd_minutos; 
....................    int8 bcd_segundos; 
....................  
....................    //Transformamos a BCD las horas y los minutos introducidos 
....................    bcd_horas = bin2bcd(horas); 
*
2912:  MOVFF  97,AD
2916:  CALL   1660
291A:  MOVFF  01,9A
....................    bcd_minutos = bin2bcd(minutos); 
291E:  MOVFF  98,AD
2922:  CALL   1660
2926:  MOVFF  01,9B
....................    bcd_segundos = bin2bcd(segundos); 
292A:  MOVFF  99,AD
292E:  CALL   1660
2932:  MOVFF  01,9C
....................  
....................    //Paramos de contar el tiempo para escribir los datos 
....................    PCF8583_write_byte(PCF8583_CTRL_STATUS_REG, 
....................                               PCF8583_STOP_COUNTING); 
2936:  CLRF   xAD
2938:  MOVLW  80
293A:  MOVWF  xAE
293C:  CALL   169C
....................  
....................    //Definimos las condiciones de la alarma 
....................    PCF8583_write_byte(PCF8583_ALARM_CONTROL_REG, 
....................                               PCF8583_DEFINIR_ALARMA); 
2940:  MOVLW  08
2942:  MOVWF  xAD
2944:  MOVLW  90
2946:  MOVWF  xAE
2948:  CALL   169C
....................  
....................    //Desactivamos las interrupciones para que no interfieran en la escritura i2c 
....................    disable_interrupts(GLOBAL); 
294C:  BCF    FF2.6
294E:  BCF    FF2.7
2950:  BTFSC  FF2.7
2952:  BRA    294E
....................    i2c_start(); 
2954:  BSF    FC5.0
2956:  BTFSC  FC5.0
2958:  BRA    2956
....................    i2c_write(PCF8583_WRITE_ADDRESS); 
295A:  MOVLW  A0
295C:  MOVLB  2
295E:  MOVWF  xBA
2960:  MOVLB  0
2962:  CALL   1680
....................    //Escribimos en los registros de hora y minutos 
....................    i2c_write(PCF8583_ALARM_100S_REG); 
2966:  MOVLW  09
2968:  MOVLB  2
296A:  MOVWF  xBA
296C:  MOVLB  0
296E:  CALL   1680
....................    i2c_write(0x00); 
2972:  MOVLB  2
2974:  CLRF   xBA
2976:  MOVLB  0
2978:  CALL   1680
....................    i2c_write(bcd_segundos); 
297C:  MOVFF  9C,2BA
2980:  CALL   1680
....................    i2c_write(bcd_minutos); 
2984:  MOVFF  9B,2BA
2988:  CALL   1680
....................    i2c_write(bcd_horas); 
298C:  MOVFF  9A,2BA
2990:  CALL   1680
....................    i2c_stop(); 
2994:  BSF    FC5.2
2996:  BTFSC  FC5.2
2998:  BRA    2996
....................  
....................    //OJO! No volvemos a activar las interrupciones por si llamamos al método 
....................    //dentro de una rutina de interrupción 
....................  
....................    //Activamos la alarma 
....................    PCF8583_write_byte(PCF8583_CTRL_STATUS_REG, 
....................                               PCF8583_ACTIVAR_ALARMA); 
299A:  CLRF   xAD
299C:  MOVLW  04
299E:  MOVWF  xAE
29A0:  CALL   169C
....................  
....................  
....................  
....................    //Activamos el flag indicador de alarma 
....................    alarma_activada = TRUE; 
29A4:  MOVLW  01
29A6:  MOVWF  1E
....................  
.................... } 
29A8:  RETLW  00
....................  
.................... #include "LCDeasy.c" 
.................... ////----------------------------------------------------------------------------//// 
.................... // 	Funciones para la gestion del display LCD de la EasyPIC3 
.................... //	con el compilador de CCS. 
.................... //	Es una adaptación del archivo LCD.c de CCS para las prácticas de la 
.................... //	asignatura, y por tanto no distribuible a usuarios no autorizados. 
.................... //------------------------------------------------------------------------------//// 
....................  
.................... //  lcd_init()   Inicializa el LCD: debe ser llamada antes que las otras funciones. 
.................... // 
.................... //  lcd_putc(c)  Visualiza c en la siguiente posición del display. 
.................... //               Caracteres especiales de control: 
.................... //                      \f  Borrar display 
.................... //                      \n  Saltar a la segunda linea 
.................... //                      \b  Retroceder una posición. 
.................... // 
.................... //  lcd_gotoxy(x,y) Selecciona la nueva posicion de escritura en el display. 
.................... //                  (la esquina superior izquierda es 1,1) 
.................... // 
.................... //  lcd_getc(x,y)   Devuelve el caracter de la posicion x,y del display. 
.................... //			(esta función no va en la EASYPIC3, pues R/W=0) 
.................... // 
.................... //  lcd_send_byte(rs,byte)	escribe byte en el registro de datos(con rs=1) o de 
.................... //				instrucciones (con rs=0). 
.................... //------------------------------------------------------------------------------// 
.................... // Conexion del LCD con el PIC: 
.................... //     RB0 -- 
.................... //     RB1 -- 
.................... //     RB2  rs 
.................... //     RB3  Enable 
.................... //     RB4  D4 
.................... //     RB5  D5 
.................... //     RB6  D6 
.................... //     RB7  D7 
.................... // 
.................... // Los pines D0-D3 del LCD no se usan 
.................... // El pin RB0 del PIC no se usa 
.................... // El pin RB1 no está conectado en la tarjeta, 
.................... // podría ser para r/w 
....................  
.................... // Un-comment the following define to use port B 
.................... #define use_portb_lcd TRUE 		//LINEA DES-COMENTADA---------------- 
....................  
....................  
.................... struct lcd_pin_map {                 // This structure is overlayed 
....................            int unused : 2 ;	//MODIFICADA PARA EASYPIC-------------------- 
.................... 	   //BOOLEAN rw;		//MODIFICADA PARA EASYPIC-------------------- 
.................... 	   BOOLEAN rs;           // on to an I/O port to gain 
....................            BOOLEAN ENABLE;            // access to the LCD pins. 
....................            		           	// The bits are allocated from 
....................            			          // low order up.  ENABLE will 
....................            int     data : 4;         	// be pin B3------------------------- 
....................         } lcd; 
....................  
....................  
.................... #if defined(__PCH__) 
.................... #if defined use_portb_lcd 
....................    #byte lcd = 0xF81                   // This puts the entire structure 
.................... #else 
....................    #byte lcd = 0xF83                   // This puts the entire structure 
.................... #endif 
.................... #else 
.................... #if defined use_portb_lcd 
....................    #byte lcd = 6                  // on to port B (at address 6) 
.................... #else 
....................    #byte lcd = 8                 // on to port D (at address 8) 
.................... #endif 
.................... #endif 
....................  
.................... #if defined use_portb_lcd 
....................    #define set_tris_lcd(x) set_tris_b(x) 
.................... #else 
....................    #define set_tris_lcd(x) set_tris_d(x) 
.................... #endif 
....................  
....................  
.................... #define lcd_type 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #define lcd_line_two 0x40    // LCD RAM address for the second line 
....................  
....................  
.................... BYTE const LCD_INIT_STRING[4] = {0x24 | (lcd_type << 2), 0xF, 1, 6}; 
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................  
....................  
....................                              // The following are used for setting 
....................                              // the I/O port direction register. 
....................  
.................... struct lcd_pin_map const LCD_WRITE = {3,0,0,0}; // For write mode all pins are out 
.................... struct lcd_pin_map const LCD_READ = {3,0,0,15}; // For read mode data pins are in 
....................  
....................  
....................  
.................... BYTE lcd_read_byte() { 
....................       BYTE low,high; 
....................       set_tris_lcd(LCD_READ); 
....................       //////lcd.rw = 1; 
....................       delay_cycles(1); 
....................       lcd.enable = 1; 
....................       delay_cycles(1); 
....................       high = lcd.data; 
....................       lcd.enable = 0; 
....................       delay_cycles(1); 
....................       lcd.enable = 1; 
....................       delay_us(1); 
....................       low = lcd.data; 
....................       lcd.enable = 0; 
....................       set_tris_lcd(LCD_WRITE); 
....................       return( (high<<4) | low); 
.................... } 
....................  
....................  
.................... void lcd_send_nibble( BYTE n ) { 
....................       lcd.data = n; 
*
12D8:  SWAPF  xAF,W
12DA:  ANDLW  F0
12DC:  MOVWF  00
12DE:  MOVLW  0F
12E0:  ANDWF  F81,W
12E2:  IORWF  00,W
12E4:  MOVWF  F81
....................       delay_cycles(1); 
12E6:  NOP   
....................       lcd.enable = 1; 
12E8:  BSF    F81.3
....................       delay_us(2); 
12EA:  CLRWDT
12EC:  NOP   
12EE:  NOP   
12F0:  NOP   
....................       lcd.enable = 0; 
12F2:  BCF    F81.3
.................... } 
12F4:  RETLW  00
....................  
....................  
.................... void lcd_send_byte( BYTE address, BYTE n ) { 
....................  
....................       lcd.rs = 0; 
*
1314:  BCF    F81.2
....................       delay_us(3000); 
1316:  CLRWDT
1318:  MOVLW  02
131A:  MOVWF  xAE
131C:  RCALL  12A8
131E:  MOVLW  09
1320:  MOVWF  xAE
1322:  MOVLW  6D
1324:  MOVWF  xAF
1326:  RCALL  12F6
1328:  DECFSZ xAE,F
132A:  BRA    1322
.................... //      while ( bit_test(lcd_read_byte(),7) ) ; 
....................       lcd.rs = address; 
132C:  BTFSS  xAC.0
132E:  BCF    F81.2
1330:  BTFSC  xAC.0
1332:  BSF    F81.2
....................       delay_cycles(1); 
1334:  NOP   
....................       //////////lcd.rw = 0; 
....................       delay_cycles(1); 
1336:  NOP   
....................       lcd.enable = 0; 
1338:  BCF    F81.3
....................       lcd_send_nibble(n >> 4); 
133A:  SWAPF  xAD,W
133C:  MOVWF  xAE
133E:  MOVLW  0F
1340:  ANDWF  xAE,F
1342:  MOVFF  AE,AF
1346:  RCALL  12D8
....................       lcd_send_nibble(n & 0xf); 
1348:  MOVF   xAD,W
134A:  ANDLW  0F
134C:  MOVWF  xAE
134E:  MOVWF  xAF
1350:  RCALL  12D8
.................... } 
1352:  RETLW  00
....................  
....................  
.................... void lcd_init() { 
....................     BYTE i; 
....................     set_tris_lcd(LCD_WRITE); 
1354:  MOVLW  03
1356:  MOVWF  F93
....................     lcd.rs = 0; 
1358:  BCF    F81.2
....................     /////lcd.rw = 0; 
....................     lcd.enable = 0; 
135A:  BCF    F81.3
....................     delay_ms(50); 
135C:  MOVLW  32
135E:  MOVWF  xAE
1360:  RCALL  12A8
....................     //for(i=1;i<=3;++i) { 
....................     //   lcd_send_nibble(3); 
....................     //  delay_ms(5); 
....................     //} 
....................     lcd_send_nibble(2); 
1362:  MOVLW  02
1364:  MOVWF  xAF
1366:  RCALL  12D8
....................     delay_ms(5); 
1368:  MOVLW  05
136A:  MOVWF  xAE
136C:  RCALL  12A8
....................     for(i=0;i<=3;++i) 
136E:  CLRF   x95
1370:  MOVF   x95,W
1372:  SUBLW  03
1374:  BNC   139A
....................        { lcd_send_byte(0,LCD_INIT_STRING[i]); 
1376:  CLRF   03
1378:  MOVF   x95,W
137A:  MOVFF  FF2,96
137E:  BCF    FF2.7
1380:  CALL   00B4
1384:  BTFSC  x96.7
1386:  BSF    FF2.7
1388:  MOVWF  x97
138A:  CLRF   xAC
138C:  MOVWF  xAD
138E:  RCALL  1314
....................         delay_ms(5); } 
1390:  MOVLW  05
1392:  MOVWF  xAE
1394:  RCALL  12A8
1396:  INCF   x95,F
1398:  BRA    1370
.................... } 
139A:  GOTO   5D22 (RETURN)
....................  
....................  
.................... void lcd_gotoxy( BYTE x, BYTE y) { 
....................    BYTE address; 
....................  
....................    if(y!=1) 
139E:  DECFSZ xA9,W
13A0:  BRA    13A4
13A2:  BRA    13AA
....................      address=lcd_line_two; 
13A4:  MOVLW  40
13A6:  MOVWF  xAA
....................    else 
13A8:  BRA    13AC
....................      address=0; 
13AA:  CLRF   xAA
....................    address+=x-1; 
13AC:  MOVLW  01
13AE:  SUBWF  xA8,W
13B0:  ADDWF  xAA,F
....................    lcd_send_byte(0,0x80|address); 
13B2:  MOVF   xAA,W
13B4:  IORLW  80
13B6:  MOVWF  xAB
13B8:  CLRF   xAC
13BA:  MOVWF  xAD
13BC:  RCALL  1314
.................... } 
13BE:  RETLW  00
....................  
.................... void lcd_putc( char c) { 
....................    switch (c) { 
13C0:  MOVF   xA7,W
13C2:  XORLW  0C
13C4:  BZ    13D0
13C6:  XORLW  06
13C8:  BZ    13E0
13CA:  XORLW  02
13CC:  BZ    13EC
13CE:  BRA    13F6
....................      case '\f'   : lcd_send_byte(0,1); 
13D0:  CLRF   xAC
13D2:  MOVLW  01
13D4:  MOVWF  xAD
13D6:  RCALL  1314
....................                    delay_ms(2); 
13D8:  MOVLW  02
13DA:  MOVWF  xAE
13DC:  RCALL  12A8
....................                                            break; 
13DE:  BRA    1402
....................      case '\n'   : lcd_gotoxy(1,2);        break; 
13E0:  MOVLW  01
13E2:  MOVWF  xA8
13E4:  MOVLW  02
13E6:  MOVWF  xA9
13E8:  RCALL  139E
13EA:  BRA    1402
....................      case '\b'   : lcd_send_byte(0,0x10);  break; 
13EC:  CLRF   xAC
13EE:  MOVLW  10
13F0:  MOVWF  xAD
13F2:  RCALL  1314
13F4:  BRA    1402
....................      default     : lcd_send_byte(1,c);     break; 
13F6:  MOVLW  01
13F8:  MOVWF  xAC
13FA:  MOVFF  A7,AD
13FE:  RCALL  1314
1400:  BRA    1402
....................    } 
.................... } 
1402:  RETLW  00
....................  
.................... char lcd_getc( BYTE x, BYTE y) { 
....................    char value; 
....................  
....................     lcd_gotoxy(x,y); 
....................     while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................     lcd.rs=1; 
....................     value = lcd_read_byte(); 
....................     lcd.rs=0; 
....................     return(value); 
.................... } 
....................  
.................... #include "1wire.c" 
.................... /***********************1Wire Class***********************/ 
.................... /*Funciones básicas para comunicación con un solo sensor 1wire */ 
.................... /*********************************************************/ 
.................... /*-------1-wire definitions-------*/ 
....................  
.................... #define ONE_WIRE_PIN PIN_A5 //modificar de acuerdo con la tarjeta 
....................  
....................  
.................... /************onewire_reset*************************************************/ 
.................... void onewire_reset()  // OK if just using a single permanently connected device 
.................... { 
....................  output_low(ONE_WIRE_PIN); 
*
1DEC:  BCF    F92.5
1DEE:  BCF    F89.5
....................  delay_us( 500 ); // pull 1-wire low for reset pulse 
1DF0:  CLRWDT
1DF2:  MOVLW  02
1DF4:  MOVWF  xAC
1DF6:  MOVLW  F7
1DF8:  MOVWF  xAF
1DFA:  CALL   12F6
1DFE:  DECFSZ xAC,F
1E00:  BRA    1DF6
....................  output_float(ONE_WIRE_PIN); // float 1-wire high 
1E02:  BSF    F92.5
....................  delay_us( 500 ); // wait-out remaining initialisation window. 
1E04:  CLRWDT
1E06:  MOVLW  02
1E08:  MOVWF  xAC
1E0A:  MOVLW  F7
1E0C:  MOVWF  xAF
1E0E:  CALL   12F6
1E12:  DECFSZ xAC,F
1E14:  BRA    1E0A
....................  output_float(ONE_WIRE_PIN); 
1E16:  BSF    F92.5
.................... } 
1E18:  RETLW  00
....................  
.................... /*********************** onewire_write() ********************************/ 
.................... /*Esta función escribe un byte en el sensor.*/ 
.................... /* */ 
.................... /*Parametros: byte - el byte a escribir en el 1wire */ 
....................  
.................... void onewire_write(int data) 
.................... { 
....................  int count; 
....................  
....................  for (count=0; count<8; ++count) 
1E1A:  CLRF   xAE
1E1C:  MOVF   xAE,W
1E1E:  SUBLW  07
1E20:  BNC   1E56
....................  { 
....................   output_low(ONE_WIRE_PIN); 
1E22:  BCF    F92.5
1E24:  BCF    F89.5
....................   delay_us( 2 ); // pull 1-wire low to initiate write time-slot. 
1E26:  CLRWDT
1E28:  NOP   
1E2A:  NOP   
1E2C:  NOP   
....................   output_bit(ONE_WIRE_PIN, shift_right(&data,1,0)); // set output bit on 1-wire 
1E2E:  BCF    FD8.0
1E30:  RRCF   xAD,F
1E32:  BC    1E38
1E34:  BCF    F89.5
1E36:  BRA    1E3A
1E38:  BSF    F89.5
1E3A:  BCF    F92.5
....................   delay_us( 60 ); // wait until end of write slot. 
1E3C:  CLRWDT
1E3E:  MOVLW  27
1E40:  MOVWF  00
1E42:  DECFSZ 00,F
1E44:  BRA    1E42
1E46:  NOP   
....................   output_float(ONE_WIRE_PIN); // set 1-wire high again, 
1E48:  BSF    F92.5
....................   delay_us( 2 ); // for more than 1us minimum. 
1E4A:  CLRWDT
1E4C:  NOP   
1E4E:  NOP   
1E50:  NOP   
....................  } 
1E52:  INCF   xAE,F
1E54:  BRA    1E1C
.................... } 
1E56:  RETLW  00
....................  
.................... /*********************** read1wire() *********************************/ 
.................... /*Esta función lee un dato de 8 bits del sensor.*/ 
.................... /*Devuelve: dato de 8-bit (1-byte)*/ 
....................  
.................... int onewire_read() 
.................... { 
....................  int count, data; 
....................  
....................  for (count=0; count<8; ++count) 
*
1FC4:  CLRF   xAC
1FC6:  MOVF   xAC,W
1FC8:  SUBLW  07
1FCA:  BNC   2006
....................  { 
....................   output_low(ONE_WIRE_PIN); 
1FCC:  BCF    F92.5
1FCE:  BCF    F89.5
....................   delay_us( 2 ); // pull 1-wire low to initiate read time-slot. 
1FD0:  CLRWDT
1FD2:  NOP   
1FD4:  NOP   
1FD6:  NOP   
....................   output_float(ONE_WIRE_PIN); // now let 1-wire float high, 
1FD8:  BSF    F92.5
....................   delay_us( 8 ); // let device state stabilise, 
1FDA:  CLRWDT
1FDC:  MOVLW  04
1FDE:  MOVWF  00
1FE0:  DECFSZ 00,F
1FE2:  BRA    1FE0
1FE4:  NOP   
1FE6:  NOP   
....................   shift_right(&data,1,input(ONE_WIRE_PIN)); // and load result. 
1FE8:  BSF    F92.5
1FEA:  BTFSC  F80.5
1FEC:  BRA    1FF2
1FEE:  BCF    FD8.0
1FF0:  BRA    1FF4
1FF2:  BSF    FD8.0
1FF4:  RRCF   xAD,F
....................   delay_us( 120 ); // wait until end of read slot. 
1FF6:  CLRWDT
1FF8:  MOVLW  4F
1FFA:  MOVWF  00
1FFC:  DECFSZ 00,F
1FFE:  BRA    1FFC
2000:  NOP   
....................  } 
2002:  INCF   xAC,F
2004:  BRA    1FC6
....................  
....................  return( data ); 
2006:  MOVFF  AD,01
.................... } 
200A:  RETLW  00
....................  
.................... void ow_write_bit(int1 data) 
.................... { 
....................   output_low(ONE_WIRE_PIN); 
*
1E92:  BCF    F92.5
1E94:  BCF    F89.5
....................   delay_us( 2 ); // pull 1-wire low to initiate write time-slot. 
1E96:  CLRWDT
1E98:  NOP   
1E9A:  NOP   
1E9C:  NOP   
....................   output_bit(ONE_WIRE_PIN, data); // set output bit on 1-wire 
1E9E:  MOVF   x9D,F
1EA0:  BNZ   1EA6
1EA2:  BCF    F89.5
1EA4:  BRA    1EA8
1EA6:  BSF    F89.5
1EA8:  BCF    F92.5
....................   delay_us( 60 ); // wait until end of write slot. 
1EAA:  CLRWDT
1EAC:  MOVLW  27
1EAE:  MOVWF  00
1EB0:  DECFSZ 00,F
1EB2:  BRA    1EB0
1EB4:  NOP   
....................   output_float(ONE_WIRE_PIN); // set 1-wire high again, 
1EB6:  BSF    F92.5
....................   delay_us( 2 ); // for more than 1us minimum. 
1EB8:  CLRWDT
1EBA:  NOP   
1EBC:  NOP   
1EBE:  NOP   
.................... } 
1EC0:  RETLW  00
....................  
.................... int1 ow_read_bit() 
.................... { 
....................   int1 data; 
....................  
....................   output_low(ONE_WIRE_PIN); 
*
1E58:  BCF    F92.5
1E5A:  BCF    F89.5
....................   delay_us( 2 ); // pull 1-wire low to initiate read time-slot. 
1E5C:  CLRWDT
1E5E:  NOP   
1E60:  NOP   
1E62:  NOP   
....................   output_float(ONE_WIRE_PIN); // now let 1-wire float high, 
1E64:  BSF    F92.5
....................   delay_us( 8 ); // let device state stabilise, 
1E66:  CLRWDT
1E68:  MOVLW  04
1E6A:  MOVWF  00
1E6C:  DECFSZ 00,F
1E6E:  BRA    1E6C
1E70:  NOP   
1E72:  NOP   
....................   data = input(ONE_WIRE_PIN); // and load result. 
1E74:  BSF    F92.5
1E76:  BCF    x9D.0
1E78:  BTFSC  F80.5
1E7A:  BSF    x9D.0
....................   delay_us( 120 ); // wait until end of read slot. 
1E7C:  CLRWDT
1E7E:  MOVLW  4F
1E80:  MOVWF  00
1E82:  DECFSZ 00,F
1E84:  BRA    1E82
1E86:  NOP   
....................  
....................   return( data ); 
1E88:  MOVLW  00
1E8A:  BTFSC  x9D.0
1E8C:  MOVLW  01
1E8E:  MOVWF  01
.................... } 
1E90:  RETLW  00
....................  
.................... /////////////////////////////////////////////////////////////////// 
....................  
.................... void write_bit(int1 bitval) 
.................... { 
....................    output_low(ONE_WIRE_PIN); 
....................  
....................    if(bitval == 1) { 
....................       delay_us(1);      // 1uS min. Original code relied on 8051 being slow 
....................       output_float(ONE_WIRE_PIN); 
....................    } 
....................    delay_us(105);       // Wait for end of timeslot 
....................    output_float(ONE_WIRE_PIN); 
.................... } 
....................  
.................... int8 read_bit(void) 
.................... { 
....................    output_low(ONE_WIRE_PIN); 
....................    delay_us(1);         // 1uS min. Original code relied on 8051 being slow 
....................    output_float(ONE_WIRE_PIN); 
....................    delay_us(20);        // Wait at least 15mS from start of time slot 
....................    return(input(ONE_WIRE_PIN));   // Delay to finish time slot (total 60 to 120uS) 
.................... }                       // must be done next. 
....................  
....................  
....................  
.................... #include "ds1820.c" 
....................  
.................... /***************************************************/ 
.................... /*Driver básico del termómetro/termostato ds1820.c */ 
.................... // 
.................... //Realiza una secuencia completa de incialización, conversión 
.................... //de temperatura, y lectura del (único) sensor de temperatura 
.................... //con alimentación externa (no parásita). 
.................... // 
.................... /***************************************************/ 
....................  
.................... float ds1820_read(int* dir) 
.................... { 
....................  int8 busy=0, temp1, temp2; 
*
21B8:  CLRF   xA3
....................  signed int16 temp3; 
....................  float result; 
....................  
....................  onewire_reset();     // Cada acceso al sensor debe iniciarse con reset 
21BA:  RCALL  1DEC
....................  onewire_write(0x55); //Instrucción MATCH ROM 
21BC:  MOVLW  55
21BE:  MOVWF  xAD
21C0:  RCALL  1E1A
....................  //Mandamos por el one wire la dirección dir de 64 bits 
....................  onewire_write(dir[0]); 
21C2:  MOVFF  A1,FE9
21C6:  MOVFF  A2,FEA
21CA:  MOVFF  FEF,AC
21CE:  MOVFF  AC,AD
21D2:  RCALL  1E1A
....................  onewire_write(dir[1]); 
21D4:  MOVLW  01
21D6:  ADDWF  xA1,W
21D8:  MOVWF  FE9
21DA:  MOVLW  00
21DC:  ADDWFC xA2,W
21DE:  MOVWF  FEA
21E0:  MOVFF  FEF,AC
21E4:  MOVFF  AC,AD
21E8:  RCALL  1E1A
....................  onewire_write(dir[2]); 
21EA:  MOVLW  02
21EC:  ADDWF  xA1,W
21EE:  MOVWF  FE9
21F0:  MOVLW  00
21F2:  ADDWFC xA2,W
21F4:  MOVWF  FEA
21F6:  MOVFF  FEF,AC
21FA:  MOVFF  AC,AD
21FE:  RCALL  1E1A
....................  onewire_write(dir[3]); 
2200:  MOVLW  03
2202:  ADDWF  xA1,W
2204:  MOVWF  FE9
2206:  MOVLW  00
2208:  ADDWFC xA2,W
220A:  MOVWF  FEA
220C:  MOVFF  FEF,AC
2210:  MOVFF  AC,AD
2214:  RCALL  1E1A
....................  onewire_write(dir[4]); 
2216:  MOVLW  04
2218:  ADDWF  xA1,W
221A:  MOVWF  FE9
221C:  MOVLW  00
221E:  ADDWFC xA2,W
2220:  MOVWF  FEA
2222:  MOVFF  FEF,AC
2226:  MOVFF  AC,AD
222A:  RCALL  1E1A
....................  onewire_write(dir[5]); 
222C:  MOVLW  05
222E:  ADDWF  xA1,W
2230:  MOVWF  FE9
2232:  MOVLW  00
2234:  ADDWFC xA2,W
2236:  MOVWF  FEA
2238:  MOVFF  FEF,AC
223C:  MOVFF  AC,AD
2240:  RCALL  1E1A
....................  onewire_write(dir[6]); 
2242:  MOVLW  06
2244:  ADDWF  xA1,W
2246:  MOVWF  FE9
2248:  MOVLW  00
224A:  ADDWFC xA2,W
224C:  MOVWF  FEA
224E:  MOVFF  FEF,AC
2252:  MOVFF  AC,AD
2256:  RCALL  1E1A
....................  onewire_write(dir[7]); 
2258:  MOVLW  07
225A:  ADDWF  xA1,W
225C:  MOVWF  FE9
225E:  MOVLW  00
2260:  ADDWFC xA2,W
2262:  MOVWF  FEA
2264:  MOVFF  FEF,AC
2268:  MOVFF  AC,AD
226C:  RCALL  1E1A
....................  onewire_write(0x44); //Orden de inicio de conversión de temperatura 
226E:  MOVLW  44
2270:  MOVWF  xAD
2272:  RCALL  1E1A
....................  
....................  while (busy == 0) 	//el sensor mantiene la linea a 0 mientras realiza la conversión 
....................   busy = onewire_read(); //y la deja a 1 al completarla 
2274:  MOVF   xA3,F
2276:  BNZ   2280
2278:  RCALL  1FC4
227A:  MOVFF  01,A3
227E:  BRA    2274
....................  
....................  onewire_reset(); 
2280:  RCALL  1DEC
....................  onewire_write(0x55); //Instrucción MATCH ROM 
2282:  MOVLW  55
2284:  MOVWF  xAD
2286:  RCALL  1E1A
....................  onewire_write(dir[0]); 
2288:  MOVFF  A1,FE9
228C:  MOVFF  A2,FEA
2290:  MOVFF  FEF,AC
2294:  MOVFF  AC,AD
2298:  RCALL  1E1A
....................  onewire_write(dir[1]); 
229A:  MOVLW  01
229C:  ADDWF  xA1,W
229E:  MOVWF  FE9
22A0:  MOVLW  00
22A2:  ADDWFC xA2,W
22A4:  MOVWF  FEA
22A6:  MOVFF  FEF,AC
22AA:  MOVFF  AC,AD
22AE:  RCALL  1E1A
....................  onewire_write(dir[2]); 
22B0:  MOVLW  02
22B2:  ADDWF  xA1,W
22B4:  MOVWF  FE9
22B6:  MOVLW  00
22B8:  ADDWFC xA2,W
22BA:  MOVWF  FEA
22BC:  MOVFF  FEF,AC
22C0:  MOVFF  AC,AD
22C4:  RCALL  1E1A
....................  onewire_write(dir[3]); 
22C6:  MOVLW  03
22C8:  ADDWF  xA1,W
22CA:  MOVWF  FE9
22CC:  MOVLW  00
22CE:  ADDWFC xA2,W
22D0:  MOVWF  FEA
22D2:  MOVFF  FEF,AC
22D6:  MOVFF  AC,AD
22DA:  RCALL  1E1A
....................  onewire_write(dir[4]); 
22DC:  MOVLW  04
22DE:  ADDWF  xA1,W
22E0:  MOVWF  FE9
22E2:  MOVLW  00
22E4:  ADDWFC xA2,W
22E6:  MOVWF  FEA
22E8:  MOVFF  FEF,AC
22EC:  MOVFF  AC,AD
22F0:  RCALL  1E1A
....................  onewire_write(dir[5]); 
22F2:  MOVLW  05
22F4:  ADDWF  xA1,W
22F6:  MOVWF  FE9
22F8:  MOVLW  00
22FA:  ADDWFC xA2,W
22FC:  MOVWF  FEA
22FE:  MOVFF  FEF,AC
2302:  MOVFF  AC,AD
2306:  RCALL  1E1A
....................  onewire_write(dir[6]); 
2308:  MOVLW  06
230A:  ADDWF  xA1,W
230C:  MOVWF  FE9
230E:  MOVLW  00
2310:  ADDWFC xA2,W
2312:  MOVWF  FEA
2314:  MOVFF  FEF,AC
2318:  MOVFF  AC,AD
231C:  RCALL  1E1A
....................  onewire_write(dir[7]); 
231E:  MOVLW  07
2320:  ADDWF  xA1,W
2322:  MOVWF  FE9
2324:  MOVLW  00
2326:  ADDWFC xA2,W
2328:  MOVWF  FEA
232A:  MOVFF  FEF,AC
232E:  MOVFF  AC,AD
2332:  RCALL  1E1A
....................  onewire_write(0xBE); //Envío de la orden READ SCRATCHPAD (lectura de la memoria temporal) 
2334:  MOVLW  BE
2336:  MOVWF  xAD
2338:  RCALL  1E1A
....................  temp1 = onewire_read(); //lectura del LSB de la temperatura 
233A:  RCALL  1FC4
233C:  MOVFF  01,A4
....................  temp2 = onewire_read(); //lectura del MSB de la temperatura 
2340:  RCALL  1FC4
2342:  MOVFF  01,A5
....................  
....................  temp3 = make16(temp2, temp1); // 
2346:  MOVFF  A5,A7
234A:  MOVFF  A4,A6
....................  result = (float) temp3 / 2.0;   //Cálculo para el DS18S20 con 0.5 grad C de resolución 
234E:  MOVFF  A7,AD
2352:  MOVFF  A6,AC
2356:  BRA    200C
2358:  MOVFF  00,AC
235C:  MOVFF  01,AD
2360:  MOVFF  02,AE
2364:  MOVFF  03,AF
2368:  MOVFF  03,2B2
236C:  MOVFF  02,2B1
2370:  MOVFF  01,2B0
2374:  MOVFF  00,2AF
2378:  MOVLB  2
237A:  CLRF   xB6
237C:  CLRF   xB5
237E:  CLRF   xB4
2380:  MOVLW  80
2382:  MOVWF  xB3
2384:  MOVLB  0
2386:  RCALL  2058
2388:  MOVFF  03,AB
238C:  MOVFF  02,AA
2390:  MOVFF  01,A9
2394:  MOVFF  00,A8
.................... // result = (float) temp3 / 16.0;  //Cálculo para el DS18B20 con 0.1 grad C de resolución 
....................  
....................  delay_ms(200); 
2398:  MOVLW  C8
239A:  MOVWF  xAE
239C:  CALL   12A8
....................  return(result); 
23A0:  MOVFF  A8,00
23A4:  MOVFF  A9,01
23A8:  MOVFF  AA,02
23AC:  MOVFF  AB,03
.................... } 
23B0:  RETLW  00
....................  
.................... //Recoge las direcciones de dos dispositivos y las devuelve en los vectores de int pasados como 
.................... //argumento (cada instrucción ocupa 64 bits). Funciona también si hay más dispositivos conectados, 
.................... //pero sólo devuelve las direcciones de dos de ellos. 
.................... void ds1820_recoger_direcciones(int* dir1, int* dir2) 
.................... { 
....................    int contador, contador2; 
....................    int bit1, bit2; 
....................  
....................    onewire_reset(); 
*
1EC2:  RCALL  1DEC
....................    onewire_write(0xF0); //Función ROM SEARCH 
1EC4:  MOVLW  F0
1EC6:  MOVWF  xAD
1EC8:  RCALL  1E1A
....................  
....................    //Recorremos el array de 8 ints que contiene la dirección 
....................    for(contador=0; contador<8; contador++) 
1ECA:  CLRF   x99
1ECC:  MOVF   x99,W
1ECE:  SUBLW  07
1ED0:  BNC   1F42
....................    { 
....................       for(contador2=0; contador2<8; contador2++) 
1ED2:  CLRF   x9A
1ED4:  MOVF   x9A,W
1ED6:  SUBLW  07
1ED8:  BNC   1F3E
....................       { 
....................         //Leemos el bit correspondiente de dirección de los dispositivos 
....................         bit1 = ow_read_bit(); 
1EDA:  RCALL  1E58
1EDC:  MOVFF  01,9B
....................  
....................         //Leemos el segundo bit, que será el complemento del anterior si no hay conflictos 
....................         bit2 = ow_read_bit(); 
1EE0:  RCALL  1E58
1EE2:  MOVFF  01,9C
....................  
....................         //Si los bits son complementarios, tenemos que todos los dispositivos tienen el mismo bit de 
....................         //dirección en esa posición. 
....................         if(bit1!=bit2) 
1EE6:  MOVF   x9C,W
1EE8:  SUBWF  x9B,W
1EEA:  BZ    1F16
....................         { 
....................            shift_right(&(dir1[contador]),1,bit1); //Guardamos el resultado 
1EEC:  CLRF   03
1EEE:  MOVF   x99,W
1EF0:  ADDWF  x95,W
1EF2:  MOVWF  x9D
1EF4:  MOVF   x96,W
1EF6:  ADDWFC 03,W
1EF8:  MOVWF  x9E
1EFA:  MOVF   x9B,F
1EFC:  BNZ   1F02
1EFE:  BCF    FD8.0
1F00:  BRA    1F04
1F02:  BSF    FD8.0
1F04:  MOVFF  9E,FEA
1F08:  MOVFF  9D,FE9
1F0C:  RRCF   FED,F
....................  
....................            //Escribimos el bit de dirección para confirmar a los dispositivos la identificación 
....................            ow_write_bit(bit1); 
1F0E:  MOVFF  9B,9D
1F12:  RCALL  1E92
....................         }else 
1F14:  BRA    1F3A
....................         { 
....................            //Si no son complementarios, habrá conflicto, y habrá al menos un dispositivo con 0 en esa 
....................            //posición y al menos uno con 1. Elegimos el que tiene el 1 enviando un 1 por la línea e 
....................            //inhabilitándose los que tienen 0, que ya no contestarán a la función. 
....................            shift_right(&(dir1[contador]),1,1); 
1F16:  CLRF   03
1F18:  MOVF   x99,W
1F1A:  ADDWF  x95,W
1F1C:  MOVWF  x9D
1F1E:  MOVF   x96,W
1F20:  ADDWFC 03,W
1F22:  MOVWF  x9E
1F24:  MOVFF  9E,FEA
1F28:  MOVFF  9D,FE9
1F2C:  MOVLW  00
1F2E:  ADDWF  FE9,F
1F30:  BSF    FD8.0
1F32:  RRCF   FED,F
....................  
....................            ow_write_bit(1); 
1F34:  MOVLW  01
1F36:  MOVWF  x9D
1F38:  RCALL  1E92
....................         } 
....................       } 
1F3A:  INCF   x9A,F
1F3C:  BRA    1ED4
....................    } 
1F3E:  INCF   x99,F
1F40:  BRA    1ECC
....................  
....................    //Repetimos exactamente el mismo proceso pero eligiendo en los conflictos el dispositivo con 0. 
....................    onewire_reset(); 
1F42:  RCALL  1DEC
....................    onewire_write(0xF0); 
1F44:  MOVLW  F0
1F46:  MOVWF  xAD
1F48:  RCALL  1E1A
....................  
....................    for(contador=0; contador<8; contador++) 
1F4A:  CLRF   x99
1F4C:  MOVF   x99,W
1F4E:  SUBLW  07
1F50:  BNC   1FC0
....................    { 
....................       for(contador2=0; contador2<8; contador2++) 
1F52:  CLRF   x9A
1F54:  MOVF   x9A,W
1F56:  SUBLW  07
1F58:  BNC   1FBC
....................       { 
....................         bit1 = ow_read_bit(); 
1F5A:  RCALL  1E58
1F5C:  MOVFF  01,9B
....................  
....................         bit2 = ow_read_bit(); 
1F60:  RCALL  1E58
1F62:  MOVFF  01,9C
....................  
....................         if(bit1!=bit2) 
1F66:  MOVF   x9C,W
1F68:  SUBWF  x9B,W
1F6A:  BZ    1F96
....................         { 
....................            shift_right(&(dir2[contador]),1,bit1); 
1F6C:  CLRF   03
1F6E:  MOVF   x99,W
1F70:  ADDWF  x97,W
1F72:  MOVWF  x9D
1F74:  MOVF   x98,W
1F76:  ADDWFC 03,W
1F78:  MOVWF  x9E
1F7A:  MOVF   x9B,F
1F7C:  BNZ   1F82
1F7E:  BCF    FD8.0
1F80:  BRA    1F84
1F82:  BSF    FD8.0
1F84:  MOVFF  9E,FEA
1F88:  MOVFF  9D,FE9
1F8C:  RRCF   FED,F
....................  
....................            ow_write_bit(bit1); 
1F8E:  MOVFF  9B,9D
1F92:  RCALL  1E92
....................         }else 
1F94:  BRA    1FB8
....................         { 
....................            shift_right(&(dir2[contador]),1,0); 
1F96:  CLRF   03
1F98:  MOVF   x99,W
1F9A:  ADDWF  x97,W
1F9C:  MOVWF  x9D
1F9E:  MOVF   x98,W
1FA0:  ADDWFC 03,W
1FA2:  MOVWF  x9E
1FA4:  MOVFF  9E,FEA
1FA8:  MOVFF  9D,FE9
1FAC:  MOVLW  00
1FAE:  ADDWF  FE9,F
1FB0:  BCF    FD8.0
1FB2:  RRCF   FED,F
....................  
....................            ow_write_bit(0); 
1FB4:  CLRF   x9D
1FB6:  RCALL  1E92
....................         } 
....................       } 
1FB8:  INCF   x9A,F
1FBA:  BRA    1F54
....................    } 
1FBC:  INCF   x99,F
1FBE:  BRA    1F4C
....................  
.................... } 
1FC0:  GOTO   5D68 (RETURN)
....................  
.................... #include "teclado.c" 
.................... //*********************************************************************************** 
.................... // Método que permite gestionar un teclado matricial de 4x3 conectado a los pines 
.................... // B4B5B6B7 (filas) y a los D0D1D2 (columnas). El puerto D deberá estar definido como 
.................... // port_d y los bits utilizados de B deberán ser "tecladox", dónde x va de 1 a 4 
.................... //*********************************************************************************** 
.................... //Author: Julio Navarro Lara 
....................  
.................... //Definimos los caracteres que corresponden a cada botón del teclado 
.................... const char caracteres[12]={'1','2','3','4','5','6','7','8','9','S','0','N'}; 
....................  
.................... //Método para detectar la pulsación de una tecla. Devuelve el caracter pulsado. 
.................... char find_key() 
.................... { 
....................    //Variables auxiliares 
....................    int8 fila, columna, temp, contador, puertoB; 
....................    char key = 0; //Tecla pulsada 
*
3118:  CLRF   x9D
....................  
....................    //Recorremos las filas forzando un valor con el puerto B para detectar 
....................    //la tecla pulsada 
....................    for(fila=0; fila < NUM_FILAS; fila++){ 
311A:  CLRF   x98
311C:  MOVF   x98,W
311E:  SUBLW  03
3120:  BTFSS  FD8.0
3122:  BRA    3200
....................  
....................       //Forzamos la salida de B a que tenga todo 1 menos la posición a inspeccionar 
....................       puertoB = ~(1 << fila); 
3124:  MOVLW  01
3126:  MOVWF  00
3128:  MOVF   x98,W
312A:  MOVWF  01
312C:  BZ    3136
312E:  BCF    FD8.0
3130:  RLCF   00,F
3132:  DECFSZ 01,F
3134:  BRA    312E
3136:  MOVF   00,W
3138:  XORLW  FF
313A:  MOVWF  x9C
....................       teclado1 = puertoB & 0b1; 
313C:  MOVF   x9C,W
313E:  ANDLW  01
3140:  MOVWF  01
3142:  BTFSC  FE8.0
3144:  BRA    314A
3146:  BCF    F81.4
3148:  BRA    314C
314A:  BSF    F81.4
....................       teclado2 = (puertoB & 0b10) >> 1; 
314C:  MOVF   x9C,W
314E:  ANDLW  02
3150:  MOVWF  00
3152:  BCF    FD8.0
3154:  RRCF   00,F
3156:  MOVFF  00,01
315A:  BTFSC  00.0
315C:  BRA    3162
315E:  BCF    F81.5
3160:  BRA    3164
3162:  BSF    F81.5
....................       teclado3 = (puertoB & 0b100) >> 2; 
3164:  MOVF   x9C,W
3166:  ANDLW  04
3168:  MOVWF  00
316A:  RRCF   00,F
316C:  RRCF   00,F
316E:  MOVLW  3F
3170:  ANDWF  00,F
3172:  MOVFF  00,01
3176:  BTFSC  00.0
3178:  BRA    317E
317A:  BCF    F81.6
317C:  BRA    3180
317E:  BSF    F81.6
....................       teclado4 = (puertoB & 0b1000) >> 3; 
3180:  MOVF   x9C,W
3182:  ANDLW  08
3184:  MOVWF  00
3186:  RRCF   00,F
3188:  RRCF   00,F
318A:  RRCF   00,F
318C:  MOVLW  1F
318E:  ANDWF  00,F
3190:  MOVFF  00,01
3194:  BTFSC  00.0
3196:  BRA    319C
3198:  BCF    F81.7
319A:  BRA    319E
319C:  BSF    F81.7
....................  
....................       //Introducimos un poco de retraso 
....................       for(contador=0; contador<100; contador++); 
319E:  CLRF   x9B
31A0:  MOVF   x9B,W
31A2:  SUBLW  63
31A4:  BNC   31AA
31A6:  INCF   x9B,F
31A8:  BRA    31A0
....................  
....................       //Guardamos el valor que aparece en el puerto D 
....................       //(en sus 3 bits menos significativos) 
....................       temp = port_d & 0b00000111; 
31AA:  MOVF   F83,W
31AC:  ANDLW  07
31AE:  MOVWF  x9A
....................  
....................       //Iteramos en base a esto para ver si alguna columna está activa 
....................       //Una vez localizada la columna, podemos encontrar el caracter teniendo en cuenta 
....................       //también la fila que está activa. 
....................       for(columna=0; columna < NUM_COLUMNAS; columna++){ 
31B0:  CLRF   x99
31B2:  MOVF   x99,W
31B4:  SUBLW  02
31B6:  BNC   31FC
....................  
....................          //Realizamos la operación AND entre el valor que hay y un 1 desplazado 
....................          //según la columna que nos encontremos 
....................          if((temp & (1 << columna))==0) 
31B8:  MOVLW  01
31BA:  MOVWF  00
31BC:  MOVF   x99,W
31BE:  MOVWF  01
31C0:  BZ    31CA
31C2:  BCF    FD8.0
31C4:  RLCF   00,F
31C6:  DECFSZ 01,F
31C8:  BRA    31C2
31CA:  MOVF   00,W
31CC:  ANDWF  x9A,W
31CE:  BNZ   31F8
....................          { 
....................             //Si da 0, hemos localizado la columna dónde se encuentra la tecla 
....................             //Guardamos su índice teniendo en cuenta que las teclas se numeran de izquierda a derecha y 
....................             //de arriba a abajo. 
....................             int8 index; 
....................             index = (fila*NUM_COLUMNAS)+(2-columna); 
31D0:  MOVF   x98,W
31D2:  MULLW  03
31D4:  MOVFF  FF3,9F
31D8:  MOVLW  02
31DA:  BSF    FD8.0
31DC:  SUBFWB x99,W
31DE:  ADDWF  x9F,W
31E0:  MOVWF  x9E
....................  
....................             //Buscamos la tecla a la que se hace referencia 
....................             key = caracteres[index]; 
31E2:  CLRF   03
31E4:  MOVF   x9E,W
31E6:  MOVFF  FF2,9F
31EA:  BCF    FF2.7
31EC:  CALL   00D2
31F0:  BTFSC  x9F.7
31F2:  BSF    FF2.7
31F4:  MOVWF  x9D
....................  
....................             //Saltamos para salirnos del bucle 
....................             goto hecho; 
31F6:  BRA    3200
....................  
....................          } 
....................  
....................       } 
31F8:  INCF   x99,F
31FA:  BRA    31B2
....................    } 
31FC:  INCF   x98,F
31FE:  BRA    311C
....................  
....................    hecho: 
....................  
....................    //Devolvemos el caracter 
....................    return key; 
3200:  MOVFF  9D,01
....................  
.................... } 
3204:  RETLW  00
....................  
.................... //Devuelve la tecla pulsada, esperando a que el usuario la suelte 
.................... char get_key() 
.................... { 
....................    char key; 
....................    //Detectamos la tecla pulsada 
....................    key=find_key(); 
3206:  RCALL  3118
3208:  MOVFF  01,97
....................    //Si se pulsa alguna tecla, nos esperamos hasta que se suelte para recoger el valor 
....................    if(key) 
320C:  MOVF   x97,F
320E:  BZ    3216
....................       while(find_key() != 0); 
3210:  RCALL  3118
3212:  MOVF   01,F
3214:  BNZ   3210
....................    return key; 
3216:  MOVFF  97,01
.................... } 
321A:  RETLW  00
....................  
....................  
....................  
.................... #include "eeprom.c" 
.................... //****************************************************** 
.................... //Programa para escritura y lectura de la memoria EEPROM 
.................... //****************************************************** 
.................... //Author: Julio Navarro Lara 
....................  
....................  
.................... //Definimos las palabras de control, que constan de tres partes 
.................... //   - Los bits más altos de direccionamiento del dispositivo (fijos): 1010 
.................... //   - Los bits de dirección configurables A2A1A0: 111 (en este caso) 
.................... //   - El bit R/W', 1 para lectura y 0 para escritura 
.................... //NOTA: No es necesario definir las características de la comunicación I2C porque se supone 
.................... //que ya han sido especificadas en el código principal. 
.................... #define CONTROL_W 0b10101110 
.................... #define CONTROL_R 0b10101111 
....................  
.................... void graba_ee(long int dir, int tam, int *wdata) 
.................... { 
....................    boolean ack; 
....................    int i; 
....................    //Escribimos la palabra de control 
....................    do{ 
....................       i2c_start(); 
*
184A:  BSF    FC5.0
184C:  BTFSC  FC5.0
184E:  BRA    184C
....................       ack=i2c_write(CONTROL_W); 
1850:  MOVLW  AE
1852:  MOVLB  2
1854:  MOVWF  xBA
1856:  MOVLB  0
1858:  RCALL  1680
185A:  MOVF   01,W
185C:  BTFSC  01.0
185E:  BRA    1864
1860:  BCF    xAC.0
1862:  BRA    1866
1864:  BSF    xAC.0
....................    }while(ack); //Esperamos a que el dispositivo responda 
1866:  BTFSC  xAC.0
1868:  BRA    184A
....................    //Cuando está listo, devuelve un ACK como 0 
....................    //Mandamos la dirección en la que se quiere escribir 
....................    i2c_write(dir>>8); 
186A:  MOVFF  A8,AE
186E:  CLRF   xAF
1870:  MOVFF  A8,2BA
1874:  RCALL  1680
....................    i2c_write(dir & 255); 
1876:  MOVFF  A7,AE
187A:  CLRF   xAF
187C:  MOVFF  A7,2BA
1880:  RCALL  1680
....................  
....................    //Escribimos los datos contenidos en wdata 
....................    for(i=0;i<tam;i++){ 
1882:  CLRF   xAD
1884:  MOVF   xA9,W
1886:  SUBWF  xAD,W
1888:  BC    18AA
....................       i2c_write(*wdata); 
188A:  MOVFF  AB,03
188E:  MOVFF  AA,FE9
1892:  MOVFF  AB,FEA
1896:  MOVFF  FEF,AE
189A:  MOVFF  AE,2BA
189E:  RCALL  1680
....................       wdata++; 
18A0:  INCF   xAA,F
18A2:  BTFSC  FD8.2
18A4:  INCF   xAB,F
....................    } 
18A6:  INCF   xAD,F
18A8:  BRA    1884
....................  
....................    //Finalizamos la comunicación 
....................    i2c_stop(); 
18AA:  BSF    FC5.2
18AC:  BTFSC  FC5.2
18AE:  BRA    18AC
.................... } 
18B0:  RETLW  00
....................  
.................... void lee_ee(long int dir, int tam, int8 *rdata) 
.................... { 
....................    boolean ack; 
....................    int i; 
....................    //Comenzamos escribiendo la dirección que queremos consultar 
....................    //al igual que ya hicimos con el método de escritura 
....................    do{ 
....................       i2c_start(); 
*
3840:  BSF    FC5.0
3842:  BTFSC  FC5.0
3844:  BRA    3842
....................       ack=i2c_write(CONTROL_W); 
3846:  MOVLW  AE
3848:  MOVLB  2
384A:  MOVWF  xBA
384C:  MOVLB  0
384E:  CALL   1680
3852:  MOVF   01,W
3854:  BTFSC  01.0
3856:  BRA    385E
3858:  MOVLB  2
385A:  BCF    xB6.0
385C:  BRA    3862
385E:  MOVLB  2
3860:  BSF    xB6.0
....................    }while(ack); //Esperamos a que el dispositivo responda 
3862:  BTFSS  xB6.0
3864:  BRA    386A
3866:  MOVLB  0
3868:  BRA    3840
....................    i2c_write(dir>>8); 
386A:  MOVFF  2B2,2B8
386E:  CLRF   xB9
3870:  MOVFF  2B2,2BA
3874:  MOVLB  0
3876:  CALL   1680
....................    i2c_write(dir & 255); 
387A:  MOVLB  2
387C:  MOVFF  2B1,2B8
3880:  CLRF   xB9
3882:  MOVFF  2B1,2BA
3886:  MOVLB  0
3888:  CALL   1680
....................  
....................    //Reiniciamos la comunicación para leer los datos 
....................    i2c_start(); 
388C:  BSF    FC5.1
388E:  BTFSC  FC5.1
3890:  BRA    388E
....................    //Escribimos palabra de control de escritura 
....................    i2c_write(CONTROL_R); 
3892:  MOVLW  AF
3894:  MOVLB  2
3896:  MOVWF  xBA
3898:  MOVLB  0
389A:  CALL   1680
....................  
....................    //Leemos hasta que completemos el bus 
....................    for(i=0; i<tam-1; i++){ 
389E:  MOVLB  2
38A0:  CLRF   xB7
38A2:  MOVLW  01
38A4:  SUBWF  xB3,W
38A6:  SUBWF  xB7,W
38A8:  BC    38D0
....................       //Se responde en cada caso con ACK 
....................       //(la función i2c_read tiene su argumento al revés: 1 corresponde a 
....................       //ACK y 0 a NACK, cuando en la línea un valor bajo es ACK y uno alto, NACK) 
....................       *rdata=i2c_read(1); 
38AA:  MOVFF  2B5,03
38AE:  MOVFF  2B4,FE9
38B2:  MOVFF  2B5,FEA
38B6:  MOVLW  01
38B8:  MOVWF  00
38BA:  MOVLB  0
38BC:  CALL   26DA
38C0:  MOVFF  01,FEF
....................       rdata++; 
38C4:  MOVLB  2
38C6:  INCF   xB4,F
38C8:  BTFSC  FD8.2
38CA:  INCF   xB5,F
....................    } 
38CC:  INCF   xB7,F
38CE:  BRA    38A2
....................    //Debemos terminar la lectura con un NACK 
....................    *rdata=i2c_read(0); 
38D0:  MOVFF  2B5,03
38D4:  MOVFF  2B4,FE9
38D8:  MOVFF  2B5,FEA
38DC:  CLRF   00
38DE:  MOVLB  0
38E0:  CALL   26DA
38E4:  MOVFF  01,FEF
....................    i2c_stop(); 
38E8:  BSF    FC5.2
38EA:  BTFSC  FC5.2
38EC:  BRA    38EA
.................... } 
38EE:  RETLW  00
....................  
....................  
....................  
.................... #use fast_io(A) 
.................... #use fast_io(B) 
.................... #use fast_io(C) 
.................... #use fast_io(D) 
....................  
.................... int1 temperatura_caldera_superada; //Control de la histéresis en la caldera 
.................... int1 temp_habitacion_superada1;  //Control de la histéresis del ambiente 
.................... int1 temp_habitacion_superada2; 
.................... int1 encendido_por_alarma; //Indica si la última vez que se encendió fue en respuesta o no a una alarma 
.................... int1 toca_encender; //Indica si la próxima alarma es de encendido o de apagado 
.................... float termostato1; //Temperatura límite de la zona 1 de la vivienda 
.................... float termostato2; //Temperatura límite de la zona 2 de la vivienda 
.................... float termostato_provisional; //Valor de termostato provisional para cuando saltan las alarmas 
.................... float temperatura1; //Temperatura de la zona 1 de la vivienda 
.................... float temperatura2; //Temperatura de la zona 2 de la vivienda 
.................... float histeresis_vivienda = 0.5; //Intervalo de histéresis de la vivienda 
.................... char key; //Tecla a pulsar 
.................... char keys[2]; //Cadena para almacenar números como caracteres 
....................  
.................... //Estructura de un intervalo de programación 
.................... typedef struct 
.................... { 
....................    unsigned int horas_inicio;    //Hora a la que se inicia el encendido 
....................    unsigned int minutos_inicio;  // 
....................    unsigned int horas_fin;       //Hora a la que se apaga el sistema 
....................    unsigned int minutos_fin;     // 
....................    unsigned int termostato;      //Termostato vigente en ese intervalo 
.................... }programacion; 
....................  
.................... //Vector que incluye todas las programaciones horarias 
.................... //La información se distribuye en grupos de 5: hora_inicio, minutos_inicio, 
.................... //hora_fin, minutos_fin y termostato. 
.................... programacion programaciones[5]; 
....................  
.................... //Programación en curso en este momento 
.................... programacion prg; 
.................... int num_intervalos; //Número de intervalos de programación con los que contamos 
.................... int posicion_alarmas; //Variable que apunta a la posición de la próxima alarma 
....................  
.................... //Estructura para leer el tiempo del reloj 
.................... date_time_t tiempo; 
....................  
.................... //Registro de la hora en la que se enciende el sistema 
.................... int hora_encendido; 
.................... int minutos_encendido; 
....................  
.................... //Registro de la hora en la que se enciende la caldera 
.................... //Se supone que el encendido de la caldera se realiza en intervalos cortos, 
.................... //que se alcanza la temperatura deseada relativamente rápido. 
.................... int hora_caldera; 
.................... int minutos_caldera; 
.................... int segundos_caldera; 
.................... //Tiempo total de encendido de la caldera en cada intervalo de encendido del sistema 
.................... long t_total_caldera; 
....................  
.................... //Variables para el registro en memoria 
.................... unsigned long num_registros;  //Número de registros de fechas almacenados 
.................... int anno_actual;             //Año en el que estamos (de 0 a 99) 
.................... int anno_actual_0_to_3;      //Año en el que estamos (de 0 a 3) 
....................  
.................... //Flag para activar las interrupciones de interfaz con el teclado y alarma 
.................... int1 led_int; 
.................... int1 alarma_int; 
.................... //Flag para controlar el desbordamiento del TIMER1 
.................... int1 timer_int; 
....................  
.................... //Arrays para almacenar las direcciones de las ROM de ambos sensores de temperatura 
.................... int dir1[8], dir2[8]; 
....................  
.................... //Contador para medir el tiempo transcurrido con el menú activo 
.................... unsigned int contador_tiempo; 
....................  
....................  
.................... //Listado de métodos utilizados ordenados por orden alfabético 
.................... //************************************************************ 
.................... //Mostramos aquí una breve explicación de cada uno. El interior de los métodos está 
.................... //descrito después del método main. 
....................  
.................... //apagar_caldera() -> Apaga la caldera, almacenando el tiempo que ha estado encendida. 
.................... void apagar_caldera(); 
.................... //apagar_sistema() -> Realiza todas las operaciones necesarias para el apagado 
.................... //del sistema, como el almacenamiento de los datos necesarios en memoria. 
.................... void apagar_sistema(); 
.................... //buscar_numero() -> Escanea el teclado hasta encontrar un número de dos cifras o hasta que se decida salir 
.................... //mediante la pulsación de los botones de SI o NO. 
.................... int buscar_numero(); 
.................... //buscar_numero_rs232() -> Registra la introducción de un número de dos cifras mediante la interfaz RS232 y 
.................... //lo devuelve. Además, si se pulsa el "backspace" durante el proceso, devuelve el código correspondiente a NO 
.................... int buscar_numero_rs232(); 
.................... //comp_caldera() -> Devuelve TRUE si debemos apagar la caldera. Esta función tiene en cuenta 
.................... //cierta histéresis para evitar ciclos continuos de apagado-encendido. Hay que considerar 
.................... //que sólo puede emplearse una vez que la temperatura del agua ha superado ya el valor necesario. 
.................... int comp_caldera(); 
.................... //comprobar_hora(int hora1, int min1, int hora2, int min2) -> Devuelve TRUE 
.................... //si hora1:min1 corresponde a un tiempo menor o igual que hora2:min2. 
.................... int comprobar_hora(int hora1,int min1, int hora2, int min2); 
.................... //comprobar_temperatura() -> Devuelve un código según la temperatura de los dos sensores: 
.................... //0: Ninguno de los dos supera la temperatura del termostato 
.................... //1: El sensor 1 supera la temperatura del termostato 
.................... //2: El sensor 2 supera la temperatura del termostato 
.................... //3: Ambos sensores superan la temperatura del termostato 
.................... int comprobar_temperatura(); 
.................... //diferencia_tiempo(int hora1, int min1, int hora2, int min2) -> Calcula la 
.................... //diferencia de tiempo en minutos entre hora1:min1 y hora2:min2. 
.................... //Si hora1:min1 es mayor que hora2:min2, los considera en días consecutivos. 
.................... long diferencia_tiempo(int hora1,int min1, int hora2, int min2); 
.................... //diferencia_tiempo_sec(int hora1, int min1, int sec1, int hora2, int min2, int sec2) -> 
.................... //Calcula la diferencia de tiempo en segundos entre hora1:min1:sec1 y hora2:min2:sec2 
.................... //Si hora1:min1:sec1 es mayor que hora2:min2:sec2, los considera en días consecutivos 
.................... long diferencia_tiempo_sec(int hora1,int min1, int sec1, int hora2, int min2, int sec2); 
.................... //encender_caldera() -> Enciende la caldera, almacenando el tiempo de encendido en 
.................... //las variables correspondientes. 
.................... void encender_caldera(); 
.................... //encender_sistema() -> Realiza todas las operaciones necesarias para el encendido 
.................... //del sistema, como registro del tiempo de inicio. 
.................... void encender_sistema(); 
.................... //grabar_programaciones() -> Graba los datos de las programaciones en la memoria EEPROM. 
.................... void grabar_programaciones(); 
.................... //inicializacion() -> Lleva a cabo la inicialización del sistema (introducción de hora y fecha, 
.................... //puesta a punto de variables, etc) 
.................... void inicializacion(); 
.................... //leer_programaciones() -> Recupera de la memoria los datos de las programaciones. 
.................... void leer_programaciones(); 
.................... //mostrar_temperatura() -> Muestra en la pantalla LCD la temperatura actual y la hora. 
.................... void mostrar_temperatura(); 
.................... //ordenar_programaciones -> Ordena las programaciones por orden creciente de hora. 
.................... void ordenar_programaciones(); 
.................... //programar_proxima_alarma() -> Programa la próxima alarma que tendrá lugar. 
.................... //Siempre se tratará de una alarma para el encendido. 
.................... void programar_proxima_alarma(); 
.................... //representar_registros() -> Representa la información de los registros en el puerto RS232 
.................... //Nunca guardamos la información de los registros para no saturar la memoria y 
.................... //aprovechamos la representación de los datos para calcular medias y demás y así 
.................... //no tener que realizar un segundo barrido de lectura en memoria. 
.................... void representar_registros(); 
.................... //seleccionar_alarma() -> Selecciona la alarma más cercana a la hora en la que nos encontramos, 
.................... //en el caso de que las hubiese. 
.................... void seleccionar_alarma(); 
....................  
.................... //-------------------------------------------------------------------------------- 
....................  
.................... //Gestión de interrupciones de activación de la alarma 
.................... #INT_EXT 
.................... void alarma(){ 
....................    //Se activa el flag correspondiente 
....................    alarma_int = TRUE; 
*
1288:  BSF    1F.6
.................... } 
....................  
.................... //Gestión de interrupciones de activación de la interfaz de usuario 
128A:  BCF    FF2.1
128C:  GOTO   0070
.................... #INT_EXT1 
.................... void activacion_led(){ 
....................    //Se activa el flag correspondiente 
....................    led_int = TRUE; 
1290:  BSF    1F.5
.................... } 
....................  
.................... //Interrupción de reloj para controlar el tiempo que está activo el menú 
1292:  BCF    FF0.0
1294:  GOTO   0070
.................... #INT_TIMER1 
.................... void contador(){ 
....................    //Aumentamos en uno el valor del contador 
....................    contador_tiempo++; 
1298:  INCF   7D,F
....................    //Si llega a 76 (unos 20 segundos), activamos el flag correspondiente 
....................    if(contador_tiempo >= 76) 
129A:  MOVF   7D,W
129C:  SUBLW  4B
129E:  BC    12A2
....................       timer_int = TRUE; 
12A0:  BSF    1F.7
.................... } 
....................  
....................  
.................... //*********************************************************** 
.................... //Método main 
.................... //*********************************************************** 
12A2:  BCF    F9E.0
12A4:  GOTO   0070
.................... void main() 
.................... { 
*
5CBA:  CLRF   FF8
5CBC:  BCF    FD0.7
5CBE:  BSF    0D.7
5CC0:  CLRF   FEA
5CC2:  CLRF   FE9
5CC4:  BCF    FB8.3
5CC6:  MOVLW  19
5CC8:  MOVWF  FAF
5CCA:  MOVLW  22
5CCC:  MOVWF  FAC
5CCE:  MOVLW  90
5CD0:  MOVWF  FAB
5CD2:  BSF    F94.3
5CD4:  BSF    F94.4
5CD6:  MOVLW  13
5CD8:  MOVWF  FC8
5CDA:  MOVLW  28
5CDC:  MOVWF  FC6
5CDE:  BSF    FC7.7
5CE0:  BCF    FC7.6
5CE2:  MOVF   FC1,W
5CE4:  ANDLW  C0
5CE6:  IORLW  0F
5CE8:  MOVWF  FC1
5CEA:  MOVLW  07
5CEC:  MOVWF  FB4
5CEE:  CLRF   18
5CF0:  CLRF   19
5CF2:  MOVLW  01
5CF4:  MOVWF  1A
5CF6:  CLRF   1B
5CF8:  CLRF   1C
5CFA:  CLRF   1D
5CFC:  CLRF   1E
5CFE:  MOVLW  7E
5D00:  MOVWF  34
5D02:  CLRF   35
5D04:  CLRF   36
5D06:  CLRF   37
....................    //Vector para recoger los datos iniciales leídos de memoria 
....................    int data[6]; 
....................  
....................    //Valor auxiliar 
....................    int valor; 
....................  
....................    //Inicializamos salidas 
....................    //Comenzamos con todo apagado (sistema, motor y caldera) 
....................    sistema_encendido = FALSE; 
5D08:  BCF    F83.4
....................    motor1 = FALSE; 
5D0A:  BCF    F83.6
....................    motor2 = FALSE; 
5D0C:  BCF    F83.7
....................    caldera_encendida = FALSE; 
5D0E:  BCF    F83.5
....................    encendido_por_alarma = FALSE; 
5D10:  BCF    1F.3
....................    t_total_caldera = 0; //El tiempo total de encendido de la caldera también lo ponemos a 0 
5D12:  CLRF   68
5D14:  CLRF   67
....................  
....................    //Establecemos el estado de los puertos como entradas o salidas 
....................    set_tris_b(0x03); 
5D16:  MOVLW  03
5D18:  MOVWF  F93
....................    set_tris_d(0x0F); 
5D1A:  MOVLW  0F
5D1C:  MOVWF  F95
....................  
....................  
....................    //Inicializamos la pantalla lcd 
....................    lcd_init(); 
5D1E:  GOTO   1354
....................  
....................    //Mostramos un mensaje de inicio 
....................    lcd_send_byte(LCD_ORDEN, LCD_CLEAR); 
5D22:  CLRF   xAC
5D24:  MOVLW  01
5D26:  MOVWF  xAD
5D28:  CALL   1314
....................    lcd_send_byte(LCD_ORDEN, LCD_NO_CURSOR); 
5D2C:  CLRF   xAC
5D2E:  MOVLW  0C
5D30:  MOVWF  xAD
5D32:  CALL   1314
....................    printf(lcd_putc, "Inicializando..."); 
5D36:  CLRF   x95
5D38:  MOVF   x95,W
5D3A:  CALL   00F8
5D3E:  IORLW  00
5D40:  BZ    5D4C
5D42:  INCF   x95,F
5D44:  MOVWF  xA7
5D46:  CALL   13C0
5D4A:  BRA    5D38
....................  
....................    /* 
....................    NOTA: En el guión se nos pide que se realice la inicialización del sistema cuando 
....................    éste se instala, introduciendo fecha y hora y reseteando los datos de memoria para 
....................    iniciar el funcionamiento. Esto lo hace en nuestro programa la funcion inicializar. 
....................    Sin embargo, se ha preferido, dado que PROTEUS actualiza su reloj con el del ordenador, 
....................    dar la opción de dejar inhabilitada esta rutina para así disponer de datos históricos guardados en la 
....................    EEPROM y poder analizarlos. Debido a que nuestra simulación no puede estar las 24 horas 
....................    funcionando (entre otras cosas, porque el PCF se para) es la única forma de simular 
....................    que el sistema está siempre encendido. 
....................       De todas formas, ambas rutinas están implementadas con plena operatividad. Si se quiere 
....................    inicializar el sistema como ocurriría en la vida real, simplemente dejar descomentadas las dos 
....................    líneas de código que siguen a este comentario y mantener comentado el trozo de código que está 
....................    enmarcado por las ristras de arrobas (@), un poco más abajo. 
....................    */ 
....................  
....................  
....................    inicializacion(); 
5D4C:  GOTO   18B2
....................    PCF8583_write_byte(PCF8583_CTRL_STATUS_REG, PCF8583_START_COUNTING); 
5D50:  CLRF   xAD
5D52:  CLRF   xAE
5D54:  CALL   169C
....................  
....................  
....................    //Recogemos las direcciones de los sensores de temperatura 
....................    ds1820_recoger_direcciones(dir1, dir2); 
5D58:  CLRF   x96
5D5A:  MOVLW  6D
5D5C:  MOVWF  x95
5D5E:  CLRF   x98
5D60:  MOVLW  75
5D62:  MOVWF  x97
5D64:  GOTO   1EC2
....................  
....................    //Propiedades de conversión analógico digital 
....................    //Establecemos el comparador entre A0 y A3, y entre A1 y A2 
....................    setup_comparator(A0_A3_A1_A2); 
5D68:  MOVLW  02
5D6A:  MOVWF  FB4
5D6C:  MOVF   F92,W
5D6E:  IORLW  0F
5D70:  MOVWF  F92
5D72:  CLRWDT
5D74:  MOVLW  06
5D76:  MOVWF  00
5D78:  DECFSZ 00,F
5D7A:  BRA    5D78
5D7C:  MOVF   FB4,W
5D7E:  BCF    FA1.6
....................    //Caracterizamos los puertos A0 a A3 como entradas analógicas 
....................    setup_adc_ports(AN0_TO_AN3); 
5D80:  MOVF   FC1,W
5D82:  ANDLW  C0
5D84:  IORLW  0B
5D86:  MOVWF  FC1
....................    //Definimos el reloj de conversión 
....................    setup_adc(adc_clock_div_32); 
5D88:  MOVF   FC0,W
5D8A:  ANDLW  C0
5D8C:  IORLW  02
5D8E:  MOVWF  FC0
5D90:  BCF    FC0.7
5D92:  BSF    FC2.0
....................  
.................... /* 
....................    //@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ 
....................  
....................    //Recuperación de datos de la memoria 
....................    //Recuperamos a partir de la dirección eeprom_termostato los datos en 
....................    //el siguiente orden: termostato, número de intervalos de alarma, número de registros 
....................    //de encendido de la caldera, año actual en valores de 0 a 99 y año actual en valores de 0 a 3. 
....................    lee_ee(eeprom_termostato, 6, data); 
....................    termostato1 = termostato2 = (float)data[0]; 
....................    num_intervalos = data[1]; 
....................    //El número de registros está almacenado en un long y debemos realizar la conversión desde dos int 
....................    num_registros = (long)data[2]*256 + (long)data[3]; 
....................    anno_actual = data[4]; 
....................    anno_actual_0_to_3 = data[5]; 
....................  
....................    //Lee las programaciones de alarmas guardadas en memoria 
....................    leer_programaciones(); 
....................  
....................    //Comprobamos si hay alarmas programadas en memoria 
....................    if(num_intervalos!=0) 
....................    { 
....................       //Si las hay, seleccionamos la siguiente y programamos su activación 
....................       seleccionar_alarma(); 
....................       programar_proxima_alarma(); 
....................       toca_encender = TRUE; 
....................    }else 
....................    { 
....................       //Si no, simplemente inciamos la cuenta del reloj 
....................       PCF8583_write_byte(PCF8583_CTRL_STATUS_REG, 
....................                               PCF8583_START_COUNTING); 
....................    } 
....................  
....................    //@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ 
.................... */ 
....................  
....................    //Leemos la temperatura de las dos zonas de la vivienda 
....................    temperatura1 = ds1820_read(dir1); 
5D94:  CLRF   xA2
5D96:  MOVLW  6D
5D98:  MOVWF  xA1
5D9A:  CALL   21B8
5D9E:  MOVFF  03,2F
5DA2:  MOVFF  02,2E
5DA6:  MOVFF  01,2D
5DAA:  MOVFF  00,2C
....................    temperatura2 = ds1820_read(dir2); 
5DAE:  CLRF   xA2
5DB0:  MOVLW  75
5DB2:  MOVWF  xA1
5DB4:  CALL   21B8
5DB8:  MOVFF  03,33
5DBC:  MOVFF  02,32
5DC0:  MOVFF  01,31
5DC4:  MOVFF  00,30
....................  
....................    if(temperatura1 >= termostato1) 
5DC8:  MOVFF  23,A0
5DCC:  MOVFF  22,9F
5DD0:  MOVFF  21,9E
5DD4:  MOVFF  20,9D
5DD8:  MOVFF  2F,A4
5DDC:  MOVFF  2E,A3
5DE0:  MOVFF  2D,A2
5DE4:  MOVFF  2C,A1
5DE8:  CALL   23B2
5DEC:  BC    5DF0
5DEE:  BNZ   5E2A
....................    { 
....................       //Si supera el valor del termostato, lo indicamos con el flag 
....................       temp_habitacion_superada1 = TRUE; 
5DF0:  BSF    1F.1
....................       //Tendremos que establecer un nuevo termostato teniendo en cuenta la histéresis de la temperatura 
....................       termostato1 = termostato1 - histeresis_vivienda; 
5DF2:  BSF    FD8.1
5DF4:  MOVFF  23,2AC
5DF8:  MOVFF  22,2AB
5DFC:  MOVFF  21,2AA
5E00:  MOVFF  20,2A9
5E04:  MOVFF  37,2B0
5E08:  MOVFF  36,2AF
5E0C:  MOVFF  35,2AE
5E10:  MOVFF  34,2AD
5E14:  CALL   2428
5E18:  MOVFF  03,23
5E1C:  MOVFF  02,22
5E20:  MOVFF  01,21
5E24:  MOVFF  00,20
....................    }else 
5E28:  BRA    5E2C
....................       //Si no se supera, se indica también 
....................       temp_habitacion_superada1 = FALSE; 
5E2A:  BCF    1F.1
....................  
....................    if(temperatura2 >= termostato2) 
5E2C:  MOVFF  27,A0
5E30:  MOVFF  26,9F
5E34:  MOVFF  25,9E
5E38:  MOVFF  24,9D
5E3C:  MOVFF  33,A4
5E40:  MOVFF  32,A3
5E44:  MOVFF  31,A2
5E48:  MOVFF  30,A1
5E4C:  CALL   23B2
5E50:  BC    5E54
5E52:  BNZ   5E8E
....................    { 
....................       //Si supera el valor del termostato, lo indicamos con el flag 
....................       temp_habitacion_superada2 = TRUE; 
5E54:  BSF    1F.2
....................       //Tendremos que establecer un nuevo termostato teniendo en cuenta la histéresis de la temperatura 
....................       termostato2 = termostato2 - histeresis_vivienda; 
5E56:  BSF    FD8.1
5E58:  MOVFF  27,2AC
5E5C:  MOVFF  26,2AB
5E60:  MOVFF  25,2AA
5E64:  MOVFF  24,2A9
5E68:  MOVFF  37,2B0
5E6C:  MOVFF  36,2AF
5E70:  MOVFF  35,2AE
5E74:  MOVFF  34,2AD
5E78:  CALL   2428
5E7C:  MOVFF  03,27
5E80:  MOVFF  02,26
5E84:  MOVFF  01,25
5E88:  MOVFF  00,24
....................    }else 
5E8C:  BRA    5E90
....................       //Si no se supera, se indica también 
....................       temp_habitacion_superada2 = FALSE; 
5E8E:  BCF    1F.2
....................  
....................  
....................    if(!C1OUT) 
5E90:  BTFSC  FB4.6
5E92:  BRA    5E98
....................       //Si la temperatura del agua en la caldera supera el termostato, activamos el flag 
....................       temperatura_caldera_superada = TRUE; 
5E94:  BSF    1F.0
....................    else 
5E96:  BRA    5E9A
....................       //Si no es así, lo desactivamos 
....................       temperatura_caldera_superada = FALSE; 
5E98:  BCF    1F.0
....................  
....................    //Desactivamos los flag de las interrupciones 
....................    alarma_int = led_int = timer_int = FALSE; 
5E9A:  BCF    1F.7
5E9C:  BCF    1F.5
5E9E:  BCF    1F.6
....................  
....................    //Determinamos que la patilla de interrupción de la alarma se activa al pasar de alta a baja 
....................    ext_int_edge(0, H_TO_L); 
5EA0:  BCF    FF1.6
....................  
....................    //Configuramos las interrupciones del temporizador 
....................    setup_timer_1(T1_INTERNAL | T1_DIV_BY_8); 
5EA2:  MOVLW  B5
5EA4:  MOVWF  FCD
....................  
....................    //Activamos las interrupciones del puerto B0 y B1 
....................    enable_interrupts(INT_EXT); 
5EA6:  BSF    FF2.4
....................    enable_interrupts(INT_EXT1); 
5EA8:  BSF    FF0.3
....................    enable_interrupts(GLOBAL); 
5EAA:  MOVLW  C0
5EAC:  IORWF  FF2,F
....................  
....................    //Mostramos un mensaje que indica al técnico el éxito en la inicialización 
....................    printf("Sistema inicializado con exito!\r"); 
5EAE:  CLRF   x95
5EB0:  MOVF   x95,W
5EB2:  CALL   0124
5EB6:  IORLW  00
5EB8:  BZ    5EC4
5EBA:  INCF   x95,F
5EBC:  BTFSS  F9E.4
5EBE:  BRA    5EBC
5EC0:  MOVWF  FAD
5EC2:  BRA    5EB0
....................  
....................    //Repetimos la siguiente rutina hasta que se desconecte el micro 
....................    while(1){ 
....................       inicio: 
....................       //Inhabilitamos el perro guardián para que no interfiera con las gestión de interrupciones y 
....................       //con la medida de la temperatura 
....................       setup_wdt(WDT_OFF); 
5EC4:  BCF    FD1.0
....................  
....................       //Si la interrupción de alarma se activa, gestionamos el proceso 
....................       if(alarma_int) 
5EC6:  BTFSS  1F.6
5EC8:  BRA    60B8
....................       { 
....................          //Variables para almacenar el tiempo 
....................          int hora, minutos; 
....................  
....................          //Desactivamos las interrupciones para que no interfieran con la gestión de la alarma 
....................          disable_interrupts(GLOBAL); 
5ECA:  BCF    FF2.6
5ECC:  BCF    FF2.7
5ECE:  BTFSC  FF2.7
5ED0:  BRA    5ECC
....................  
....................          //Desactivamos el flag de la alarma en el PCF8583 
....................          PCF8583_write_byte(PCF8583_CTRL_STATUS_REG, 
....................                                  PCF8583_START_COUNTING); 
5ED2:  CLRF   xAD
5ED4:  CLRF   xAE
5ED6:  CALL   169C
....................  
....................          if(toca_encender) 
5EDA:  BTFSS  1F.4
5EDC:  BRA    6042
....................          { 
....................             if(!sistema_encendido) 
5EDE:  BTFSC  F83.4
5EE0:  BRA    6028
....................             { 
....................                //Ejecutamos esto si se trata de una alarma de encendido y el sistema 
....................                //está apagado. 
....................                //Actualizamos el termostato, guardando el valor que había ya (teniendo en 
....................                //cuenta la histéresis) 
....................                if(temp_habitacion_superada1) 
5EE2:  BTFSS  1F.1
5EE4:  BRA    5F1E
....................                   termostato_provisional = termostato1 + histeresis_vivienda; 
5EE6:  BCF    FD8.1
5EE8:  MOVFF  23,2AC
5EEC:  MOVFF  22,2AB
5EF0:  MOVFF  21,2AA
5EF4:  MOVFF  20,2A9
5EF8:  MOVFF  37,2B0
5EFC:  MOVFF  36,2AF
5F00:  MOVFF  35,2AE
5F04:  MOVFF  34,2AD
5F08:  CALL   2428
5F0C:  MOVFF  03,2B
5F10:  MOVFF  02,2A
5F14:  MOVFF  01,29
5F18:  MOVFF  00,28
....................                else 
5F1C:  BRA    5F2E
....................                   termostato_provisional = termostato1; 
5F1E:  MOVFF  23,2B
5F22:  MOVFF  22,2A
5F26:  MOVFF  21,29
5F2A:  MOVFF  20,28
....................  
....................                termostato1 = termostato2 = prg.termostato; 
5F2E:  MOVLB  2
5F30:  CLRF   xB0
5F32:  MOVFF  58,2AF
5F36:  MOVLB  0
5F38:  CALL   26A2
5F3C:  MOVFF  03,27
5F40:  MOVFF  02,26
5F44:  MOVFF  01,25
5F48:  MOVFF  00,24
5F4C:  MOVFF  27,23
5F50:  MOVFF  26,22
5F54:  MOVFF  25,21
5F58:  MOVFF  24,20
....................  
....................                //Si la temperatura no está superada, desactivamos los flag por si acaso 
....................                //lo estaba con el otro valor de termostato. 
....................                if(ds1820_read(dir1) < termostato1) 
5F5C:  CLRF   xA2
5F5E:  MOVLW  6D
5F60:  MOVWF  xA1
5F62:  CALL   21B8
5F66:  MOVFF  00,95
5F6A:  MOVFF  01,96
5F6E:  MOVFF  02,97
5F72:  MOVFF  03,98
5F76:  MOVFF  03,A0
5F7A:  MOVFF  02,9F
5F7E:  MOVFF  01,9E
5F82:  MOVFF  00,9D
5F86:  MOVFF  23,A4
5F8A:  MOVFF  22,A3
5F8E:  MOVFF  21,A2
5F92:  MOVFF  20,A1
5F96:  CALL   23B2
5F9A:  BNC   5F9E
....................                   temp_habitacion_superada1 = FALSE; 
5F9C:  BCF    1F.1
....................                if(ds1820_read(dir2) < termostato2) 
5F9E:  CLRF   xA2
5FA0:  MOVLW  75
5FA2:  MOVWF  xA1
5FA4:  CALL   21B8
5FA8:  MOVFF  00,95
5FAC:  MOVFF  01,96
5FB0:  MOVFF  02,97
5FB4:  MOVFF  03,98
5FB8:  MOVFF  03,A0
5FBC:  MOVFF  02,9F
5FC0:  MOVFF  01,9E
5FC4:  MOVFF  00,9D
5FC8:  MOVFF  27,A4
5FCC:  MOVFF  26,A3
5FD0:  MOVFF  25,A2
5FD4:  MOVFF  24,A1
5FD8:  CALL   23B2
5FDC:  BNC   5FE0
....................                   temp_habitacion_superada2 = FALSE; 
5FDE:  BCF    1F.2
....................  
....................                //Determinamos la próxima alarma como de apagado 
....................                toca_encender = FALSE; 
5FE0:  BCF    1F.4
....................  
....................                //Activamos el flag de sistema encendido por alarma 
....................                encendido_por_alarma = TRUE; 
5FE2:  BSF    1F.3
....................                //Mostramos un mensaje 
....................                lcd_send_byte(LCD_ORDEN,LCD_CLEAR); 
5FE4:  CLRF   xAC
5FE6:  MOVLW  01
5FE8:  MOVWF  xAD
5FEA:  CALL   1314
....................                printf(lcd_putc, "  Encendiendo\n  sistema..."); 
5FEE:  CLRF   x95
5FF0:  MOVF   x95,W
5FF2:  CALL   0160
5FF6:  IORLW  00
5FF8:  BZ    6004
5FFA:  INCF   x95,F
5FFC:  MOVWF  xA7
5FFE:  CALL   13C0
6002:  BRA    5FF0
....................                //Encendemos el sistema 
....................                encender_sistema(); 
6004:  CALL   28EA
....................  
....................                //Recogemos el tiempo en el que debe de saltar la alarma de apagado. 
....................                //Lo hacemos mediante variables auxiliares para dividir mejor las tareas 
....................                //y no condensar todo en una línea. 
....................                hora = prg.horas_fin; 
6008:  MOVFF  56,85
....................                minutos = prg.minutos_fin; 
600C:  MOVFF  57,86
....................  
....................                delay_ms(250); //Retraso para evitar solapamiento de alarmas 
6010:  MOVLW  FA
6012:  MOVWF  xAE
6014:  CALL   12A8
....................                               //(que salte una dos veces seguidas o algo así) 
....................  
....................                //Establecemos la alarma de apagado del sistema (segundos=0) 
....................                PCF8583_establecer_alarma(hora, minutos, 0); 
6018:  MOVFF  85,97
601C:  MOVFF  86,98
6020:  CLRF   x99
6022:  CALL   2912
....................  
....................             }else 
6026:  BRA    6040
....................             { 
....................                //Si se trata de una alarma de encendido y el sistema está encendido 
....................                delay_ms(250); //Retraso para evitar solapamiento de alarmas 
6028:  MOVLW  FA
602A:  MOVWF  xAE
602C:  CALL   12A8
....................  
....................                //Nos vamos a la siguiente alarma 
....................                posicion_alarmas++; 
6030:  INCF   5A,F
....................                //Si hemos llegado al final de la lista, volvemos al principio 
....................                if(posicion_alarmas==num_intervalos) 
6032:  MOVF   59,W
6034:  SUBWF  5A,W
6036:  BNZ   603A
....................                   posicion_alarmas = 0; 
6038:  CLRF   5A
....................  
....................                //Programamos la próxima alarma de encendido 
....................                programar_proxima_alarma(); 
603A:  CALL   29AA
....................  
....................                //Determinamos que la siguiente es de encendido 
....................                toca_encender = TRUE; 
603E:  BSF    1F.4
....................             } 
....................          }else 
6040:  BRA    60A8
....................          { 
....................             //Si se trata de una alarma de apagado 
....................  
....................             delay_ms(250); //Retraso para evitar el solapamiento de alarmas 
6042:  MOVLW  FA
6044:  MOVWF  xAE
6046:  CALL   12A8
....................  
....................             if(sistema_encendido && encendido_por_alarma) 
604A:  BTFSS  F83.4
604C:  BRA    6098
604E:  BTFSS  1F.3
6050:  BRA    6098
....................             { 
....................                //Si el sistema está encendido y se trata de un encendido por alarma: 
....................                //Restauramos el valor del termostato que había antes de la alarma 
....................                termostato1 = termostato2 = termostato_provisional; 
6052:  MOVFF  2B,27
6056:  MOVFF  2A,26
605A:  MOVFF  29,25
605E:  MOVFF  28,24
6062:  MOVFF  27,23
6066:  MOVFF  26,22
606A:  MOVFF  25,21
606E:  MOVFF  24,20
....................                //Determinamos que la próxima vez que se encienda no sea por alarma 
....................                encendido_por_alarma = FALSE; 
6072:  BCF    1F.3
....................                //Mostramos un mensaje 
....................                lcd_send_byte(LCD_ORDEN,LCD_CLEAR); 
6074:  CLRF   xAC
6076:  MOVLW  01
6078:  MOVWF  xAD
607A:  CALL   1314
....................                printf(lcd_putc, "  Apagando\n  sistema..."); 
607E:  CLRF   x95
6080:  MOVF   x95,W
6082:  CALL   0196
6086:  IORLW  00
6088:  BZ    6094
608A:  INCF   x95,F
608C:  MOVWF  xA7
608E:  CALL   13C0
6092:  BRA    6080
....................                //Apagamos el sistema 
....................                apagar_sistema(); 
6094:  CALL   2DB6
....................             } 
....................  
....................             //Nos vamos a la siguiente alarma 
....................             posicion_alarmas++; 
6098:  INCF   5A,F
....................             //Si llegamos al final de la lista, volvemos al principio 
....................             if(posicion_alarmas==num_intervalos) 
609A:  MOVF   59,W
609C:  SUBWF  5A,W
609E:  BNZ   60A2
....................                posicion_alarmas = 0; 
60A0:  CLRF   5A
....................  
....................             //Programamos la próxima alarma de encendido 
....................             programar_proxima_alarma(); 
60A2:  CALL   29AA
....................  
....................             //Y activamos que, efectivamente, se trata de una alarma de encendido 
....................             toca_encender = TRUE; 
60A6:  BSF    1F.4
....................          } 
....................  
....................          //Activamos de nuevo la alarma 
....................          PCF8583_write_byte(PCF8583_CTRL_STATUS_REG, 
....................                                  PCF8583_ACTIVAR_ALARMA); 
60A8:  CLRF   xAD
60AA:  MOVLW  04
60AC:  MOVWF  xAE
60AE:  CALL   169C
....................  
....................          //Desactivamos el flag de interrupción 
....................          alarma_int = FALSE; 
60B2:  BCF    1F.6
....................  
....................          //Volvemos a activar las interrupciones 
....................          enable_interrupts(GLOBAL); 
60B4:  MOVLW  C0
60B6:  IORWF  FF2,F
....................       } 
....................  
....................  
....................       //Si se activa la interrupción de interfaz con el usuario, se gestiona el proceso 
....................       if(led_int) 
60B8:  BTFSS  1F.5
60BA:  GOTO   6BDA
....................       { 
....................          //Contadores 
....................          int contador, contador2; 
....................          //Variable para la conversión de los valores de teclado 
....................          long numero; 
....................          //Variables provisionales para buscar en la lista de programaciones 
....................          programacion pr, pr2; 
....................  
....................          //Desactivamos interrupciones externas 
....................          disable_interrupts(GLOBAL); 
60BE:  BCF    FF2.6
60C0:  BCF    FF2.7
60C2:  BTFSC  FF2.7
60C4:  BRA    60C0
....................           
....................  
....................          //Ponemos en key un caracter cualquiera para que no se corresponda 
....................          //con ningún botón del teclado. 
....................          key='J'; 
60C6:  MOVLW  4A
60C8:  MOVWF  38
....................  
....................          //Mostramos un mensaje al usuario para que elija su opción 
....................          lcd_send_byte(LCD_ORDEN,LCD_CLEAR); 
60CA:  CLRF   xAC
60CC:  MOVLW  01
60CE:  MOVWF  xAD
60D0:  CALL   1314
....................          printf(lcd_putc, "  Indique la \n  operacion"); 
60D4:  CLRF   x95
60D6:  MOVF   x95,W
60D8:  CALL   01C8
60DC:  IORLW  00
60DE:  BZ    60EA
60E0:  INCF   x95,F
60E2:  MOVWF  xA7
60E4:  CALL   13C0
60E8:  BRA    60D6
....................  
....................          //Activamos el temporizador para controlar el tiempo que el menú está activo, 
....................          //poniendo el contador a 0. 
....................          contador_tiempo = 0; 
60EA:  CLRF   7D
....................          enable_interrupts(INT_TIMER1); 
60EC:  BSF    F9D.0
....................  
....................          //Mientras que la tecla pulsada no sea una de las válidas, seguimos barriendo el teclado 
....................          while(key!='1' && key!='2' && key!='3' && key!='4' && key!='N'){ 
60EE:  MOVF   38,W
60F0:  SUBLW  31
60F2:  BZ    6120
60F4:  MOVF   38,W
60F6:  SUBLW  32
60F8:  BZ    6120
60FA:  MOVF   38,W
60FC:  SUBLW  33
60FE:  BZ    6120
6100:  MOVF   38,W
6102:  SUBLW  34
6104:  BZ    6120
6106:  MOVF   38,W
6108:  SUBLW  4E
610A:  BZ    6120
....................             key=get_key(); 
610C:  CALL   3206
6110:  MOVFF  01,38
....................             //Si el tiempo de espera consignado expira, es equivalente a pulsar la tecla NO para salir. 
....................             if(timer_int){ 
6114:  BTFSS  1F.7
6116:  BRA    611E
....................                key='N'; 
6118:  MOVLW  4E
611A:  MOVWF  38
....................                timer_int = FALSE; //Desactivamos flag 
611C:  BCF    1F.7
....................             } 
....................          } 
611E:  BRA    60EE
....................  
....................          //Volvemos a deshabilitar la interrupción que controla el tiempo de espera 
....................          disable_interrupts(INT_TIMER1); 
6120:  BCF    F9D.0
....................  
....................          //Se elige la opción pertinente 
....................          switch(key) 
....................          { 
6122:  MOVF   38,W
6124:  XORLW  31
6126:  BZ    6146
6128:  XORLW  03
612A:  BZ    61BE
612C:  XORLW  01
612E:  BTFSC  FD8.2
6130:  BRA    652C
6132:  XORLW  07
6134:  BTFSC  FD8.2
6136:  GOTO   69FA
613A:  XORLW  7A
613C:  BTFSC  FD8.2
613E:  GOTO   6B98
6142:  GOTO   6BD4
....................             //Si es 1, entramos en la opción de apagado y encendido manual del sistema 
....................             case '1': 
....................                      //Si el sistema está apagado, lo encendemos 
....................                      if(!sistema_encendido) 
6146:  BTFSC  F83.4
6148:  BRA    6170
....................                      { 
....................                         lcd_send_byte(LCD_ORDEN,LCD_CLEAR); 
614A:  CLRF   xAC
614C:  MOVLW  01
614E:  MOVWF  xAD
6150:  CALL   1314
....................                         printf(lcd_putc, "  Encendiendo\n  sistema..."); 
6154:  CLRF   x95
6156:  MOVF   x95,W
6158:  CALL   0160
615C:  IORLW  00
615E:  BZ    616A
6160:  INCF   x95,F
6162:  MOVWF  xA7
6164:  CALL   13C0
6168:  BRA    6156
....................                         encender_sistema(); 
616A:  CALL   28EA
....................                      }else 
616E:  BRA    61BA
....................                      //Si está encendido, lo apagamos 
....................                      { 
....................                         lcd_send_byte(LCD_ORDEN,LCD_CLEAR); 
6170:  CLRF   xAC
6172:  MOVLW  01
6174:  MOVWF  xAD
6176:  CALL   1314
....................                         printf(lcd_putc, "  Apagando\n  sistema..."); 
617A:  CLRF   x95
617C:  MOVF   x95,W
617E:  CALL   0196
6182:  IORLW  00
6184:  BZ    6190
6186:  INCF   x95,F
6188:  MOVWF  xA7
618A:  CALL   13C0
618E:  BRA    617C
....................                         apagar_sistema(); 
6190:  CALL   2DB6
....................                         //Si los motores estaban en marcha, debemos apagarlos 
....................                         //motor1 = FALSE;   /* Lo hacemos ya dentro de la rutina 
....................                         //motor2 = FALSE; 
....................  
....................                         //Si estaba encendido por alguna alarma debemos indicarlo 
....................                         if(encendido_por_alarma) 
6194:  BTFSS  1F.3
6196:  BRA    61BA
....................                         { 
....................                            //Recuperamos el valor del termostato 
....................                            termostato1 = termostato2 = termostato_provisional; 
6198:  MOVFF  2B,27
619C:  MOVFF  2A,26
61A0:  MOVFF  29,25
61A4:  MOVFF  28,24
61A8:  MOVFF  27,23
61AC:  MOVFF  26,22
61B0:  MOVFF  25,21
61B4:  MOVFF  24,20
....................                            encendido_por_alarma = FALSE; 
61B8:  BCF    1F.3
....................                         } 
....................                      } 
....................                      break; 
61BA:  GOTO   6BD4
....................  
....................  
....................             //Si es 2, entramos en la opción de configuración del termostato 
....................             case '2': 
....................  
....................                      //Mostramos el valor del termostato actual 
....................                      lcd_send_byte(LCD_ORDEN, LCD_CLEAR); 
61BE:  CLRF   xAC
61C0:  MOVLW  01
61C2:  MOVWF  xAD
61C4:  CALL   1314
....................                      //Para considerar el valor del termostato hay que tener en cuenta el valor de la histéresis. 
....................                      //El termostato de la vivienda es único y no depende de la habitación en la que nos encontremos. 
....................                      if(temp_habitacion_superada1) 
61C8:  BTFSS  1F.1
61CA:  BRA    6246
....................                         printf(lcd_putc, "Modificar\ntermostato %.0f%cC",termostato1+histeresis_vivienda,223); 
61CC:  BCF    FD8.1
61CE:  MOVFF  23,2AC
61D2:  MOVFF  22,2AB
61D6:  MOVFF  21,2AA
61DA:  MOVFF  20,2A9
61DE:  MOVFF  37,2B0
61E2:  MOVFF  36,2AF
61E6:  MOVFF  35,2AE
61EA:  MOVFF  34,2AD
61EE:  CALL   2428
61F2:  MOVFF  00,95
61F6:  MOVFF  01,96
61FA:  MOVFF  02,97
61FE:  MOVFF  03,98
6202:  CLRF   x99
6204:  MOVF   x99,W
6206:  CALL   01FC
620A:  INCF   x99,F
620C:  MOVWF  00
620E:  MOVWF  xA7
6210:  CALL   13C0
6214:  MOVLW  15
6216:  SUBWF  x99,W
6218:  BNZ   6204
621A:  MOVLW  89
621C:  MOVWF  FE9
621E:  MOVFF  98,9D
6222:  MOVFF  97,9C
6226:  MOVFF  96,9B
622A:  MOVFF  95,9A
622E:  CLRF   x9E
6230:  CALL   32E0
6234:  MOVLW  DF
6236:  MOVWF  xA7
6238:  CALL   13C0
623C:  MOVLW  43
623E:  MOVWF  xA7
6240:  CALL   13C0
....................                      else 
6244:  BRA    6288
....................                         printf(lcd_putc, "Modificar\ntermostato %.0f%cC",termostato1,223); 
6246:  CLRF   x95
6248:  MOVF   x95,W
624A:  CALL   01FC
624E:  INCF   x95,F
6250:  MOVWF  00
6252:  MOVWF  xA7
6254:  CALL   13C0
6258:  MOVLW  15
625A:  SUBWF  x95,W
625C:  BNZ   6248
625E:  MOVLW  89
6260:  MOVWF  FE9
6262:  MOVFF  23,9D
6266:  MOVFF  22,9C
626A:  MOVFF  21,9B
626E:  MOVFF  20,9A
6272:  CLRF   x9E
6274:  CALL   32E0
6278:  MOVLW  DF
627A:  MOVWF  xA7
627C:  CALL   13C0
6280:  MOVLW  43
6282:  MOVWF  xA7
6284:  CALL   13C0
....................  
....................                      //Retardamos cierto tiempo para que el usuario vea correctamente los datos de la pantalla 
....................                      delay_ms(LCD_T_RETARDO*2); 
6288:  MOVLW  04
628A:  MOVWF  x95
628C:  MOVLW  FA
628E:  MOVWF  xAE
6290:  CALL   12A8
6294:  DECFSZ x95,F
6296:  BRA    628C
....................  
....................                      //Pedimos la introducción de nuevo valor 
....................                      lcd_send_byte(LCD_ORDEN, LCD_CLEAR); 
6298:  CLRF   xAC
629A:  MOVLW  01
629C:  MOVWF  xAD
629E:  CALL   1314
....................                      lcd_send_byte(LCD_ORDEN, LCD_CURSOR); //Activamos el cursor en la pantalla 
62A2:  CLRF   xAC
62A4:  MOVLW  0E
62A6:  MOVWF  xAD
62A8:  CALL   1314
....................                      printf(lcd_putc, "Nuevo valor:\n       %cC",223); 
62AC:  CLRF   x95
62AE:  MOVF   x95,W
62B0:  CALL   0234
62B4:  INCF   x95,F
62B6:  MOVWF  00
62B8:  MOVWF  xA7
62BA:  CALL   13C0
62BE:  MOVLW  0D
62C0:  SUBWF  x95,W
62C2:  BNZ   62AE
62C4:  MOVLW  07
62C6:  MOVWF  x96
62C8:  MOVLW  20
62CA:  MOVWF  xA7
62CC:  CALL   13C0
62D0:  DECFSZ x96,F
62D2:  BRA    62C8
62D4:  MOVLW  DF
62D6:  MOVWF  xA7
62D8:  CALL   13C0
62DC:  MOVLW  43
62DE:  MOVWF  xA7
62E0:  CALL   13C0
....................                      lcd_gotoxy(6,2); 
62E4:  MOVLW  06
62E6:  MOVWF  xA8
62E8:  MOVLW  02
62EA:  MOVWF  xA9
62EC:  CALL   139E
....................  
....................                      //Recogemos el número de dos cifras introducido por el teclado 
....................                      valor=buscar_numero(); 
62F0:  CALL   3470
62F4:  MOVFF  01,84
....................  
....................                      //Si se pulsa la tecla SI o NO, salimos 
....................                      if(valor==NO || valor==SI) 
62F8:  MOVF   x84,W
62FA:  SUBLW  64
62FC:  BZ    6304
62FE:  MOVF   x84,W
6300:  SUBLW  65
6302:  BNZ   630A
....................                         goto salir; 
6304:  GOTO   6B98
....................                      else 
6308:  BRA    652A
....................                      { 
....................                         //Retardamos cierto tiempo para permitir al usuario visualizar el valor que ha introducido 
....................                         delay_ms(LCD_T_RETARDO); 
630A:  MOVLW  02
630C:  MOVWF  x95
630E:  MOVLW  FA
6310:  MOVWF  xAE
6312:  CALL   12A8
6316:  DECFSZ x95,F
6318:  BRA    630E
....................  
....................                         //Mostramos un mensaje de aplicación de cambios y desactivamos el cursor 
....................                         lcd_send_byte(LCD_ORDEN, LCD_CLEAR); 
631A:  CLRF   xAC
631C:  MOVLW  01
631E:  MOVWF  xAD
6320:  CALL   1314
....................                         lcd_send_byte(LCD_ORDEN, LCD_NO_CURSOR); 
6324:  CLRF   xAC
6326:  MOVLW  0C
6328:  MOVWF  xAD
632A:  CALL   1314
....................                         printf(lcd_putc, "  Aplicando\n  cambios..."); 
632E:  CLRF   x95
6330:  MOVF   x95,W
6332:  CALL   0260
6336:  IORLW  00
6338:  BZ    6344
633A:  INCF   x95,F
633C:  MOVWF  xA7
633E:  CALL   13C0
6342:  BRA    6330
....................  
....................                         if(valor<=temp_max && valor>=temp_min) 
6344:  MOVF   x84,W
6346:  SUBLW  20
6348:  BTFSS  FD8.0
634A:  BRA    64FA
634C:  MOVF   x84,W
634E:  SUBLW  0F
6350:  BTFSC  FD8.0
6352:  BRA    64FA
....................                         { 
....................                            //Si el valor está dentro de los límites propuestos, guardamos el valor nuevo 
....................  
....................                            //Leemos la temperatura de la zona1 de la vivienda 
....................                            temperatura1 = ds1820_read(dir1); 
6354:  CLRF   xA2
6356:  MOVLW  6D
6358:  MOVWF  xA1
635A:  CALL   21B8
635E:  MOVFF  03,2F
6362:  MOVFF  02,2E
6366:  MOVFF  01,2D
636A:  MOVFF  00,2C
....................                            if(temperatura1 >= (float)valor) 
636E:  MOVLB  2
6370:  CLRF   xB0
6372:  MOVFF  84,2AF
6376:  MOVLB  0
6378:  CALL   26A2
637C:  MOVFF  03,A0
6380:  MOVFF  02,9F
6384:  MOVFF  01,9E
6388:  MOVFF  00,9D
638C:  MOVFF  2F,A4
6390:  MOVFF  2E,A3
6394:  MOVFF  2D,A2
6398:  MOVFF  2C,A1
639C:  CALL   23B2
63A0:  BC    63A4
63A2:  BNZ   63FC
....................                            { 
....................                               //Si supera el valor del termostato, lo indicamos con el flag 
....................                               temp_habitacion_superada1 = TRUE; 
63A4:  BSF    1F.1
....................                               //Guardamos el termostato nuevo teniendo en cuenta la histeresis de la vivienda 
....................                               termostato1 = (float)valor - histeresis_vivienda; 
63A6:  MOVLB  2
63A8:  CLRF   xB0
63AA:  MOVFF  84,2AF
63AE:  MOVLB  0
63B0:  CALL   26A2
63B4:  MOVFF  00,95
63B8:  MOVFF  01,96
63BC:  MOVFF  02,97
63C0:  MOVFF  03,98
63C4:  BSF    FD8.1
63C6:  MOVFF  03,2AC
63CA:  MOVFF  02,2AB
63CE:  MOVFF  01,2AA
63D2:  MOVFF  00,2A9
63D6:  MOVFF  37,2B0
63DA:  MOVFF  36,2AF
63DE:  MOVFF  35,2AE
63E2:  MOVFF  34,2AD
63E6:  CALL   2428
63EA:  MOVFF  03,23
63EE:  MOVFF  02,22
63F2:  MOVFF  01,21
63F6:  MOVFF  00,20
....................                            }else 
63FA:  BRA    641C
....................                            { 
....................                               //Si no se supera, se indica también 
....................                               temp_habitacion_superada1 = FALSE; 
63FC:  BCF    1F.1
....................                               //Se guarda el valor tal cual 
....................                               termostato1 = (float)valor; 
63FE:  MOVLB  2
6400:  CLRF   xB0
6402:  MOVFF  84,2AF
6406:  MOVLB  0
6408:  CALL   26A2
640C:  MOVFF  03,23
6410:  MOVFF  02,22
6414:  MOVFF  01,21
6418:  MOVFF  00,20
....................                            } 
....................  
....................                            //Repetimos el proceso con la zona2 de la vivienda 
....................                            temperatura2 = ds1820_read(dir2); 
641C:  CLRF   xA2
641E:  MOVLW  75
6420:  MOVWF  xA1
6422:  CALL   21B8
6426:  MOVFF  03,33
642A:  MOVFF  02,32
642E:  MOVFF  01,31
6432:  MOVFF  00,30
....................                            if(temperatura2 >= (float)valor) 
6436:  MOVLB  2
6438:  CLRF   xB0
643A:  MOVFF  84,2AF
643E:  MOVLB  0
6440:  CALL   26A2
6444:  MOVFF  03,A0
6448:  MOVFF  02,9F
644C:  MOVFF  01,9E
6450:  MOVFF  00,9D
6454:  MOVFF  33,A4
6458:  MOVFF  32,A3
645C:  MOVFF  31,A2
6460:  MOVFF  30,A1
6464:  CALL   23B2
6468:  BC    646C
646A:  BNZ   64C4
....................                            { 
....................                               //Si supera el valor del termostato, lo indicamos con el flag 
....................                               temp_habitacion_superada2 = TRUE; 
646C:  BSF    1F.2
....................                               //Guardamos el termostato nuevo teniendo en cuenta la histeresis de la vivienda 
....................                               termostato2 = (float)valor - histeresis_vivienda; 
646E:  MOVLB  2
6470:  CLRF   xB0
6472:  MOVFF  84,2AF
6476:  MOVLB  0
6478:  CALL   26A2
647C:  MOVFF  00,95
6480:  MOVFF  01,96
6484:  MOVFF  02,97
6488:  MOVFF  03,98
648C:  BSF    FD8.1
648E:  MOVFF  03,2AC
6492:  MOVFF  02,2AB
6496:  MOVFF  01,2AA
649A:  MOVFF  00,2A9
649E:  MOVFF  37,2B0
64A2:  MOVFF  36,2AF
64A6:  MOVFF  35,2AE
64AA:  MOVFF  34,2AD
64AE:  CALL   2428
64B2:  MOVFF  03,27
64B6:  MOVFF  02,26
64BA:  MOVFF  01,25
64BE:  MOVFF  00,24
....................                            }else 
64C2:  BRA    64E4
....................                            { 
....................                               //Si no se supera, se indica también 
....................                               temp_habitacion_superada2 = FALSE; 
64C4:  BCF    1F.2
....................                               //Se guarda el valor tal cual 
....................                               termostato2 = (float)valor; 
64C6:  MOVLB  2
64C8:  CLRF   xB0
64CA:  MOVFF  84,2AF
64CE:  MOVLB  0
64D0:  CALL   26A2
64D4:  MOVFF  03,27
64D8:  MOVFF  02,26
64DC:  MOVFF  01,25
64E0:  MOVFF  00,24
....................                            } 
....................  
....................                            //Guardamos el nuevo valor del termostato en memoria 
....................                            graba_ee(eeprom_termostato, 1, &valor); 
64E4:  CLRF   xA8
64E6:  MOVLW  10
64E8:  MOVWF  xA7
64EA:  MOVLW  01
64EC:  MOVWF  xA9
64EE:  CLRF   xAB
64F0:  MOVLW  84
64F2:  MOVWF  xAA
64F4:  CALL   184A
....................  
....................                         } 
....................                         else 
64F8:  BRA    652A
....................                         { 
....................                            //Si el valor es incorrecto, mostramos un mensaje de error 
....................                            lcd_send_byte(LCD_ORDEN, LCD_CLEAR); 
64FA:  CLRF   xAC
64FC:  MOVLW  01
64FE:  MOVWF  xAD
6500:  CALL   1314
....................                            printf(lcd_putc, "   Valor\n   incorrecto"); 
6504:  CLRF   x95
6506:  MOVF   x95,W
6508:  CALL   0294
650C:  IORLW  00
650E:  BZ    651A
6510:  INCF   x95,F
6512:  MOVWF  xA7
6514:  CALL   13C0
6518:  BRA    6506
....................                            delay_ms(LCD_T_RETARDO); 
651A:  MOVLW  02
651C:  MOVWF  x95
651E:  MOVLW  FA
6520:  MOVWF  xAE
6522:  CALL   12A8
6526:  DECFSZ x95,F
6528:  BRA    651E
....................                         } 
....................                      } 
....................  
....................                      break; 
652A:  BRA    6BD4
....................  
....................  
....................             //Si es 3, entramos en la opción de configuración de las alarmas 
....................             case '3': 
....................  
....................                      //Mostramos el encabezamiento de la operación 
....................                      lcd_send_byte(LCD_ORDEN, LCD_CLEAR); 
652C:  CLRF   xAC
652E:  MOVLW  01
6530:  MOVWF  xAD
6532:  CALL   1314
....................                      printf(lcd_putc," Programar\n sistema"); 
6536:  CLRF   x95
6538:  MOVF   x95,W
653A:  CALL   02C6
653E:  IORLW  00
6540:  BZ    654C
6542:  INCF   x95,F
6544:  MOVWF  xA7
6546:  CALL   13C0
654A:  BRA    6538
....................                      delay_ms(LCD_T_RETARDO); 
654C:  MOVLW  02
654E:  MOVWF  x95
6550:  MOVLW  FA
6552:  MOVWF  xAE
6554:  CALL   12A8
6558:  DECFSZ x95,F
655A:  BRA    6550
....................  
....................                      //Tenemos la posibilidad de introducir 5 intervalos de alarma. 
....................                      //Se va guiando al usuario por la configuración de cada intervalo mediante el siguiente bucle 
....................                      for(contador=0; contador<5; contador++) 
655C:  CLRF   x87
655E:  MOVF   x87,W
6560:  SUBLW  04
6562:  BTFSS  FD8.0
6564:  BRA    69B0
....................                      { 
....................                         //Se muestra el intervalo a configurar 
....................                         lcd_send_byte(LCD_ORDEN, LCD_CLEAR); 
6566:  CLRF   xAC
6568:  MOVLW  01
656A:  MOVWF  xAD
656C:  CALL   1314
....................                         printf(lcd_putc, " INTERVALO %i\n   :      :",contador+1); 
6570:  MOVLW  01
6572:  ADDWF  x87,W
6574:  MOVWF  x95
6576:  CLRF   x96
6578:  MOVF   x96,W
657A:  CALL   02F4
657E:  INCF   x96,F
6580:  MOVWF  00
6582:  MOVWF  xA7
6584:  CALL   13C0
6588:  MOVLW  0B
658A:  SUBWF  x96,W
658C:  BNZ   6578
658E:  MOVFF  95,97
6592:  MOVLW  1F
6594:  MOVWF  x98
6596:  CALL   3526
659A:  MOVLW  0A
659C:  MOVWF  xA7
659E:  CALL   13C0
65A2:  MOVLW  03
65A4:  MOVWF  x97
65A6:  MOVLW  20
65A8:  MOVWF  xA7
65AA:  CALL   13C0
65AE:  DECFSZ x97,F
65B0:  BRA    65A6
65B2:  MOVLW  3A
65B4:  MOVWF  xA7
65B6:  CALL   13C0
65BA:  MOVLW  06
65BC:  MOVWF  x98
65BE:  MOVLW  20
65C0:  MOVWF  xA7
65C2:  CALL   13C0
65C6:  DECFSZ x98,F
65C8:  BRA    65BE
65CA:  MOVLW  3A
65CC:  MOVWF  xA7
65CE:  CALL   13C0
....................                         lcd_gotoxy(2,2); 
65D2:  MOVLW  02
65D4:  MOVWF  xA8
65D6:  MOVWF  xA9
65D8:  CALL   139E
....................                         lcd_send_byte(LCD_ORDEN, LCD_CURSOR); 
65DC:  CLRF   xAC
65DE:  MOVLW  0E
65E0:  MOVWF  xAD
65E2:  CALL   1314
....................  
....................                         //Se pide al usuario el valor de hora de inicio de la alarma 
....................                         pr.horas_inicio = buscar_numero(); 
65E6:  CALL   3470
65EA:  MOVFF  01,8B
....................  
....................                         //Si se pulsa el botón de NO, se sale de la configuración 
....................                         if(pr.horas_inicio==NO) 
65EE:  MOVF   x8B,W
65F0:  SUBLW  64
65F2:  BNZ   65F6
....................                            goto salir; 
65F4:  BRA    6B98
....................  
....................                         //Si se pulsa Sí, se indica que no quieren introducirse más alarmas 
....................                         if(pr.horas_inicio==SI) 
65F6:  MOVF   x8B,W
65F8:  SUBLW  65
65FA:  BNZ   660E
....................                         { 
....................                            //Si era la primera alarma que se gestionaba, se interpreta como que 
....................                            //no se quiere activar ninguna alarma 
....................                            if(contador==0) 
65FC:  MOVF   x87,F
65FE:  BNZ   660C
....................                            { 
....................                               //Desactivamos las alarmas 
....................                               PCF8583_write_byte(PCF8583_CTRL_STATUS_REG, 
....................                                     PCF8583_START_COUNTING); 
6600:  CLRF   xAD
6602:  CLRF   xAE
6604:  CALL   169C
....................                               //Habilitamos interrupciones 
....................                               //enable_interrupts(GLOBAL); 
....................                               //Salimos 
....................                               goto salir; 
6608:  BRA    6B98
....................                            } 
....................                            else 
660A:  BRA    660E
....................                               //Salimos simplemente del bucle 
....................                               break; 
660C:  BRA    69B0
....................                         } 
....................  
....................                         //Movemos el cursor en la pantalla 
....................                         lcd_gotoxy(5,2); 
660E:  MOVLW  05
6610:  MOVWF  xA8
6612:  MOVLW  02
6614:  MOVWF  xA9
6616:  CALL   139E
....................  
....................                         //Se pide al usuario el valor de los minutos de inicio 
....................                         pr.minutos_inicio = buscar_numero(); 
661A:  CALL   3470
661E:  MOVFF  01,8C
....................  
....................                         //Si se pulsa NO, se sale 
....................                         if(pr.minutos_inicio==NO) 
6622:  MOVF   x8C,W
6624:  SUBLW  64
6626:  BNZ   662A
....................                            goto salir; 
6628:  BRA    6B98
....................  
....................                         //Si se pulsa SI, interrumpimos la introducción de alarmas 
....................                         if(pr.minutos_inicio==SI) 
662A:  MOVF   x8C,W
662C:  SUBLW  65
662E:  BNZ   6642
....................                         { 
....................                            //Si es el primer intervalo, interpretamos como que el usuario 
....................                            //no quiere programar alarmas 
....................                            if(contador==0) 
6630:  MOVF   x87,F
6632:  BNZ   6640
....................                            { 
....................                               //Desactivamos las alarmas 
....................                               PCF8583_write_byte(PCF8583_CTRL_STATUS_REG, 
....................                                     PCF8583_START_COUNTING); 
6634:  CLRF   xAD
6636:  CLRF   xAE
6638:  CALL   169C
....................                               //Habilitamos interrupciones 
....................                               //enable_interrupts(GLOBAL); 
....................                               goto salir; 
663C:  BRA    6B98
....................                            } 
....................                            else 
663E:  BRA    6642
....................                               //Salimos del bucle 
....................                               break; 
6640:  BRA    69B0
....................                         } 
....................  
....................                         //******************************************************************************** 
....................                         //Los comentarios a partir de este punto y hasta la siguiente línea de asteriscos 
....................                         //son equivalentes a los mostrados arriba pero esta vez con la hora de finalización 
....................  
....................                         lcd_gotoxy(9,2); 
6642:  MOVLW  09
6644:  MOVWF  xA8
6646:  MOVLW  02
6648:  MOVWF  xA9
664A:  CALL   139E
....................  
....................                         pr.horas_fin = buscar_numero(); 
664E:  CALL   3470
6652:  MOVFF  01,8D
....................  
....................                         if(pr.horas_fin==NO) 
6656:  MOVF   x8D,W
6658:  SUBLW  64
665A:  BNZ   665E
....................                            goto salir; 
665C:  BRA    6B98
....................  
....................                         if(pr.horas_fin==SI) 
665E:  MOVF   x8D,W
6660:  SUBLW  65
6662:  BNZ   6676
....................                         { 
....................                            if(contador==0) 
6664:  MOVF   x87,F
6666:  BNZ   6674
....................                            { 
....................                               PCF8583_write_byte(PCF8583_CTRL_STATUS_REG, 
....................                                     PCF8583_START_COUNTING); 
6668:  CLRF   xAD
666A:  CLRF   xAE
666C:  CALL   169C
....................                               //Habilitamos interrupciones 
....................                               //enable_interrupts(GLOBAL); 
....................                               goto salir; 
6670:  BRA    6B98
....................                            } 
....................                            else 
6672:  BRA    6676
....................                               break; 
6674:  BRA    69B0
....................                         } 
....................  
....................  
....................                         lcd_gotoxy(12,2); 
6676:  MOVLW  0C
6678:  MOVWF  xA8
667A:  MOVLW  02
667C:  MOVWF  xA9
667E:  CALL   139E
....................  
....................                         pr.minutos_fin = buscar_numero(); 
6682:  CALL   3470
6686:  MOVFF  01,8E
....................  
....................                         if(pr.minutos_fin==NO) 
668A:  MOVF   x8E,W
668C:  SUBLW  64
668E:  BNZ   6692
....................                            goto salir; 
6690:  BRA    6B98
....................  
....................                         if(pr.minutos_fin==SI) 
6692:  MOVF   x8E,W
6694:  SUBLW  65
6696:  BNZ   66AA
....................                         { 
....................                            if(contador==0) 
6698:  MOVF   x87,F
669A:  BNZ   66A8
....................                            { 
....................                               PCF8583_write_byte(PCF8583_CTRL_STATUS_REG, 
....................                                     PCF8583_START_COUNTING); 
669C:  CLRF   xAD
669E:  CLRF   xAE
66A0:  CALL   169C
....................                               //Habilitamos interrupciones 
....................                               //enable_interrupts(GLOBAL); 
....................                               goto salir; 
66A4:  BRA    6B98
....................                            } 
....................                            else 
66A6:  BRA    66AA
....................                               break; 
66A8:  BRA    69B0
....................                         } 
....................  
....................                         //Ver comentarios arriba 
....................                         //************************************************************ 
....................  
....................                         //Desactivamos el cursor de la pantalla 
....................                         lcd_send_byte(LCD_ORDEN, LCD_NO_CURSOR); 
66AA:  CLRF   xAC
66AC:  MOVLW  0C
66AE:  MOVWF  xAD
66B0:  CALL   1314
....................  
....................                         //Introducimos cierto retardo para que el usuario pueda visualizar los valores introducidos en la pantalla 
....................                         delay_ms(LCD_T_RETARDO); 
66B4:  MOVLW  02
66B6:  MOVWF  x95
66B8:  MOVLW  FA
66BA:  MOVWF  xAE
66BC:  CALL   12A8
66C0:  DECFSZ x95,F
66C2:  BRA    66B8
....................  
....................                         //Comprobamos que los valores introducidos son correctos: horas menores que 24 y minutos menores que 60 
....................                         //Además, comprobamos que la hora de finalización no vaya antes que la de inicio 
....................                         if(pr.horas_inicio>23 || pr.horas_fin>23 || pr.minutos_inicio>59 || pr.minutos_fin>59 
....................                               || comprobar_hora(pr.horas_fin,pr.minutos_fin,pr.horas_inicio,pr.minutos_inicio)) 
66C4:  MOVF   x8B,W
66C6:  SUBLW  17
66C8:  BNC   66F4
66CA:  MOVF   x8D,W
66CC:  SUBLW  17
66CE:  BNC   66F4
66D0:  MOVF   x8C,W
66D2:  SUBLW  3B
66D4:  BNC   66F4
66D6:  MOVF   x8E,W
66D8:  SUBLW  3B
66DA:  BNC   66F4
66DC:  MOVFF  8D,AB
66E0:  MOVFF  8E,AC
66E4:  MOVFF  8B,AD
66E8:  MOVFF  8C,AE
66EC:  CALL   2AEA
66F0:  MOVF   01,F
66F2:  BZ    6728
....................                         { 
....................                            //Si se produce un error de este tipo, se indica 
....................                            lcd_send_byte(LCD_ORDEN, LCD_CLEAR); 
66F4:  CLRF   xAC
66F6:  MOVLW  01
66F8:  MOVWF  xAD
66FA:  CALL   1314
....................                            printf(lcd_putc, "   Valores\n   incorrectos"); 
66FE:  CLRF   x95
6700:  MOVF   x95,W
6702:  CALL   0320
6706:  IORLW  00
6708:  BZ    6714
670A:  INCF   x95,F
670C:  MOVWF  xA7
670E:  CALL   13C0
6712:  BRA    6700
....................                            delay_ms(LCD_T_RETARDO); 
6714:  MOVLW  02
6716:  MOVWF  x95
6718:  MOVLW  FA
671A:  MOVWF  xAE
671C:  CALL   12A8
6720:  DECFSZ x95,F
6722:  BRA    6718
....................                            //Se repite la última iteración del bloque 
....................                            contador--; 
6724:  DECF   x87,F
....................                            continue; 
6726:  BRA    69AC
....................                         } 
....................  
....................                         //No puede haber un intervalo de encendido de más de 4 horas. 
....................                         //Esto deriva de un problema propio de almacenamiento de números enteros, pero es perfectamente lógico 
....................                         //que un sistema de calefacción tenga un tiempo máximo de encendido para regular el uso abusivo del sistema 
....................                         //y evitar averías por un funcionamiento muy prolongado. 
....................                         if(diferencia_tiempo(pr.horas_inicio, pr.minutos_inicio, pr.horas_fin, pr.minutos_fin)>240) 
6728:  MOVFF  8B,A1
672C:  MOVFF  8C,A2
6730:  MOVFF  8D,A3
6734:  MOVFF  8E,A4
6738:  CALL   2B1E
673C:  MOVFF  02,96
6740:  MOVFF  01,95
6744:  MOVF   x96,F
6746:  BNZ   674E
6748:  MOVF   x95,W
674A:  SUBLW  F0
674C:  BC    6782
....................                         { 
....................                            //Mostramos un aviso 
....................                            lcd_send_byte(LCD_ORDEN, LCD_CLEAR); 
674E:  CLRF   xAC
6750:  MOVLW  01
6752:  MOVWF  xAD
6754:  CALL   1314
....................                            printf(lcd_putc, "Intervalo limite\nde 4 horas"); 
6758:  CLRF   x95
675A:  MOVF   x95,W
675C:  CALL   0354
6760:  IORLW  00
6762:  BZ    676E
6764:  INCF   x95,F
6766:  MOVWF  xA7
6768:  CALL   13C0
676C:  BRA    675A
....................                            delay_ms(LCD_T_RETARDO); 
676E:  MOVLW  02
6770:  MOVWF  x95
6772:  MOVLW  FA
6774:  MOVWF  xAE
6776:  CALL   12A8
677A:  DECFSZ x95,F
677C:  BRA    6772
....................                            //Se repite la última iteración del bloque 
....................                            contador--; 
677E:  DECF   x87,F
....................                            continue; 
6780:  BRA    69AC
....................  
....................                         } 
....................  
....................                         //El usuario debe ahora introducir el valor del temostato para ese periodo de encendido 
....................                         lcd_send_byte(LCD_ORDEN, LCD_CLEAR); 
6782:  CLRF   xAC
6784:  MOVLW  01
6786:  MOVWF  xAD
6788:  CALL   1314
....................                         printf(lcd_putc, "Termostato %i\n      %cC", contador+1, 223); 
678C:  MOVLW  01
678E:  ADDWF  x87,W
6790:  MOVWF  x95
6792:  CLRF   x96
6794:  MOVF   x96,W
6796:  CALL   038A
679A:  INCF   x96,F
679C:  MOVWF  00
679E:  MOVWF  xA7
67A0:  CALL   13C0
67A4:  MOVLW  0B
67A6:  SUBWF  x96,W
67A8:  BNZ   6794
67AA:  MOVFF  95,97
67AE:  MOVLW  1F
67B0:  MOVWF  x98
67B2:  CALL   3526
67B6:  MOVLW  0A
67B8:  MOVWF  xA7
67BA:  CALL   13C0
67BE:  MOVLW  06
67C0:  MOVWF  x97
67C2:  MOVLW  20
67C4:  MOVWF  xA7
67C6:  CALL   13C0
67CA:  DECFSZ x97,F
67CC:  BRA    67C2
67CE:  MOVLW  DF
67D0:  MOVWF  xA7
67D2:  CALL   13C0
67D6:  MOVLW  43
67D8:  MOVWF  xA7
67DA:  CALL   13C0
....................                         lcd_gotoxy(4,2); 
67DE:  MOVLW  04
67E0:  MOVWF  xA8
67E2:  MOVLW  02
67E4:  MOVWF  xA9
67E6:  CALL   139E
....................                         lcd_send_byte(LCD_ORDEN, LCD_CURSOR); //Activamos el cursor 
67EA:  CLRF   xAC
67EC:  MOVLW  0E
67EE:  MOVWF  xAD
67F0:  CALL   1314
....................  
....................                         //Recogemos el número introducido por el usuario 
....................                         pr.termostato = buscar_numero(); 
67F4:  CALL   3470
67F8:  MOVFF  01,8F
....................  
....................                         //Eliminamos el cursor 
....................                         lcd_send_byte(LCD_ORDEN, LCD_NO_CURSOR); 
67FC:  CLRF   xAC
67FE:  MOVLW  0C
6800:  MOVWF  xAD
6802:  CALL   1314
....................  
....................                         //Retardamos para que el usuario pueda ver el valor que ha introducido 
....................                         delay_ms(LCD_T_RETARDO); 
6806:  MOVLW  02
6808:  MOVWF  x95
680A:  MOVLW  FA
680C:  MOVWF  xAE
680E:  CALL   12A8
6812:  DECFSZ x95,F
6814:  BRA    680A
....................  
....................                         //Si no se cumplen los límites de temperatura especificados para el termostato, no es válido el valor 
....................                         if(pr.termostato>temp_max || pr.termostato<temp_min) 
6816:  MOVF   x8F,W
6818:  SUBLW  20
681A:  BNC   6822
681C:  MOVF   x8F,W
681E:  SUBLW  0F
6820:  BNC   6856
....................                         { 
....................                            //Se muestra un mensaje de error 
....................                            lcd_send_byte(LCD_ORDEN, LCD_CLEAR); 
6822:  CLRF   xAC
6824:  MOVLW  01
6826:  MOVWF  xAD
6828:  CALL   1314
....................                            printf(lcd_putc, "   Valor\n   incorrecto"); 
682C:  CLRF   x95
682E:  MOVF   x95,W
6830:  CALL   0294
6834:  IORLW  00
6836:  BZ    6842
6838:  INCF   x95,F
683A:  MOVWF  xA7
683C:  CALL   13C0
6840:  BRA    682E
....................                            delay_ms(LCD_T_RETARDO); 
6842:  MOVLW  02
6844:  MOVWF  x95
6846:  MOVLW  FA
6848:  MOVWF  xAE
684A:  CALL   12A8
684E:  DECFSZ x95,F
6850:  BRA    6846
....................                            //Se repite la última iteración 
....................                            contador--; 
6852:  DECF   x87,F
....................                            continue; 
6854:  BRA    69AC
....................                         } 
....................  
....................                         //Comprobamos que los intervalos sean correctos respecto a los otros, es decir, 
....................                         //que no haya solapamiento entre los distintos intervalos programados. 
....................                         for(contador2=0; contador2<contador; contador2++) 
6856:  CLRF   x88
6858:  MOVF   x87,W
685A:  SUBWF  x88,W
685C:  BTFSC  FD8.0
685E:  BRA    6988
....................                         { 
....................                            //Tomamos las programaciones almacenadas anteriormente 
....................                            pr2 = programaciones[contador2]; 
6860:  MOVF   x88,W
6862:  MULLW  05
6864:  MOVF   FF3,W
6866:  CLRF   03
6868:  ADDLW  3B
686A:  MOVWF  01
686C:  MOVLW  00
686E:  ADDWFC 03,F
6870:  MOVFF  01,95
6874:  MOVFF  03,96
6878:  CLRF   FEA
687A:  MOVLW  90
687C:  MOVWF  FE9
687E:  MOVFF  03,FE2
6882:  MOVFF  01,FE1
6886:  MOVLW  05
6888:  MOVWF  01
688A:  MOVFF  FE6,FEE
688E:  DECFSZ 01,F
6890:  BRA    688A
....................  
....................                            //Controlamos todas las posibilidades de solapamiento 
....................                            if( 
....................                               (comprobar_hora(pr2.horas_inicio, pr2.minutos_inicio, pr.horas_fin, pr.minutos_fin) && 
....................                               !comprobar_hora(pr2.horas_inicio, pr2.minutos_inicio, pr.horas_inicio, pr.minutos_inicio)) 
....................  
....................                               ||(comprobar_hora(pr2.horas_fin, pr2.minutos_fin, pr.horas_fin, pr.minutos_fin) && 
....................                                 !comprobar_hora(pr2.horas_fin, pr2.minutos_fin, pr.horas_inicio, pr.minutos_inicio)) 
....................  
....................                               ||(comprobar_hora(pr.horas_inicio, pr.minutos_inicio, pr2.horas_fin, pr2.minutos_fin) && 
....................                                 !comprobar_hora(pr.horas_inicio, pr.minutos_inicio, pr2.horas_inicio, pr2.minutos_inicio)) 
....................  
....................                               ||(comprobar_hora(pr.horas_fin, pr.minutos_fin, pr2.horas_fin, pr2.minutos_fin) && 
....................                                 !comprobar_hora(pr.horas_fin, pr.minutos_fin, pr2.horas_inicio, pr2.minutos_inicio)) 
....................                            ) 
6892:  MOVFF  90,AB
6896:  MOVFF  91,AC
689A:  MOVFF  8D,AD
689E:  MOVFF  8E,AE
68A2:  CALL   2AEA
68A6:  MOVF   01,F
68A8:  BZ    68C2
68AA:  MOVFF  90,AB
68AE:  MOVFF  91,AC
68B2:  MOVFF  8B,AD
68B6:  MOVFF  8C,AE
68BA:  CALL   2AEA
68BE:  MOVF   01,F
68C0:  BZ    6952
68C2:  MOVFF  92,AB
68C6:  MOVFF  93,AC
68CA:  MOVFF  8D,AD
68CE:  MOVFF  8E,AE
68D2:  CALL   2AEA
68D6:  MOVF   01,F
68D8:  BZ    68F2
68DA:  MOVFF  92,AB
68DE:  MOVFF  93,AC
68E2:  MOVFF  8B,AD
68E6:  MOVFF  8C,AE
68EA:  CALL   2AEA
68EE:  MOVF   01,F
68F0:  BZ    6952
68F2:  MOVFF  8B,AB
68F6:  MOVFF  8C,AC
68FA:  MOVFF  92,AD
68FE:  MOVFF  93,AE
6902:  CALL   2AEA
6906:  MOVF   01,F
6908:  BZ    6922
690A:  MOVFF  8B,AB
690E:  MOVFF  8C,AC
6912:  MOVFF  90,AD
6916:  MOVFF  91,AE
691A:  CALL   2AEA
691E:  MOVF   01,F
6920:  BZ    6952
6922:  MOVFF  8D,AB
6926:  MOVFF  8E,AC
692A:  MOVFF  92,AD
692E:  MOVFF  93,AE
6932:  CALL   2AEA
6936:  MOVF   01,F
6938:  BZ    6984
693A:  MOVFF  8D,AB
693E:  MOVFF  8E,AC
6942:  MOVFF  90,AD
6946:  MOVFF  91,AE
694A:  CALL   2AEA
694E:  MOVF   01,F
6950:  BNZ   6984
....................                            { 
....................                               //Si hay solapamiento, mostramos un mensaje de error y salimos 
....................                               lcd_send_byte(LCD_ORDEN, LCD_CLEAR); 
6952:  CLRF   xAC
6954:  MOVLW  01
6956:  MOVWF  xAD
6958:  CALL   1314
....................                               printf(lcd_putc, "Solapamiento\nde intervalos!"); 
695C:  CLRF   x95
695E:  MOVF   x95,W
6960:  CALL   03B6
6964:  IORLW  00
6966:  BZ    6972
6968:  INCF   x95,F
696A:  MOVWF  xA7
696C:  CALL   13C0
6970:  BRA    695E
....................                               delay_ms(LCD_T_RETARDO*2); 
6972:  MOVLW  04
6974:  MOVWF  x95
6976:  MOVLW  FA
6978:  MOVWF  xAE
697A:  CALL   12A8
697E:  DECFSZ x95,F
6980:  BRA    6976
....................                               goto salir; 
6982:  BRA    6B98
....................                            } 
....................                         } 
6984:  INCF   x88,F
6986:  BRA    6858
....................  
....................                         //Añadimos esta programación a la lista de programaciones 
....................                         programaciones[contador]=pr; 
6988:  MOVF   x87,W
698A:  MULLW  05
698C:  MOVF   FF3,W
698E:  CLRF   03
6990:  ADDLW  3B
6992:  MOVWF  FE9
6994:  MOVLW  00
6996:  ADDWFC 03,W
6998:  MOVWF  FEA
699A:  CLRF   FE2
699C:  MOVLW  8B
699E:  MOVWF  FE1
69A0:  MOVLW  05
69A2:  MOVWF  01
69A4:  MOVFF  FE6,FEE
69A8:  DECFSZ 01,F
69AA:  BRA    69A4
....................                      } 
69AC:  INCF   x87,F
69AE:  BRA    655E
....................  
....................                      //Mostramos un mensaje 
....................                      lcd_send_byte(LCD_ORDEN,LCD_CLEAR); 
69B0:  CLRF   xAC
69B2:  MOVLW  01
69B4:  MOVWF  xAD
69B6:  CALL   1314
....................                      lcd_send_byte(LCD_ORDEN,LCD_NO_CURSOR); 
69BA:  CLRF   xAC
69BC:  MOVLW  0C
69BE:  MOVWF  xAD
69C0:  CALL   1314
....................                      printf(lcd_putc, "  Aplicando\n  cambios..."); 
69C4:  CLRF   x95
69C6:  MOVF   x95,W
69C8:  CALL   0260
69CC:  IORLW  00
69CE:  BZ    69DA
69D0:  INCF   x95,F
69D2:  MOVWF  xA7
69D4:  CALL   13C0
69D8:  BRA    69C6
....................  
....................                      //Habilitamos la alarma 
....................                      PCF8583_write_byte(PCF8583_CTRL_STATUS_REG, 
....................                                  PCF8583_ACTIVAR_ALARMA); 
69DA:  CLRF   xAD
69DC:  MOVLW  04
69DE:  MOVWF  xAE
69E0:  CALL   169C
....................                      //Habilitamos interrupciones 
....................                      //enable_interrupts(GLOBAL); 
....................  
....................                      //Guardamos el número de intervalos configurados 
....................                      num_intervalos = contador; 
69E4:  MOVFF  87,59
....................  
....................                      //Ordenamos las programaciones por orden de hora de inicio 
....................                      ordenar_programaciones(); 
69E8:  GOTO   35FE
....................  
....................                      //Seleccionamos la próxima alarma a ejecutar 
....................                      seleccionar_alarma(); 
69EC:  GOTO   3736
....................  
....................                      //Programamos la próxima alarma para que salte el reloj en el momento indicado 
....................                      programar_proxima_alarma(); 
69F0:  CALL   29AA
....................  
....................                      //Indicamos que se trata de una alarma de encendido 
....................                      toca_encender = TRUE; 
69F4:  BSF    1F.4
....................  
....................                      //Guardamos las programaciones introducidas 
....................                      grabar_programaciones(); 
69F6:  GOTO   37B8
....................  
....................                      break; 
....................  
....................  
....................             //Si es 4, entramos en el modo de revisión y obtención de datos históricos 
....................             case '4': 
....................                      key = 'J'; //Carácter falso para permitir la entrada de datos 
69FA:  MOVLW  4A
69FC:  MOVWF  38
....................                      //Solicitamos la introducción de una clave 
....................                      lcd_send_byte(LCD_ORDEN, LCD_CLEAR); 
69FE:  CLRF   xAC
6A00:  MOVLW  01
6A02:  MOVWF  xAD
6A04:  CALL   1314
....................                      lcd_send_byte(LCD_ORDEN, LCD_CURSOR); 
6A08:  CLRF   xAC
6A0A:  MOVLW  0E
6A0C:  MOVWF  xAD
6A0E:  CALL   1314
....................                      printf(lcd_putc, "  CLAVE:\n  "); 
6A12:  CLRF   x95
6A14:  MOVF   x95,W
6A16:  CALL   03EC
6A1A:  IORLW  00
6A1C:  BZ    6A28
6A1E:  INCF   x95,F
6A20:  MOVWF  xA7
6A22:  CALL   13C0
6A26:  BRA    6A14
....................  
....................                      //Habilitamos de nuevo el temporizador para evitar 
....................                      //que el menú esté mucho tiempo activo 
....................                      contador_tiempo = 0; 
6A28:  CLRF   7D
....................                      enable_interrupts(INT_TIMER1); 
6A2A:  BSF    F9D.0
....................  
....................                      //Introducimos primero los dos primero dígitos 
....................                      contador = 0; 
6A2C:  CLRF   x87
....................                      while(contador!=2) 
....................                      { 
6A2E:  MOVF   x87,W
6A30:  SUBLW  02
6A32:  BZ    6A74
....................                         key = get_key(); 
6A34:  CALL   3206
6A38:  MOVFF  01,38
....................                         //Si se trata de un número, lo guardamos y mostramos un asterisco 
....................                         //por tratarse de una clave 
....................                         if(isdigit(key)){ 
6A3C:  MOVF   38,W
6A3E:  SUBLW  2F
6A40:  BC    6A6A
6A42:  MOVF   38,W
6A44:  SUBLW  39
6A46:  BNC   6A6A
....................                            //Reseteamos el contador de espera 
....................                            contador_tiempo = 0; 
6A48:  CLRF   7D
....................                            lcd_putc('*'); 
6A4A:  MOVLW  2A
6A4C:  MOVWF  xA7
6A4E:  CALL   13C0
....................                            keys[contador] = key; 
6A52:  CLRF   03
6A54:  MOVF   x87,W
6A56:  ADDLW  39
6A58:  MOVWF  FE9
6A5A:  MOVLW  00
6A5C:  ADDWFC 03,W
6A5E:  MOVWF  FEA
6A60:  MOVFF  38,FEF
....................                            key = 'J'; 
6A64:  MOVLW  4A
6A66:  MOVWF  38
....................                            contador++; 
6A68:  INCF   x87,F
....................                         } 
....................                         //Si transcurre el tiempo máximo, salimos, anulando el flag 
....................                         if(timer_int){ 
6A6A:  BTFSS  1F.7
6A6C:  BRA    6A72
....................                            timer_int = FALSE; 
6A6E:  BCF    1F.7
....................                            goto salir; 
6A70:  BRA    6B98
....................                         } 
....................                      } 
6A72:  BRA    6A2E
....................  
....................                      //Convertimos los dígitos introducidos a un valor numérico 
....................                      numero = atoi(keys); 
6A74:  CLRF   xA9
6A76:  MOVLW  39
6A78:  MOVWF  xA8
6A7A:  CALL   1450
6A7E:  CLRF   03
6A80:  MOVFF  01,89
6A84:  MOVFF  03,8A
....................  
....................                      //Repetimos la operación con los dos dígitos menos significativos 
....................                      contador = 0; 
6A88:  CLRF   x87
....................                      while(contador!=2) 
....................                      { 
6A8A:  MOVF   x87,W
6A8C:  SUBLW  02
6A8E:  BZ    6AD0
....................                         key = get_key(); 
6A90:  CALL   3206
6A94:  MOVFF  01,38
....................                         if(isdigit(key)){ 
6A98:  MOVF   38,W
6A9A:  SUBLW  2F
6A9C:  BC    6AC6
6A9E:  MOVF   38,W
6AA0:  SUBLW  39
6AA2:  BNC   6AC6
....................                            //Reseteamos el contador de espera 
....................                            contador_tiempo = 0; 
6AA4:  CLRF   7D
....................                            lcd_putc('*'); 
6AA6:  MOVLW  2A
6AA8:  MOVWF  xA7
6AAA:  CALL   13C0
....................                            keys[contador] = key; 
6AAE:  CLRF   03
6AB0:  MOVF   x87,W
6AB2:  ADDLW  39
6AB4:  MOVWF  FE9
6AB6:  MOVLW  00
6AB8:  ADDWFC 03,W
6ABA:  MOVWF  FEA
6ABC:  MOVFF  38,FEF
....................                            key = 'J'; 
6AC0:  MOVLW  4A
6AC2:  MOVWF  38
....................                            contador++; 
6AC4:  INCF   x87,F
....................                         } 
....................                         //Si transcurre el tiempo máximo, salimos, suprimiendo el flag 
....................                         if(timer_int){ 
6AC6:  BTFSS  1F.7
6AC8:  BRA    6ACE
....................                            timer_int = FALSE; 
6ACA:  BCF    1F.7
....................                            goto salir; 
6ACC:  BRA    6B98
....................                         } 
....................                      } 
6ACE:  BRA    6A8A
....................  
....................                      //Deshabilitamos el control de la espera 
....................                      disable_interrupts(INT_TIMER1); 
6AD0:  BCF    F9D.0
....................  
....................                      //Construimos la clave a partir de las dos lecturas 
....................                      numero = numero*100 + atoi(keys); 
6AD2:  MOVFF  8A,B3
6AD6:  MOVFF  89,B2
6ADA:  CLRF   xB5
6ADC:  MOVLW  64
6ADE:  MOVWF  xB4
6AE0:  CALL   182C
6AE4:  MOVFF  02,96
6AE8:  MOVFF  01,95
6AEC:  CLRF   xA9
6AEE:  MOVLW  39
6AF0:  MOVWF  xA8
6AF2:  CALL   1450
6AF6:  CLRF   03
6AF8:  MOVF   01,W
6AFA:  BTFSC  FE8.7
6AFC:  DECF   03,F
6AFE:  ADDWF  x95,W
6B00:  MOVWF  01
6B02:  MOVF   x96,W
6B04:  ADDWFC 03,F
6B06:  MOVFF  01,89
6B0A:  MOVFF  03,8A
....................  
....................                      //Retardamos un poco para que el usuario pueda ver que ha introducido 4 dígitos 
....................                      delay_ms(LCD_T_RETARDO); 
6B0E:  MOVLW  02
6B10:  MOVWF  x95
6B12:  MOVLW  FA
6B14:  MOVWF  xAE
6B16:  CALL   12A8
6B1A:  DECFSZ x95,F
6B1C:  BRA    6B12
....................  
....................                      if(numero == clave) 
6B1E:  MOVF   x89,W
6B20:  SUBLW  61
6B22:  BNZ   6B5A
6B24:  MOVF   x8A,W
6B26:  SUBLW  09
6B28:  BNZ   6B5A
....................                      { 
....................                         //Si la clave es correcta, entramos en el modo revisión 
....................                         lcd_send_byte(LCD_ORDEN, LCD_CLEAR); 
6B2A:  CLRF   xAC
6B2C:  MOVLW  01
6B2E:  MOVWF  xAD
6B30:  CALL   1314
....................                         lcd_send_byte(LCD_ORDEN, LCD_NO_CURSOR); 
6B34:  CLRF   xAC
6B36:  MOVLW  0C
6B38:  MOVWF  xAD
6B3A:  CALL   1314
....................                         printf(lcd_putc, "  Modo\n  revision"); 
6B3E:  CLRF   x95
6B40:  MOVF   x95,W
6B42:  CALL   0412
6B46:  IORLW  00
6B48:  BZ    6B54
6B4A:  INCF   x95,F
6B4C:  MOVWF  xA7
6B4E:  CALL   13C0
6B52:  BRA    6B40
....................                         //Representamos el contenido de los registros y activamos la interfaz RS-232 
....................                         representar_registros(); 
6B54:  GOTO   3BBE
....................                      }else 
6B58:  BRA    6B96
....................                      { 
....................                         //Si la clave es incorrecta, lo indicamos y salimos 
....................                         lcd_send_byte(LCD_ORDEN, LCD_CLEAR); 
6B5A:  CLRF   xAC
6B5C:  MOVLW  01
6B5E:  MOVWF  xAD
6B60:  CALL   1314
....................                         lcd_send_byte(LCD_ORDEN, LCD_NO_CURSOR); 
6B64:  CLRF   xAC
6B66:  MOVLW  0C
6B68:  MOVWF  xAD
6B6A:  CALL   1314
....................                         printf(lcd_putc, "  Clave\n  incorrecta"); 
6B6E:  CLRF   x95
6B70:  MOVF   x95,W
6B72:  CALL   043E
6B76:  IORLW  00
6B78:  BZ    6B84
6B7A:  INCF   x95,F
6B7C:  MOVWF  xA7
6B7E:  CALL   13C0
6B82:  BRA    6B70
....................                         delay_ms(LCD_T_RETARDO); 
6B84:  MOVLW  02
6B86:  MOVWF  x95
6B88:  MOVLW  FA
6B8A:  MOVWF  xAE
6B8C:  CALL   12A8
6B90:  DECFSZ x95,F
6B92:  BRA    6B88
....................                         goto salir; 
6B94:  BRA    6B98
....................                      } 
....................  
....................                      break; 
6B96:  BRA    6BD4
....................  
....................  
....................             //Si se pulsa NO, salimos del menú de interfaz con el usuario 
....................             case 'N': 
....................                      //Aquí confluyen todas las salidas de esta rutina 
....................                      salir: 
....................                      //Se muestra un mensaje de finalización 
....................                      lcd_send_byte(LCD_ORDEN,LCD_CLEAR); 
6B98:  CLRF   xAC
6B9A:  MOVLW  01
6B9C:  MOVWF  xAD
6B9E:  CALL   1314
....................                      lcd_send_byte(LCD_ORDEN,LCD_NO_CURSOR); 
6BA2:  CLRF   xAC
6BA4:  MOVLW  0C
6BA6:  MOVWF  xAD
6BA8:  CALL   1314
....................                      printf(lcd_putc, "  Anulando\n  operacion..."); 
6BAC:  CLRF   x95
6BAE:  MOVF   x95,W
6BB0:  CALL   046E
6BB4:  IORLW  00
6BB6:  BZ    6BC2
6BB8:  INCF   x95,F
6BBA:  MOVWF  xA7
6BBC:  CALL   13C0
6BC0:  BRA    6BAE
....................                      delay_ms(LCD_T_RETARDO); 
6BC2:  MOVLW  02
6BC4:  MOVWF  x95
6BC6:  MOVLW  FA
6BC8:  MOVWF  xAE
6BCA:  CALL   12A8
6BCE:  DECFSZ x95,F
6BD0:  BRA    6BC6
....................                      break; 
6BD2:  BRA    6BD4
....................  
....................          } 
....................  
....................          //Volvemos a habilitar las interrupciones 
....................          enable_interrupts(GLOBAL); 
6BD4:  MOVLW  C0
6BD6:  IORWF  FF2,F
....................           
....................  
....................          //Se desactiva el flag de indicación de la interrupción 
....................          led_int = FALSE; 
6BD8:  BCF    1F.5
....................       } 
....................  
....................       //Comenzamos el bloque de comprobación de parámetros y activación de los procesos necesarios. 
....................  
....................       //Comparamos primero la temperatura del agua en la caldera. Esta comprobación se 
....................       //realiza siempre, independientemente de que el sistema esté o no encendido. 
....................       if(C1OUT) 
6BDA:  BTFSS  FB4.6
6BDC:  BRA    6BFC
....................       { 
....................          //Entramos aquí si la temperatura de la caldera es menor que la necesaria 
....................          if(temperatura_caldera_superada) 
6BDE:  BTFSS  1F.0
6BE0:  BRA    6BF2
....................          { 
....................             //Si la temperatura de la caldera estaba superada la última vez, tenemos en cuenta cierta histéresis 
....................             //de los valores. 
....................             if(!comp_caldera()) 
6BE2:  GOTO   5782
6BE6:  MOVF   01,F
6BE8:  BNZ   6BF0
....................             { 
....................                //Si la temperatura de la caldera es menor que la necesaria, encendemos la caldera. 
....................                temperatura_caldera_superada = FALSE; 
6BEA:  BCF    1F.0
....................                encender_caldera(); 
6BEC:  CALL   5948
....................             } 
....................  
....................          } 
....................          else if(!caldera_encendida) 
6BF0:  BRA    6BFA
6BF2:  BTFSC  F83.5
6BF4:  BRA    6BFA
....................          { 
....................             //Si no estaba encendida, la encendemos 
....................             encender_caldera(); 
6BF6:  CALL   5948
....................          } 
....................       } 
....................       else 
6BFA:  BRA    6C0A
....................       { 
....................          //Si la temperatura de la caldera es mayor que la necesaria, apagamos la caldera si está encendida 
....................          //y activamos el flag correspondiente 
....................          if(!temperatura_caldera_superada) 
6BFC:  BTFSC  1F.0
6BFE:  BRA    6C02
....................             temperatura_caldera_superada = TRUE; 
6C00:  BSF    1F.0
....................          if(caldera_encendida) 
6C02:  BTFSS  F83.5
6C04:  BRA    6C0A
....................             apagar_caldera(); 
6C06:  GOTO   5962
....................       } 
....................  
....................       //Leemos el código de estado de los sensores 
....................       valor = comprobar_temperatura(); 
6C0A:  GOTO   5B00
6C0E:  MOVFF  01,84
....................  
....................       //Comprobamos que el sistema no lleve encendido más de 4 horas, ya que en ese caso hay riesgo de avería 
....................       //(en realidad esta limitación deriva de un problema propio de representación en memoria). 
....................       //Ya leimos el tiempo en comprobar_temperatura(), así que no necesitamos leerlo de nuevo. 
....................       if(sistema_encendido && diferencia_tiempo(hora_encendido, minutos_encendido, tiempo.hours, tiempo.minutes)>240) 
6C12:  BTFSS  F83.4
6C14:  BRA    6CBE
6C16:  MOVFF  62,A1
6C1A:  MOVFF  63,A2
6C1E:  MOVFF  5D,A3
6C22:  MOVFF  5C,A4
6C26:  CALL   2B1E
6C2A:  MOVFF  02,96
6C2E:  MOVFF  01,95
6C32:  MOVF   x96,F
6C34:  BNZ   6C3C
6C36:  MOVF   x95,W
6C38:  SUBLW  F0
6C3A:  BC    6CBE
....................       { 
....................          //Si la diferencia de tiempo es mayor que 4 horas, lo indicamos y apagamos los motores y el sistema 
....................          lcd_send_byte(LCD_ORDEN,LCD_CLEAR); 
6C3C:  CLRF   xAC
6C3E:  MOVLW  01
6C40:  MOVWF  xAD
6C42:  CALL   1314
....................          printf(lcd_putc, "Demasiado tiempo\nencendido!"); 
6C46:  CLRF   x95
6C48:  MOVF   x95,W
6C4A:  CALL   04A2
6C4E:  IORLW  00
6C50:  BZ    6C5C
6C52:  INCF   x95,F
6C54:  MOVWF  xA7
6C56:  CALL   13C0
6C5A:  BRA    6C48
....................          delay_ms(2*LCD_T_RETARDO); 
6C5C:  MOVLW  04
6C5E:  MOVWF  x95
6C60:  MOVLW  FA
6C62:  MOVWF  xAE
6C64:  CALL   12A8
6C68:  DECFSZ x95,F
6C6A:  BRA    6C60
....................          lcd_send_byte(LCD_ORDEN,LCD_CLEAR); 
6C6C:  CLRF   xAC
6C6E:  MOVLW  01
6C70:  MOVWF  xAD
6C72:  CALL   1314
....................          printf(lcd_putc, "  Apagando\n  sistema..."); 
6C76:  CLRF   x95
6C78:  MOVF   x95,W
6C7A:  CALL   0196
6C7E:  IORLW  00
6C80:  BZ    6C8C
6C82:  INCF   x95,F
6C84:  MOVWF  xA7
6C86:  CALL   13C0
6C8A:  BRA    6C78
....................          apagar_sistema(); 
6C8C:  CALL   2DB6
....................  
....................          motor1 = FALSE; 
6C90:  BCF    F83.6
....................          motor2 = FALSE; 
6C92:  BCF    F83.7
....................  
....................          //Si estaba encendido por alguna alarma, recuperamos el termostato anterior. 
....................          if(encendido_por_alarma) 
6C94:  BTFSS  1F.3
6C96:  BRA    6CBA
....................          { 
....................             termostato1 = termostato2 = termostato_provisional; 
6C98:  MOVFF  2B,27
6C9C:  MOVFF  2A,26
6CA0:  MOVFF  29,25
6CA4:  MOVFF  28,24
6CA8:  MOVFF  27,23
6CAC:  MOVFF  26,22
6CB0:  MOVFF  25,21
6CB4:  MOVFF  24,20
....................             encendido_por_alarma = FALSE; 
6CB8:  BCF    1F.3
....................          } 
....................  
....................          goto inicio; 
6CBA:  GOTO   5EC4
....................  
....................       } 
....................  
....................       //Comprobamos ahora la temperatura de la vivienda. Esto se realiza sólo si el sistema está encendido 
....................       if(valor && sistema_encendido && temperatura_caldera_superada) 
6CBE:  MOVF   x84,F
6CC0:  BZ    6CE8
6CC2:  BTFSS  F83.4
6CC4:  BRA    6CE8
6CC6:  BTFSS  1F.0
6CC8:  BRA    6CE8
....................       { 
....................          //Si la temperatura es menor que la necesaria, el sistema está encendido y la temperatura del 
....................          //agua en la caldera es la adecuada, encendemos el motor de circulación del agua necesario 
....................          if(valor==1) 
6CCA:  DECFSZ x84,W
6CCC:  BRA    6CD2
....................          { 
....................             motor1 = TRUE; 
6CCE:  BSF    F83.6
....................             motor2 = FALSE; 
6CD0:  BCF    F83.7
....................          } 
....................          if(valor==2) 
6CD2:  MOVF   x84,W
6CD4:  SUBLW  02
6CD6:  BNZ   6CDC
....................          { 
....................             motor1 = FALSE; 
6CD8:  BCF    F83.6
....................             motor2 = TRUE; 
6CDA:  BSF    F83.7
....................          } 
....................          if(valor==3) 
6CDC:  MOVF   x84,W
6CDE:  SUBLW  03
6CE0:  BNZ   6CE6
....................          { 
....................             motor1 = TRUE; 
6CE2:  BSF    F83.6
....................             motor2 = TRUE; 
6CE4:  BSF    F83.7
....................          } 
....................  
....................       } 
....................       else 
6CE6:  BRA    6CEC
....................       { 
....................         //Si no se cumplen las condiciones, apagamos los motores si están encendidos 
....................         motor1 = FALSE; 
6CE8:  BCF    F83.6
....................         motor2 = FALSE; 
6CEA:  BCF    F83.7
....................       } 
....................  
....................       //Activamos el perro guardián y las interrupciones 
....................       setup_wdt(WDT_ON); 
6CEC:  BSF    FD1.0
....................       enable_interrupts(GLOBAL); 
6CEE:  MOVLW  C0
6CF0:  IORWF  FF2,F
....................       //Ponemos a "dormir" al microcontrolador para que el gasto de energía sea menor 
....................       //Esto lo hacemos sólo si no se han levantado los flags de interrupción en estos segundos, 
....................       //ya que esto provocaría que se aplazase la gestión de la interrupción hasta que saltase el 
....................       //perro guardián. 
....................       if(!alarma_int && !led_int) 
6CF2:  BTFSC  1F.6
6CF4:  BRA    6CFC
6CF6:  BTFSC  1F.5
6CF8:  BRA    6CFC
....................          sleep(); 
6CFA:  SLEEP 
....................  
....................    } 
6CFC:  GOTO   5EC4
....................  
.................... } 
....................  
.................... ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 
.................... //**************************************************************************** 
.................... //    Descripción de los métodos utilizados ordenados por orden alfabético 
.................... //**************************************************************************** 
.................... //Puede verse una explicación general de su función al principio del programa 
....................  
.................... void apagar_caldera() 
.................... { 
6D00:  SLEEP 
....................    int hora, minutos, segundos; //Variables para el tiempo 
....................  
....................    //Leemos el tiempo 
....................    PCF8583_read_datetime(&tiempo); 
*
5962:  CLRF   xA2
5964:  MOVLW  5B
5966:  MOVWF  xA1
5968:  CALL   2764
....................    //Habilitamos interrupciones 
....................    //enable_interrupts(GLOBAL); 
....................  
....................    //Copiamos en las variables 
....................    hora = tiempo.hours; 
596C:  MOVFF  5D,95
....................    minutos = tiempo.minutes; 
5970:  MOVFF  5C,96
....................    segundos = tiempo.seconds; 
5974:  MOVFF  5B,97
....................  
....................    //Sumamos al tiempo total de encendido de la caldera el tiempo que ha estado encendida esta vez 
....................    t_total_caldera = t_total_caldera + diferencia_tiempo_sec(hora_caldera, minutos_caldera, segundos_caldera, hora, minutos, segundos); 
5978:  MOVFF  64,A1
597C:  MOVFF  65,A2
5980:  MOVFF  66,A3
5984:  MOVFF  95,A4
5988:  MOVFF  96,A5
598C:  MOVFF  97,A6
5990:  CALL   2C12
5994:  MOVF   01,W
5996:  ADDWF  67,F
5998:  MOVF   02,W
599A:  ADDWFC 68,F
....................  
....................    //Apagamos la caldera 
....................    caldera_encendida = FALSE; 
599C:  BCF    F83.5
.................... } 
599E:  GOTO   6C0A (RETURN)
....................  
.................... //----------------------------------------------------------------------------------------------------------------------------------------- 
....................  
.................... void apagar_sistema() 
.................... { 
....................    long minutos_trans;  //Minutos transcurridos desde el encendido del sistema 
....................    int t_entera, t_decimal; //Temperatura del hogar en ese momento (parte entera y decimal) 
....................    int data[8];  //Vector para almacenar los datos a guardar 
....................  
....................    //Apagamos el sistema 
....................    sistema_encendido = FALSE; 
*
2DB6:  BCF    F83.4
....................  
....................    //Guardamos todos los datos en memoria. Esto llevará tiempo, así que apagamos también los motores 
....................    //para no esperar a la rutina de comprobación de la temperatura 
....................    motor1 = FALSE; 
2DB8:  BCF    F83.6
....................    motor2 = FALSE; 
2DBA:  BCF    F83.7
....................  
....................    //Si llegamos al límite de la memoria, se resetea el indicador 
....................    if((eeprom_registros + num_registros*2*8)>=0x1000) 
2DBC:  BCF    FD8.0
2DBE:  RLCF   69,W
2DC0:  MOVWF  xA1
2DC2:  RLCF   6A,W
2DC4:  MOVWF  xA2
2DC6:  RLCF   xA1,W
2DC8:  MOVWF  02
2DCA:  RLCF   xA2,W
2DCC:  MOVWF  03
2DCE:  RLCF   02,F
2DD0:  RLCF   03,F
2DD2:  RLCF   02,F
2DD4:  RLCF   03,F
2DD6:  MOVLW  F8
2DD8:  ANDWF  02,F
2DDA:  MOVF   02,W
2DDC:  ADDLW  50
2DDE:  MOVWF  xA3
2DE0:  MOVLW  00
2DE2:  ADDWFC 03,W
2DE4:  MOVWF  xA4
2DE6:  SUBLW  0F
2DE8:  BC    2DEE
....................       num_registros = 0; 
2DEA:  CLRF   6A
2DEC:  CLRF   69
....................  
....................    //Leemos el tiempo actual 
....................    PCF8583_read_datetime(&tiempo); 
2DEE:  CLRF   xA2
2DF0:  MOVLW  5B
2DF2:  MOVWF  xA1
2DF4:  RCALL  2764
....................    //Habilitamos interrupciones (se desactivan en el método anterior) 
....................    //enable_interrupts(GLOBAL); 
....................  
....................    //Almacenamos en el vector los valores del tiempo 
....................    data[0] = tiempo.day;                  //Día de desconexión 
2DF6:  MOVFF  5E,99
....................    data[1] = tiempo.month;                //Mes de desconexión 
2DFA:  MOVFF  5F,9A
....................    data[2] = tiempo.hours;                //Hora de desconexión 
2DFE:  MOVFF  5D,9B
....................    data[3] = tiempo.minutes;              //Minutos de desconexión 
2E02:  MOVFF  5C,9C
....................  
....................    //Leemos la temperatura de la zona 1 en ese momento 
....................    temperatura1 = ds1820_read(dir1); 
2E06:  CLRF   xA2
2E08:  MOVLW  6D
2E0A:  MOVWF  xA1
2E0C:  CALL   21B8
2E10:  MOVFF  03,2F
2E14:  MOVFF  02,2E
2E18:  MOVFF  01,2D
2E1C:  MOVFF  00,2C
....................  
....................    //Descomponemos la temperatura en su parte entera y parte decimal para almacenarla 
....................    t_entera = (int)temperatura1; 
2E20:  MOVFF  2F,A8
2E24:  MOVFF  2E,A7
2E28:  MOVFF  2D,A6
2E2C:  MOVFF  2C,A5
2E30:  CALL   17F2
2E34:  MOVFF  01,97
....................    t_decimal = (int)((temperatura1-t_entera)*100); 
2E38:  MOVLB  2
2E3A:  CLRF   xB0
2E3C:  MOVFF  97,2AF
2E40:  MOVLB  0
2E42:  RCALL  26A2
2E44:  BSF    FD8.1
2E46:  MOVFF  2F,2AC
2E4A:  MOVFF  2E,2AB
2E4E:  MOVFF  2D,2AA
2E52:  MOVFF  2C,2A9
2E56:  MOVFF  03,2B0
2E5A:  MOVFF  02,2AF
2E5E:  MOVFF  01,2AE
2E62:  MOVFF  00,2AD
2E66:  CALL   2428
2E6A:  MOVFF  00,A1
2E6E:  MOVFF  01,A2
2E72:  MOVFF  02,A3
2E76:  MOVFF  03,A4
2E7A:  MOVFF  03,2C8
2E7E:  MOVFF  02,2C7
2E82:  MOVFF  01,2C6
2E86:  MOVFF  00,2C5
2E8A:  MOVLB  2
2E8C:  CLRF   xCC
2E8E:  CLRF   xCB
2E90:  MOVLW  48
2E92:  MOVWF  xCA
2E94:  MOVLW  85
2E96:  MOVWF  xC9
2E98:  MOVLB  0
2E9A:  RCALL  29F2
2E9C:  MOVFF  03,A8
2EA0:  MOVFF  02,A7
2EA4:  MOVFF  01,A6
2EA8:  MOVFF  00,A5
2EAC:  CALL   17F2
2EB0:  MOVFF  01,98
....................  
....................    //Almacenamos los valores 
....................    data[4] = t_entera;                    //Valor entero de última temperatura medida en la zona 1 
2EB4:  MOVFF  97,9D
....................    data[5] = t_decimal;                   //Valor decimal de última temperatura medida en la zona 1 
2EB8:  MOVFF  98,9E
....................  
....................    //Repetimos el proceso con la temperatura de la zona 2 
....................    temperatura2 = ds1820_read(dir2); 
2EBC:  CLRF   xA2
2EBE:  MOVLW  75
2EC0:  MOVWF  xA1
2EC2:  CALL   21B8
2EC6:  MOVFF  03,33
2ECA:  MOVFF  02,32
2ECE:  MOVFF  01,31
2ED2:  MOVFF  00,30
....................    t_entera = (int)temperatura2; 
2ED6:  MOVFF  33,A8
2EDA:  MOVFF  32,A7
2EDE:  MOVFF  31,A6
2EE2:  MOVFF  30,A5
2EE6:  CALL   17F2
2EEA:  MOVFF  01,97
....................    t_decimal = (int)((temperatura2-t_entera)*100); 
2EEE:  MOVLB  2
2EF0:  CLRF   xB0
2EF2:  MOVFF  97,2AF
2EF6:  MOVLB  0
2EF8:  CALL   26A2
2EFC:  BSF    FD8.1
2EFE:  MOVFF  33,2AC
2F02:  MOVFF  32,2AB
2F06:  MOVFF  31,2AA
2F0A:  MOVFF  30,2A9
2F0E:  MOVFF  03,2B0
2F12:  MOVFF  02,2AF
2F16:  MOVFF  01,2AE
2F1A:  MOVFF  00,2AD
2F1E:  CALL   2428
2F22:  MOVFF  00,A1
2F26:  MOVFF  01,A2
2F2A:  MOVFF  02,A3
2F2E:  MOVFF  03,A4
2F32:  MOVFF  03,2C8
2F36:  MOVFF  02,2C7
2F3A:  MOVFF  01,2C6
2F3E:  MOVFF  00,2C5
2F42:  MOVLB  2
2F44:  CLRF   xCC
2F46:  CLRF   xCB
2F48:  MOVLW  48
2F4A:  MOVWF  xCA
2F4C:  MOVLW  85
2F4E:  MOVWF  xC9
2F50:  MOVLB  0
2F52:  RCALL  29F2
2F54:  MOVFF  03,A8
2F58:  MOVFF  02,A7
2F5C:  MOVFF  01,A6
2F60:  MOVFF  00,A5
2F64:  CALL   17F2
2F68:  MOVFF  01,98
....................  
....................    //Almacenamos 
....................    data[6] = t_entera;                    //Valor entero de última temperatura medida en la zona 2 
2F6C:  MOVFF  97,9F
....................    data[7] = t_decimal;                   //Valor decimal de última temperatura medida en la zona 2 
2F70:  MOVFF  98,A0
....................  
....................    //Grabamos los datos en memoria 
....................    graba_ee((unsigned long)eeprom_registros + num_registros*(unsigned long)2*(unsigned long)8, 8, data); 
2F74:  BCF    FD8.0
2F76:  RLCF   69,W
2F78:  MOVWF  xA1
2F7A:  RLCF   6A,W
2F7C:  MOVWF  xA2
2F7E:  RLCF   xA1,W
2F80:  MOVWF  02
2F82:  RLCF   xA2,W
2F84:  MOVWF  03
2F86:  RLCF   02,F
2F88:  RLCF   03,F
2F8A:  RLCF   02,F
2F8C:  RLCF   03,F
2F8E:  MOVLW  F8
2F90:  ANDWF  02,F
2F92:  MOVF   02,W
2F94:  ADDLW  50
2F96:  MOVWF  xA3
2F98:  MOVLW  00
2F9A:  ADDWFC 03,W
2F9C:  MOVWF  xA4
2F9E:  MOVWF  xA8
2FA0:  MOVFF  A3,A7
2FA4:  MOVLW  08
2FA6:  MOVWF  xA9
2FA8:  CLRF   xAB
2FAA:  MOVLW  99
2FAC:  MOVWF  xAA
2FAE:  CALL   184A
....................  
....................  
....................    //Calculamos el año en el que nos encontramos 
....................    if(anno_actual_0_to_3 != tiempo.year) 
2FB2:  MOVF   60,W
2FB4:  SUBWF  6C,W
2FB6:  BZ    2FD8
....................    { 
....................       //Si el año que teníamos almacenado no es igual que el que marca el reloj, 
....................       //debemos de actualizar las variables correspondientes. 
....................       anno_actual++; 
2FB8:  INCF   6B,F
....................       anno_actual_0_to_3++; 
2FBA:  INCF   6C,F
....................  
....................       //Guardamos los valores en el vector data 
....................       data[0] = anno_actual; 
2FBC:  MOVFF  6B,99
....................       data[1] = anno_actual_0_to_3; 
2FC0:  MOVFF  6C,9A
....................  
....................       //Guardamos los valores en memoria 
....................       graba_ee(eeprom_anno_actual, 2, data); 
2FC4:  CLRF   xA8
2FC6:  MOVLW  14
2FC8:  MOVWF  xA7
2FCA:  MOVLW  02
2FCC:  MOVWF  xA9
2FCE:  CLRF   xAB
2FD0:  MOVLW  99
2FD2:  MOVWF  xAA
2FD4:  CALL   184A
....................    } 
....................  
....................    //Guardamos el año en el que nos encontramos 
....................    data[0] = anno_actual; 
2FD8:  MOVFF  6B,99
....................  
....................    //Calculamos los minutos transcurridos desde el encendido como una diferencia de tiempos 
....................    minutos_trans = diferencia_tiempo(hora_encendido, minutos_encendido, tiempo.hours, tiempo.minutes); 
2FDC:  MOVFF  62,A1
2FE0:  MOVFF  63,A2
2FE4:  MOVFF  5D,A3
2FE8:  MOVFF  5C,A4
2FEC:  RCALL  2B1E
2FEE:  MOVFF  02,96
2FF2:  MOVFF  01,95
....................  
....................    //Si la caldera estaba encendida, sumamos el último intervalo de encendido al tiempo total 
....................    if(caldera_encendida) 
2FF6:  BTFSS  F83.5
2FF8:  BRA    301C
....................       t_total_caldera = t_total_caldera + diferencia_tiempo_sec(hora_caldera, minutos_caldera, segundos_caldera, tiempo.hours, tiempo.minutes, tiempo.seconds); 
2FFA:  MOVFF  64,A1
2FFE:  MOVFF  65,A2
3002:  MOVFF  66,A3
3006:  MOVFF  5D,A4
300A:  MOVFF  5C,A5
300E:  MOVFF  5B,A6
3012:  RCALL  2C12
3014:  MOVF   01,W
3016:  ADDWF  67,F
3018:  MOVF   02,W
301A:  ADDWFC 68,F
....................  
....................    //Guardamos los dos tiempos calculados 
....................    data[1] = (unsigned int)minutos_trans;          //Minutos transcurridos desde el encendido 
301C:  MOVFF  95,9A
....................    data[2] = (unsigned int)(t_total_caldera/60);   //Tiempo total que ha estado encendida la caldera 
3020:  MOVFF  68,A2
3024:  MOVFF  67,A1
3028:  CLRF   xA4
302A:  MOVLW  3C
302C:  MOVWF  xA3
302E:  BRA    2D70
3030:  MOVFF  01,9B
....................                                                    //en este intervalo (en minutos) 
....................  
....................    //Guardamos también el valor del termostato teniendo en cuenta la histéresis 
....................    if(temp_habitacion_superada1) 
3034:  BTFSS  1F.1
3036:  BRA    3078
....................       data[3]=(int)(termostato1+histeresis_vivienda); 
3038:  BCF    FD8.1
303A:  MOVFF  23,2AC
303E:  MOVFF  22,2AB
3042:  MOVFF  21,2AA
3046:  MOVFF  20,2A9
304A:  MOVFF  37,2B0
304E:  MOVFF  36,2AF
3052:  MOVFF  35,2AE
3056:  MOVFF  34,2AD
305A:  CALL   2428
305E:  MOVFF  03,A8
3062:  MOVFF  02,A7
3066:  MOVFF  01,A6
306A:  MOVFF  00,A5
306E:  CALL   17F2
3072:  MOVFF  01,9C
....................    else 
3076:  BRA    3090
....................       data[3]=(int)termostato1; 
3078:  MOVFF  23,A8
307C:  MOVFF  22,A7
3080:  MOVFF  21,A6
3084:  MOVFF  20,A5
3088:  CALL   17F2
308C:  MOVFF  01,9C
....................  
....................    //Grabamos esta segunda tanda de datos 
....................    graba_ee((unsigned long)eeprom_registros + num_registros*2*8 + 8, 4, data); 
3090:  BCF    FD8.0
3092:  RLCF   69,W
3094:  MOVWF  xA1
3096:  RLCF   6A,W
3098:  MOVWF  xA2
309A:  RLCF   xA1,W
309C:  MOVWF  02
309E:  RLCF   xA2,W
30A0:  MOVWF  03
30A2:  RLCF   02,F
30A4:  RLCF   03,F
30A6:  RLCF   02,F
30A8:  RLCF   03,F
30AA:  MOVLW  F8
30AC:  ANDWF  02,F
30AE:  MOVF   02,W
30B0:  ADDLW  50
30B2:  MOVWF  xA3
30B4:  MOVLW  00
30B6:  ADDWFC 03,W
30B8:  MOVWF  xA4
30BA:  MOVLW  08
30BC:  ADDWF  xA3,W
30BE:  MOVWF  xA5
30C0:  MOVLW  00
30C2:  ADDWFC xA4,W
30C4:  MOVWF  xA6
30C6:  MOVWF  xA8
30C8:  MOVFF  A5,A7
30CC:  MOVLW  04
30CE:  MOVWF  xA9
30D0:  CLRF   xAB
30D2:  MOVLW  99
30D4:  MOVWF  xAA
30D6:  CALL   184A
....................  
....................    //Aumentamos en uno el número de registros 
....................    num_registros++; 
30DA:  INCF   69,F
30DC:  BTFSC  FD8.2
30DE:  INCF   6A,F
....................  
....................    //Guardamos el número de registros en memoria (descomponiendo antes en dos int) 
....................    data[0] = (int)(num_registros/256); 
30E0:  MOVF   6A,W
30E2:  MOVWF  x99
....................    data[1] = (int)(num_registros - data[0]*256); 
30E4:  CLRF   xB3
30E6:  MOVFF  99,B2
30EA:  MOVLW  01
30EC:  MOVWF  xB5
30EE:  CLRF   xB4
30F0:  CALL   182C
30F4:  MOVF   01,W
30F6:  SUBWF  69,W
30F8:  MOVWF  00
30FA:  MOVF   02,W
30FC:  SUBWFB 6A,W
30FE:  MOVFF  00,9A
....................  
....................    graba_ee(eeprom_num_registros, 2, data); 
3102:  CLRF   xA8
3104:  MOVLW  12
3106:  MOVWF  xA7
3108:  MOVLW  02
310A:  MOVWF  xA9
310C:  CLRF   xAB
310E:  MOVLW  99
3110:  MOVWF  xAA
3112:  CALL   184A
.................... } 
3116:  RETLW  00
....................  
.................... //----------------------------------------------------------------------------------------------------------------------------------------- 
....................  
.................... int buscar_numero(){ 
....................    //Variables auxiliares 
....................    int contador = 0; 
*
3470:  CLRF   x95
....................    int numero; 
....................  
....................    //Carácter falso para evitar confusiones 
....................    key = 'J'; 
3472:  MOVLW  4A
3474:  MOVWF  38
....................  
....................    //Habilitamos el temporizador para evitar que el usuario mantenga 
....................    //mucho tiempo el menú activo 
....................    contador_tiempo = 0; 
3476:  CLRF   7D
....................    enable_interrupts(INT_TIMER1); 
3478:  BSF    F9D.0
....................  
....................    //Se continua la búsqueda hasta que no se pulse SI o NO o hasta 
....................    //que no se introduzca un número de 2 cifras. 
....................    while(key != 'N' && key!='S' && contador!=2) 
....................    { 
347A:  MOVF   38,W
347C:  SUBLW  4E
347E:  BZ    34CC
3480:  MOVF   38,W
3482:  SUBLW  53
3484:  BZ    34CC
3486:  MOVF   x95,W
3488:  SUBLW  02
348A:  BZ    34CC
....................       key = get_key(); 
348C:  RCALL  3206
348E:  MOVFF  01,38
....................       //Si la tecla corresponde a un dígito, la imprimimos por pantalla 
....................       //y pasamos a la siguiente 
....................       if(isdigit(key)){ 
3492:  MOVF   38,W
3494:  SUBLW  2F
3496:  BC    34C0
3498:  MOVF   38,W
349A:  SUBLW  39
349C:  BNC   34C0
....................          //Reseteamos el contador de tiempo 
....................          contador_tiempo = 0; 
349E:  CLRF   7D
....................          lcd_putc(key); 
34A0:  MOVFF  38,A7
34A4:  CALL   13C0
....................          keys[contador] = key; 
34A8:  CLRF   03
34AA:  MOVF   x95,W
34AC:  ADDLW  39
34AE:  MOVWF  FE9
34B0:  MOVLW  00
34B2:  ADDWFC 03,W
34B4:  MOVWF  FEA
34B6:  MOVFF  38,FEF
....................          key = 'J'; 
34BA:  MOVLW  4A
34BC:  MOVWF  38
....................          contador++; 
34BE:  INCF   x95,F
....................       } 
....................       //Si salta el tiempo previsto, devuelve el valor de anulación de la operación 
....................       if(timer_int){ 
34C0:  BTFSS  1F.7
34C2:  BRA    34CA
....................          key = 'N'; 
34C4:  MOVLW  4E
34C6:  MOVWF  38
....................          timer_int = FALSE; //Desactivamos el flag 
34C8:  BCF    1F.7
....................       } 
....................    } 
34CA:  BRA    347A
....................  
....................    //Volvemos a deshabilitar la interrupción del timer 
....................    disable_interrupts(INT_TIMER1); 
34CC:  BCF    F9D.0
....................  
....................    //Si la tecla es NO, devolvemos el código correspondiente 
....................    if(key == 'N') 
34CE:  MOVF   38,W
34D0:  SUBLW  4E
34D2:  BNZ   34DA
....................       return NO; 
34D4:  MOVLW  64
34D6:  MOVWF  01
34D8:  BRA    34F8
....................  
....................    //Procedemos de la misma manera si es SÍ 
....................    if(key == 'S') 
34DA:  MOVF   38,W
34DC:  SUBLW  53
34DE:  BNZ   34E6
....................       return SI; 
34E0:  MOVLW  65
34E2:  MOVWF  01
34E4:  BRA    34F8
....................  
....................    //Transformamos los caracteres a entero 
....................    numero = atoi(keys); 
34E6:  CLRF   xA9
34E8:  MOVLW  39
34EA:  MOVWF  xA8
34EC:  CALL   1450
34F0:  MOVFF  01,96
....................  
....................    //Devolvemos el resultado 
....................    return numero; 
34F4:  MOVFF  96,01
.................... } 
34F8:  RETLW  00
....................  
.................... //----------------------------------------------------------------------------------------------------------------------------------------- 
....................  
.................... int buscar_numero_rs232(){ 
....................    char c[3]; //Cadena que contendrá los números en caracteres 
....................  
....................    //Iniciamos los caracteres a valores nulos que no se correspondan con números 
....................    //Además, esto nos servirá para que c[2] marque el fin de la cadena a la hora de aplicar 
....................    //el método atoi(). 
....................    c[0]=c[1]=c[2]='\0'; 
*
15EA:  CLRF   xA7
15EC:  MOVFF  A7,A6
15F0:  MOVFF  A6,A5
....................  
....................    //Leemos la primera cifra del número 
....................    while(!isdigit(c[0]) && c[0]!='\b') 
....................       c[0]=getch(); 
15F4:  MOVF   xA5,W
15F6:  SUBLW  2F
15F8:  BC    1600
15FA:  MOVF   xA5,W
15FC:  SUBLW  39
15FE:  BC    1610
1600:  MOVF   xA5,W
1602:  SUBLW  08
1604:  BZ    1610
1606:  BTFSS  F9E.5
1608:  BRA    1606
160A:  MOVFF  FAE,A5
160E:  BRA    15F4
....................    //Si se trata de un "backspace", devolvemos un mensaje de anulación de operación 
....................    if(c[0]=='\b') 
1610:  MOVF   xA5,W
1612:  SUBLW  08
1614:  BNZ   161C
....................       return NO; 
1616:  MOVLW  64
1618:  MOVWF  01
161A:  BRA    165E
....................    //Imprimimos la primera cifra 
....................    printf("%c", c[0]); 
161C:  MOVF   xA5,W
161E:  BTFSS  F9E.4
1620:  BRA    161E
1622:  MOVWF  FAD
....................  
....................    //Leemos la segunda cifra del número, procediendo de la misma manera 
....................    while(!isdigit(c[1]) && c[1]!='\b') 
....................       c[1]=getch(); 
1624:  MOVF   xA6,W
1626:  SUBLW  2F
1628:  BC    1630
162A:  MOVF   xA6,W
162C:  SUBLW  39
162E:  BC    1640
1630:  MOVF   xA6,W
1632:  SUBLW  08
1634:  BZ    1640
1636:  BTFSS  F9E.5
1638:  BRA    1636
163A:  MOVFF  FAE,A6
163E:  BRA    1624
....................    if(c[1]=='\b') 
1640:  MOVF   xA6,W
1642:  SUBLW  08
1644:  BNZ   164C
....................       return NO; 
1646:  MOVLW  64
1648:  MOVWF  01
164A:  BRA    165E
....................    printf("%c", c[1]); 
164C:  MOVF   xA6,W
164E:  BTFSS  F9E.4
1650:  BRA    164E
1652:  MOVWF  FAD
....................  
....................    //Transformamos a entero la cadena y la devolvemos 
....................    return atoi(c); 
1654:  CLRF   xA9
1656:  MOVLW  A5
1658:  MOVWF  xA8
165A:  RCALL  1450
165C:  MOVF   01,W
.................... } 
165E:  RETLW  00
....................  
.................... //----------------------------------------------------------------------------------------------------------------------------------------- 
....................  
.................... int comp_caldera() 
.................... { 
....................    //Suponemos una variación de la temperatura del agua en la caldera de t_max_calderaºC 
....................    //a t_min_calderaºC, con una precisión que depende del potenciómetro. 
....................  
....................    //Variables para registrar el termostato y la temperatura de la caldera 
....................    float termo, temp; 
....................  
....................    //Establecemos como entrada analógica a analizar la del termostato 
....................    set_adc_channel(termostato_caldera); 
*
5782:  MOVLW  0C
5784:  MOVWF  01
5786:  MOVF   FC2,W
5788:  ANDLW  C3
578A:  IORWF  01,W
578C:  MOVWF  FC2
....................    delay_us(10);  //Retraso para posibilitar la lectura 
578E:  CLRWDT
5790:  MOVLW  06
5792:  MOVWF  00
5794:  DECFSZ 00,F
5796:  BRA    5794
....................    //Transformamos el valor analógico leído en la escala utilizada por el termostato 
....................    termo = t_min_caldera + ((t_max_caldera-t_min_caldera)*(float)read_adc())/AD_num_valores; 
5798:  BSF    FC2.1
579A:  BTFSC  FC2.1
579C:  BRA    579A
579E:  MOVF   FC4,W
57A0:  MOVLB  2
57A2:  CLRF   xB0
57A4:  MOVWF  xAF
57A6:  MOVLB  0
57A8:  CALL   26A2
57AC:  MOVLB  2
57AE:  CLRF   xC8
57B0:  CLRF   xC7
57B2:  MOVLW  48
57B4:  MOVWF  xC6
57B6:  MOVLW  85
57B8:  MOVWF  xC5
57BA:  MOVFF  03,2CC
57BE:  MOVFF  02,2CB
57C2:  MOVFF  01,2CA
57C6:  MOVFF  00,2C9
57CA:  MOVLB  0
57CC:  CALL   29F2
57D0:  MOVFF  00,9D
57D4:  MOVFF  01,9E
57D8:  MOVFF  02,9F
57DC:  MOVFF  03,A0
57E0:  MOVFF  03,2B2
57E4:  MOVFF  02,2B1
57E8:  MOVFF  01,2B0
57EC:  MOVFF  00,2AF
57F0:  MOVLB  2
57F2:  CLRF   xB6
57F4:  CLRF   xB5
57F6:  MOVLW  7F
57F8:  MOVWF  xB4
57FA:  MOVLW  86
57FC:  MOVWF  xB3
57FE:  MOVLB  0
5800:  CALL   2058
5804:  BCF    FD8.1
5806:  MOVLB  2
5808:  CLRF   xAC
580A:  CLRF   xAB
580C:  CLRF   xAA
580E:  CLRF   xA9
5810:  MOVFF  03,2B0
5814:  MOVFF  02,2AF
5818:  MOVFF  01,2AE
581C:  MOVFF  00,2AD
5820:  MOVLB  0
5822:  CALL   2428
5826:  MOVFF  03,98
582A:  MOVFF  02,97
582E:  MOVFF  01,96
5832:  MOVFF  00,95
....................  
....................    //Establecemos como entrada analógica a analizar la de la temperatura del agua 
....................    set_adc_channel(temperatura_caldera); 
5836:  MOVLW  00
5838:  MOVWF  01
583A:  MOVF   FC2,W
583C:  ANDLW  C3
583E:  IORWF  01,W
5840:  MOVWF  FC2
....................    delay_us(10); //Retraso para posibilitar la lectura 
5842:  CLRWDT
5844:  MOVLW  06
5846:  MOVWF  00
5848:  DECFSZ 00,F
584A:  BRA    5848
....................    //Transformamos el valor analógico leído a la escala utlizada en la temperatura 
....................    temp = t_min_caldera + ((t_max_caldera-t_min_caldera)*(float)read_adc())/AD_num_valores; 
584C:  BSF    FC2.1
584E:  BTFSC  FC2.1
5850:  BRA    584E
5852:  MOVF   FC4,W
5854:  MOVLB  2
5856:  CLRF   xB0
5858:  MOVWF  xAF
585A:  MOVLB  0
585C:  CALL   26A2
5860:  MOVLB  2
5862:  CLRF   xC8
5864:  CLRF   xC7
5866:  MOVLW  48
5868:  MOVWF  xC6
586A:  MOVLW  85
586C:  MOVWF  xC5
586E:  MOVFF  03,2CC
5872:  MOVFF  02,2CB
5876:  MOVFF  01,2CA
587A:  MOVFF  00,2C9
587E:  MOVLB  0
5880:  CALL   29F2
5884:  MOVFF  00,9D
5888:  MOVFF  01,9E
588C:  MOVFF  02,9F
5890:  MOVFF  03,A0
5894:  MOVFF  03,2B2
5898:  MOVFF  02,2B1
589C:  MOVFF  01,2B0
58A0:  MOVFF  00,2AF
58A4:  MOVLB  2
58A6:  CLRF   xB6
58A8:  CLRF   xB5
58AA:  MOVLW  7F
58AC:  MOVWF  xB4
58AE:  MOVLW  86
58B0:  MOVWF  xB3
58B2:  MOVLB  0
58B4:  CALL   2058
58B8:  BCF    FD8.1
58BA:  MOVLB  2
58BC:  CLRF   xAC
58BE:  CLRF   xAB
58C0:  CLRF   xAA
58C2:  CLRF   xA9
58C4:  MOVFF  03,2B0
58C8:  MOVFF  02,2AF
58CC:  MOVFF  01,2AE
58D0:  MOVFF  00,2AD
58D4:  MOVLB  0
58D6:  CALL   2428
58DA:  MOVFF  03,9C
58DE:  MOVFF  02,9B
58E2:  MOVFF  01,9A
58E6:  MOVFF  00,99
....................  
....................    //Comparamos ambas temperaturas teniendo en cuenta la histéresis de la caldera 
....................    if(temp > termo-histeresis_caldera) 
58EA:  BSF    FD8.1
58EC:  MOVFF  98,2AC
58F0:  MOVFF  97,2AB
58F4:  MOVFF  96,2AA
58F8:  MOVFF  95,2A9
58FC:  MOVLB  2
58FE:  CLRF   xB0
5900:  CLRF   xAF
5902:  MOVLW  20
5904:  MOVWF  xAE
5906:  MOVLW  82
5908:  MOVWF  xAD
590A:  MOVLB  0
590C:  CALL   2428
5910:  MOVFF  03,A0
5914:  MOVFF  02,9F
5918:  MOVFF  01,9E
591C:  MOVFF  00,9D
5920:  MOVFF  9C,A4
5924:  MOVFF  9B,A3
5928:  MOVFF  9A,A2
592C:  MOVFF  99,A1
5930:  CALL   23B2
5934:  BNC   593E
....................       return TRUE; 
5936:  MOVLW  01
5938:  MOVWF  01
593A:  BRA    5944
....................    else 
593C:  BRA    5944
....................       return FALSE; 
593E:  MOVLW  00
5940:  MOVWF  01
5942:  BRA    5944
.................... } 
5944:  GOTO   6BE6 (RETURN)
....................  
.................... //----------------------------------------------------------------------------------------------------------------------------------------- 
....................  
.................... int comprobar_hora(int hora1, int min1, int hora2, int min2) 
.................... { 
....................    //Si hora1 es menor, devolvemos TRUE 
....................    if(hora1 < hora2) 
*
2AEA:  MOVF   xAD,W
2AEC:  SUBWF  xAB,W
2AEE:  BC    2AF6
....................       return TRUE; 
2AF0:  MOVLW  01
2AF2:  MOVWF  01
2AF4:  BRA    2B1C
....................    //Si hora1 es mayor, devolvemos FALSE 
....................    if(hora1 > hora2) 
2AF6:  MOVF   xAB,W
2AF8:  SUBWF  xAD,W
2AFA:  BC    2B02
....................       return FALSE; 
2AFC:  MOVLW  00
2AFE:  MOVWF  01
2B00:  BRA    2B1C
....................    //Si las horas coinciden habrá que comparar los minutos 
....................    if(hora1==hora2) 
2B02:  MOVF   xAD,W
2B04:  SUBWF  xAB,W
2B06:  BNZ   2B1C
....................    { 
....................       //Se sigue el mismo criterio de antes con la comparación 
....................       //de los minutos. 
....................       if(min1 <= min2) 
2B08:  MOVF   xAC,W
2B0A:  SUBWF  xAE,W
2B0C:  BNC   2B16
....................          return TRUE; 
2B0E:  MOVLW  01
2B10:  MOVWF  01
2B12:  BRA    2B1C
....................       else 
2B14:  BRA    2B1C
....................          return FALSE; 
2B16:  MOVLW  00
2B18:  MOVWF  01
2B1A:  BRA    2B1C
....................    } 
.................... } 
2B1C:  RETLW  00
....................  
.................... //----------------------------------------------------------------------------------------------------------------------------------------- 
....................  
.................... int comprobar_temperatura() 
.................... { 
....................    //Flags auxiliares 
....................    int1 flag1, flag2; 
....................  
....................    //Leemos la temperatura 
....................    temperatura1 = ds1820_read(dir1); 
*
5B00:  CLRF   xA2
5B02:  MOVLW  6D
5B04:  MOVWF  xA1
5B06:  CALL   21B8
5B0A:  MOVFF  03,2F
5B0E:  MOVFF  02,2E
5B12:  MOVFF  01,2D
5B16:  MOVFF  00,2C
....................    temperatura2 = ds1820_read(dir2); 
5B1A:  CLRF   xA2
5B1C:  MOVLW  75
5B1E:  MOVWF  xA1
5B20:  CALL   21B8
5B24:  MOVFF  03,33
5B28:  MOVFF  02,32
5B2C:  MOVFF  01,31
5B30:  MOVFF  00,30
....................  
....................    //Mostramos la información en la pantalla lcd 
....................    mostrar_temperatura(); 
5B34:  BRA    5A1A
....................  
....................    //************************************ 
....................    //NOTA: El termostato no lo hemos implementado con la función ALARM SEARCH del ds1820 
....................    //por dos razones: por necesitar un algoritmo bastante complejo en el caso de dos dispositivos 
....................    //y por que se ha llegado a la conclusión de que consume más memoria y tiempo, ya que 
....................    //de todas formas tenemos que leer las temperaturas para mostrarlas por pantalla. Si se 
....................    //quiere ver un ejemplo de utilización de este modo de termostato del ds1820, en el prototipo 
....................    //construido para probar en la EasyPic3 se ha implementado con un único sensor. 
....................    //************************************ 
....................  
....................    //Nos centramos primero en el sensor 1 
....................    if(temperatura1 < termostato1) 
5B36:  MOVFF  2F,A0
5B3A:  MOVFF  2E,9F
5B3E:  MOVFF  2D,9E
5B42:  MOVFF  2C,9D
5B46:  MOVFF  23,A4
5B4A:  MOVFF  22,A3
5B4E:  MOVFF  21,A2
5B52:  MOVFF  20,A1
5B56:  CALL   23B2
5B5A:  BNC   5B9C
....................    { 
....................       //Si la temperatura es menor que la del termostato, devolvemos TRUE 
....................       if(temp_habitacion_superada1) 
5B5C:  BTFSS  1F.1
5B5E:  BRA    5B98
....................       { 
....................          //Si la temperatura antes era mayor, indicamos el cambio en el flag 
....................          temp_habitacion_superada1 = FALSE; 
5B60:  BCF    1F.1
....................          //Tenemos en cuenta la histéresis para el nuevo valor del termostato 
....................          termostato1 = termostato1 + histeresis_vivienda; 
5B62:  BCF    FD8.1
5B64:  MOVFF  23,2AC
5B68:  MOVFF  22,2AB
5B6C:  MOVFF  21,2AA
5B70:  MOVFF  20,2A9
5B74:  MOVFF  37,2B0
5B78:  MOVFF  36,2AF
5B7C:  MOVFF  35,2AE
5B80:  MOVFF  34,2AD
5B84:  CALL   2428
5B88:  MOVFF  03,23
5B8C:  MOVFF  02,22
5B90:  MOVFF  01,21
5B94:  MOVFF  00,20
....................       } 
....................       flag1 = TRUE; 
5B98:  BSF    x95.0
....................    } 
....................    else 
5B9A:  BRA    5BDA
....................    { 
....................       //Si la temperatura es mayor que la del termostato, devolvemos FALSE 
....................       if(!temp_habitacion_superada1) 
5B9C:  BTFSC  1F.1
5B9E:  BRA    5BD8
....................       { 
....................          //Si antes era menor, cambiamos el flag 
....................          temp_habitacion_superada1 = TRUE; 
5BA0:  BSF    1F.1
....................          //Guardamos el nuevo valor del termostato teniendo en cuenta la histéresis 
....................          termostato1 = termostato1 - histeresis_vivienda; 
5BA2:  BSF    FD8.1
5BA4:  MOVFF  23,2AC
5BA8:  MOVFF  22,2AB
5BAC:  MOVFF  21,2AA
5BB0:  MOVFF  20,2A9
5BB4:  MOVFF  37,2B0
5BB8:  MOVFF  36,2AF
5BBC:  MOVFF  35,2AE
5BC0:  MOVFF  34,2AD
5BC4:  CALL   2428
5BC8:  MOVFF  03,23
5BCC:  MOVFF  02,22
5BD0:  MOVFF  01,21
5BD4:  MOVFF  00,20
....................       } 
....................       flag1 = FALSE; 
5BD8:  BCF    x95.0
....................    } 
....................  
....................    //Repetimos las mismas operaciones para el sensor 2 
....................    if(temperatura2 < termostato2) 
5BDA:  MOVFF  33,A0
5BDE:  MOVFF  32,9F
5BE2:  MOVFF  31,9E
5BE6:  MOVFF  30,9D
5BEA:  MOVFF  27,A4
5BEE:  MOVFF  26,A3
5BF2:  MOVFF  25,A2
5BF6:  MOVFF  24,A1
5BFA:  CALL   23B2
5BFE:  BNC   5C40
....................    { 
....................       //Si la temperatura es menor que la del termostato, devolvemos TRUE 
....................       if(temp_habitacion_superada2) 
5C00:  BTFSS  1F.2
5C02:  BRA    5C3C
....................       { 
....................          //Si la temperatura antes era mayor, indicamos el cambio en el flag 
....................          temp_habitacion_superada2 = FALSE; 
5C04:  BCF    1F.2
....................          //Tenemos en cuenta la histéresis para el nuevo valor del termostato 
....................          termostato2 = termostato2 + histeresis_vivienda; 
5C06:  BCF    FD8.1
5C08:  MOVFF  27,2AC
5C0C:  MOVFF  26,2AB
5C10:  MOVFF  25,2AA
5C14:  MOVFF  24,2A9
5C18:  MOVFF  37,2B0
5C1C:  MOVFF  36,2AF
5C20:  MOVFF  35,2AE
5C24:  MOVFF  34,2AD
5C28:  CALL   2428
5C2C:  MOVFF  03,27
5C30:  MOVFF  02,26
5C34:  MOVFF  01,25
5C38:  MOVFF  00,24
....................       } 
....................       flag2 = TRUE; 
5C3C:  BSF    x95.1
....................    } 
....................    else 
5C3E:  BRA    5C7E
....................    { 
....................       //Si la temperatura es mayor que la del termostato, devolvemos FALSE 
....................       if(!temp_habitacion_superada2) 
5C40:  BTFSC  1F.2
5C42:  BRA    5C7C
....................       { 
....................          //Si antes era menor, cambiamos el flag 
....................          temp_habitacion_superada2 = TRUE; 
5C44:  BSF    1F.2
....................          //Guardamos el nuevo valor del termostato teniendo en cuenta la histéresis 
....................          termostato2 = termostato2 - histeresis_vivienda; 
5C46:  BSF    FD8.1
5C48:  MOVFF  27,2AC
5C4C:  MOVFF  26,2AB
5C50:  MOVFF  25,2AA
5C54:  MOVFF  24,2A9
5C58:  MOVFF  37,2B0
5C5C:  MOVFF  36,2AF
5C60:  MOVFF  35,2AE
5C64:  MOVFF  34,2AD
5C68:  CALL   2428
5C6C:  MOVFF  03,27
5C70:  MOVFF  02,26
5C74:  MOVFF  01,25
5C78:  MOVFF  00,24
....................       } 
....................       flag2 = FALSE; 
5C7C:  BCF    x95.1
....................    } 
....................  
....................    //Devolvemos el código correspondiente según se explica en la definición de la función 
....................    if(!flag1 && !flag2) 
5C7E:  BTFSC  x95.0
5C80:  BRA    5C8C
5C82:  BTFSC  x95.1
5C84:  BRA    5C8C
....................       return 0; 
5C86:  MOVLW  00
5C88:  MOVWF  01
5C8A:  BRA    5CB6
....................    if(flag1 && !flag2) 
5C8C:  BTFSS  x95.0
5C8E:  BRA    5C9A
5C90:  BTFSC  x95.1
5C92:  BRA    5C9A
....................       return 1; 
5C94:  MOVLW  01
5C96:  MOVWF  01
5C98:  BRA    5CB6
....................    if(!flag1 && flag2) 
5C9A:  BTFSC  x95.0
5C9C:  BRA    5CA8
5C9E:  BTFSS  x95.1
5CA0:  BRA    5CA8
....................       return 2; 
5CA2:  MOVLW  02
5CA4:  MOVWF  01
5CA6:  BRA    5CB6
....................    if(flag1 && flag2) 
5CA8:  BTFSS  x95.0
5CAA:  BRA    5CB6
5CAC:  BTFSS  x95.1
5CAE:  BRA    5CB6
....................       return 3; 
5CB0:  MOVLW  03
5CB2:  MOVWF  01
5CB4:  BRA    5CB6
.................... } 
5CB6:  GOTO   6C0E (RETURN)
....................  
.................... //----------------------------------------------------------------------------------------------------------------------------------------- 
....................  
.................... long diferencia_tiempo(int hora1, int min1, int hora2, int min2) 
.................... { 
....................    long dif; 
....................  
....................    //Si hora1:min1 es menor que hora2:min2, devolvemos simplemente la diferencia en minutos 
....................    if(comprobar_hora(hora1,min1,hora2,min2)) 
*
2B1E:  MOVFF  A1,AB
2B22:  MOVFF  A2,AC
2B26:  MOVFF  A3,AD
2B2A:  MOVFF  A4,AE
2B2E:  RCALL  2AEA
2B30:  MOVF   01,F
2B32:  BZ    2B98
....................       dif = ((long)hora2*60 + (long)min2) - ((long)hora1*60 + (long)min1); 
2B34:  CLRF   xA8
2B36:  MOVFF  A3,A7
2B3A:  MOVFF  A8,B3
2B3E:  MOVFF  A3,B2
2B42:  CLRF   xB5
2B44:  MOVLW  3C
2B46:  MOVWF  xB4
2B48:  CALL   182C
2B4C:  MOVFF  02,A9
2B50:  MOVFF  01,A8
2B54:  CLRF   03
2B56:  MOVF   xA4,W
2B58:  ADDWF  01,W
2B5A:  MOVWF  xAA
2B5C:  MOVF   03,W
2B5E:  ADDWFC 02,W
2B60:  MOVWF  xAB
2B62:  CLRF   xAD
2B64:  MOVFF  A1,AC
2B68:  MOVFF  AD,B3
2B6C:  MOVFF  A1,B2
2B70:  CLRF   xB5
2B72:  MOVLW  3C
2B74:  MOVWF  xB4
2B76:  CALL   182C
2B7A:  MOVFF  01,AD
2B7E:  CLRF   03
2B80:  MOVF   xA2,W
2B82:  ADDWF  01,W
2B84:  MOVWF  01
2B86:  MOVF   02,W
2B88:  ADDWFC 03,F
2B8A:  MOVF   01,W
2B8C:  SUBWF  xAA,W
2B8E:  MOVWF  xA5
2B90:  MOVF   03,W
2B92:  SUBWFB xAB,W
2B94:  MOVWF  xA6
....................    //Si no es así, habrá que tener en cuenta que hora1:min1 se encuentra en el día anterior 
....................    //al de hora2:min2 
....................    else 
2B96:  BRA    2C08
....................       dif = (24*60-((long)hora1*60 + (long)min1)) + (long)hora2*60 + (long)min2; 
2B98:  CLRF   xA8
2B9A:  MOVFF  A1,A7
2B9E:  MOVFF  A8,B3
2BA2:  MOVFF  A1,B2
2BA6:  CLRF   xB5
2BA8:  MOVLW  3C
2BAA:  MOVWF  xB4
2BAC:  CALL   182C
2BB0:  MOVFF  02,A9
2BB4:  MOVFF  01,A8
2BB8:  CLRF   03
2BBA:  MOVF   xA2,W
2BBC:  ADDWF  01,W
2BBE:  MOVWF  01
2BC0:  MOVF   02,W
2BC2:  ADDWFC 03,F
2BC4:  MOVF   01,W
2BC6:  XORLW  FF
2BC8:  ADDLW  A1
2BCA:  MOVWF  xAA
2BCC:  MOVLW  05
2BCE:  SUBFWB 03,W
2BD0:  MOVWF  xAB
2BD2:  CLRF   xAD
2BD4:  MOVFF  A3,AC
2BD8:  MOVFF  AD,B3
2BDC:  MOVFF  A3,B2
2BE0:  CLRF   xB5
2BE2:  MOVLW  3C
2BE4:  MOVWF  xB4
2BE6:  CALL   182C
2BEA:  MOVFF  02,03
2BEE:  MOVF   01,W
2BF0:  ADDWF  xAA,W
2BF2:  MOVWF  xAD
2BF4:  MOVF   02,W
2BF6:  ADDWFC xAB,W
2BF8:  MOVWF  xAE
2BFA:  CLRF   03
2BFC:  MOVF   xA4,W
2BFE:  ADDWF  xAD,W
2C00:  MOVWF  xA5
2C02:  MOVF   03,W
2C04:  ADDWFC xAE,W
2C06:  MOVWF  xA6
....................  
....................    //Devolvemos el resultado 
....................    return dif; 
2C08:  MOVFF  A5,01
2C0C:  MOVFF  A6,02
.................... } 
2C10:  RETLW  00
....................  
.................... //----------------------------------------------------------------------------------------------------------------------------------------- 
....................  
.................... long diferencia_tiempo_sec(int hora1, int min1, int sec1, int hora2, int min2, int sec2) 
.................... { 
....................    unsigned long dif; 
....................    unsigned long dif2; 
....................  
....................    //Si hora1:min1 es menor que hora2:min2, ambas horas están en el mismo día 
....................    if(comprobar_hora(hora1,min1,hora2,min2)) 
2C12:  MOVFF  A1,AB
2C16:  MOVFF  A2,AC
2C1A:  MOVFF  A4,AD
2C1E:  MOVFF  A5,AE
2C22:  RCALL  2AEA
2C24:  MOVF   01,F
2C26:  BZ    2CCC
....................    { 
....................       //Si la hora y los minutos son iguales, devolvemos simplemente la diferencia en segundos 
....................       if(hora1==hora2 && min1==min2) 
2C28:  MOVF   xA4,W
2C2A:  SUBWF  xA1,W
2C2C:  BNZ   2C3E
2C2E:  MOVF   xA5,W
2C30:  SUBWF  xA2,W
2C32:  BNZ   2C3E
....................          dif = abs(sec2-sec1); 
2C34:  MOVF   xA3,W
2C36:  SUBWF  xA6,W
2C38:  CLRF   xA8
2C3A:  MOVWF  xA7
....................       else 
2C3C:  BRA    2CCA
....................       { 
....................          //Si no habrá que tener en cuenta también la diferencia entre horas y minutos 
....................          dif2 = ((long)hora2*60 + (long)min2) - ((long)hora1*60 + (long)min1); 
2C3E:  CLRF   xAC
2C40:  MOVFF  A4,AB
2C44:  MOVFF  AC,B3
2C48:  MOVFF  A4,B2
2C4C:  CLRF   xB5
2C4E:  MOVLW  3C
2C50:  MOVWF  xB4
2C52:  CALL   182C
2C56:  MOVFF  02,AD
2C5A:  MOVFF  01,AC
2C5E:  CLRF   03
2C60:  MOVF   xA5,W
2C62:  ADDWF  01,W
2C64:  MOVWF  xAE
2C66:  MOVF   03,W
2C68:  ADDWFC 02,W
2C6A:  MOVWF  xAF
2C6C:  CLRF   xB1
2C6E:  MOVFF  A1,B0
2C72:  MOVFF  B1,B3
2C76:  MOVFF  A1,B2
2C7A:  CLRF   xB5
2C7C:  MOVLW  3C
2C7E:  MOVWF  xB4
2C80:  CALL   182C
2C84:  MOVFF  01,B1
2C88:  CLRF   03
2C8A:  MOVF   xA2,W
2C8C:  ADDWF  01,W
2C8E:  MOVWF  01
2C90:  MOVF   02,W
2C92:  ADDWFC 03,F
2C94:  MOVF   01,W
2C96:  SUBWF  xAE,W
2C98:  MOVWF  xA9
2C9A:  MOVF   03,W
2C9C:  SUBWFB xAF,W
2C9E:  MOVWF  xAA
....................          //No hacemos la diferencia en segundos directamente porque el long no da de sí 
....................          dif = dif2*60 + sec2 - sec1; 
2CA0:  MOVFF  AA,B3
2CA4:  MOVFF  A9,B2
2CA8:  CLRF   xB5
2CAA:  MOVLW  3C
2CAC:  MOVWF  xB4
2CAE:  CALL   182C
2CB2:  MOVF   xA6,W
2CB4:  ADDWF  01,W
2CB6:  MOVWF  xAD
2CB8:  MOVLW  00
2CBA:  ADDWFC 02,W
2CBC:  MOVWF  xAE
2CBE:  MOVF   xA3,W
2CC0:  SUBWF  xAD,W
2CC2:  MOVWF  xA7
2CC4:  MOVLW  00
2CC6:  SUBWFB xAE,W
2CC8:  MOVWF  xA8
....................       } 
....................    } 
....................    else{ 
2CCA:  BRA    2D66
....................       //Si no, simplemente tenemos en cuenta que están en días diferentes y luego le añadimos la 
....................       //diferencia en segundos 
....................       dif2 = (24*60-((long)hora1*60 + (long)min1)) + (long)hora2*60 + (long)min2; 
2CCC:  CLRF   xAC
2CCE:  MOVFF  A1,AB
2CD2:  MOVFF  AC,B3
2CD6:  MOVFF  A1,B2
2CDA:  CLRF   xB5
2CDC:  MOVLW  3C
2CDE:  MOVWF  xB4
2CE0:  CALL   182C
2CE4:  MOVFF  02,AD
2CE8:  MOVFF  01,AC
2CEC:  CLRF   03
2CEE:  MOVF   xA2,W
2CF0:  ADDWF  01,W
2CF2:  MOVWF  01
2CF4:  MOVF   02,W
2CF6:  ADDWFC 03,F
2CF8:  MOVF   01,W
2CFA:  XORLW  FF
2CFC:  ADDLW  A1
2CFE:  MOVWF  xAE
2D00:  MOVLW  05
2D02:  SUBFWB 03,W
2D04:  MOVWF  xAF
2D06:  CLRF   xB1
2D08:  MOVFF  A4,B0
2D0C:  MOVFF  B1,B3
2D10:  MOVFF  A4,B2
2D14:  CLRF   xB5
2D16:  MOVLW  3C
2D18:  MOVWF  xB4
2D1A:  CALL   182C
2D1E:  MOVFF  02,03
2D22:  MOVF   01,W
2D24:  ADDWF  xAE,W
2D26:  MOVWF  xB1
2D28:  MOVF   02,W
2D2A:  ADDWFC xAF,W
2D2C:  MOVWF  xB2
2D2E:  CLRF   03
2D30:  MOVF   xA5,W
2D32:  ADDWF  xB1,W
2D34:  MOVWF  xA9
2D36:  MOVF   03,W
2D38:  ADDWFC xB2,W
2D3A:  MOVWF  xAA
....................       dif = dif2*60 + sec2 - sec1; 
2D3C:  MOVFF  AA,B3
2D40:  MOVFF  A9,B2
2D44:  CLRF   xB5
2D46:  MOVLW  3C
2D48:  MOVWF  xB4
2D4A:  CALL   182C
2D4E:  MOVF   xA6,W
2D50:  ADDWF  01,W
2D52:  MOVWF  xAD
2D54:  MOVLW  00
2D56:  ADDWFC 02,W
2D58:  MOVWF  xAE
2D5A:  MOVF   xA3,W
2D5C:  SUBWF  xAD,W
2D5E:  MOVWF  xA7
2D60:  MOVLW  00
2D62:  SUBWFB xAE,W
2D64:  MOVWF  xA8
....................    } 
....................  
....................    //Devolvemos el resultado 
....................    return dif; 
2D66:  MOVFF  A7,01
2D6A:  MOVFF  A8,02
.................... } 
2D6E:  RETLW  00
....................  
.................... //----------------------------------------------------------------------------------------------------------------------------------------- 
....................  
.................... void encender_caldera() 
.................... { 
....................    //Leemos el tiempo actual 
....................    PCF8583_read_datetime(&tiempo); 
*
5948:  CLRF   xA2
594A:  MOVLW  5B
594C:  MOVWF  xA1
594E:  CALL   2764
....................    //Habilitamos interrupciones (se desactivan en el método anterior) 
....................    //enable_interrupts(GLOBAL); 
....................  
....................    //Guardamos los datos en las variables correspondientes 
....................    hora_caldera = tiempo.hours; 
5952:  MOVFF  5D,64
....................    minutos_caldera = tiempo.minutes; 
5956:  MOVFF  5C,65
....................    segundos_caldera = tiempo.seconds; 
595A:  MOVFF  5B,66
....................  
....................    //Encendemos la caldera 
....................    caldera_encendida = TRUE; 
595E:  BSF    F83.5
.................... } 
5960:  RETLW  00
....................  
.................... //----------------------------------------------------------------------------------------------------------------------------------------- 
....................  
.................... void encender_sistema() 
.................... { 
....................    //Leemos el tiempo actual 
....................    PCF8583_read_datetime(&tiempo); 
*
28EA:  CLRF   xA2
28EC:  MOVLW  5B
28EE:  MOVWF  xA1
28F0:  RCALL  2764
....................    //Habilitamos interrupciones (se desactivan en el método anterior) 
....................    //enable_interrupts(GLOBAL); 
....................  
....................    //Registramos la hora y minutos en los que se enciende el sistema 
....................    hora_encendido    = tiempo.hours; 
28F2:  MOVFF  5D,62
....................    minutos_encendido = tiempo.minutes; 
28F6:  MOVFF  5C,63
....................  
....................    //Inicializamos a 0 el tiempo total que está encendida la caldera 
....................    t_total_caldera = 0; 
28FA:  CLRF   68
28FC:  CLRF   67
....................  
....................    //Si la caldera está encendida, inicializamos el instante de encendido a 
....................    //éste. 
....................    if(caldera_encendida) 
28FE:  BTFSS  F83.5
2900:  BRA    290E
....................    { 
....................       hora_caldera = tiempo.hours; 
2902:  MOVFF  5D,64
....................       minutos_caldera = tiempo.minutes; 
2906:  MOVFF  5C,65
....................       segundos_caldera = tiempo.seconds; 
290A:  MOVFF  5B,66
....................    } 
....................  
....................    //Encendemos el sistema 
....................    sistema_encendido = TRUE; 
290E:  BSF    F83.4
.................... } 
2910:  RETLW  00
....................  
.................... //----------------------------------------------------------------------------------------------------------------------------------------- 
....................  
.................... void grabar_programaciones() 
.................... { 
....................    int datos[5];   //Vector para contener los datos a grabar 
....................    programacion pr; //Variable temporal de programacion 
....................    int contador;   //Contador para el bucle 
....................  
....................    //Recorremos todo el vector de programaciones (hasta el número de programaciones que tengamos) 
....................    for(contador=0; contador<num_intervalos; contador++) 
*
37B8:  CLRF   x9F
37BA:  MOVF   59,W
37BC:  SUBWF  x9F,W
37BE:  BC    3828
....................    { 
....................       //Seleccionamos la programación 
....................       pr = programaciones[contador]; 
37C0:  MOVF   x9F,W
37C2:  MULLW  05
37C4:  MOVF   FF3,W
37C6:  CLRF   03
37C8:  ADDLW  3B
37CA:  MOVWF  01
37CC:  MOVLW  00
37CE:  ADDWFC 03,F
37D0:  MOVFF  01,A0
37D4:  MOVFF  03,A1
37D8:  CLRF   FEA
37DA:  MOVLW  9A
37DC:  MOVWF  FE9
37DE:  MOVFF  03,FE2
37E2:  MOVFF  01,FE1
37E6:  MOVLW  05
37E8:  MOVWF  01
37EA:  MOVFF  FE6,FEE
37EE:  DECFSZ 01,F
37F0:  BRA    37EA
....................  
....................       //Almacenamos los datos en el vector 
....................       datos[0] = pr.horas_inicio; 
37F2:  MOVFF  9A,95
....................       datos[1] = pr.minutos_inicio; 
37F6:  MOVFF  9B,96
....................       datos[2] = pr.horas_fin; 
37FA:  MOVFF  9C,97
....................       datos[3] = pr.minutos_fin; 
37FE:  MOVFF  9D,98
....................       datos[4] = pr.termostato; 
3802:  MOVFF  9E,99
....................  
....................       //Guardamos los datos en la posición de memoria correspondiente de la EEPROM 
....................       graba_ee(eeprom_programaciones + (contador+1)*8, 5, datos); 
3806:  MOVLW  01
3808:  ADDWF  x9F,W
380A:  MULLW  08
380C:  MOVF   FF3,W
380E:  ADDLW  18
3810:  MOVWF  xA1
3812:  CLRF   xA8
3814:  MOVWF  xA7
3816:  MOVLW  05
3818:  MOVWF  xA9
381A:  CLRF   xAB
381C:  MOVLW  95
381E:  MOVWF  xAA
3820:  CALL   184A
....................    } 
3824:  INCF   x9F,F
3826:  BRA    37BA
....................  
....................    //Guardamos en la EEPROM en el número de intervalos 
....................    graba_ee(eeprom_num_intervalos, 1, &num_intervalos); 
3828:  CLRF   xA8
382A:  MOVLW  11
382C:  MOVWF  xA7
382E:  MOVLW  01
3830:  MOVWF  xA9
3832:  CLRF   xAB
3834:  MOVLW  59
3836:  MOVWF  xAA
3838:  CALL   184A
....................  
....................    //He optado por escribir de programación en programación porque a pesar de que 
....................    //en el datasheet aseguran que la memoria tiene una paginación de 32 bytes en la 
....................    //simulación parece tener menos, así que de este modo nos evitamos problemas 
.................... } 
383C:  GOTO   6BD4 (RETURN)
....................  
.................... //----------------------------------------------------------------------------------------------------------------------------------------- 
....................  
.................... void inicializacion() 
.................... { 
....................    //NOTA: todos los pequeños retardos introducidos en esta rutina sirven para que el técnico 
....................    //no se sienta atosigado por los continuos mensajes que le aparecen solicitándole información. 
....................  
....................  
....................    //Variables para introducir los datos de fecha y hora 
....................    int weekday, dia, mes, anno, horas, minutos; 
....................    //Variable para escritura en memoria 
....................    int data[8]; 
....................    char c[2]; //Cadena para la conversión a int 
....................  
....................    //Comenzamos pidiendo la introducción de la fecha 
....................    //Es una lástima que en RS232 no se vean bien las tildes 
....................    e1: 
....................    printf("\rInicializacion del sistema\r"); 
*
18B2:  CLRF   xA5
18B4:  MOVF   xA5,W
18B6:  CALL   04D8
18BA:  IORLW  00
18BC:  BZ    18C8
18BE:  INCF   xA5,F
18C0:  BTFSS  F9E.4
18C2:  BRA    18C0
18C4:  MOVWF  FAD
18C6:  BRA    18B4
....................    printf("**************************\r"); 
18C8:  CLRF   xA5
18CA:  MOVF   xA5,W
18CC:  CALL   0510
18D0:  IORLW  00
18D2:  BZ    18DE
18D4:  INCF   xA5,F
18D6:  BTFSS  F9E.4
18D8:  BRA    18D6
18DA:  MOVWF  FAD
18DC:  BRA    18CA
....................    //Primero solicitamos el día de la semana 
....................    printf("Dia de la semana (1->Lunes, 2->Martes, ...): LUNES    "); 
18DE:  CLRF   xA5
18E0:  MOVF   xA5,W
18E2:  CALL   0546
18E6:  IORLW  00
18E8:  BZ    18F4
18EA:  INCF   xA5,F
18EC:  BTFSS  F9E.4
18EE:  BRA    18EC
18F0:  MOVWF  FAD
18F2:  BRA    18E0
....................  
....................    //En principio se indica que es lunes 
....................    weekday = 0; 
18F4:  CLRF   x95
....................  
....................    //Inicializamos el vector de caracteres a \0 por dos motivos según la posición: 
....................    //c[0] para que no se elija un día indeseado sin intervención del técnico y c[1], 
....................    //para marcar el fin de la cadena. 
....................    c[0]=c[1]='\0'; 
18F6:  CLRF   xA4
18F8:  MOVFF  A4,A3
....................  
....................    //Iteramos en el bucle hasta que no se pulse ENTER 
....................    while(c[0]!=13){ 
18FC:  MOVF   xA3,W
18FE:  SUBLW  0D
1900:  BTFSC  FD8.2
1902:  BRA    19CE
....................       //Guardamos el caracter leído 
....................       c[0]=getch(); 
1904:  BTFSS  F9E.5
1906:  BRA    1904
1908:  MOVFF  FAE,A3
....................  
....................       //Además se asigna un valor numérico a la variable weekday para almacenarla en el reloj. 
....................       weekday=atoi(c)-1; 
190C:  CLRF   xA9
190E:  MOVLW  A3
1910:  MOVWF  xA8
1912:  RCALL  1450
1914:  MOVLW  01
1916:  SUBWF  01,W
1918:  MOVWF  x95
....................  
....................       //Según el día introducido, imprimimos un resultado u otro por pantalla, borrando el 
....................       //anterior. Para ello, todos los días ocupan el tamaño del mayor (miércoles) gracias a espacios. 
....................       switch(weekday) 
....................       { 
191A:  MOVF   x95,W
191C:  ADDLW  F9
191E:  BC    19CC
1920:  ADDLW  07
1922:  GOTO   1DBA
....................          case 0: printf("\b\b\b\b\b\b\b\b\bLUNES    "); 
1926:  CLRF   xA5
1928:  MOVF   xA5,W
192A:  CALL   0598
192E:  IORLW  00
1930:  BZ    193C
1932:  INCF   xA5,F
1934:  BTFSS  F9E.4
1936:  BRA    1934
1938:  MOVWF  FAD
193A:  BRA    1928
....................                  break; 
193C:  BRA    19CC
....................          case 1: printf("\b\b\b\b\b\b\b\b\bMARTES   "); 
193E:  CLRF   xA5
1940:  MOVF   xA5,W
1942:  CALL   05C6
1946:  IORLW  00
1948:  BZ    1954
194A:  INCF   xA5,F
194C:  BTFSS  F9E.4
194E:  BRA    194C
1950:  MOVWF  FAD
1952:  BRA    1940
....................                  break; 
1954:  BRA    19CC
....................          case 2: printf("\b\b\b\b\b\b\b\b\bMIERCOLES"); 
1956:  CLRF   xA5
1958:  MOVF   xA5,W
195A:  CALL   05F4
195E:  IORLW  00
1960:  BZ    196C
1962:  INCF   xA5,F
1964:  BTFSS  F9E.4
1966:  BRA    1964
1968:  MOVWF  FAD
196A:  BRA    1958
....................                  break; 
196C:  BRA    19CC
....................          case 3: printf("\b\b\b\b\b\b\b\b\bJUEVES   "); 
196E:  CLRF   xA5
1970:  MOVF   xA5,W
1972:  CALL   0622
1976:  IORLW  00
1978:  BZ    1984
197A:  INCF   xA5,F
197C:  BTFSS  F9E.4
197E:  BRA    197C
1980:  MOVWF  FAD
1982:  BRA    1970
....................                  break; 
1984:  BRA    19CC
....................          case 4: printf("\b\b\b\b\b\b\b\b\bVIERNES  "); 
1986:  CLRF   xA5
1988:  MOVF   xA5,W
198A:  CALL   0650
198E:  IORLW  00
1990:  BZ    199C
1992:  INCF   xA5,F
1994:  BTFSS  F9E.4
1996:  BRA    1994
1998:  MOVWF  FAD
199A:  BRA    1988
....................                  break; 
199C:  BRA    19CC
....................          case 5: printf("\b\b\b\b\b\b\b\b\bSABADO   "); 
199E:  CLRF   xA5
19A0:  MOVF   xA5,W
19A2:  CALL   067E
19A6:  IORLW  00
19A8:  BZ    19B4
19AA:  INCF   xA5,F
19AC:  BTFSS  F9E.4
19AE:  BRA    19AC
19B0:  MOVWF  FAD
19B2:  BRA    19A0
....................                  break; 
19B4:  BRA    19CC
....................          case 6: printf("\b\b\b\b\b\b\b\b\bDOMINGO  "); 
19B6:  CLRF   xA5
19B8:  MOVF   xA5,W
19BA:  CALL   06AC
19BE:  IORLW  00
19C0:  BZ    19CC
19C2:  INCF   xA5,F
19C4:  BTFSS  F9E.4
19C6:  BRA    19C4
19C8:  MOVWF  FAD
19CA:  BRA    19B8
....................       } 
....................    } 
19CC:  BRA    18FC
....................  
....................    //Pedimos la introducción de la fecha 
....................    printf("\rFECHA: "); 
19CE:  CLRF   xA5
19D0:  MOVF   xA5,W
19D2:  CALL   06DA
19D6:  IORLW  00
19D8:  BZ    19E4
19DA:  INCF   xA5,F
19DC:  BTFSS  F9E.4
19DE:  BRA    19DC
19E0:  MOVWF  FAD
19E2:  BRA    19D0
....................  
....................    //Leemos el día del mes 
....................    dia = buscar_numero_rs232(); 
19E4:  RCALL  15EA
19E6:  MOVFF  01,96
....................    //Si pulsamos "backspace", se resetea la inicialización 
....................    if(dia==NO) 
19EA:  MOVF   x96,W
19EC:  SUBLW  64
19EE:  BNZ   1A08
....................    { 
....................       printf("\rReseteando inicializacion...\r"); 
19F0:  CLRF   xA5
19F2:  MOVF   xA5,W
19F4:  CALL   06FE
19F8:  IORLW  00
19FA:  BZ    1A06
19FC:  INCF   xA5,F
19FE:  BTFSS  F9E.4
1A00:  BRA    19FE
1A02:  MOVWF  FAD
1A04:  BRA    19F2
....................       goto e1; 
1A06:  BRA    18B2
....................    } 
....................    //Si el día introducido no es válido, también reseteamos la inicialización 
....................    if(dia>31 || dia==0) 
1A08:  MOVF   x96,W
1A0A:  SUBLW  1F
1A0C:  BNC   1A12
1A0E:  MOVF   x96,F
1A10:  BNZ   1A38
....................    { 
....................       printf("\rDia incorrecto. Reseteando inicializacion...\r"); 
1A12:  CLRF   xA5
1A14:  MOVF   xA5,W
1A16:  CALL   0738
1A1A:  IORLW  00
1A1C:  BZ    1A28
1A1E:  INCF   xA5,F
1A20:  BTFSS  F9E.4
1A22:  BRA    1A20
1A24:  MOVWF  FAD
1A26:  BRA    1A14
....................       delay_ms(LCD_T_RETARDO); 
1A28:  MOVLW  02
1A2A:  MOVWF  xA5
1A2C:  MOVLW  FA
1A2E:  MOVWF  xAE
1A30:  RCALL  12A8
1A32:  DECFSZ xA5,F
1A34:  BRA    1A2C
....................       goto e1; 
1A36:  BRA    18B2
....................    } 
....................  
....................    //Leemos el mes 
....................    printf("/"); 
1A38:  CLRF   xA5
1A3A:  MOVF   xA5,W
1A3C:  CALL   0782
1A40:  IORLW  00
1A42:  BZ    1A4E
1A44:  INCF   xA5,F
1A46:  BTFSS  F9E.4
1A48:  BRA    1A46
1A4A:  MOVWF  FAD
1A4C:  BRA    1A3A
....................    mes = buscar_numero_rs232(); 
1A4E:  RCALL  15EA
1A50:  MOVFF  01,97
....................    //Si pulsamos "backspace", se resetea la inicialización 
....................    if(mes==NO) 
1A54:  MOVF   x97,W
1A56:  SUBLW  64
1A58:  BNZ   1A72
....................    { 
....................       printf("\rReseteando inicializacion...\r"); 
1A5A:  CLRF   xA5
1A5C:  MOVF   xA5,W
1A5E:  CALL   06FE
1A62:  IORLW  00
1A64:  BZ    1A70
1A66:  INCF   xA5,F
1A68:  BTFSS  F9E.4
1A6A:  BRA    1A68
1A6C:  MOVWF  FAD
1A6E:  BRA    1A5C
....................       goto e1; 
1A70:  BRA    18B2
....................    } 
....................    //Si el mes introducido no es válido, reseteamos la inicialización de igual modo 
....................    if(mes>12 || mes==0) 
1A72:  MOVF   x97,W
1A74:  SUBLW  0C
1A76:  BNC   1A7C
1A78:  MOVF   x97,F
1A7A:  BNZ   1AA2
....................    { 
....................       printf("\rMes incorrecto. Reseteando inicializacion...\r"); 
1A7C:  CLRF   xA5
1A7E:  MOVF   xA5,W
1A80:  CALL   079E
1A84:  IORLW  00
1A86:  BZ    1A92
1A88:  INCF   xA5,F
1A8A:  BTFSS  F9E.4
1A8C:  BRA    1A8A
1A8E:  MOVWF  FAD
1A90:  BRA    1A7E
....................       delay_ms(LCD_T_RETARDO); 
1A92:  MOVLW  02
1A94:  MOVWF  xA5
1A96:  MOVLW  FA
1A98:  MOVWF  xAE
1A9A:  RCALL  12A8
1A9C:  DECFSZ xA5,F
1A9E:  BRA    1A96
....................       goto e1; 
1AA0:  BRA    18B2
....................    } 
....................  
....................    //Si el día introducido no se encuentra en el mes seleccionado, mostramos un mensaje 
....................    //de error y reseteamos la operación 
....................    if((dia>29 && mes==2)||(dia==31 && (mes==4 || mes==6 || mes==9 || mes==11))) 
1AA2:  MOVF   x96,W
1AA4:  SUBLW  1D
1AA6:  BC    1AAE
1AA8:  MOVF   x97,W
1AAA:  SUBLW  02
1AAC:  BZ    1ACC
1AAE:  MOVF   x96,W
1AB0:  SUBLW  1F
1AB2:  BNZ   1AF4
1AB4:  MOVF   x97,W
1AB6:  SUBLW  04
1AB8:  BZ    1ACC
1ABA:  MOVF   x97,W
1ABC:  SUBLW  06
1ABE:  BZ    1ACC
1AC0:  MOVF   x97,W
1AC2:  SUBLW  09
1AC4:  BZ    1ACC
1AC6:  MOVF   x97,W
1AC8:  SUBLW  0B
1ACA:  BNZ   1AF4
....................    { 
....................       printf("\rError en la fecha. Reseteando inicializacion...\r"); 
1ACC:  CLRF   xA5
1ACE:  MOVF   xA5,W
1AD0:  CALL   07E8
1AD4:  IORLW  00
1AD6:  BZ    1AE2
1AD8:  INCF   xA5,F
1ADA:  BTFSS  F9E.4
1ADC:  BRA    1ADA
1ADE:  MOVWF  FAD
1AE0:  BRA    1ACE
....................       delay_ms(LCD_T_RETARDO); 
1AE2:  MOVLW  02
1AE4:  MOVWF  xA5
1AE6:  MOVLW  FA
1AE8:  MOVWF  xAE
1AEA:  CALL   12A8
1AEE:  DECFSZ xA5,F
1AF0:  BRA    1AE6
....................       goto e1; 
1AF2:  BRA    18B2
....................    } 
....................  
....................    //Leemos el año 
....................    printf("/"); 
1AF4:  CLRF   xA5
1AF6:  MOVF   xA5,W
1AF8:  CALL   0782
1AFC:  IORLW  00
1AFE:  BZ    1B0A
1B00:  INCF   xA5,F
1B02:  BTFSS  F9E.4
1B04:  BRA    1B02
1B06:  MOVWF  FAD
1B08:  BRA    1AF6
....................    anno = buscar_numero_rs232(); 
1B0A:  RCALL  15EA
1B0C:  MOVFF  01,98
....................    //Si pulsamos "backspace", se resetea la inicialización 
....................    if(anno==NO) 
1B10:  MOVF   x98,W
1B12:  SUBLW  64
1B14:  BNZ   1B3E
....................    { 
....................       printf("\rReseteando inicializacion...\r"); 
1B16:  CLRF   xA5
1B18:  MOVF   xA5,W
1B1A:  CALL   06FE
1B1E:  IORLW  00
1B20:  BZ    1B2C
1B22:  INCF   xA5,F
1B24:  BTFSS  F9E.4
1B26:  BRA    1B24
1B28:  MOVWF  FAD
1B2A:  BRA    1B18
....................       delay_ms(LCD_T_RETARDO); 
1B2C:  MOVLW  02
1B2E:  MOVWF  xA5
1B30:  MOVLW  FA
1B32:  MOVWF  xAE
1B34:  CALL   12A8
1B38:  DECFSZ xA5,F
1B3A:  BRA    1B30
....................       goto e1; 
1B3C:  BRA    18B2
....................    } 
....................    //Si el valor del año es incorrecto, reseteamos también la inicialización. 
....................    //Tampoco se permite un año menor que 2009 (año de fabricación del sistema de control) 
....................    if(anno>99 || anno<9) 
1B3E:  MOVF   x98,W
1B40:  SUBLW  63
1B42:  BNC   1B4A
1B44:  MOVF   x98,W
1B46:  SUBLW  08
1B48:  BNC   1B72
....................    { 
....................       printf("\rAnno incorrecto. Reseteando inicializacion...\r"); 
1B4A:  CLRF   xA5
1B4C:  MOVF   xA5,W
1B4E:  CALL   0834
1B52:  IORLW  00
1B54:  BZ    1B60
1B56:  INCF   xA5,F
1B58:  BTFSS  F9E.4
1B5A:  BRA    1B58
1B5C:  MOVWF  FAD
1B5E:  BRA    1B4C
....................       delay_ms(LCD_T_RETARDO); 
1B60:  MOVLW  02
1B62:  MOVWF  xA5
1B64:  MOVLW  FA
1B66:  MOVWF  xAE
1B68:  CALL   12A8
1B6C:  DECFSZ xA5,F
1B6E:  BRA    1B64
....................       goto e1; 
1B70:  BRA    18B2
....................    } 
....................  
....................  
....................    //Si el año no es bisiesto y hemos seleccionado el 29 de febrero, 
....................    //mostramos un mensaje y reseteamos la operación. 
....................    if(anno%4!=0 && mes==2 && dia==29) 
1B72:  MOVF   x98,W
1B74:  ANDLW  03
1B76:  BZ    1BAC
1B78:  MOVF   x97,W
1B7A:  SUBLW  02
1B7C:  BNZ   1BAC
1B7E:  MOVF   x96,W
1B80:  SUBLW  1D
1B82:  BNZ   1BAC
....................    { 
....................       printf("\rEl anno no es bisiesto. Reseteando inicializacion...\r"); 
1B84:  CLRF   xA5
1B86:  MOVF   xA5,W
1B88:  CALL   087E
1B8C:  IORLW  00
1B8E:  BZ    1B9A
1B90:  INCF   xA5,F
1B92:  BTFSS  F9E.4
1B94:  BRA    1B92
1B96:  MOVWF  FAD
1B98:  BRA    1B86
....................       delay_ms(LCD_T_RETARDO); 
1B9A:  MOVLW  02
1B9C:  MOVWF  xA5
1B9E:  MOVLW  FA
1BA0:  MOVWF  xAE
1BA2:  CALL   12A8
1BA6:  DECFSZ xA5,F
1BA8:  BRA    1B9E
....................       goto e1; 
1BAA:  BRA    18B2
....................    } 
....................  
....................    //Introducimos un pequeño retardo para que el técnico vea los valores introducidos 
....................    delay_ms(LCD_T_RETARDO); 
1BAC:  MOVLW  02
1BAE:  MOVWF  xA5
1BB0:  MOVLW  FA
1BB2:  MOVWF  xAE
1BB4:  CALL   12A8
1BB8:  DECFSZ xA5,F
1BBA:  BRA    1BB0
....................  
....................    //Calculamos el año en el intervalo de 0 a 3 según sean bisiesto este año 
....................    //o los anteriores. 
....................    if(anno%4==0) 
1BBC:  MOVF   x98,W
1BBE:  ANDLW  03
1BC0:  BNZ   1BC6
....................       anno_actual_0_to_3 = 0; 
1BC2:  CLRF   6C
....................    else if((anno-1)%4==0) 
1BC4:  BRA    1BEE
1BC6:  MOVLW  01
1BC8:  SUBWF  x98,W
1BCA:  ANDLW  03
1BCC:  BNZ   1BD4
....................       anno_actual_0_to_3 = 1; 
1BCE:  MOVLW  01
1BD0:  MOVWF  6C
....................    else if((anno-2)%4==0) 
1BD2:  BRA    1BEE
1BD4:  MOVLW  02
1BD6:  SUBWF  x98,W
1BD8:  ANDLW  03
1BDA:  BNZ   1BE2
....................       anno_actual_0_to_3 = 2; 
1BDC:  MOVLW  02
1BDE:  MOVWF  6C
....................    else if((anno-3)%4==0) 
1BE0:  BRA    1BEE
1BE2:  MOVLW  03
1BE4:  SUBWF  x98,W
1BE6:  ANDLW  03
1BE8:  BNZ   1BEE
....................       anno_actual_0_to_3 = 3; 
1BEA:  MOVLW  03
1BEC:  MOVWF  6C
....................  
....................    e2: 
....................    //Se pide la introducción de la hora 
....................    printf("\rHORA: "); 
1BEE:  CLRF   xA5
1BF0:  MOVF   xA5,W
1BF2:  CALL   08D0
1BF6:  IORLW  00
1BF8:  BZ    1C04
1BFA:  INCF   xA5,F
1BFC:  BTFSS  F9E.4
1BFE:  BRA    1BFC
1C00:  MOVWF  FAD
1C02:  BRA    1BF0
....................  
....................    //Leemos la hora 
....................    horas = buscar_numero_rs232(); 
1C04:  RCALL  15EA
1C06:  MOVFF  01,99
....................    //Si se pulsa "backspace", se resetea todo el proceso 
....................    if(horas==NO) 
1C0A:  MOVF   x99,W
1C0C:  SUBLW  64
1C0E:  BNZ   1C38
....................    { 
....................       printf("\rReseteando la inicializacion...\r"); 
1C10:  CLRF   xA5
1C12:  MOVF   xA5,W
1C14:  CALL   08F2
1C18:  IORLW  00
1C1A:  BZ    1C26
1C1C:  INCF   xA5,F
1C1E:  BTFSS  F9E.4
1C20:  BRA    1C1E
1C22:  MOVWF  FAD
1C24:  BRA    1C12
....................       delay_ms(LCD_T_RETARDO); 
1C26:  MOVLW  02
1C28:  MOVWF  xA5
1C2A:  MOVLW  FA
1C2C:  MOVWF  xAE
1C2E:  CALL   12A8
1C32:  DECFSZ xA5,F
1C34:  BRA    1C2A
....................       goto e1; 
1C36:  BRA    18B2
....................    } 
....................    //Si las horas son incorrectas, mostramos un mensaje de error por pantalla y 
....................    //reseteamos la introducción de la misma. 
....................    if(horas>23) 
1C38:  MOVF   x99,W
1C3A:  SUBLW  17
1C3C:  BC    1C66
....................    { 
....................       printf("  Hora incorrecta!"); 
1C3E:  CLRF   xA5
1C40:  MOVF   xA5,W
1C42:  CALL   092E
1C46:  IORLW  00
1C48:  BZ    1C54
1C4A:  INCF   xA5,F
1C4C:  BTFSS  F9E.4
1C4E:  BRA    1C4C
1C50:  MOVWF  FAD
1C52:  BRA    1C40
....................       delay_ms(LCD_T_RETARDO); 
1C54:  MOVLW  02
1C56:  MOVWF  xA5
1C58:  MOVLW  FA
1C5A:  MOVWF  xAE
1C5C:  CALL   12A8
1C60:  DECFSZ xA5,F
1C62:  BRA    1C58
....................       goto e2; 
1C64:  BRA    1BEE
....................    } 
....................  
....................  
....................    //Leemos los minutos 
....................    printf(":"); 
1C66:  CLRF   xA5
1C68:  MOVF   xA5,W
1C6A:  CALL   095C
1C6E:  IORLW  00
1C70:  BZ    1C7C
1C72:  INCF   xA5,F
1C74:  BTFSS  F9E.4
1C76:  BRA    1C74
1C78:  MOVWF  FAD
1C7A:  BRA    1C68
....................    minutos = buscar_numero_rs232(); 
1C7C:  RCALL  15EA
1C7E:  MOVFF  01,9A
....................  
....................    //Si se pulsa "backspace", reseteamos la inicialización completa 
....................    if(minutos==NO) 
1C82:  MOVF   x9A,W
1C84:  SUBLW  64
1C86:  BNZ   1CB0
....................    { 
....................       printf("\rReseteando la inicializacion...\r"); 
1C88:  CLRF   xA5
1C8A:  MOVF   xA5,W
1C8C:  CALL   08F2
1C90:  IORLW  00
1C92:  BZ    1C9E
1C94:  INCF   xA5,F
1C96:  BTFSS  F9E.4
1C98:  BRA    1C96
1C9A:  MOVWF  FAD
1C9C:  BRA    1C8A
....................       delay_ms(LCD_T_RETARDO); 
1C9E:  MOVLW  02
1CA0:  MOVWF  xA5
1CA2:  MOVLW  FA
1CA4:  MOVWF  xAE
1CA6:  CALL   12A8
1CAA:  DECFSZ xA5,F
1CAC:  BRA    1CA2
....................       goto e1; 
1CAE:  BRA    18B2
....................    } 
....................    //Si los minutos no son correctos, mostramos un mensaje de error por pantalla y 
....................    //reseteamos la introducción de los minutos 
....................    if(minutos>59) 
1CB0:  MOVF   x9A,W
1CB2:  SUBLW  3B
1CB4:  BC    1CDE
....................    { 
....................       printf("  Minutos incorrectos!"); 
1CB6:  CLRF   xA5
1CB8:  MOVF   xA5,W
1CBA:  CALL   0978
1CBE:  IORLW  00
1CC0:  BZ    1CCC
1CC2:  INCF   xA5,F
1CC4:  BTFSS  F9E.4
1CC6:  BRA    1CC4
1CC8:  MOVWF  FAD
1CCA:  BRA    1CB8
....................       delay_ms(LCD_T_RETARDO); 
1CCC:  MOVLW  02
1CCE:  MOVWF  xA5
1CD0:  MOVLW  FA
1CD2:  MOVWF  xAE
1CD4:  CALL   12A8
1CD8:  DECFSZ xA5,F
1CDA:  BRA    1CD0
....................       goto e2; 
1CDC:  BRA    1BEE
....................    } 
....................  
....................    //Introducimos un pequeño retardo para que el técnico pueda ver la hora introducida 
....................    delay_ms(LCD_T_RETARDO); 
1CDE:  MOVLW  02
1CE0:  MOVWF  xA5
1CE2:  MOVLW  FA
1CE4:  MOVWF  xAE
1CE6:  CALL   12A8
1CEA:  DECFSZ xA5,F
1CEC:  BRA    1CE2
....................  
....................    //Mostramos un mensaje de guardado de configuración 
....................    printf("\rGuardando configuracion..."); 
1CEE:  CLRF   xA5
1CF0:  MOVF   xA5,W
1CF2:  CALL   09AA
1CF6:  IORLW  00
1CF8:  BZ    1D04
1CFA:  INCF   xA5,F
1CFC:  BTFSS  F9E.4
1CFE:  BRA    1CFC
1D00:  MOVWF  FAD
1D02:  BRA    1CF0
....................  
....................    //Almacenamos todo en la estructura que contiene la información del tiempo 
....................    tiempo.month   = mes; 
1D04:  MOVFF  97,5F
....................    tiempo.day     = dia; 
1D08:  MOVFF  96,5E
....................    tiempo.year    = anno_actual_0_to_3; 
1D0C:  MOVFF  6C,60
....................    tiempo.hours   = horas; 
1D10:  MOVFF  99,5D
....................    tiempo.minutes = minutos; 
1D14:  MOVFF  9A,5C
....................    tiempo.seconds = 0x00; 
1D18:  CLRF   5B
....................    tiempo.weekday = weekday; 
1D1A:  MOVFF  95,61
....................  
....................    //Fijamos el reloj a esa fecha y hora 
....................    PCF8583_set_datetime(&tiempo); 
1D1E:  CLRF   xA6
1D20:  MOVLW  5B
1D22:  MOVWF  xA5
1D24:  BRA    16C8
....................  
....................    //Establecemos los parámetros iniciales del sistema para resetear la memoria 
....................    termostato1 = termostato2 = (float)20; 
1D26:  CLRF   27
1D28:  CLRF   26
1D2A:  MOVLW  20
1D2C:  MOVWF  25
1D2E:  MOVLW  83
1D30:  MOVWF  24
1D32:  MOVFF  27,23
1D36:  MOVFF  26,22
1D3A:  MOVFF  25,21
1D3E:  MOVFF  24,20
....................    num_intervalos = 0; 
1D42:  CLRF   59
....................    num_registros = 0; 
1D44:  CLRF   6A
1D46:  CLRF   69
....................    anno_actual = anno; 
1D48:  MOVFF  98,6B
....................  
....................    //Escribimos los datos en la EEPROM, almacenando antes en un vector para 
....................    //agilizar la escritura por ráfaga 
....................    data[0] = (int)termostato1; 
1D4C:  MOVFF  23,A8
1D50:  MOVFF  22,A7
1D54:  MOVFF  21,A6
1D58:  MOVFF  20,A5
1D5C:  RCALL  17F2
1D5E:  MOVFF  01,9B
....................    data[1] = num_intervalos; 
1D62:  MOVFF  59,9C
....................    data[2] = (int)(num_registros/256); 
1D66:  MOVF   6A,W
1D68:  MOVWF  x9D
....................    data[3] = (int)(num_registros - data[0]*256); 
1D6A:  CLRF   xB3
1D6C:  MOVFF  9B,B2
1D70:  MOVLW  01
1D72:  MOVWF  xB5
1D74:  CLRF   xB4
1D76:  RCALL  182C
1D78:  MOVF   01,W
1D7A:  SUBWF  69,W
1D7C:  MOVWF  00
1D7E:  MOVF   02,W
1D80:  SUBWFB 6A,W
1D82:  MOVFF  00,9E
....................    data[4] = anno_actual; 
1D86:  MOVFF  6B,9F
....................    data[5] = anno_actual_0_to_3; 
1D8A:  MOVFF  6C,A0
....................  
....................    graba_ee(eeprom_termostato, 6, data); 
1D8E:  CLRF   xA8
1D90:  MOVLW  10
1D92:  MOVWF  xA7
1D94:  MOVLW  06
1D96:  MOVWF  xA9
1D98:  CLRF   xAB
1D9A:  MOVLW  9B
1D9C:  MOVWF  xAA
1D9E:  RCALL  184A
....................  
....................    //Mostramos un mensaje de inicio del sistema 
....................    printf("\rIniciando sistema...\r"); 
1DA0:  CLRF   xA5
1DA2:  MOVF   xA5,W
1DA4:  CALL   09E0
1DA8:  IORLW  00
1DAA:  BZ    1DB6
1DAC:  INCF   xA5,F
1DAE:  BTFSS  F9E.4
1DB0:  BRA    1DAE
1DB2:  MOVWF  FAD
1DB4:  BRA    1DA2
....................  
.................... } 
1DB6:  GOTO   5D50 (RETURN)
....................  
.................... //----------------------------------------------------------------------------------------------------------------------------------------- 
....................  
.................... void leer_programaciones(){ 
....................    int datos[5];    //Vector para almacenar los datos recuperados 
....................    programacion pr;  //Variable temporal para guardar la programación 
....................    int contador;    //Contador del bucle 
....................  
....................    //Se supone que antes ha sido recuperado el número de intervalos 
....................    //Recorremos todas las programaciones guardadas 
....................    for(contador=0; contador<num_intervalos; contador++) 
....................    { 
....................       //Leemos de memoria 
....................       lee_ee(eeprom_programaciones + (contador+1)*8, 5, datos); 
....................  
....................       //Guardamos los datos en la programación 
....................       pr.horas_inicio   = datos[0]; 
....................       pr.minutos_inicio = datos[1]; 
....................       pr.horas_fin      = datos[2]; 
....................       pr.minutos_fin    = datos[3]; 
....................       pr.termostato     = datos[4]; 
....................  
....................       //Guardamos la programación en el vector correspondiente 
....................       programaciones[contador] = pr; 
....................  
....................    } 
....................  
.................... } 
....................  
.................... //----------------------------------------------------------------------------------------------------------------------------------------- 
....................  
.................... void mostrar_temperatura() 
.................... { 
....................    //Leemos el tiempo y lo guardamos en la variable tiempo 
....................    PCF8583_read_datetime(&tiempo); 
*
5A1A:  CLRF   xA2
5A1C:  MOVLW  5B
5A1E:  MOVWF  xA1
5A20:  CALL   2764
....................    //Activamos las interrupciones, que se desactivan dentro del método 
....................    //enable_interrupts(GLOBAL); 
....................  
....................    //Mostramos la temperatura registrada 
....................    lcd_send_byte(LCD_ORDEN, LCD_CLEAR); 
5A24:  CLRF   xAC
5A26:  MOVLW  01
5A28:  MOVWF  xAD
5A2A:  CALL   1314
....................    printf(lcd_putc, "%3.1f%cC  %3.1f%cC\nHORA - ", temperatura1, 223, temperatura2, 223); 
5A2E:  MOVLW  02
5A30:  MOVWF  FE9
5A32:  MOVFF  2F,9D
5A36:  MOVFF  2E,9C
5A3A:  MOVFF  2D,9B
5A3E:  MOVFF  2C,9A
5A42:  MOVLW  01
5A44:  MOVWF  x9E
5A46:  CALL   32E0
5A4A:  MOVLW  DF
5A4C:  MOVWF  xA7
5A4E:  CALL   13C0
5A52:  MOVLW  43
5A54:  MOVWF  xA7
5A56:  CALL   13C0
5A5A:  MOVLW  20
5A5C:  MOVWF  xA7
5A5E:  CALL   13C0
5A62:  MOVLW  20
5A64:  MOVWF  xA7
5A66:  CALL   13C0
5A6A:  MOVLW  02
5A6C:  MOVWF  FE9
5A6E:  MOVFF  33,9D
5A72:  MOVFF  32,9C
5A76:  MOVFF  31,9B
5A7A:  MOVFF  30,9A
5A7E:  MOVLW  01
5A80:  MOVWF  x9E
5A82:  CALL   32E0
5A86:  MOVLW  DF
5A88:  MOVWF  xA7
5A8A:  CALL   13C0
5A8E:  MOVLW  11
5A90:  MOVWF  x96
5A92:  MOVF   x96,W
5A94:  CALL   0A12
5A98:  INCF   x96,F
5A9A:  MOVWF  00
5A9C:  MOVWF  xA7
5A9E:  CALL   13C0
5AA2:  MOVLW  1A
5AA4:  SUBWF  x96,W
5AA6:  BNZ   5A92
....................  
....................    //Mostramos la hora 
....................    //Comprobamos si los valores son menores que 10 para añadir un cero 
....................    //delante y que queden los valores alineados 
....................    if(tiempo.hours < 10) 
5AA8:  MOVF   5D,W
5AAA:  SUBLW  09
5AAC:  BNC   5AC4
....................       printf(lcd_putc, "0"); 
5AAE:  CLRF   x96
5AB0:  MOVF   x96,W
5AB2:  CALL   0A48
5AB6:  IORLW  00
5AB8:  BZ    5AC4
5ABA:  INCF   x96,F
5ABC:  MOVWF  xA7
5ABE:  CALL   13C0
5AC2:  BRA    5AB0
....................    printf(lcd_putc, "%u:", tiempo.hours); 
5AC4:  MOVFF  5D,96
5AC8:  MOVLW  1B
5ACA:  MOVWF  x97
5ACC:  RCALL  59A2
5ACE:  MOVLW  3A
5AD0:  MOVWF  xA7
5AD2:  CALL   13C0
....................    if(tiempo.minutes < 10) 
5AD6:  MOVF   5C,W
5AD8:  SUBLW  09
5ADA:  BNC   5AF2
....................       printf(lcd_putc, "0"); 
5ADC:  CLRF   x96
5ADE:  MOVF   x96,W
5AE0:  CALL   0A48
5AE4:  IORLW  00
5AE6:  BZ    5AF2
5AE8:  INCF   x96,F
5AEA:  MOVWF  xA7
5AEC:  CALL   13C0
5AF0:  BRA    5ADE
....................    printf(lcd_putc, "%u", tiempo.minutes); 
5AF2:  MOVFF  5C,96
5AF6:  MOVLW  1B
5AF8:  MOVWF  x97
5AFA:  RCALL  59A2
.................... } 
5AFC:  GOTO   5B36 (RETURN)
....................  
.................... //----------------------------------------------------------------------------------------------------------------------------------------- 
....................  
.................... void ordenar_programaciones() 
.................... { 
....................    //Variables temporales y contadores auxiliares 
....................    programacion *pr1; 
....................    programacion *pr2; 
....................    int contador1, contador2; 
....................    int h_inicio_1, min_inicio_1, h_inicio_2, min_inicio_2; 
....................  
....................    //Ambos punteros comienzan apuntando al principio de programaciones 
....................    pr1 = programaciones; 
*
35FE:  CLRF   x96
3600:  MOVLW  3B
3602:  MOVWF  x95
....................    pr2 = programaciones; 
3604:  CLRF   x98
3606:  MOVWF  x97
....................  
....................  
....................    //Algoritmo de la burbuja 
....................    for(contador1=0; contador1 < num_intervalos; contador1++) 
3608:  CLRF   x99
360A:  MOVF   59,W
360C:  SUBWF  x99,W
360E:  BTFSC  FD8.0
3610:  BRA    3732
....................    { 
....................       //Apuntamos a las dos últimas posiciones del vector 
....................       pr1 = programaciones+num_intervalos-2; 
3612:  MOVF   59,W
3614:  MULLW  05
3616:  MOVF   FF3,W
3618:  ADDLW  3B
361A:  MOVWF  xA4
361C:  CLRF   xA5
361E:  BTFSC  FD8.0
3620:  INCF   xA5,F
3622:  MOVLW  0A
3624:  SUBWF  xA4,W
3626:  MOVWF  x95
3628:  MOVLW  00
362A:  SUBWFB xA5,W
362C:  MOVWF  x96
....................       pr2 = programaciones+num_intervalos-1; 
362E:  MOVF   59,W
3630:  MULLW  05
3632:  MOVF   FF3,W
3634:  ADDLW  3B
3636:  MOVWF  xA4
3638:  CLRF   xA5
363A:  BTFSC  FD8.0
363C:  INCF   xA5,F
363E:  MOVLW  05
3640:  SUBWF  xA4,W
3642:  MOVWF  x97
3644:  MOVLW  00
3646:  SUBWFB xA5,W
3648:  MOVWF  x98
....................  
....................       //Iteramos hasta llegar a la zona ordenada del vector 
....................       for(contador2=0; contador2 < num_intervalos-contador1-1; contador2++) 
364A:  CLRF   x9A
364C:  MOVF   x99,W
364E:  SUBWF  59,W
3650:  ADDLW  FF
3652:  SUBWF  x9A,W
3654:  BC    372E
....................       { 
....................          //Tomamos para la comparación los instantes de inicio 
....................          h_inicio_1   = (*pr1).horas_inicio; 
3656:  MOVFF  95,FE9
365A:  MOVFF  96,FEA
365E:  MOVFF  FEF,9B
....................          min_inicio_1 = (*pr1).minutos_inicio; 
3662:  MOVLW  01
3664:  ADDWF  x95,W
3666:  MOVWF  FE9
3668:  MOVLW  00
366A:  ADDWFC x96,W
366C:  MOVWF  FEA
366E:  MOVFF  FEF,9C
....................          h_inicio_2   = (*pr2).horas_inicio; 
3672:  MOVFF  97,FE9
3676:  MOVFF  98,FEA
367A:  MOVFF  FEF,9D
....................          min_inicio_2 = (*pr2).minutos_inicio; 
367E:  MOVLW  01
3680:  ADDWF  x97,W
3682:  MOVWF  FE9
3684:  MOVLW  00
3686:  ADDWFC x98,W
3688:  MOVWF  FEA
368A:  MOVFF  FEF,9E
....................  
....................          //Si la hora de pr2 es menor que la de pr1, habrá que intercambiar los 
....................          //valores para mover la menor a una posición más baja 
....................          if(comprobar_hora(h_inicio_2, min_inicio_2, h_inicio_1, min_inicio_1)) 
368E:  MOVFF  9D,AB
3692:  MOVFF  9E,AC
3696:  MOVFF  9B,AD
369A:  MOVFF  9C,AE
369E:  CALL   2AEA
36A2:  MOVF   01,F
36A4:  BZ    371A
....................          { 
....................             programacion temporal; 
....................             temporal = *pr1; 
36A6:  MOVFF  96,03
36AA:  MOVFF  95,A4
36AE:  MOVFF  96,A5
36B2:  CLRF   FEA
36B4:  MOVLW  9F
36B6:  MOVWF  FE9
36B8:  MOVFF  96,FE2
36BC:  MOVFF  95,FE1
36C0:  MOVLW  05
36C2:  MOVWF  01
36C4:  MOVFF  FE6,FEE
36C8:  DECFSZ 01,F
36CA:  BRA    36C4
....................             *pr1 = *pr2; 
36CC:  MOVFF  95,A6
36D0:  MOVFF  96,A7
36D4:  MOVFF  98,03
36D8:  MOVFF  97,A8
36DC:  MOVFF  98,A9
36E0:  MOVFF  96,FEA
36E4:  MOVFF  95,FE9
36E8:  MOVFF  98,FE2
36EC:  MOVFF  97,FE1
36F0:  MOVLW  05
36F2:  MOVWF  01
36F4:  MOVFF  FE6,FEE
36F8:  DECFSZ 01,F
36FA:  BRA    36F4
....................             *pr2 = temporal; 
36FC:  MOVFF  98,03
3700:  MOVFF  97,FE9
3704:  MOVFF  03,FEA
3708:  CLRF   FE2
370A:  MOVLW  9F
370C:  MOVWF  FE1
370E:  MOVLW  05
3710:  MOVWF  01
3712:  MOVFF  FE6,FEE
3716:  DECFSZ 01,F
3718:  BRA    3712
....................          } 
....................  
....................          //Pasamos a la siguiente posición y repetimos el proceso 
....................          pr1--; 
371A:  MOVLW  FB
371C:  ADDWF  x95,F
371E:  BTFSS  FD8.0
3720:  DECF   x96,F
....................          pr2--; 
3722:  MOVLW  FB
3724:  ADDWF  x97,F
3726:  BTFSS  FD8.0
3728:  DECF   x98,F
....................       } 
372A:  INCF   x9A,F
372C:  BRA    364C
....................    } 
372E:  INCF   x99,F
3730:  BRA    360A
.................... } 
3732:  GOTO   69EC (RETURN)
....................  
.................... //----------------------------------------------------------------------------------------------------------------------------------------- 
....................  
.................... void programar_proxima_alarma() 
.................... { 
....................    //Variables auxiliares 
....................    int hora, minutos; 
....................  
....................    //Recuperamos los datos de inicio de la alarma actual 
....................    prg=programaciones[posicion_alarmas]; 
*
29AA:  MOVF   5A,W
29AC:  MULLW  05
29AE:  MOVF   FF3,W
29B0:  CLRF   03
29B2:  ADDLW  3B
29B4:  MOVWF  01
29B6:  MOVLW  00
29B8:  ADDWFC 03,F
29BA:  MOVFF  01,97
29BE:  MOVFF  03,98
29C2:  CLRF   FEA
29C4:  MOVLW  54
29C6:  MOVWF  FE9
29C8:  MOVFF  03,FE2
29CC:  MOVFF  01,FE1
29D0:  MOVLW  05
29D2:  MOVWF  01
29D4:  MOVFF  FE6,FEE
29D8:  DECFSZ 01,F
29DA:  BRA    29D4
....................    hora = prg.horas_inicio; 
29DC:  MOVFF  54,95
....................    minutos = prg.minutos_inicio; 
29E0:  MOVFF  55,96
....................  
....................    //Establecemos la alarma a ese tiempo 
....................    PCF8583_establecer_alarma(hora, minutos, 0); 
29E4:  MOVFF  95,97
29E8:  MOVFF  96,98
29EC:  CLRF   x99
29EE:  RCALL  2912
....................    //Habilitamos interrupciones (se desactivan en el método anterior) 
....................    //enable_interrupts(GLOBAL); 
.................... } 
29F0:  RETLW  00
....................  
.................... //----------------------------------------------------------------------------------------------------------------------------------------- 
....................  
.................... void representar_registros() 
.................... { 
....................    //Contadores y variables auxiliares 
....................    int contador, contador2; 
....................    unsigned int data[8], data2[4]; 
....................  
....................    float media_dia_mes[12];         //Tiempos medios en minutos que se enciende el sistema en cada mes 
....................    int dias_meses[12];              //Número de dias que tiene cada mes 
....................    float media_dia_caldera;         //Tiempo medio que se enciende la caldera cada día 
....................    float valor;                     //Tiempo medio en minutos que se enciende el sistema por día 
....................    float media_dia_mes_caldera[12]; //Tiempo medio que se enciende la caldera en cada mes 
....................  
....................    unsigned long valor_total;  //Tiempo total de encendido de la caldera 
....................    unsigned long valor_total_caldera; //Tiempo total de encendido del sistema 
....................  
....................    //Capacidad para 4 años de datos 
....................    //Vectores de almacenamiento de los datos anuales 
....................    float media_annos[4][12]; 
....................    float media_annos_caldera[4][12]; 
....................    //Número de años de los que se tienen datos 
....................    int num_annos; 
....................    //Años correspondientes 
....................    int annos[4]; 
....................  
....................    //Variables para almacenar valores provisionales 
....................    long tiempo_x_dia;         //Tiempo que se enciende cada día el sistema (minutos) 
....................    long tiempo_x_dia_caldera; //Tiempo que se enciende cada día la caldera (minutos) 
....................    int dia[3];               //Día con el que estamos trabajando (día/mes/año) 
....................    long num_dias;             //Número de días que llevamos analizados 
....................  
....................    //dias_meses = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}; 
....................    dias_meses[0] = dias_meses[2] = dias_meses[4] = dias_meses[6] = dias_meses[7] = dias_meses[9] = dias_meses[11] = 31; 
*
3BBE:  MOVLW  1F
3BC0:  MOVWF  xDE
3BC2:  MOVFF  DE,DC
3BC6:  MOVFF  DC,DA
3BCA:  MOVFF  DA,D9
3BCE:  MOVFF  D9,D7
3BD2:  MOVFF  D7,D5
3BD6:  MOVFF  D5,D3
....................    dias_meses[1] = 28; 
3BDA:  MOVLW  1C
3BDC:  MOVWF  xD4
....................    dias_meses[3] = dias_meses[5] = dias_meses[8] = dias_meses[10] = 30; 
3BDE:  MOVLW  1E
3BE0:  MOVWF  xDD
3BE2:  MOVFF  DD,DB
3BE6:  MOVFF  DB,D8
3BEA:  MOVFF  D8,D6
....................  
....................    //Inicializamos los vectores a 0 
....................    for(contador=0; contador<12;contador++) 
3BEE:  CLRF   x95
3BF0:  MOVF   x95,W
3BF2:  SUBLW  0B
3BF4:  BNC   3C14
....................    { 
....................       media_dia_mes[contador]=0; 
3BF6:  MOVF   x95,W
3BF8:  MULLW  04
3BFA:  MOVF   FF3,W
3BFC:  CLRF   03
3BFE:  ADDLW  A3
3C00:  MOVWF  FE9
3C02:  MOVLW  00
3C04:  ADDWFC 03,W
3C06:  MOVWF  FEA
3C08:  CLRF   FEF
3C0A:  CLRF   FEC
3C0C:  CLRF   FEC
3C0E:  CLRF   FEC
....................    } 
3C10:  INCF   x95,F
3C12:  BRA    3BF0
....................  
....................    for(contador=0; contador<12;contador++) 
3C14:  CLRF   x95
3C16:  MOVF   x95,W
3C18:  SUBLW  0B
3C1A:  BNC   3C3A
....................    { 
....................       media_dia_mes_caldera[contador]=0; 
3C1C:  MOVF   x95,W
3C1E:  MULLW  04
3C20:  MOVF   FF3,W
3C22:  CLRF   03
3C24:  ADDLW  E7
3C26:  MOVWF  FE9
3C28:  MOVLW  00
3C2A:  ADDWFC 03,W
3C2C:  MOVWF  FEA
3C2E:  CLRF   FEF
3C30:  CLRF   FEC
3C32:  CLRF   FEC
3C34:  CLRF   FEC
....................    } 
3C36:  INCF   x95,F
3C38:  BRA    3C16
....................  
....................    for(contador=0; contador<4 ;contador++) 
3C3A:  CLRF   x95
3C3C:  MOVF   x95,W
3C3E:  SUBLW  03
3C40:  BNC   3C88
....................    { 
....................       for(contador2=0; contador2<12 ;contador2++) 
3C42:  CLRF   x96
3C44:  MOVF   x96,W
3C46:  SUBLW  0B
3C48:  BNC   3C84
....................       { 
....................          media_annos[contador][contador2]=0; 
3C4A:  MOVF   x95,W
3C4C:  MULLW  30
3C4E:  MOVF   FF3,W
3C50:  MOVLB  2
3C52:  CLRF   xAA
3C54:  MOVWF  xA9
3C56:  MOVLB  0
3C58:  MOVF   x96,W
3C5A:  MULLW  04
3C5C:  MOVF   FF3,W
3C5E:  CLRF   03
3C60:  MOVLB  2
3C62:  ADDWF  xA9,W
3C64:  MOVWF  01
3C66:  MOVF   xAA,W
3C68:  ADDWFC 03,F
3C6A:  MOVF   01,W
3C6C:  ADDLW  1B
3C6E:  MOVWF  FE9
3C70:  MOVLW  01
3C72:  ADDWFC 03,W
3C74:  MOVWF  FEA
3C76:  CLRF   FEF
3C78:  CLRF   FEC
3C7A:  CLRF   FEC
3C7C:  CLRF   FEC
....................       } 
3C7E:  MOVLB  0
3C80:  INCF   x96,F
3C82:  BRA    3C44
....................    } 
3C84:  INCF   x95,F
3C86:  BRA    3C3C
....................  
....................    for(contador=0; contador<4 ;contador++) 
3C88:  CLRF   x95
3C8A:  MOVF   x95,W
3C8C:  SUBLW  03
3C8E:  BNC   3CD6
....................    { 
....................       for(contador2=0; contador2<12 ;contador2++) 
3C90:  CLRF   x96
3C92:  MOVF   x96,W
3C94:  SUBLW  0B
3C96:  BNC   3CD2
....................       { 
....................          media_annos_caldera[contador][contador2]=0; 
3C98:  MOVF   x95,W
3C9A:  MULLW  30
3C9C:  MOVF   FF3,W
3C9E:  MOVLB  2
3CA0:  CLRF   xAA
3CA2:  MOVWF  xA9
3CA4:  MOVLB  0
3CA6:  MOVF   x96,W
3CA8:  MULLW  04
3CAA:  MOVF   FF3,W
3CAC:  CLRF   03
3CAE:  MOVLB  2
3CB0:  ADDWF  xA9,W
3CB2:  MOVWF  01
3CB4:  MOVF   xAA,W
3CB6:  ADDWFC 03,F
3CB8:  MOVF   01,W
3CBA:  ADDLW  DB
3CBC:  MOVWF  FE9
3CBE:  MOVLW  01
3CC0:  ADDWFC 03,W
3CC2:  MOVWF  FEA
3CC4:  CLRF   FEF
3CC6:  CLRF   FEC
3CC8:  CLRF   FEC
3CCA:  CLRF   FEC
....................       } 
3CCC:  MOVLB  0
3CCE:  INCF   x96,F
3CD0:  BRA    3C92
....................    } 
3CD2:  INCF   x95,F
3CD4:  BRA    3C8A
....................  
....................    //Iniciamos a cero las otras variables 
....................    dia[0] = dia[1] = dia[2] = 0; 
3CD6:  MOVLB  2
3CD8:  CLRF   xA6
3CDA:  MOVFF  2A6,2A5
3CDE:  MOVFF  2A5,2A4
....................    num_dias = 0; 
3CE2:  CLRF   xA8
3CE4:  CLRF   xA7
....................    num_annos = 0; 
3CE6:  CLRF   x9B
....................  
....................    media_dia_caldera = 0; 
3CE8:  MOVLB  0
3CEA:  CLRF   xE2
3CEC:  CLRF   xE1
3CEE:  CLRF   xE0
3CF0:  CLRF   xDF
....................    valor = 0; 
3CF2:  CLRF   xE6
3CF4:  CLRF   xE5
3CF6:  CLRF   xE4
3CF8:  CLRF   xE3
....................    valor_total = 0; 
3CFA:  MOVLB  1
3CFC:  CLRF   x18
3CFE:  CLRF   x17
....................    valor_total_caldera = 0; 
3D00:  CLRF   x1A
3D02:  CLRF   x19
....................  
....................    //Imprimimos el encabezamiento 
....................    printf("\rREGISTRO DE EVENTOS\r"); 
3D04:  MOVLB  2
3D06:  CLRF   xA9
3D08:  MOVF   xA9,W
3D0A:  MOVLB  0
3D0C:  CALL   0A64
3D10:  IORLW  00
3D12:  BZ    3D22
3D14:  MOVLB  2
3D16:  INCF   xA9,F
3D18:  BTFSS  F9E.4
3D1A:  BRA    3D18
3D1C:  MOVWF  FAD
3D1E:  BRA    3D08
3D20:  MOVLB  0
....................    printf("*******************\r"); 
3D22:  MOVLB  2
3D24:  CLRF   xA9
3D26:  MOVF   xA9,W
3D28:  MOVLB  0
3D2A:  CALL   0A94
3D2E:  IORLW  00
3D30:  BZ    3D40
3D32:  MOVLB  2
3D34:  INCF   xA9,F
3D36:  BTFSS  F9E.4
3D38:  BRA    3D36
3D3A:  MOVWF  FAD
3D3C:  BRA    3D26
3D3E:  MOVLB  0
....................    printf("Momento de apagado     Temperatura1       Temperatura2         Termostato        Minutos encendido       Minutos caldera\r"); 
3D40:  MOVLB  2
3D42:  CLRF   xA9
3D44:  MOVF   xA9,W
3D46:  MOVLB  0
3D48:  CALL   0AC4
3D4C:  IORLW  00
3D4E:  BZ    3D5E
3D50:  MOVLB  2
3D52:  INCF   xA9,F
3D54:  BTFSS  F9E.4
3D56:  BRA    3D54
3D58:  MOVWF  FAD
3D5A:  BRA    3D44
3D5C:  MOVLB  0
....................    printf("===========================================================================================================================\r"); 
3D5E:  MOVLB  2
3D60:  CLRF   xA9
3D62:  MOVF   xA9,W
3D64:  MOVLB  0
3D66:  CALL   0B58
3D6A:  IORLW  00
3D6C:  BZ    3D7C
3D6E:  MOVLB  2
3D70:  INCF   xA9,F
3D72:  BTFSS  F9E.4
3D74:  BRA    3D72
3D76:  MOVWF  FAD
3D78:  BRA    3D62
3D7A:  MOVLB  0
....................  
....................    //Recorremos todos los registros almacenados 
....................    for(contador=0; contador<num_registros; contador++) 
3D7C:  CLRF   x95
3D7E:  MOVF   6A,F
3D80:  BNZ   3D8C
3D82:  MOVF   69,W
3D84:  SUBWF  x95,W
3D86:  BTFSC  FD8.0
3D88:  GOTO   4552
....................    { 
....................       //Comenzamos leyendo los datos de memoria 
....................       lee_ee((unsigned long)eeprom_registros + (unsigned long)contador*(unsigned long)2*(unsigned long)8, 8, data); 
3D8C:  MOVLB  2
3D8E:  CLRF   xAA
3D90:  MOVFF  95,2A9
3D94:  BCF    FD8.0
3D96:  RLCF   xA9,W
3D98:  MOVWF  xAB
3D9A:  RLCF   xAA,W
3D9C:  MOVWF  xAC
3D9E:  RLCF   xAB,W
3DA0:  MOVWF  02
3DA2:  RLCF   xAC,W
3DA4:  MOVWF  03
3DA6:  RLCF   02,F
3DA8:  RLCF   03,F
3DAA:  RLCF   02,F
3DAC:  RLCF   03,F
3DAE:  MOVLW  F8
3DB0:  ANDWF  02,F
3DB2:  MOVF   02,W
3DB4:  ADDLW  50
3DB6:  MOVWF  xAD
3DB8:  MOVLW  00
3DBA:  ADDWFC 03,W
3DBC:  MOVWF  xAE
3DBE:  MOVWF  xB2
3DC0:  MOVFF  2AD,2B1
3DC4:  MOVLW  08
3DC6:  MOVWF  xB3
3DC8:  CLRF   xB5
3DCA:  MOVLW  97
3DCC:  MOVWF  xB4
3DCE:  MOVLB  0
3DD0:  RCALL  3840
....................       lee_ee((unsigned long)eeprom_registros + (unsigned long)contador*(unsigned long)2*(unsigned long)8 + (unsigned long)8, 4, data2); 
3DD2:  MOVLB  2
3DD4:  CLRF   xAA
3DD6:  MOVFF  95,2A9
3DDA:  BCF    FD8.0
3DDC:  RLCF   xA9,W
3DDE:  MOVWF  xAB
3DE0:  RLCF   xAA,W
3DE2:  MOVWF  xAC
3DE4:  RLCF   xAB,W
3DE6:  MOVWF  02
3DE8:  RLCF   xAC,W
3DEA:  MOVWF  03
3DEC:  RLCF   02,F
3DEE:  RLCF   03,F
3DF0:  RLCF   02,F
3DF2:  RLCF   03,F
3DF4:  MOVLW  F8
3DF6:  ANDWF  02,F
3DF8:  MOVF   02,W
3DFA:  ADDLW  50
3DFC:  MOVWF  xAD
3DFE:  MOVLW  00
3E00:  ADDWFC 03,W
3E02:  MOVWF  xAE
3E04:  MOVLW  08
3E06:  ADDWF  xAD,W
3E08:  MOVWF  xAF
3E0A:  MOVLW  00
3E0C:  ADDWFC xAE,W
3E0E:  MOVWF  xB0
3E10:  MOVWF  xB2
3E12:  MOVFF  2AF,2B1
3E16:  MOVLW  04
3E18:  MOVWF  xB3
3E1A:  CLRF   xB5
3E1C:  MOVLW  9F
3E1E:  MOVWF  xB4
3E20:  MOVLB  0
3E22:  RCALL  3840
....................  
....................       //Si cambiamos de día debemos gestionar los datos del nuevo día y almacenar los del anterior 
....................       if(dia[0]!=data[0] || dia[1]!=data[1] || dia[2]!=data2[0]) 
3E24:  MOVF   x97,W
3E26:  MOVLB  2
3E28:  SUBWF  xA4,W
3E2A:  BNZ   3E42
3E2C:  MOVLB  0
3E2E:  MOVF   x98,W
3E30:  MOVLB  2
3E32:  SUBWF  xA5,W
3E34:  BNZ   3E42
3E36:  MOVLB  0
3E38:  MOVF   x9F,W
3E3A:  MOVLB  2
3E3C:  SUBWF  xA6,W
3E3E:  BTFSC  FD8.2
3E40:  BRA    41B8
....................       { 
....................          //Lógicamente, no tenemos en cuenta para la media los días en los que no se enciende: 
....................          //días de verano, calurosos, etc. Esta información puede visualizarse en la media 
....................          //por meses. 
....................          //Guardamos los datos del día anterior si el día no es el primero 
....................          if(dia[0]!=0) 
3E42:  MOVF   xA4,F
3E44:  BZ    3F1A
....................          { 
....................             //En la media de tiempo por día, acumulamos el tiempo que ha estado encendido el último día 
....................             valor = valor + (float)tiempo_x_dia; 
3E46:  MOVFF  2A1,2B0
3E4A:  MOVFF  2A0,2AF
3E4E:  MOVLB  0
3E50:  CALL   26A2
3E54:  BCF    FD8.1
3E56:  MOVFF  E6,2AC
3E5A:  MOVFF  E5,2AB
3E5E:  MOVFF  E4,2AA
3E62:  MOVFF  E3,2A9
3E66:  MOVFF  03,2B0
3E6A:  MOVFF  02,2AF
3E6E:  MOVFF  01,2AE
3E72:  MOVFF  00,2AD
3E76:  CALL   2428
3E7A:  MOVFF  03,E6
3E7E:  MOVFF  02,E5
3E82:  MOVFF  01,E4
3E86:  MOVFF  00,E3
....................             //Guardamos también este valor en el registro del año 
....................             media_dia_mes[dia[1]-1] = valor; 
3E8A:  MOVLW  01
3E8C:  MOVLB  2
3E8E:  SUBWF  xA5,W
3E90:  MULLW  04
3E92:  MOVF   FF3,W
3E94:  CLRF   03
3E96:  ADDLW  A3
3E98:  MOVWF  FE9
3E9A:  MOVLW  00
3E9C:  ADDWFC 03,W
3E9E:  MOVWF  FEA
3EA0:  MOVFF  E3,FEF
3EA4:  MOVFF  E4,FEC
3EA8:  MOVFF  E5,FEC
3EAC:  MOVFF  E6,FEC
....................             //Realizamos la misma operación con la media de encendido de la caldera 
....................             media_dia_caldera = media_dia_caldera + (float)tiempo_x_dia_caldera; 
3EB0:  MOVFF  2A3,2B0
3EB4:  MOVFF  2A2,2AF
3EB8:  MOVLB  0
3EBA:  CALL   26A2
3EBE:  BCF    FD8.1
3EC0:  MOVFF  E2,2AC
3EC4:  MOVFF  E1,2AB
3EC8:  MOVFF  E0,2AA
3ECC:  MOVFF  DF,2A9
3ED0:  MOVFF  03,2B0
3ED4:  MOVFF  02,2AF
3ED8:  MOVFF  01,2AE
3EDC:  MOVFF  00,2AD
3EE0:  CALL   2428
3EE4:  MOVFF  03,E2
3EE8:  MOVFF  02,E1
3EEC:  MOVFF  01,E0
3EF0:  MOVFF  00,DF
....................             media_dia_mes_caldera[dia[1]-1] = media_dia_caldera; 
3EF4:  MOVLW  01
3EF6:  MOVLB  2
3EF8:  SUBWF  xA5,W
3EFA:  MULLW  04
3EFC:  MOVF   FF3,W
3EFE:  CLRF   03
3F00:  ADDLW  E7
3F02:  MOVWF  FE9
3F04:  MOVLW  00
3F06:  ADDWFC 03,W
3F08:  MOVWF  FEA
3F0A:  MOVFF  DF,FEF
3F0E:  MOVFF  E0,FEC
3F12:  MOVFF  E1,FEC
3F16:  MOVFF  E2,FEC
....................          } 
....................          //La sumatoria podría alcanzar un valor muy alto. El sistema no está preparado para estas eventualidades 
....................          //y debería ser reseteado cada cierto tiempo. Si el sistema va a utilizarse mucho (zonas muy frías o mal 
....................          //aisladas), el usuario debería informar al fabricante para aumentar la memoria de almacenamiento y el 
....................          //tamaño de las variables 
....................  
....................          //Si cambiamos de año, habrá que guardar los datos anuales 
....................          if(dia[2]!=data2[0]) 
3F1A:  MOVLB  0
3F1C:  MOVF   x9F,W
3F1E:  MOVLB  2
3F20:  SUBWF  xA6,W
3F22:  BTFSC  FD8.2
3F24:  BRA    419E
....................          { 
....................             //Comprobamos que no nos encontrabamos en el año introducido por defecto 
....................             if(dia[2]!=0) 
3F26:  MOVF   xA6,F
3F28:  BTFSC  FD8.2
3F2A:  BRA    418A
....................             { 
....................                //En ese caso, guardamos los datos de todo el año 
....................                for(contador2=0; contador2<12; contador2++) 
3F2C:  MOVLB  0
3F2E:  CLRF   x96
3F30:  MOVF   x96,W
3F32:  SUBLW  0B
3F34:  BTFSS  FD8.0
3F36:  BRA    4174
....................                { 
....................                   media_dia_mes[contador2] = media_dia_mes[contador2]/(float)dias_meses[contador2]; 
3F38:  MOVF   x96,W
3F3A:  MULLW  04
3F3C:  MOVF   FF3,W
3F3E:  CLRF   03
3F40:  ADDLW  A3
3F42:  MOVWF  01
3F44:  MOVLW  00
3F46:  ADDWFC 03,F
3F48:  MOVFF  01,2A9
3F4C:  MOVFF  03,2AA
3F50:  MOVLB  0
3F52:  MOVF   x96,W
3F54:  MULLW  04
3F56:  MOVF   FF3,W
3F58:  CLRF   03
3F5A:  ADDLW  A3
3F5C:  MOVWF  FE9
3F5E:  MOVLW  00
3F60:  ADDWFC 03,W
3F62:  MOVWF  FEA
3F64:  MOVFF  FEF,2AB
3F68:  MOVFF  FEC,2AC
3F6C:  MOVFF  FEC,2AD
3F70:  MOVFF  FEC,2AE
3F74:  CLRF   03
3F76:  MOVF   x96,W
3F78:  ADDLW  D3
3F7A:  MOVWF  FE9
3F7C:  MOVLW  00
3F7E:  ADDWFC 03,W
3F80:  MOVWF  FEA
3F82:  MOVF   FEF,W
3F84:  MOVLB  2
3F86:  CLRF   xB0
3F88:  MOVWF  xAF
3F8A:  MOVLB  0
3F8C:  CALL   26A2
3F90:  MOVFF  2AE,2B2
3F94:  MOVFF  2AD,2B1
3F98:  MOVFF  2AC,2B0
3F9C:  MOVFF  2AB,2AF
3FA0:  MOVFF  03,2B6
3FA4:  MOVFF  02,2B5
3FA8:  MOVFF  01,2B4
3FAC:  MOVFF  00,2B3
3FB0:  CALL   2058
3FB4:  MOVFF  2AA,FEA
3FB8:  MOVFF  2A9,FE9
3FBC:  MOVFF  00,FEF
3FC0:  MOVFF  01,FEC
3FC4:  MOVFF  02,FEC
3FC8:  MOVFF  03,FEC
....................                   media_dia_mes_caldera[contador2] = media_dia_mes_caldera[contador2]/(float)dias_meses[contador2]; 
3FCC:  MOVF   x96,W
3FCE:  MULLW  04
3FD0:  MOVF   FF3,W
3FD2:  CLRF   03
3FD4:  ADDLW  E7
3FD6:  MOVWF  01
3FD8:  MOVLW  00
3FDA:  ADDWFC 03,F
3FDC:  MOVFF  01,2A9
3FE0:  MOVFF  03,2AA
3FE4:  MOVLB  0
3FE6:  MOVF   x96,W
3FE8:  MULLW  04
3FEA:  MOVF   FF3,W
3FEC:  CLRF   03
3FEE:  ADDLW  E7
3FF0:  MOVWF  FE9
3FF2:  MOVLW  00
3FF4:  ADDWFC 03,W
3FF6:  MOVWF  FEA
3FF8:  MOVFF  FEF,2AB
3FFC:  MOVFF  FEC,2AC
4000:  MOVFF  FEC,2AD
4004:  MOVFF  FEC,2AE
4008:  CLRF   03
400A:  MOVF   x96,W
400C:  ADDLW  D3
400E:  MOVWF  FE9
4010:  MOVLW  00
4012:  ADDWFC 03,W
4014:  MOVWF  FEA
4016:  MOVF   FEF,W
4018:  MOVLB  2
401A:  CLRF   xB0
401C:  MOVWF  xAF
401E:  MOVLB  0
4020:  CALL   26A2
4024:  MOVFF  2AE,2B2
4028:  MOVFF  2AD,2B1
402C:  MOVFF  2AC,2B0
4030:  MOVFF  2AB,2AF
4034:  MOVFF  03,2B6
4038:  MOVFF  02,2B5
403C:  MOVFF  01,2B4
4040:  MOVFF  00,2B3
4044:  CALL   2058
4048:  MOVFF  2AA,FEA
404C:  MOVFF  2A9,FE9
4050:  MOVFF  00,FEF
4054:  MOVFF  01,FEC
4058:  MOVFF  02,FEC
405C:  MOVFF  03,FEC
....................                   media_annos[num_annos][contador2] = media_dia_mes[contador2]; 
4060:  MOVLB  2
4062:  MOVF   x9B,W
4064:  MULLW  30
4066:  MOVF   FF3,W
4068:  CLRF   xAA
406A:  MOVWF  xA9
406C:  MOVLB  0
406E:  MOVF   x96,W
4070:  MULLW  04
4072:  MOVF   FF3,W
4074:  CLRF   03
4076:  MOVLB  2
4078:  ADDWF  xA9,W
407A:  MOVWF  01
407C:  MOVF   xAA,W
407E:  ADDWFC 03,F
4080:  MOVF   01,W
4082:  ADDLW  1B
4084:  MOVWF  01
4086:  MOVLW  01
4088:  ADDWFC 03,F
408A:  MOVFF  01,2AB
408E:  MOVFF  03,2AC
4092:  MOVLB  0
4094:  MOVF   x96,W
4096:  MULLW  04
4098:  MOVF   FF3,W
409A:  CLRF   03
409C:  ADDLW  A3
409E:  MOVWF  FE9
40A0:  MOVLW  00
40A2:  ADDWFC 03,W
40A4:  MOVWF  FEA
40A6:  MOVFF  FEF,00
40AA:  MOVFF  FEC,01
40AE:  MOVFF  FEC,02
40B2:  MOVFF  FEC,03
40B6:  MOVFF  2AC,FEA
40BA:  MOVFF  2AB,FE9
40BE:  MOVFF  00,FEF
40C2:  MOVFF  01,FEC
40C6:  MOVFF  02,FEC
40CA:  MOVFF  03,FEC
....................                   media_annos_caldera[num_annos][contador2] = media_dia_mes_caldera[contador2]; 
40CE:  MOVLB  2
40D0:  MOVF   x9B,W
40D2:  MULLW  30
40D4:  MOVF   FF3,W
40D6:  CLRF   xAA
40D8:  MOVWF  xA9
40DA:  MOVLB  0
40DC:  MOVF   x96,W
40DE:  MULLW  04
40E0:  MOVF   FF3,W
40E2:  CLRF   03
40E4:  MOVLB  2
40E6:  ADDWF  xA9,W
40E8:  MOVWF  01
40EA:  MOVF   xAA,W
40EC:  ADDWFC 03,F
40EE:  MOVF   01,W
40F0:  ADDLW  DB
40F2:  MOVWF  01
40F4:  MOVLW  01
40F6:  ADDWFC 03,F
40F8:  MOVFF  01,2AB
40FC:  MOVFF  03,2AC
4100:  MOVLB  0
4102:  MOVF   x96,W
4104:  MULLW  04
4106:  MOVF   FF3,W
4108:  CLRF   03
410A:  ADDLW  E7
410C:  MOVWF  FE9
410E:  MOVLW  00
4110:  ADDWFC 03,W
4112:  MOVWF  FEA
4114:  MOVFF  FEF,00
4118:  MOVFF  FEC,01
411C:  MOVFF  FEC,02
4120:  MOVFF  FEC,03
4124:  MOVFF  2AC,FEA
4128:  MOVFF  2AB,FE9
412C:  MOVFF  00,FEF
4130:  MOVFF  01,FEC
4134:  MOVFF  02,FEC
4138:  MOVFF  03,FEC
....................                   //Volvemos a inicializar los contenedores de información anual 
....................                   media_dia_mes[contador2]=0; 
413C:  MOVF   x96,W
413E:  MULLW  04
4140:  MOVF   FF3,W
4142:  CLRF   03
4144:  ADDLW  A3
4146:  MOVWF  FE9
4148:  MOVLW  00
414A:  ADDWFC 03,W
414C:  MOVWF  FEA
414E:  CLRF   FEF
4150:  CLRF   FEC
4152:  CLRF   FEC
4154:  CLRF   FEC
....................                   media_dia_mes_caldera[contador2]=0; 
4156:  MOVF   x96,W
4158:  MULLW  04
415A:  MOVF   FF3,W
415C:  CLRF   03
415E:  ADDLW  E7
4160:  MOVWF  FE9
4162:  MOVLW  00
4164:  ADDWFC 03,W
4166:  MOVWF  FEA
4168:  CLRF   FEF
416A:  CLRF   FEC
416C:  CLRF   FEC
416E:  CLRF   FEC
....................                } 
4170:  INCF   x96,F
4172:  BRA    3F30
....................  
....................                //Guardamos el año del que se trata 
....................                annos[num_annos]=dia[2]; 
4174:  CLRF   03
4176:  MOVLB  2
4178:  MOVF   x9B,W
417A:  ADDLW  9C
417C:  MOVWF  FE9
417E:  MOVLW  02
4180:  ADDWFC 03,W
4182:  MOVWF  FEA
4184:  MOVFF  2A6,FEF
....................  
....................                //Aumentamos en 1 el número de años 
....................                num_annos++; 
4188:  INCF   x9B,F
....................             } 
....................  
....................             //COMPROBAR BISIESTO 
....................             //En realidad, un año será bisiesto si es divisible por 4 y no lo es por 100, 
....................             //excepto si este último lo es por 400. Sin embargo, dado que trabajamos con las 
....................             //dos últimas cifras y que el próximo año divisible por 4 que no lo es por 100 
....................             //es el 2100, mejor nos limitaremos a la divisibilidad por 4. 
....................             //Dependiendo si el año es bisiesto o no, le damos a febrero 29 o 28 días. 
....................             if(data2[0]%4 == 0) 
418A:  MOVLB  0
418C:  MOVF   x9F,W
418E:  ANDLW  03
4190:  BNZ   4198
....................                dias_meses[1] = 29; 
4192:  MOVLW  1D
4194:  MOVWF  xD4
....................             else 
4196:  BRA    419C
....................                dias_meses[1] = 28; 
4198:  MOVLW  1C
419A:  MOVWF  xD4
419C:  MOVLB  2
....................          } 
....................  
....................          //Modificamos la información del día 
....................          dia[0] = data[0]; 
419E:  MOVFF  97,2A4
....................          dia[1] = data[1]; 
41A2:  MOVFF  98,2A5
....................          dia[2] = data2[0]; 
41A6:  MOVFF  9F,2A6
....................  
....................          //Aumentamos en 1 el número de días 
....................          num_dias++; 
41AA:  INCF   xA7,F
41AC:  BTFSC  FD8.2
41AE:  INCF   xA8,F
....................  
....................          //Reseteamos las variables acumulativas de tiempo por día 
....................          tiempo_x_dia = 0; 
41B0:  CLRF   xA1
41B2:  CLRF   xA0
....................          tiempo_x_dia_caldera = 0; 
41B4:  CLRF   xA3
41B6:  CLRF   xA2
....................       } 
....................  
....................       //Le sumamos al tiempo de encendido de sistema y caldera el correspondiente de este registro 
....................       tiempo_x_dia = tiempo_x_dia + data2[1]; 
41B8:  MOVLB  0
41BA:  MOVF   xA0,W
41BC:  MOVLB  2
41BE:  ADDWF  xA0,F
41C0:  MOVLW  00
41C2:  ADDWFC xA1,F
....................       tiempo_x_dia_caldera = tiempo_x_dia_caldera + data2[2]; 
41C4:  MOVLB  0
41C6:  MOVF   xA1,W
41C8:  MOVLB  2
41CA:  ADDWF  xA2,F
41CC:  MOVLW  00
41CE:  ADDWFC xA3,F
....................       //También incrementamos los tiempos totales 
....................       valor_total = valor_total + data2[1]; 
41D0:  MOVLB  0
41D2:  MOVF   xA0,W
41D4:  MOVLB  1
41D6:  ADDWF  x17,F
41D8:  MOVLW  00
41DA:  ADDWFC x18,F
....................       valor_total_caldera = valor_total_caldera + data2[2]; 
41DC:  MOVLB  0
41DE:  MOVF   xA1,W
41E0:  MOVLB  1
41E2:  ADDWF  x19,F
41E4:  MOVLW  00
41E6:  ADDWFC x1A,F
....................  
....................       //Representamos todos los datos, teniendo en cuenta algunos requisitos representativos 
....................       //para que los datos queden alineados (número menores que 10, que 100, etc). 
....................       if(data[0]<10) 
41E8:  MOVLB  0
41EA:  MOVF   x97,W
41EC:  SUBLW  09
41EE:  BNC   420E
....................          printf(" "); 
41F0:  MOVLB  2
41F2:  CLRF   xA9
41F4:  MOVF   xA9,W
41F6:  MOVLB  0
41F8:  CALL   0BF0
41FC:  IORLW  00
41FE:  BZ    420E
4200:  MOVLB  2
4202:  INCF   xA9,F
4204:  BTFSS  F9E.4
4206:  BRA    4204
4208:  MOVWF  FAD
420A:  BRA    41F4
420C:  MOVLB  0
....................  
....................       printf("%u/", data[0]); 
420E:  MOVFF  97,2AA
4212:  MOVLW  1B
4214:  MOVLB  2
4216:  MOVWF  xAB
4218:  MOVLB  0
421A:  CALL   38F0
421E:  MOVLW  2F
4220:  BTFSS  F9E.4
4222:  BRA    4220
4224:  MOVWF  FAD
....................  
....................       if(data[1]<10) 
4226:  MOVF   x98,W
4228:  SUBLW  09
422A:  BNC   424A
....................          printf("0"); 
422C:  MOVLB  2
422E:  CLRF   xA9
4230:  MOVF   xA9,W
4232:  MOVLB  0
4234:  CALL   0A48
4238:  IORLW  00
423A:  BZ    424A
423C:  MOVLB  2
423E:  INCF   xA9,F
4240:  BTFSS  F9E.4
4242:  BRA    4240
4244:  MOVWF  FAD
4246:  BRA    4230
4248:  MOVLB  0
....................  
....................       printf("%u/", data[1]); 
424A:  MOVFF  98,2AA
424E:  MOVLW  1B
4250:  MOVLB  2
4252:  MOVWF  xAB
4254:  MOVLB  0
4256:  CALL   38F0
425A:  MOVLW  2F
425C:  BTFSS  F9E.4
425E:  BRA    425C
4260:  MOVWF  FAD
....................  
....................       if(data2[0]<10) 
4262:  MOVF   x9F,W
4264:  SUBLW  09
4266:  BNC   4286
....................          printf("0"); 
4268:  MOVLB  2
426A:  CLRF   xA9
426C:  MOVF   xA9,W
426E:  MOVLB  0
4270:  CALL   0A48
4274:  IORLW  00
4276:  BZ    4286
4278:  MOVLB  2
427A:  INCF   xA9,F
427C:  BTFSS  F9E.4
427E:  BRA    427C
4280:  MOVWF  FAD
4282:  BRA    426C
4284:  MOVLB  0
....................  
....................       printf("%u  ", data2[0]); 
4286:  MOVFF  9F,2AA
428A:  MOVLW  1B
428C:  MOVLB  2
428E:  MOVWF  xAB
4290:  MOVLB  0
4292:  CALL   38F0
4296:  MOVLW  20
4298:  BTFSS  F9E.4
429A:  BRA    4298
429C:  MOVWF  FAD
429E:  MOVLW  20
42A0:  BTFSS  F9E.4
42A2:  BRA    42A0
42A4:  MOVWF  FAD
....................  
....................       if(data[2]<10) 
42A6:  MOVF   x99,W
42A8:  SUBLW  09
42AA:  BNC   42CA
....................          printf("0"); 
42AC:  MOVLB  2
42AE:  CLRF   xA9
42B0:  MOVF   xA9,W
42B2:  MOVLB  0
42B4:  CALL   0A48
42B8:  IORLW  00
42BA:  BZ    42CA
42BC:  MOVLB  2
42BE:  INCF   xA9,F
42C0:  BTFSS  F9E.4
42C2:  BRA    42C0
42C4:  MOVWF  FAD
42C6:  BRA    42B0
42C8:  MOVLB  0
....................  
....................       printf("%u:", data[2]); 
42CA:  MOVFF  99,2AA
42CE:  MOVLW  1B
42D0:  MOVLB  2
42D2:  MOVWF  xAB
42D4:  MOVLB  0
42D6:  CALL   38F0
42DA:  MOVLW  3A
42DC:  BTFSS  F9E.4
42DE:  BRA    42DC
42E0:  MOVWF  FAD
....................  
....................       if(data[3]<10) 
42E2:  MOVF   x9A,W
42E4:  SUBLW  09
42E6:  BNC   4306
....................          printf("0"); 
42E8:  MOVLB  2
42EA:  CLRF   xA9
42EC:  MOVF   xA9,W
42EE:  MOVLB  0
42F0:  CALL   0A48
42F4:  IORLW  00
42F6:  BZ    4306
42F8:  MOVLB  2
42FA:  INCF   xA9,F
42FC:  BTFSS  F9E.4
42FE:  BRA    42FC
4300:  MOVWF  FAD
4302:  BRA    42EC
4304:  MOVLB  0
....................  
....................       printf("%u          ", data[3]); 
4306:  MOVFF  9A,2AA
430A:  MOVLW  1B
430C:  MOVLB  2
430E:  MOVWF  xAB
4310:  MOVLB  0
4312:  CALL   38F0
4316:  MOVLW  0A
4318:  MOVLB  2
431A:  MOVWF  xA9
431C:  MOVLW  20
431E:  BTFSS  F9E.4
4320:  BRA    431E
4322:  MOVWF  FAD
4324:  DECFSZ xA9,F
4326:  BRA    431C
....................  
....................       if(data[4]<10) 
4328:  MOVLB  0
432A:  MOVF   x9B,W
432C:  SUBLW  09
432E:  BNC   434E
....................          printf(" "); 
4330:  MOVLB  2
4332:  CLRF   xA9
4334:  MOVF   xA9,W
4336:  MOVLB  0
4338:  CALL   0BF0
433C:  IORLW  00
433E:  BZ    434E
4340:  MOVLB  2
4342:  INCF   xA9,F
4344:  BTFSS  F9E.4
4346:  BRA    4344
4348:  MOVWF  FAD
434A:  BRA    4334
434C:  MOVLB  0
....................  
....................       printf("%u.", data[4]); 
434E:  MOVFF  9B,2AA
4352:  MOVLW  1B
4354:  MOVLB  2
4356:  MOVWF  xAB
4358:  MOVLB  0
435A:  CALL   38F0
435E:  MOVLW  2E
4360:  BTFSS  F9E.4
4362:  BRA    4360
4364:  MOVWF  FAD
....................  
....................       if(data[5]<10) 
4366:  MOVF   x9C,W
4368:  SUBLW  09
436A:  BNC   438A
....................          printf("0"); 
436C:  MOVLB  2
436E:  CLRF   xA9
4370:  MOVF   xA9,W
4372:  MOVLB  0
4374:  CALL   0A48
4378:  IORLW  00
437A:  BZ    438A
437C:  MOVLB  2
437E:  INCF   xA9,F
4380:  BTFSS  F9E.4
4382:  BRA    4380
4384:  MOVWF  FAD
4386:  BRA    4370
4388:  MOVLB  0
....................  
....................       printf("%u%cC             ", data[5], 223); 
438A:  MOVFF  9C,2AA
438E:  MOVLW  1B
4390:  MOVLB  2
4392:  MOVWF  xAB
4394:  MOVLB  0
4396:  CALL   38F0
439A:  MOVLW  DF
439C:  BTFSS  F9E.4
439E:  BRA    439C
43A0:  MOVWF  FAD
43A2:  MOVLW  43
43A4:  BTFSS  F9E.4
43A6:  BRA    43A4
43A8:  MOVWF  FAD
43AA:  MOVLW  0D
43AC:  MOVLB  2
43AE:  MOVWF  xA9
43B0:  MOVLW  20
43B2:  BTFSS  F9E.4
43B4:  BRA    43B2
43B6:  MOVWF  FAD
43B8:  DECFSZ xA9,F
43BA:  BRA    43B0
....................  
....................       if(data[6]<10) 
43BC:  MOVLB  0
43BE:  MOVF   x9D,W
43C0:  SUBLW  09
43C2:  BNC   43E2
....................          printf(" "); 
43C4:  MOVLB  2
43C6:  CLRF   xA9
43C8:  MOVF   xA9,W
43CA:  MOVLB  0
43CC:  CALL   0BF0
43D0:  IORLW  00
43D2:  BZ    43E2
43D4:  MOVLB  2
43D6:  INCF   xA9,F
43D8:  BTFSS  F9E.4
43DA:  BRA    43D8
43DC:  MOVWF  FAD
43DE:  BRA    43C8
43E0:  MOVLB  0
....................  
....................       printf("%u.", data[6]); 
43E2:  MOVFF  9D,2AA
43E6:  MOVLW  1B
43E8:  MOVLB  2
43EA:  MOVWF  xAB
43EC:  MOVLB  0
43EE:  CALL   38F0
43F2:  MOVLW  2E
43F4:  BTFSS  F9E.4
43F6:  BRA    43F4
43F8:  MOVWF  FAD
....................  
....................       if(data[7]<10) 
43FA:  MOVF   x9E,W
43FC:  SUBLW  09
43FE:  BNC   441E
....................          printf("0"); 
4400:  MOVLB  2
4402:  CLRF   xA9
4404:  MOVF   xA9,W
4406:  MOVLB  0
4408:  CALL   0A48
440C:  IORLW  00
440E:  BZ    441E
4410:  MOVLB  2
4412:  INCF   xA9,F
4414:  BTFSS  F9E.4
4416:  BRA    4414
4418:  MOVWF  FAD
441A:  BRA    4404
441C:  MOVLB  0
....................  
....................       printf("%u%cC              %u%cC                  ", data[7], 223, data2[3], 223); 
441E:  MOVFF  9E,2AA
4422:  MOVLW  1B
4424:  MOVLB  2
4426:  MOVWF  xAB
4428:  MOVLB  0
442A:  CALL   38F0
442E:  MOVLW  DF
4430:  BTFSS  F9E.4
4432:  BRA    4430
4434:  MOVWF  FAD
4436:  MOVLW  43
4438:  BTFSS  F9E.4
443A:  BRA    4438
443C:  MOVWF  FAD
443E:  MOVLW  0E
4440:  MOVLB  2
4442:  MOVWF  xA9
4444:  MOVLW  20
4446:  BTFSS  F9E.4
4448:  BRA    4446
444A:  MOVWF  FAD
444C:  DECFSZ xA9,F
444E:  BRA    4444
4450:  MOVFF  A2,2AA
4454:  MOVLW  1B
4456:  MOVWF  xAB
4458:  MOVLB  0
445A:  CALL   38F0
445E:  MOVLW  DF
4460:  BTFSS  F9E.4
4462:  BRA    4460
4464:  MOVWF  FAD
4466:  MOVLW  43
4468:  BTFSS  F9E.4
446A:  BRA    4468
446C:  MOVWF  FAD
446E:  MOVLW  12
4470:  MOVLB  2
4472:  MOVWF  xAA
4474:  MOVLW  20
4476:  BTFSS  F9E.4
4478:  BRA    4476
447A:  MOVWF  FAD
447C:  DECFSZ xAA,F
447E:  BRA    4474
....................  
....................       if(data2[1]<100) 
4480:  MOVLB  0
4482:  MOVF   xA0,W
4484:  SUBLW  63
4486:  BNC   44A6
....................          printf(" "); 
4488:  MOVLB  2
448A:  CLRF   xA9
448C:  MOVF   xA9,W
448E:  MOVLB  0
4490:  CALL   0BF0
4494:  IORLW  00
4496:  BZ    44A6
4498:  MOVLB  2
449A:  INCF   xA9,F
449C:  BTFSS  F9E.4
449E:  BRA    449C
44A0:  MOVWF  FAD
44A2:  BRA    448C
44A4:  MOVLB  0
....................       if(data2[1]<10) 
44A6:  MOVF   xA0,W
44A8:  SUBLW  09
44AA:  BNC   44CA
....................          printf(" "); 
44AC:  MOVLB  2
44AE:  CLRF   xA9
44B0:  MOVF   xA9,W
44B2:  MOVLB  0
44B4:  CALL   0BF0
44B8:  IORLW  00
44BA:  BZ    44CA
44BC:  MOVLB  2
44BE:  INCF   xA9,F
44C0:  BTFSS  F9E.4
44C2:  BRA    44C0
44C4:  MOVWF  FAD
44C6:  BRA    44B0
44C8:  MOVLB  0
....................  
....................       printf("%u                    ", data2[1]); 
44CA:  MOVFF  A0,2AA
44CE:  MOVLW  1B
44D0:  MOVLB  2
44D2:  MOVWF  xAB
44D4:  MOVLB  0
44D6:  CALL   38F0
44DA:  MOVLW  14
44DC:  MOVLB  2
44DE:  MOVWF  xA9
44E0:  MOVLW  20
44E2:  BTFSS  F9E.4
44E4:  BRA    44E2
44E6:  MOVWF  FAD
44E8:  DECFSZ xA9,F
44EA:  BRA    44E0
....................  
....................       if(data2[2]<100) 
44EC:  MOVLB  0
44EE:  MOVF   xA1,W
44F0:  SUBLW  63
44F2:  BNC   4512
....................          printf(" "); 
44F4:  MOVLB  2
44F6:  CLRF   xA9
44F8:  MOVF   xA9,W
44FA:  MOVLB  0
44FC:  CALL   0BF0
4500:  IORLW  00
4502:  BZ    4512
4504:  MOVLB  2
4506:  INCF   xA9,F
4508:  BTFSS  F9E.4
450A:  BRA    4508
450C:  MOVWF  FAD
450E:  BRA    44F8
4510:  MOVLB  0
....................       if(data2[2]<10) 
4512:  MOVF   xA1,W
4514:  SUBLW  09
4516:  BNC   4536
....................          printf(" "); 
4518:  MOVLB  2
451A:  CLRF   xA9
451C:  MOVF   xA9,W
451E:  MOVLB  0
4520:  CALL   0BF0
4524:  IORLW  00
4526:  BZ    4536
4528:  MOVLB  2
452A:  INCF   xA9,F
452C:  BTFSS  F9E.4
452E:  BRA    452C
4530:  MOVWF  FAD
4532:  BRA    451C
4534:  MOVLB  0
....................  
....................       printf("%u\r", data2[2]); 
4536:  MOVFF  A1,2AA
453A:  MOVLW  1B
453C:  MOVLB  2
453E:  MOVWF  xAB
4540:  MOVLB  0
4542:  CALL   38F0
4546:  MOVLW  0D
4548:  BTFSS  F9E.4
454A:  BRA    4548
454C:  MOVWF  FAD
....................  
....................    } 
454E:  INCF   x95,F
4550:  BRA    3D7E
....................  
....................    //Debemos realizar la operación de guardado para el último día. El proceso es el mismo 
....................    //que hemos seguido arriba. 
....................    if(dia[0]!=0) 
4552:  MOVLB  2
4554:  MOVF   xA4,F
4556:  BZ    462C
....................    { 
....................       valor = valor + (float)tiempo_x_dia; 
4558:  MOVFF  2A1,2B0
455C:  MOVFF  2A0,2AF
4560:  MOVLB  0
4562:  CALL   26A2
4566:  BCF    FD8.1
4568:  MOVFF  E6,2AC
456C:  MOVFF  E5,2AB
4570:  MOVFF  E4,2AA
4574:  MOVFF  E3,2A9
4578:  MOVFF  03,2B0
457C:  MOVFF  02,2AF
4580:  MOVFF  01,2AE
4584:  MOVFF  00,2AD
4588:  CALL   2428
458C:  MOVFF  03,E6
4590:  MOVFF  02,E5
4594:  MOVFF  01,E4
4598:  MOVFF  00,E3
....................       media_dia_mes[dia[1]-1] = valor; 
459C:  MOVLW  01
459E:  MOVLB  2
45A0:  SUBWF  xA5,W
45A2:  MULLW  04
45A4:  MOVF   FF3,W
45A6:  CLRF   03
45A8:  ADDLW  A3
45AA:  MOVWF  FE9
45AC:  MOVLW  00
45AE:  ADDWFC 03,W
45B0:  MOVWF  FEA
45B2:  MOVFF  E3,FEF
45B6:  MOVFF  E4,FEC
45BA:  MOVFF  E5,FEC
45BE:  MOVFF  E6,FEC
....................       media_dia_caldera = media_dia_caldera + (float)tiempo_x_dia_caldera; 
45C2:  MOVFF  2A3,2B0
45C6:  MOVFF  2A2,2AF
45CA:  MOVLB  0
45CC:  CALL   26A2
45D0:  BCF    FD8.1
45D2:  MOVFF  E2,2AC
45D6:  MOVFF  E1,2AB
45DA:  MOVFF  E0,2AA
45DE:  MOVFF  DF,2A9
45E2:  MOVFF  03,2B0
45E6:  MOVFF  02,2AF
45EA:  MOVFF  01,2AE
45EE:  MOVFF  00,2AD
45F2:  CALL   2428
45F6:  MOVFF  03,E2
45FA:  MOVFF  02,E1
45FE:  MOVFF  01,E0
4602:  MOVFF  00,DF
....................       media_dia_mes_caldera[dia[1]-1] = media_dia_caldera; 
4606:  MOVLW  01
4608:  MOVLB  2
460A:  SUBWF  xA5,W
460C:  MULLW  04
460E:  MOVF   FF3,W
4610:  CLRF   03
4612:  ADDLW  E7
4614:  MOVWF  FE9
4616:  MOVLW  00
4618:  ADDWFC 03,W
461A:  MOVWF  FEA
461C:  MOVFF  DF,FEF
4620:  MOVFF  E0,FEC
4624:  MOVFF  E1,FEC
4628:  MOVFF  E2,FEC
....................    } 
....................  
....................    //Comprobamos que no nos encontrabamos en el año introducido por defecto 
....................    if(dia[2]!=0) 
462C:  MOVF   xA6,F
462E:  BTFSC  FD8.2
4630:  BRA    485C
....................    { 
....................       for(contador2=0; contador2<12; contador2++) 
4632:  MOVLB  0
4634:  CLRF   x96
4636:  MOVF   x96,W
4638:  SUBLW  0B
463A:  BTFSS  FD8.0
463C:  BRA    4846
....................       { 
....................          media_dia_mes[contador2] = media_dia_mes[contador2]/(float)dias_meses[contador2]; 
463E:  MOVF   x96,W
4640:  MULLW  04
4642:  MOVF   FF3,W
4644:  CLRF   03
4646:  ADDLW  A3
4648:  MOVWF  01
464A:  MOVLW  00
464C:  ADDWFC 03,F
464E:  MOVFF  01,2A9
4652:  MOVFF  03,2AA
4656:  MOVLB  0
4658:  MOVF   x96,W
465A:  MULLW  04
465C:  MOVF   FF3,W
465E:  CLRF   03
4660:  ADDLW  A3
4662:  MOVWF  FE9
4664:  MOVLW  00
4666:  ADDWFC 03,W
4668:  MOVWF  FEA
466A:  MOVFF  FEF,2AB
466E:  MOVFF  FEC,2AC
4672:  MOVFF  FEC,2AD
4676:  MOVFF  FEC,2AE
467A:  CLRF   03
467C:  MOVF   x96,W
467E:  ADDLW  D3
4680:  MOVWF  FE9
4682:  MOVLW  00
4684:  ADDWFC 03,W
4686:  MOVWF  FEA
4688:  MOVF   FEF,W
468A:  MOVLB  2
468C:  CLRF   xB0
468E:  MOVWF  xAF
4690:  MOVLB  0
4692:  CALL   26A2
4696:  MOVFF  2AE,2B2
469A:  MOVFF  2AD,2B1
469E:  MOVFF  2AC,2B0
46A2:  MOVFF  2AB,2AF
46A6:  MOVFF  03,2B6
46AA:  MOVFF  02,2B5
46AE:  MOVFF  01,2B4
46B2:  MOVFF  00,2B3
46B6:  CALL   2058
46BA:  MOVFF  2AA,FEA
46BE:  MOVFF  2A9,FE9
46C2:  MOVFF  00,FEF
46C6:  MOVFF  01,FEC
46CA:  MOVFF  02,FEC
46CE:  MOVFF  03,FEC
....................          media_dia_mes_caldera[contador2] = media_dia_mes_caldera[contador2]/(float)dias_meses[contador2]; 
46D2:  MOVF   x96,W
46D4:  MULLW  04
46D6:  MOVF   FF3,W
46D8:  CLRF   03
46DA:  ADDLW  E7
46DC:  MOVWF  01
46DE:  MOVLW  00
46E0:  ADDWFC 03,F
46E2:  MOVFF  01,2A9
46E6:  MOVFF  03,2AA
46EA:  MOVLB  0
46EC:  MOVF   x96,W
46EE:  MULLW  04
46F0:  MOVF   FF3,W
46F2:  CLRF   03
46F4:  ADDLW  E7
46F6:  MOVWF  FE9
46F8:  MOVLW  00
46FA:  ADDWFC 03,W
46FC:  MOVWF  FEA
46FE:  MOVFF  FEF,2AB
4702:  MOVFF  FEC,2AC
4706:  MOVFF  FEC,2AD
470A:  MOVFF  FEC,2AE
470E:  CLRF   03
4710:  MOVF   x96,W
4712:  ADDLW  D3
4714:  MOVWF  FE9
4716:  MOVLW  00
4718:  ADDWFC 03,W
471A:  MOVWF  FEA
471C:  MOVF   FEF,W
471E:  MOVLB  2
4720:  CLRF   xB0
4722:  MOVWF  xAF
4724:  MOVLB  0
4726:  CALL   26A2
472A:  MOVFF  2AE,2B2
472E:  MOVFF  2AD,2B1
4732:  MOVFF  2AC,2B0
4736:  MOVFF  2AB,2AF
473A:  MOVFF  03,2B6
473E:  MOVFF  02,2B5
4742:  MOVFF  01,2B4
4746:  MOVFF  00,2B3
474A:  CALL   2058
474E:  MOVFF  2AA,FEA
4752:  MOVFF  2A9,FE9
4756:  MOVFF  00,FEF
475A:  MOVFF  01,FEC
475E:  MOVFF  02,FEC
4762:  MOVFF  03,FEC
....................          media_annos[num_annos][contador2] = media_dia_mes[contador2]; 
4766:  MOVLB  2
4768:  MOVF   x9B,W
476A:  MULLW  30
476C:  MOVF   FF3,W
476E:  CLRF   xAA
4770:  MOVWF  xA9
4772:  MOVLB  0
4774:  MOVF   x96,W
4776:  MULLW  04
4778:  MOVF   FF3,W
477A:  CLRF   03
477C:  MOVLB  2
477E:  ADDWF  xA9,W
4780:  MOVWF  01
4782:  MOVF   xAA,W
4784:  ADDWFC 03,F
4786:  MOVF   01,W
4788:  ADDLW  1B
478A:  MOVWF  01
478C:  MOVLW  01
478E:  ADDWFC 03,F
4790:  MOVFF  01,2AB
4794:  MOVFF  03,2AC
4798:  MOVLB  0
479A:  MOVF   x96,W
479C:  MULLW  04
479E:  MOVF   FF3,W
47A0:  CLRF   03
47A2:  ADDLW  A3
47A4:  MOVWF  FE9
47A6:  MOVLW  00
47A8:  ADDWFC 03,W
47AA:  MOVWF  FEA
47AC:  MOVFF  FEF,00
47B0:  MOVFF  FEC,01
47B4:  MOVFF  FEC,02
47B8:  MOVFF  FEC,03
47BC:  MOVFF  2AC,FEA
47C0:  MOVFF  2AB,FE9
47C4:  MOVFF  00,FEF
47C8:  MOVFF  01,FEC
47CC:  MOVFF  02,FEC
47D0:  MOVFF  03,FEC
....................          media_annos_caldera[num_annos][contador2] = media_dia_mes_caldera[contador2]; 
47D4:  MOVLB  2
47D6:  MOVF   x9B,W
47D8:  MULLW  30
47DA:  MOVF   FF3,W
47DC:  CLRF   xAA
47DE:  MOVWF  xA9
47E0:  MOVLB  0
47E2:  MOVF   x96,W
47E4:  MULLW  04
47E6:  MOVF   FF3,W
47E8:  CLRF   03
47EA:  MOVLB  2
47EC:  ADDWF  xA9,W
47EE:  MOVWF  01
47F0:  MOVF   xAA,W
47F2:  ADDWFC 03,F
47F4:  MOVF   01,W
47F6:  ADDLW  DB
47F8:  MOVWF  01
47FA:  MOVLW  01
47FC:  ADDWFC 03,F
47FE:  MOVFF  01,2AB
4802:  MOVFF  03,2AC
4806:  MOVLB  0
4808:  MOVF   x96,W
480A:  MULLW  04
480C:  MOVF   FF3,W
480E:  CLRF   03
4810:  ADDLW  E7
4812:  MOVWF  FE9
4814:  MOVLW  00
4816:  ADDWFC 03,W
4818:  MOVWF  FEA
481A:  MOVFF  FEF,00
481E:  MOVFF  FEC,01
4822:  MOVFF  FEC,02
4826:  MOVFF  FEC,03
482A:  MOVFF  2AC,FEA
482E:  MOVFF  2AB,FE9
4832:  MOVFF  00,FEF
4836:  MOVFF  01,FEC
483A:  MOVFF  02,FEC
483E:  MOVFF  03,FEC
....................       } 
4842:  INCF   x96,F
4844:  BRA    4636
....................  
....................       annos[num_annos]=dia[2]; 
4846:  CLRF   03
4848:  MOVLB  2
484A:  MOVF   x9B,W
484C:  ADDLW  9C
484E:  MOVWF  FE9
4850:  MOVLW  02
4852:  ADDWFC 03,W
4854:  MOVWF  FEA
4856:  MOVFF  2A6,FEF
....................  
....................       num_annos++; 
485A:  INCF   x9B,F
....................    } 
....................  
....................    //Calculamos la media como el cociente entre los valore de tiempo calculados y el número de 
....................    //días en los que se ha encendido la caldera 
....................    valor = valor/(float)num_dias; 
485C:  MOVFF  2A8,2B0
4860:  MOVFF  2A7,2AF
4864:  MOVLB  0
4866:  CALL   26A2
486A:  MOVFF  E6,2B2
486E:  MOVFF  E5,2B1
4872:  MOVFF  E4,2B0
4876:  MOVFF  E3,2AF
487A:  MOVFF  03,2B6
487E:  MOVFF  02,2B5
4882:  MOVFF  01,2B4
4886:  MOVFF  00,2B3
488A:  CALL   2058
488E:  MOVFF  03,E6
4892:  MOVFF  02,E5
4896:  MOVFF  01,E4
489A:  MOVFF  00,E3
....................    media_dia_caldera = media_dia_caldera/(float)num_dias; 
489E:  MOVFF  2A8,2B0
48A2:  MOVFF  2A7,2AF
48A6:  CALL   26A2
48AA:  MOVFF  E2,2B2
48AE:  MOVFF  E1,2B1
48B2:  MOVFF  E0,2B0
48B6:  MOVFF  DF,2AF
48BA:  MOVFF  03,2B6
48BE:  MOVFF  02,2B5
48C2:  MOVFF  01,2B4
48C6:  MOVFF  00,2B3
48CA:  CALL   2058
48CE:  MOVFF  03,E2
48D2:  MOVFF  02,E1
48D6:  MOVFF  01,E0
48DA:  MOVFF  00,DF
....................  
....................    repetir: 
....................    //Menú para mostrar los datos 
....................    printf("\r===========================================================================================================================\r"); 
48DE:  MOVLB  2
48E0:  CLRF   xA9
48E2:  MOVF   xA9,W
48E4:  MOVLB  0
48E6:  CALL   0C0C
48EA:  IORLW  00
48EC:  BZ    48FC
48EE:  MOVLB  2
48F0:  INCF   xA9,F
48F2:  BTFSS  F9E.4
48F4:  BRA    48F2
48F6:  MOVWF  FAD
48F8:  BRA    48E2
48FA:  MOVLB  0
....................    printf("¿Que operacion desea realizar?\r"); 
48FC:  MOVLB  2
48FE:  CLRF   xA9
4900:  MOVF   xA9,W
4902:  MOVLB  0
4904:  CALL   0CA4
4908:  IORLW  00
490A:  BZ    491A
490C:  MOVLB  2
490E:  INCF   xA9,F
4910:  BTFSS  F9E.4
4912:  BRA    4910
4914:  MOVWF  FAD
4916:  BRA    4900
4918:  MOVLB  0
....................    printf("0. Salir\r"); 
491A:  MOVLB  2
491C:  CLRF   xA9
491E:  MOVF   xA9,W
4920:  MOVLB  0
4922:  CALL   0CDE
4926:  IORLW  00
4928:  BZ    4938
492A:  MOVLB  2
492C:  INCF   xA9,F
492E:  BTFSS  F9E.4
4930:  BRA    492E
4932:  MOVWF  FAD
4934:  BRA    491E
4936:  MOVLB  0
....................    printf("1. Extraer tiempos medios por dia\r"); 
4938:  MOVLB  2
493A:  CLRF   xA9
493C:  MOVF   xA9,W
493E:  MOVLB  0
4940:  CALL   0D02
4944:  IORLW  00
4946:  BZ    4956
4948:  MOVLB  2
494A:  INCF   xA9,F
494C:  BTFSS  F9E.4
494E:  BRA    494C
4950:  MOVWF  FAD
4952:  BRA    493C
4954:  MOVLB  0
....................    printf("2. Extraer tiempos totales\r"); 
4956:  MOVLB  2
4958:  CLRF   xA9
495A:  MOVF   xA9,W
495C:  MOVLB  0
495E:  CALL   0D40
4962:  IORLW  00
4964:  BZ    4974
4966:  MOVLB  2
4968:  INCF   xA9,F
496A:  BTFSS  F9E.4
496C:  BRA    496A
496E:  MOVWF  FAD
4970:  BRA    495A
4972:  MOVLB  0
....................    printf("3. Extraer datos mensuales\r"); 
4974:  MOVLB  2
4976:  CLRF   xA9
4978:  MOVF   xA9,W
497A:  MOVLB  0
497C:  CALL   0D76
4980:  IORLW  00
4982:  BZ    4992
4984:  MOVLB  2
4986:  INCF   xA9,F
4988:  BTFSS  F9E.4
498A:  BRA    4988
498C:  MOVWF  FAD
498E:  BRA    4978
4990:  MOVLB  0
....................    printf("===========================================================================================================================\r"); 
4992:  MOVLB  2
4994:  CLRF   xA9
4996:  MOVF   xA9,W
4998:  MOVLB  0
499A:  CALL   0B58
499E:  IORLW  00
49A0:  BZ    49B0
49A2:  MOVLB  2
49A4:  INCF   xA9,F
49A6:  BTFSS  F9E.4
49A8:  BRA    49A6
49AA:  MOVWF  FAD
49AC:  BRA    4996
49AE:  MOVLB  0
....................  
....................    //Esperamos la introducción de una de las opciones por parte del técnico 
....................    while(key!='1' && key!='2' && key!='3' && key!='0'){ 
49B0:  MOVF   38,W
49B2:  SUBLW  31
49B4:  BZ    49D2
49B6:  MOVF   38,W
49B8:  SUBLW  32
49BA:  BZ    49D2
49BC:  MOVF   38,W
49BE:  SUBLW  33
49C0:  BZ    49D2
49C2:  MOVF   38,W
49C4:  SUBLW  30
49C6:  BZ    49D2
....................       key=getch(); 
49C8:  BTFSS  F9E.5
49CA:  BRA    49C8
49CC:  MOVFF  FAE,38
....................    } 
49D0:  BRA    49B0
....................  
....................    switch(key) 
....................    { 
49D2:  MOVLW  30
49D4:  SUBWF  38,W
49D6:  ADDLW  FC
49D8:  BTFSC  FD8.0
49DA:  GOTO   5752
49DE:  ADDLW  04
49E0:  GOTO   5756
....................       //En el caso 0, se sale del sistema 
....................       case '0': 
....................                //Se indica la salida mediante un mensaje 
....................                printf("\rSaliendo...\r"); 
49E4:  MOVLB  2
49E6:  CLRF   xA9
49E8:  MOVF   xA9,W
49EA:  MOVLB  0
49EC:  CALL   0DAC
49F0:  IORLW  00
49F2:  BZ    4A02
49F4:  MOVLB  2
49F6:  INCF   xA9,F
49F8:  BTFSS  F9E.4
49FA:  BRA    49F8
49FC:  MOVWF  FAD
49FE:  BRA    49E8
4A00:  MOVLB  0
....................                break; 
4A02:  GOTO   5752
....................  
....................       //En el caso 1, se muestran los valores medios 
....................       case '1': 
....................                key = 'J';  //Utilizamos este carácter para evitar la elección errónea de la misma acción 
4A06:  MOVLW  4A
4A08:  MOVWF  38
....................                printf("\rTiempo medio de encendido del sistema por dia: %3.2f minutos\r\r", valor); 
4A0A:  MOVLB  2
4A0C:  CLRF   xA9
4A0E:  MOVF   xA9,W
4A10:  MOVLB  0
4A12:  CALL   0DD4
4A16:  MOVLB  2
4A18:  INCF   xA9,F
4A1A:  MOVWF  00
4A1C:  MOVF   00,W
4A1E:  BTFSS  F9E.4
4A20:  BRA    4A1E
4A22:  MOVWF  FAD
4A24:  MOVLW  30
4A26:  SUBWF  xA9,W
4A28:  BNZ   4A0E
4A2A:  MOVLW  02
4A2C:  MOVWF  FE9
4A2E:  MOVFF  E6,2BB
4A32:  MOVFF  E5,2BA
4A36:  MOVFF  E4,2B9
4A3A:  MOVFF  E3,2B8
4A3E:  MOVWF  xBC
4A40:  MOVLB  0
4A42:  CALL   396E
4A46:  MOVLW  35
4A48:  MOVLB  2
4A4A:  MOVWF  xAA
4A4C:  MOVF   xAA,W
4A4E:  MOVLB  0
4A50:  CALL   0DD4
4A54:  MOVLB  2
4A56:  INCF   xAA,F
4A58:  MOVWF  00
4A5A:  MOVF   00,W
4A5C:  BTFSS  F9E.4
4A5E:  BRA    4A5C
4A60:  MOVWF  FAD
4A62:  MOVLW  3F
4A64:  SUBWF  xAA,W
4A66:  BNZ   4A4C
....................                printf("Tiempo medio de encendido de la caldera por dia: %3.2f minutos\r\r", media_dia_caldera); 
4A68:  CLRF   xA9
4A6A:  MOVF   xA9,W
4A6C:  MOVLB  0
4A6E:  CALL   0E2E
4A72:  MOVLB  2
4A74:  INCF   xA9,F
4A76:  MOVWF  00
4A78:  MOVF   00,W
4A7A:  BTFSS  F9E.4
4A7C:  BRA    4A7A
4A7E:  MOVWF  FAD
4A80:  MOVLW  31
4A82:  SUBWF  xA9,W
4A84:  BNZ   4A6A
4A86:  MOVLW  02
4A88:  MOVWF  FE9
4A8A:  MOVFF  E2,2BB
4A8E:  MOVFF  E1,2BA
4A92:  MOVFF  E0,2B9
4A96:  MOVFF  DF,2B8
4A9A:  MOVWF  xBC
4A9C:  MOVLB  0
4A9E:  CALL   396E
4AA2:  MOVLW  36
4AA4:  MOVLB  2
4AA6:  MOVWF  xAA
4AA8:  MOVF   xAA,W
4AAA:  MOVLB  0
4AAC:  CALL   0E2E
4AB0:  MOVLB  2
4AB2:  INCF   xAA,F
4AB4:  MOVWF  00
4AB6:  MOVF   00,W
4AB8:  BTFSS  F9E.4
4ABA:  BRA    4AB8
4ABC:  MOVWF  FAD
4ABE:  MOVLW  40
4AC0:  SUBWF  xAA,W
4AC2:  BNZ   4AA8
....................                goto repetir; 
4AC4:  MOVLB  0
4AC6:  BRA    48DE
....................                break; 
4AC8:  GOTO   5752
....................  
....................       //En el caso 2, se muestran los valores totales 
....................       case '2': 
....................                key = 'J'; //Ídem 
4ACC:  MOVLW  4A
4ACE:  MOVWF  38
....................                printf("\rTiempo total de encendido del sistema: %lu minutos\r\r", valor_total); 
4AD0:  MOVLB  2
4AD2:  CLRF   xA9
4AD4:  MOVF   xA9,W
4AD6:  MOVLB  0
4AD8:  CALL   0E8A
4ADC:  MOVLB  2
4ADE:  INCF   xA9,F
4AE0:  MOVWF  00
4AE2:  MOVF   00,W
4AE4:  BTFSS  F9E.4
4AE6:  BRA    4AE4
4AE8:  MOVWF  FAD
4AEA:  MOVLW  28
4AEC:  SUBWF  xA9,W
4AEE:  BNZ   4AD4
4AF0:  MOVLW  10
4AF2:  MOVWF  FE9
4AF4:  MOVFF  118,2AB
4AF8:  MOVFF  117,2AA
4AFC:  MOVLB  0
4AFE:  CALL   3B14
4B02:  MOVLW  2B
4B04:  MOVLB  2
4B06:  MOVWF  xAA
4B08:  MOVF   xAA,W
4B0A:  MOVLB  0
4B0C:  CALL   0E8A
4B10:  MOVLB  2
4B12:  INCF   xAA,F
4B14:  MOVWF  00
4B16:  MOVF   00,W
4B18:  BTFSS  F9E.4
4B1A:  BRA    4B18
4B1C:  MOVWF  FAD
4B1E:  MOVLW  35
4B20:  SUBWF  xAA,W
4B22:  BNZ   4B08
....................                printf("Tiempo total de encendido de la caldera: %lu minutos\r\r", valor_total_caldera); 
4B24:  CLRF   xA9
4B26:  MOVF   xA9,W
4B28:  MOVLB  0
4B2A:  CALL   0EDA
4B2E:  MOVLB  2
4B30:  INCF   xA9,F
4B32:  MOVWF  00
4B34:  MOVF   00,W
4B36:  BTFSS  F9E.4
4B38:  BRA    4B36
4B3A:  MOVWF  FAD
4B3C:  MOVLW  29
4B3E:  SUBWF  xA9,W
4B40:  BNZ   4B26
4B42:  MOVLW  10
4B44:  MOVWF  FE9
4B46:  MOVFF  11A,2AB
4B4A:  MOVFF  119,2AA
4B4E:  MOVLB  0
4B50:  CALL   3B14
4B54:  MOVLW  2C
4B56:  MOVLB  2
4B58:  MOVWF  xAA
4B5A:  MOVF   xAA,W
4B5C:  MOVLB  0
4B5E:  CALL   0EDA
4B62:  MOVLB  2
4B64:  INCF   xAA,F
4B66:  MOVWF  00
4B68:  MOVF   00,W
4B6A:  BTFSS  F9E.4
4B6C:  BRA    4B6A
4B6E:  MOVWF  FAD
4B70:  MOVLW  36
4B72:  SUBWF  xAA,W
4B74:  BNZ   4B5A
....................                goto repetir; 
4B76:  MOVLB  0
4B78:  BRA    48DE
....................                break; 
4B7A:  GOTO   5752
....................  
....................       //En el caso 3, se muestran todos los valores medios por meses y años 
....................       case '3': 
....................                key = 'J'; //Ídem 
4B7E:  MOVLW  4A
4B80:  MOVWF  38
....................                //Se representan todos los años de los que se tiene registro 
....................                for(contador=0; contador<num_annos; contador++) 
4B82:  CLRF   x95
4B84:  MOVLB  2
4B86:  MOVF   x9B,W
4B88:  MOVLB  0
4B8A:  SUBWF  x95,W
4B8C:  BTFSC  FD8.0
4B8E:  GOTO   574C
....................                { 
....................                   //Imprimimos el año en el que nos encontramos 
....................                   printf("\r20"); 
4B92:  MOVLB  2
4B94:  CLRF   xA9
4B96:  MOVF   xA9,W
4B98:  MOVLB  0
4B9A:  CALL   0F2C
4B9E:  IORLW  00
4BA0:  BZ    4BB0
4BA2:  MOVLB  2
4BA4:  INCF   xA9,F
4BA6:  BTFSS  F9E.4
4BA8:  BRA    4BA6
4BAA:  MOVWF  FAD
4BAC:  BRA    4B96
4BAE:  MOVLB  0
....................                   if(annos[contador]<10) 
4BB0:  CLRF   03
4BB2:  MOVF   x95,W
4BB4:  ADDLW  9C
4BB6:  MOVWF  FE9
4BB8:  MOVLW  02
4BBA:  ADDWFC 03,W
4BBC:  MOVWF  FEA
4BBE:  MOVF   FEF,W
4BC0:  SUBLW  09
4BC2:  BNC   4BE2
....................                      printf("0"); 
4BC4:  MOVLB  2
4BC6:  CLRF   xA9
4BC8:  MOVF   xA9,W
4BCA:  MOVLB  0
4BCC:  CALL   0A48
4BD0:  IORLW  00
4BD2:  BZ    4BE2
4BD4:  MOVLB  2
4BD6:  INCF   xA9,F
4BD8:  BTFSS  F9E.4
4BDA:  BRA    4BD8
4BDC:  MOVWF  FAD
4BDE:  BRA    4BC8
4BE0:  MOVLB  0
....................                   printf("%u\r", annos[contador]); 
4BE2:  CLRF   03
4BE4:  MOVF   x95,W
4BE6:  ADDLW  9C
4BE8:  MOVWF  FE9
4BEA:  MOVLW  02
4BEC:  ADDWFC 03,W
4BEE:  MOVWF  FEA
4BF0:  MOVFF  FEF,2A9
4BF4:  MOVFF  2A9,2AA
4BF8:  MOVLW  1B
4BFA:  MOVLB  2
4BFC:  MOVWF  xAB
4BFE:  MOVLB  0
4C00:  CALL   38F0
4C04:  MOVLW  0D
4C06:  BTFSS  F9E.4
4C08:  BRA    4C06
4C0A:  MOVWF  FAD
....................                   printf("--------------------------------------------------------------------------------------------------------------------\r"); 
4C0C:  MOVLB  2
4C0E:  CLRF   xA9
4C10:  MOVF   xA9,W
4C12:  MOVLB  0
4C14:  CALL   0F4A
4C18:  IORLW  00
4C1A:  BZ    4C2A
4C1C:  MOVLB  2
4C1E:  INCF   xA9,F
4C20:  BTFSS  F9E.4
4C22:  BRA    4C20
4C24:  MOVWF  FAD
4C26:  BRA    4C10
4C28:  MOVLB  0
....................                   printf("              Tiempo medio de encendido del sistema (min/dia)      Tiempo medio de encendido de la caldera (min/dia)\r"); 
4C2A:  MOVLB  2
4C2C:  CLRF   xA9
4C2E:  MOVF   xA9,W
4C30:  MOVLB  0
4C32:  CALL   0FDA
4C36:  IORLW  00
4C38:  BZ    4C48
4C3A:  MOVLB  2
4C3C:  INCF   xA9,F
4C3E:  BTFSS  F9E.4
4C40:  BRA    4C3E
4C42:  MOVWF  FAD
4C44:  BRA    4C2E
4C46:  MOVLB  0
....................                   printf("ENERO                              %3.2f                                                     %3.2f\r", media_annos[contador][0], media_annos_caldera[contador][0]); 
4C48:  MOVF   x95,W
4C4A:  MULLW  30
4C4C:  MOVF   FF3,W
4C4E:  MOVLB  2
4C50:  CLRF   xAA
4C52:  MOVWF  xA9
4C54:  MOVLW  1B
4C56:  ADDWF  xA9,W
4C58:  MOVWF  FE9
4C5A:  MOVLW  01
4C5C:  ADDWFC xAA,W
4C5E:  MOVWF  FEA
4C60:  MOVFF  FEF,2AB
4C64:  MOVFF  FEC,2AC
4C68:  MOVFF  FEC,2AD
4C6C:  MOVFF  FEC,2AE
4C70:  MOVLB  0
4C72:  MOVF   x95,W
4C74:  MULLW  30
4C76:  MOVF   FF3,W
4C78:  MOVLB  2
4C7A:  CLRF   xB0
4C7C:  MOVWF  xAF
4C7E:  MOVLW  DB
4C80:  ADDWF  xAF,W
4C82:  MOVWF  FE9
4C84:  MOVLW  01
4C86:  ADDWFC xB0,W
4C88:  MOVWF  FEA
4C8A:  MOVFF  FEF,2B1
4C8E:  MOVFF  FEC,2B2
4C92:  MOVFF  FEC,2B3
4C96:  MOVFF  FEC,2B4
4C9A:  CLRF   xB5
4C9C:  MOVF   xB5,W
4C9E:  MOVLB  0
4CA0:  CALL   106A
4CA4:  MOVLB  2
4CA6:  INCF   xB5,F
4CA8:  MOVWF  00
4CAA:  MOVF   00,W
4CAC:  BTFSS  F9E.4
4CAE:  BRA    4CAC
4CB0:  MOVWF  FAD
4CB2:  MOVLW  05
4CB4:  SUBWF  xB5,W
4CB6:  BNZ   4C9C
4CB8:  MOVLW  1E
4CBA:  MOVWF  xB6
4CBC:  MOVLW  20
4CBE:  BTFSS  F9E.4
4CC0:  BRA    4CBE
4CC2:  MOVWF  FAD
4CC4:  DECFSZ xB6,F
4CC6:  BRA    4CBC
4CC8:  MOVLW  02
4CCA:  MOVWF  FE9
4CCC:  MOVFF  2AE,2BB
4CD0:  MOVFF  2AD,2BA
4CD4:  MOVFF  2AC,2B9
4CD8:  MOVFF  2AB,2B8
4CDC:  MOVWF  xBC
4CDE:  MOVLB  0
4CE0:  CALL   396E
4CE4:  MOVLW  35
4CE6:  MOVLB  2
4CE8:  MOVWF  xB7
4CEA:  MOVLW  20
4CEC:  BTFSS  F9E.4
4CEE:  BRA    4CEC
4CF0:  MOVWF  FAD
4CF2:  DECFSZ xB7,F
4CF4:  BRA    4CEA
4CF6:  MOVLW  02
4CF8:  MOVWF  FE9
4CFA:  MOVFF  2B4,2BB
4CFE:  MOVFF  2B3,2BA
4D02:  MOVFF  2B2,2B9
4D06:  MOVFF  2B1,2B8
4D0A:  MOVWF  xBC
4D0C:  MOVLB  0
4D0E:  CALL   396E
4D12:  MOVLW  0D
4D14:  BTFSS  F9E.4
4D16:  BRA    4D14
4D18:  MOVWF  FAD
....................                   printf("FEBRERO                            %3.2f                                                     %3.2f\r", media_annos[contador][1], media_annos_caldera[contador][1]); 
4D1A:  MOVF   x95,W
4D1C:  MULLW  30
4D1E:  MOVF   FF3,W
4D20:  MOVLB  2
4D22:  CLRF   xAA
4D24:  MOVWF  xA9
4D26:  MOVLW  04
4D28:  ADDWF  xA9,W
4D2A:  MOVWF  01
4D2C:  MOVLW  00
4D2E:  ADDWFC xAA,W
4D30:  MOVWF  03
4D32:  MOVF   01,W
4D34:  ADDLW  1B
4D36:  MOVWF  FE9
4D38:  MOVLW  01
4D3A:  ADDWFC 03,W
4D3C:  MOVWF  FEA
4D3E:  MOVFF  FEF,2AB
4D42:  MOVFF  FEC,2AC
4D46:  MOVFF  FEC,2AD
4D4A:  MOVFF  FEC,2AE
4D4E:  MOVLB  0
4D50:  MOVF   x95,W
4D52:  MULLW  30
4D54:  MOVF   FF3,W
4D56:  MOVLB  2
4D58:  CLRF   xB0
4D5A:  MOVWF  xAF
4D5C:  MOVLW  04
4D5E:  ADDWF  xAF,W
4D60:  MOVWF  01
4D62:  MOVLW  00
4D64:  ADDWFC xB0,W
4D66:  MOVWF  03
4D68:  MOVF   01,W
4D6A:  ADDLW  DB
4D6C:  MOVWF  FE9
4D6E:  MOVLW  01
4D70:  ADDWFC 03,W
4D72:  MOVWF  FEA
4D74:  MOVFF  FEF,2B1
4D78:  MOVFF  FEC,2B2
4D7C:  MOVFF  FEC,2B3
4D80:  MOVFF  FEC,2B4
4D84:  CLRF   xB5
4D86:  MOVF   xB5,W
4D88:  MOVLB  0
4D8A:  CALL   1096
4D8E:  MOVLB  2
4D90:  INCF   xB5,F
4D92:  MOVWF  00
4D94:  MOVF   00,W
4D96:  BTFSS  F9E.4
4D98:  BRA    4D96
4D9A:  MOVWF  FAD
4D9C:  MOVLW  07
4D9E:  SUBWF  xB5,W
4DA0:  BNZ   4D86
4DA2:  MOVLW  1C
4DA4:  MOVWF  xB6
4DA6:  MOVLW  20
4DA8:  BTFSS  F9E.4
4DAA:  BRA    4DA8
4DAC:  MOVWF  FAD
4DAE:  DECFSZ xB6,F
4DB0:  BRA    4DA6
4DB2:  MOVLW  02
4DB4:  MOVWF  FE9
4DB6:  MOVFF  2AE,2BB
4DBA:  MOVFF  2AD,2BA
4DBE:  MOVFF  2AC,2B9
4DC2:  MOVFF  2AB,2B8
4DC6:  MOVWF  xBC
4DC8:  MOVLB  0
4DCA:  CALL   396E
4DCE:  MOVLW  35
4DD0:  MOVLB  2
4DD2:  MOVWF  xB7
4DD4:  MOVLW  20
4DD6:  BTFSS  F9E.4
4DD8:  BRA    4DD6
4DDA:  MOVWF  FAD
4DDC:  DECFSZ xB7,F
4DDE:  BRA    4DD4
4DE0:  MOVLW  02
4DE2:  MOVWF  FE9
4DE4:  MOVFF  2B4,2BB
4DE8:  MOVFF  2B3,2BA
4DEC:  MOVFF  2B2,2B9
4DF0:  MOVFF  2B1,2B8
4DF4:  MOVWF  xBC
4DF6:  MOVLB  0
4DF8:  CALL   396E
4DFC:  MOVLW  0D
4DFE:  BTFSS  F9E.4
4E00:  BRA    4DFE
4E02:  MOVWF  FAD
....................                   printf("MARZO                              %3.2f                                                     %3.2f\r", media_annos[contador][2], media_annos_caldera[contador][2]); 
4E04:  MOVF   x95,W
4E06:  MULLW  30
4E08:  MOVF   FF3,W
4E0A:  MOVLB  2
4E0C:  CLRF   xAA
4E0E:  MOVWF  xA9
4E10:  MOVLW  08
4E12:  ADDWF  xA9,W
4E14:  MOVWF  01
4E16:  MOVLW  00
4E18:  ADDWFC xAA,W
4E1A:  MOVWF  03
4E1C:  MOVF   01,W
4E1E:  ADDLW  1B
4E20:  MOVWF  FE9
4E22:  MOVLW  01
4E24:  ADDWFC 03,W
4E26:  MOVWF  FEA
4E28:  MOVFF  FEF,2AB
4E2C:  MOVFF  FEC,2AC
4E30:  MOVFF  FEC,2AD
4E34:  MOVFF  FEC,2AE
4E38:  MOVLB  0
4E3A:  MOVF   x95,W
4E3C:  MULLW  30
4E3E:  MOVF   FF3,W
4E40:  MOVLB  2
4E42:  CLRF   xB0
4E44:  MOVWF  xAF
4E46:  MOVLW  08
4E48:  ADDWF  xAF,W
4E4A:  MOVWF  01
4E4C:  MOVLW  00
4E4E:  ADDWFC xB0,W
4E50:  MOVWF  03
4E52:  MOVF   01,W
4E54:  ADDLW  DB
4E56:  MOVWF  FE9
4E58:  MOVLW  01
4E5A:  ADDWFC 03,W
4E5C:  MOVWF  FEA
4E5E:  MOVFF  FEF,2B1
4E62:  MOVFF  FEC,2B2
4E66:  MOVFF  FEC,2B3
4E6A:  MOVFF  FEC,2B4
4E6E:  CLRF   xB5
4E70:  MOVF   xB5,W
4E72:  MOVLB  0
4E74:  CALL   10C4
4E78:  MOVLB  2
4E7A:  INCF   xB5,F
4E7C:  MOVWF  00
4E7E:  MOVF   00,W
4E80:  BTFSS  F9E.4
4E82:  BRA    4E80
4E84:  MOVWF  FAD
4E86:  MOVLW  05
4E88:  SUBWF  xB5,W
4E8A:  BNZ   4E70
4E8C:  MOVLW  1E
4E8E:  MOVWF  xB6
4E90:  MOVLW  20
4E92:  BTFSS  F9E.4
4E94:  BRA    4E92
4E96:  MOVWF  FAD
4E98:  DECFSZ xB6,F
4E9A:  BRA    4E90
4E9C:  MOVLW  02
4E9E:  MOVWF  FE9
4EA0:  MOVFF  2AE,2BB
4EA4:  MOVFF  2AD,2BA
4EA8:  MOVFF  2AC,2B9
4EAC:  MOVFF  2AB,2B8
4EB0:  MOVWF  xBC
4EB2:  MOVLB  0
4EB4:  CALL   396E
4EB8:  MOVLW  35
4EBA:  MOVLB  2
4EBC:  MOVWF  xB7
4EBE:  MOVLW  20
4EC0:  BTFSS  F9E.4
4EC2:  BRA    4EC0
4EC4:  MOVWF  FAD
4EC6:  DECFSZ xB7,F
4EC8:  BRA    4EBE
4ECA:  MOVLW  02
4ECC:  MOVWF  FE9
4ECE:  MOVFF  2B4,2BB
4ED2:  MOVFF  2B3,2BA
4ED6:  MOVFF  2B2,2B9
4EDA:  MOVFF  2B1,2B8
4EDE:  MOVWF  xBC
4EE0:  MOVLB  0
4EE2:  CALL   396E
4EE6:  MOVLW  0D
4EE8:  BTFSS  F9E.4
4EEA:  BRA    4EE8
4EEC:  MOVWF  FAD
....................                   printf("ABRIL                              %3.2f                                                     %3.2f\r", media_annos[contador][3], media_annos_caldera[contador][3]); 
4EEE:  MOVF   x95,W
4EF0:  MULLW  30
4EF2:  MOVF   FF3,W
4EF4:  MOVLB  2
4EF6:  CLRF   xAA
4EF8:  MOVWF  xA9
4EFA:  MOVLW  0C
4EFC:  ADDWF  xA9,W
4EFE:  MOVWF  01
4F00:  MOVLW  00
4F02:  ADDWFC xAA,W
4F04:  MOVWF  03
4F06:  MOVF   01,W
4F08:  ADDLW  1B
4F0A:  MOVWF  FE9
4F0C:  MOVLW  01
4F0E:  ADDWFC 03,W
4F10:  MOVWF  FEA
4F12:  MOVFF  FEF,2AB
4F16:  MOVFF  FEC,2AC
4F1A:  MOVFF  FEC,2AD
4F1E:  MOVFF  FEC,2AE
4F22:  MOVLB  0
4F24:  MOVF   x95,W
4F26:  MULLW  30
4F28:  MOVF   FF3,W
4F2A:  MOVLB  2
4F2C:  CLRF   xB0
4F2E:  MOVWF  xAF
4F30:  MOVLW  0C
4F32:  ADDWF  xAF,W
4F34:  MOVWF  01
4F36:  MOVLW  00
4F38:  ADDWFC xB0,W
4F3A:  MOVWF  03
4F3C:  MOVF   01,W
4F3E:  ADDLW  DB
4F40:  MOVWF  FE9
4F42:  MOVLW  01
4F44:  ADDWFC 03,W
4F46:  MOVWF  FEA
4F48:  MOVFF  FEF,2B1
4F4C:  MOVFF  FEC,2B2
4F50:  MOVFF  FEC,2B3
4F54:  MOVFF  FEC,2B4
4F58:  CLRF   xB5
4F5A:  MOVF   xB5,W
4F5C:  MOVLB  0
4F5E:  CALL   10F0
4F62:  MOVLB  2
4F64:  INCF   xB5,F
4F66:  MOVWF  00
4F68:  MOVF   00,W
4F6A:  BTFSS  F9E.4
4F6C:  BRA    4F6A
4F6E:  MOVWF  FAD
4F70:  MOVLW  05
4F72:  SUBWF  xB5,W
4F74:  BNZ   4F5A
4F76:  MOVLW  1E
4F78:  MOVWF  xB6
4F7A:  MOVLW  20
4F7C:  BTFSS  F9E.4
4F7E:  BRA    4F7C
4F80:  MOVWF  FAD
4F82:  DECFSZ xB6,F
4F84:  BRA    4F7A
4F86:  MOVLW  02
4F88:  MOVWF  FE9
4F8A:  MOVFF  2AE,2BB
4F8E:  MOVFF  2AD,2BA
4F92:  MOVFF  2AC,2B9
4F96:  MOVFF  2AB,2B8
4F9A:  MOVWF  xBC
4F9C:  MOVLB  0
4F9E:  CALL   396E
4FA2:  MOVLW  35
4FA4:  MOVLB  2
4FA6:  MOVWF  xB7
4FA8:  MOVLW  20
4FAA:  BTFSS  F9E.4
4FAC:  BRA    4FAA
4FAE:  MOVWF  FAD
4FB0:  DECFSZ xB7,F
4FB2:  BRA    4FA8
4FB4:  MOVLW  02
4FB6:  MOVWF  FE9
4FB8:  MOVFF  2B4,2BB
4FBC:  MOVFF  2B3,2BA
4FC0:  MOVFF  2B2,2B9
4FC4:  MOVFF  2B1,2B8
4FC8:  MOVWF  xBC
4FCA:  MOVLB  0
4FCC:  CALL   396E
4FD0:  MOVLW  0D
4FD2:  BTFSS  F9E.4
4FD4:  BRA    4FD2
4FD6:  MOVWF  FAD
....................                   printf("MAYO                               %3.2f                                                     %3.2f\r", media_annos[contador][4], media_annos_caldera[contador][4]); 
4FD8:  MOVF   x95,W
4FDA:  MULLW  30
4FDC:  MOVF   FF3,W
4FDE:  MOVLB  2
4FE0:  CLRF   xAA
4FE2:  MOVWF  xA9
4FE4:  MOVLW  10
4FE6:  ADDWF  xA9,W
4FE8:  MOVWF  01
4FEA:  MOVLW  00
4FEC:  ADDWFC xAA,W
4FEE:  MOVWF  03
4FF0:  MOVF   01,W
4FF2:  ADDLW  1B
4FF4:  MOVWF  FE9
4FF6:  MOVLW  01
4FF8:  ADDWFC 03,W
4FFA:  MOVWF  FEA
4FFC:  MOVFF  FEF,2AB
5000:  MOVFF  FEC,2AC
5004:  MOVFF  FEC,2AD
5008:  MOVFF  FEC,2AE
500C:  MOVLB  0
500E:  MOVF   x95,W
5010:  MULLW  30
5012:  MOVF   FF3,W
5014:  MOVLB  2
5016:  CLRF   xB0
5018:  MOVWF  xAF
501A:  MOVLW  10
501C:  ADDWF  xAF,W
501E:  MOVWF  01
5020:  MOVLW  00
5022:  ADDWFC xB0,W
5024:  MOVWF  03
5026:  MOVF   01,W
5028:  ADDLW  DB
502A:  MOVWF  FE9
502C:  MOVLW  01
502E:  ADDWFC 03,W
5030:  MOVWF  FEA
5032:  MOVFF  FEF,2B1
5036:  MOVFF  FEC,2B2
503A:  MOVFF  FEC,2B3
503E:  MOVFF  FEC,2B4
5042:  CLRF   xB5
5044:  MOVF   xB5,W
5046:  MOVLB  0
5048:  CALL   111C
504C:  MOVLB  2
504E:  INCF   xB5,F
5050:  MOVWF  00
5052:  MOVF   00,W
5054:  BTFSS  F9E.4
5056:  BRA    5054
5058:  MOVWF  FAD
505A:  MOVLW  04
505C:  SUBWF  xB5,W
505E:  BNZ   5044
5060:  MOVLW  1F
5062:  MOVWF  xB6
5064:  MOVLW  20
5066:  BTFSS  F9E.4
5068:  BRA    5066
506A:  MOVWF  FAD
506C:  DECFSZ xB6,F
506E:  BRA    5064
5070:  MOVLW  02
5072:  MOVWF  FE9
5074:  MOVFF  2AE,2BB
5078:  MOVFF  2AD,2BA
507C:  MOVFF  2AC,2B9
5080:  MOVFF  2AB,2B8
5084:  MOVWF  xBC
5086:  MOVLB  0
5088:  CALL   396E
508C:  MOVLW  35
508E:  MOVLB  2
5090:  MOVWF  xB7
5092:  MOVLW  20
5094:  BTFSS  F9E.4
5096:  BRA    5094
5098:  MOVWF  FAD
509A:  DECFSZ xB7,F
509C:  BRA    5092
509E:  MOVLW  02
50A0:  MOVWF  FE9
50A2:  MOVFF  2B4,2BB
50A6:  MOVFF  2B3,2BA
50AA:  MOVFF  2B2,2B9
50AE:  MOVFF  2B1,2B8
50B2:  MOVWF  xBC
50B4:  MOVLB  0
50B6:  CALL   396E
50BA:  MOVLW  0D
50BC:  BTFSS  F9E.4
50BE:  BRA    50BC
50C0:  MOVWF  FAD
....................                   printf("JUNIO                              %3.2f                                                     %3.2f\r", media_annos[contador][5], media_annos_caldera[contador][5]); 
50C2:  MOVF   x95,W
50C4:  MULLW  30
50C6:  MOVF   FF3,W
50C8:  MOVLB  2
50CA:  CLRF   xAA
50CC:  MOVWF  xA9
50CE:  MOVLW  14
50D0:  ADDWF  xA9,W
50D2:  MOVWF  01
50D4:  MOVLW  00
50D6:  ADDWFC xAA,W
50D8:  MOVWF  03
50DA:  MOVF   01,W
50DC:  ADDLW  1B
50DE:  MOVWF  FE9
50E0:  MOVLW  01
50E2:  ADDWFC 03,W
50E4:  MOVWF  FEA
50E6:  MOVFF  FEF,2AB
50EA:  MOVFF  FEC,2AC
50EE:  MOVFF  FEC,2AD
50F2:  MOVFF  FEC,2AE
50F6:  MOVLB  0
50F8:  MOVF   x95,W
50FA:  MULLW  30
50FC:  MOVF   FF3,W
50FE:  MOVLB  2
5100:  CLRF   xB0
5102:  MOVWF  xAF
5104:  MOVLW  14
5106:  ADDWF  xAF,W
5108:  MOVWF  01
510A:  MOVLW  00
510C:  ADDWFC xB0,W
510E:  MOVWF  03
5110:  MOVF   01,W
5112:  ADDLW  DB
5114:  MOVWF  FE9
5116:  MOVLW  01
5118:  ADDWFC 03,W
511A:  MOVWF  FEA
511C:  MOVFF  FEF,2B1
5120:  MOVFF  FEC,2B2
5124:  MOVFF  FEC,2B3
5128:  MOVFF  FEC,2B4
512C:  CLRF   xB5
512E:  MOVF   xB5,W
5130:  MOVLB  0
5132:  CALL   1146
5136:  MOVLB  2
5138:  INCF   xB5,F
513A:  MOVWF  00
513C:  MOVF   00,W
513E:  BTFSS  F9E.4
5140:  BRA    513E
5142:  MOVWF  FAD
5144:  MOVLW  05
5146:  SUBWF  xB5,W
5148:  BNZ   512E
514A:  MOVLW  1E
514C:  MOVWF  xB6
514E:  MOVLW  20
5150:  BTFSS  F9E.4
5152:  BRA    5150
5154:  MOVWF  FAD
5156:  DECFSZ xB6,F
5158:  BRA    514E
515A:  MOVLW  02
515C:  MOVWF  FE9
515E:  MOVFF  2AE,2BB
5162:  MOVFF  2AD,2BA
5166:  MOVFF  2AC,2B9
516A:  MOVFF  2AB,2B8
516E:  MOVWF  xBC
5170:  MOVLB  0
5172:  CALL   396E
5176:  MOVLW  35
5178:  MOVLB  2
517A:  MOVWF  xB7
517C:  MOVLW  20
517E:  BTFSS  F9E.4
5180:  BRA    517E
5182:  MOVWF  FAD
5184:  DECFSZ xB7,F
5186:  BRA    517C
5188:  MOVLW  02
518A:  MOVWF  FE9
518C:  MOVFF  2B4,2BB
5190:  MOVFF  2B3,2BA
5194:  MOVFF  2B2,2B9
5198:  MOVFF  2B1,2B8
519C:  MOVWF  xBC
519E:  MOVLB  0
51A0:  CALL   396E
51A4:  MOVLW  0D
51A6:  BTFSS  F9E.4
51A8:  BRA    51A6
51AA:  MOVWF  FAD
....................                   printf("JULIO                              %3.2f                                                     %3.2f\r", media_annos[contador][6], media_annos_caldera[contador][6]); 
51AC:  MOVF   x95,W
51AE:  MULLW  30
51B0:  MOVF   FF3,W
51B2:  MOVLB  2
51B4:  CLRF   xAA
51B6:  MOVWF  xA9
51B8:  MOVLW  18
51BA:  ADDWF  xA9,W
51BC:  MOVWF  01
51BE:  MOVLW  00
51C0:  ADDWFC xAA,W
51C2:  MOVWF  03
51C4:  MOVF   01,W
51C6:  ADDLW  1B
51C8:  MOVWF  FE9
51CA:  MOVLW  01
51CC:  ADDWFC 03,W
51CE:  MOVWF  FEA
51D0:  MOVFF  FEF,2AB
51D4:  MOVFF  FEC,2AC
51D8:  MOVFF  FEC,2AD
51DC:  MOVFF  FEC,2AE
51E0:  MOVLB  0
51E2:  MOVF   x95,W
51E4:  MULLW  30
51E6:  MOVF   FF3,W
51E8:  MOVLB  2
51EA:  CLRF   xB0
51EC:  MOVWF  xAF
51EE:  MOVLW  18
51F0:  ADDWF  xAF,W
51F2:  MOVWF  01
51F4:  MOVLW  00
51F6:  ADDWFC xB0,W
51F8:  MOVWF  03
51FA:  MOVF   01,W
51FC:  ADDLW  DB
51FE:  MOVWF  FE9
5200:  MOVLW  01
5202:  ADDWFC 03,W
5204:  MOVWF  FEA
5206:  MOVFF  FEF,2B1
520A:  MOVFF  FEC,2B2
520E:  MOVFF  FEC,2B3
5212:  MOVFF  FEC,2B4
5216:  CLRF   xB5
5218:  MOVF   xB5,W
521A:  MOVLB  0
521C:  CALL   1172
5220:  MOVLB  2
5222:  INCF   xB5,F
5224:  MOVWF  00
5226:  MOVF   00,W
5228:  BTFSS  F9E.4
522A:  BRA    5228
522C:  MOVWF  FAD
522E:  MOVLW  05
5230:  SUBWF  xB5,W
5232:  BNZ   5218
5234:  MOVLW  1E
5236:  MOVWF  xB6
5238:  MOVLW  20
523A:  BTFSS  F9E.4
523C:  BRA    523A
523E:  MOVWF  FAD
5240:  DECFSZ xB6,F
5242:  BRA    5238
5244:  MOVLW  02
5246:  MOVWF  FE9
5248:  MOVFF  2AE,2BB
524C:  MOVFF  2AD,2BA
5250:  MOVFF  2AC,2B9
5254:  MOVFF  2AB,2B8
5258:  MOVWF  xBC
525A:  MOVLB  0
525C:  CALL   396E
5260:  MOVLW  35
5262:  MOVLB  2
5264:  MOVWF  xB7
5266:  MOVLW  20
5268:  BTFSS  F9E.4
526A:  BRA    5268
526C:  MOVWF  FAD
526E:  DECFSZ xB7,F
5270:  BRA    5266
5272:  MOVLW  02
5274:  MOVWF  FE9
5276:  MOVFF  2B4,2BB
527A:  MOVFF  2B3,2BA
527E:  MOVFF  2B2,2B9
5282:  MOVFF  2B1,2B8
5286:  MOVWF  xBC
5288:  MOVLB  0
528A:  CALL   396E
528E:  MOVLW  0D
5290:  BTFSS  F9E.4
5292:  BRA    5290
5294:  MOVWF  FAD
....................                   printf("AGOSTO                             %3.2f                                                     %3.2f\r", media_annos[contador][7], media_annos_caldera[contador][7]); 
5296:  MOVF   x95,W
5298:  MULLW  30
529A:  MOVF   FF3,W
529C:  MOVLB  2
529E:  CLRF   xAA
52A0:  MOVWF  xA9
52A2:  MOVLW  1C
52A4:  ADDWF  xA9,W
52A6:  MOVWF  01
52A8:  MOVLW  00
52AA:  ADDWFC xAA,W
52AC:  MOVWF  03
52AE:  MOVF   01,W
52B0:  ADDLW  1B
52B2:  MOVWF  FE9
52B4:  MOVLW  01
52B6:  ADDWFC 03,W
52B8:  MOVWF  FEA
52BA:  MOVFF  FEF,2AB
52BE:  MOVFF  FEC,2AC
52C2:  MOVFF  FEC,2AD
52C6:  MOVFF  FEC,2AE
52CA:  MOVLB  0
52CC:  MOVF   x95,W
52CE:  MULLW  30
52D0:  MOVF   FF3,W
52D2:  MOVLB  2
52D4:  CLRF   xB0
52D6:  MOVWF  xAF
52D8:  MOVLW  1C
52DA:  ADDWF  xAF,W
52DC:  MOVWF  01
52DE:  MOVLW  00
52E0:  ADDWFC xB0,W
52E2:  MOVWF  03
52E4:  MOVF   01,W
52E6:  ADDLW  DB
52E8:  MOVWF  FE9
52EA:  MOVLW  01
52EC:  ADDWFC 03,W
52EE:  MOVWF  FEA
52F0:  MOVFF  FEF,2B1
52F4:  MOVFF  FEC,2B2
52F8:  MOVFF  FEC,2B3
52FC:  MOVFF  FEC,2B4
5300:  CLRF   xB5
5302:  MOVF   xB5,W
5304:  MOVLB  0
5306:  CALL   119E
530A:  MOVLB  2
530C:  INCF   xB5,F
530E:  MOVWF  00
5310:  MOVF   00,W
5312:  BTFSS  F9E.4
5314:  BRA    5312
5316:  MOVWF  FAD
5318:  MOVLW  06
531A:  SUBWF  xB5,W
531C:  BNZ   5302
531E:  MOVLW  1D
5320:  MOVWF  xB6
5322:  MOVLW  20
5324:  BTFSS  F9E.4
5326:  BRA    5324
5328:  MOVWF  FAD
532A:  DECFSZ xB6,F
532C:  BRA    5322
532E:  MOVLW  02
5330:  MOVWF  FE9
5332:  MOVFF  2AE,2BB
5336:  MOVFF  2AD,2BA
533A:  MOVFF  2AC,2B9
533E:  MOVFF  2AB,2B8
5342:  MOVWF  xBC
5344:  MOVLB  0
5346:  CALL   396E
534A:  MOVLW  35
534C:  MOVLB  2
534E:  MOVWF  xB7
5350:  MOVLW  20
5352:  BTFSS  F9E.4
5354:  BRA    5352
5356:  MOVWF  FAD
5358:  DECFSZ xB7,F
535A:  BRA    5350
535C:  MOVLW  02
535E:  MOVWF  FE9
5360:  MOVFF  2B4,2BB
5364:  MOVFF  2B3,2BA
5368:  MOVFF  2B2,2B9
536C:  MOVFF  2B1,2B8
5370:  MOVWF  xBC
5372:  MOVLB  0
5374:  CALL   396E
5378:  MOVLW  0D
537A:  BTFSS  F9E.4
537C:  BRA    537A
537E:  MOVWF  FAD
....................                   printf("SEPTIEMBRE                         %3.2f                                                     %3.2f\r", media_annos[contador][8], media_annos_caldera[contador][8]); 
5380:  MOVF   x95,W
5382:  MULLW  30
5384:  MOVF   FF3,W
5386:  MOVLB  2
5388:  CLRF   xAA
538A:  MOVWF  xA9
538C:  MOVLW  20
538E:  ADDWF  xA9,W
5390:  MOVWF  01
5392:  MOVLW  00
5394:  ADDWFC xAA,W
5396:  MOVWF  03
5398:  MOVF   01,W
539A:  ADDLW  1B
539C:  MOVWF  FE9
539E:  MOVLW  01
53A0:  ADDWFC 03,W
53A2:  MOVWF  FEA
53A4:  MOVFF  FEF,2AB
53A8:  MOVFF  FEC,2AC
53AC:  MOVFF  FEC,2AD
53B0:  MOVFF  FEC,2AE
53B4:  MOVLB  0
53B6:  MOVF   x95,W
53B8:  MULLW  30
53BA:  MOVF   FF3,W
53BC:  MOVLB  2
53BE:  CLRF   xB0
53C0:  MOVWF  xAF
53C2:  MOVLW  20
53C4:  ADDWF  xAF,W
53C6:  MOVWF  01
53C8:  MOVLW  00
53CA:  ADDWFC xB0,W
53CC:  MOVWF  03
53CE:  MOVF   01,W
53D0:  ADDLW  DB
53D2:  MOVWF  FE9
53D4:  MOVLW  01
53D6:  ADDWFC 03,W
53D8:  MOVWF  FEA
53DA:  MOVFF  FEF,2B1
53DE:  MOVFF  FEC,2B2
53E2:  MOVFF  FEC,2B3
53E6:  MOVFF  FEC,2B4
53EA:  CLRF   xB5
53EC:  MOVF   xB5,W
53EE:  MOVLB  0
53F0:  CALL   11CA
53F4:  MOVLB  2
53F6:  INCF   xB5,F
53F8:  MOVWF  00
53FA:  MOVF   00,W
53FC:  BTFSS  F9E.4
53FE:  BRA    53FC
5400:  MOVWF  FAD
5402:  MOVLW  0A
5404:  SUBWF  xB5,W
5406:  BNZ   53EC
5408:  MOVLW  19
540A:  MOVWF  xB6
540C:  MOVLW  20
540E:  BTFSS  F9E.4
5410:  BRA    540E
5412:  MOVWF  FAD
5414:  DECFSZ xB6,F
5416:  BRA    540C
5418:  MOVLW  02
541A:  MOVWF  FE9
541C:  MOVFF  2AE,2BB
5420:  MOVFF  2AD,2BA
5424:  MOVFF  2AC,2B9
5428:  MOVFF  2AB,2B8
542C:  MOVWF  xBC
542E:  MOVLB  0
5430:  CALL   396E
5434:  MOVLW  35
5436:  MOVLB  2
5438:  MOVWF  xB7
543A:  MOVLW  20
543C:  BTFSS  F9E.4
543E:  BRA    543C
5440:  MOVWF  FAD
5442:  DECFSZ xB7,F
5444:  BRA    543A
5446:  MOVLW  02
5448:  MOVWF  FE9
544A:  MOVFF  2B4,2BB
544E:  MOVFF  2B3,2BA
5452:  MOVFF  2B2,2B9
5456:  MOVFF  2B1,2B8
545A:  MOVWF  xBC
545C:  MOVLB  0
545E:  CALL   396E
5462:  MOVLW  0D
5464:  BTFSS  F9E.4
5466:  BRA    5464
5468:  MOVWF  FAD
....................                   printf("OCTUBRE                            %3.2f                                                     %3.2f\r", media_annos[contador][9], media_annos_caldera[contador][9]); 
546A:  MOVF   x95,W
546C:  MULLW  30
546E:  MOVF   FF3,W
5470:  MOVLB  2
5472:  CLRF   xAA
5474:  MOVWF  xA9
5476:  MOVLW  24
5478:  ADDWF  xA9,W
547A:  MOVWF  01
547C:  MOVLW  00
547E:  ADDWFC xAA,W
5480:  MOVWF  03
5482:  MOVF   01,W
5484:  ADDLW  1B
5486:  MOVWF  FE9
5488:  MOVLW  01
548A:  ADDWFC 03,W
548C:  MOVWF  FEA
548E:  MOVFF  FEF,2AB
5492:  MOVFF  FEC,2AC
5496:  MOVFF  FEC,2AD
549A:  MOVFF  FEC,2AE
549E:  MOVLB  0
54A0:  MOVF   x95,W
54A2:  MULLW  30
54A4:  MOVF   FF3,W
54A6:  MOVLB  2
54A8:  CLRF   xB0
54AA:  MOVWF  xAF
54AC:  MOVLW  24
54AE:  ADDWF  xAF,W
54B0:  MOVWF  01
54B2:  MOVLW  00
54B4:  ADDWFC xB0,W
54B6:  MOVWF  03
54B8:  MOVF   01,W
54BA:  ADDLW  DB
54BC:  MOVWF  FE9
54BE:  MOVLW  01
54C0:  ADDWFC 03,W
54C2:  MOVWF  FEA
54C4:  MOVFF  FEF,2B1
54C8:  MOVFF  FEC,2B2
54CC:  MOVFF  FEC,2B3
54D0:  MOVFF  FEC,2B4
54D4:  CLRF   xB5
54D6:  MOVF   xB5,W
54D8:  MOVLB  0
54DA:  CALL   11FA
54DE:  MOVLB  2
54E0:  INCF   xB5,F
54E2:  MOVWF  00
54E4:  MOVF   00,W
54E6:  BTFSS  F9E.4
54E8:  BRA    54E6
54EA:  MOVWF  FAD
54EC:  MOVLW  07
54EE:  SUBWF  xB5,W
54F0:  BNZ   54D6
54F2:  MOVLW  1C
54F4:  MOVWF  xB6
54F6:  MOVLW  20
54F8:  BTFSS  F9E.4
54FA:  BRA    54F8
54FC:  MOVWF  FAD
54FE:  DECFSZ xB6,F
5500:  BRA    54F6
5502:  MOVLW  02
5504:  MOVWF  FE9
5506:  MOVFF  2AE,2BB
550A:  MOVFF  2AD,2BA
550E:  MOVFF  2AC,2B9
5512:  MOVFF  2AB,2B8
5516:  MOVWF  xBC
5518:  MOVLB  0
551A:  CALL   396E
551E:  MOVLW  35
5520:  MOVLB  2
5522:  MOVWF  xB7
5524:  MOVLW  20
5526:  BTFSS  F9E.4
5528:  BRA    5526
552A:  MOVWF  FAD
552C:  DECFSZ xB7,F
552E:  BRA    5524
5530:  MOVLW  02
5532:  MOVWF  FE9
5534:  MOVFF  2B4,2BB
5538:  MOVFF  2B3,2BA
553C:  MOVFF  2B2,2B9
5540:  MOVFF  2B1,2B8
5544:  MOVWF  xBC
5546:  MOVLB  0
5548:  CALL   396E
554C:  MOVLW  0D
554E:  BTFSS  F9E.4
5550:  BRA    554E
5552:  MOVWF  FAD
....................                   printf("NOVIEMBRE                          %3.2f                                                     %3.2f\r", media_annos[contador][10], media_annos_caldera[contador][10]); 
5554:  MOVF   x95,W
5556:  MULLW  30
5558:  MOVF   FF3,W
555A:  MOVLB  2
555C:  CLRF   xAA
555E:  MOVWF  xA9
5560:  MOVLW  28
5562:  ADDWF  xA9,W
5564:  MOVWF  01
5566:  MOVLW  00
5568:  ADDWFC xAA,W
556A:  MOVWF  03
556C:  MOVF   01,W
556E:  ADDLW  1B
5570:  MOVWF  FE9
5572:  MOVLW  01
5574:  ADDWFC 03,W
5576:  MOVWF  FEA
5578:  MOVFF  FEF,2AB
557C:  MOVFF  FEC,2AC
5580:  MOVFF  FEC,2AD
5584:  MOVFF  FEC,2AE
5588:  MOVLB  0
558A:  MOVF   x95,W
558C:  MULLW  30
558E:  MOVF   FF3,W
5590:  MOVLB  2
5592:  CLRF   xB0
5594:  MOVWF  xAF
5596:  MOVLW  28
5598:  ADDWF  xAF,W
559A:  MOVWF  01
559C:  MOVLW  00
559E:  ADDWFC xB0,W
55A0:  MOVWF  03
55A2:  MOVF   01,W
55A4:  ADDLW  DB
55A6:  MOVWF  FE9
55A8:  MOVLW  01
55AA:  ADDWFC 03,W
55AC:  MOVWF  FEA
55AE:  MOVFF  FEF,2B1
55B2:  MOVFF  FEC,2B2
55B6:  MOVFF  FEC,2B3
55BA:  MOVFF  FEC,2B4
55BE:  CLRF   xB5
55C0:  MOVF   xB5,W
55C2:  MOVLB  0
55C4:  CALL   1228
55C8:  MOVLB  2
55CA:  INCF   xB5,F
55CC:  MOVWF  00
55CE:  MOVF   00,W
55D0:  BTFSS  F9E.4
55D2:  BRA    55D0
55D4:  MOVWF  FAD
55D6:  MOVLW  09
55D8:  SUBWF  xB5,W
55DA:  BNZ   55C0
55DC:  MOVLW  1A
55DE:  MOVWF  xB6
55E0:  MOVLW  20
55E2:  BTFSS  F9E.4
55E4:  BRA    55E2
55E6:  MOVWF  FAD
55E8:  DECFSZ xB6,F
55EA:  BRA    55E0
55EC:  MOVLW  02
55EE:  MOVWF  FE9
55F0:  MOVFF  2AE,2BB
55F4:  MOVFF  2AD,2BA
55F8:  MOVFF  2AC,2B9
55FC:  MOVFF  2AB,2B8
5600:  MOVWF  xBC
5602:  MOVLB  0
5604:  CALL   396E
5608:  MOVLW  35
560A:  MOVLB  2
560C:  MOVWF  xB7
560E:  MOVLW  20
5610:  BTFSS  F9E.4
5612:  BRA    5610
5614:  MOVWF  FAD
5616:  DECFSZ xB7,F
5618:  BRA    560E
561A:  MOVLW  02
561C:  MOVWF  FE9
561E:  MOVFF  2B4,2BB
5622:  MOVFF  2B3,2BA
5626:  MOVFF  2B2,2B9
562A:  MOVFF  2B1,2B8
562E:  MOVWF  xBC
5630:  MOVLB  0
5632:  CALL   396E
5636:  MOVLW  0D
5638:  BTFSS  F9E.4
563A:  BRA    5638
563C:  MOVWF  FAD
....................                   printf("DICIEMBRE                          %3.2f                                                     %3.2f\r", media_annos[contador][11], media_annos_caldera[contador][11]); 
563E:  MOVF   x95,W
5640:  MULLW  30
5642:  MOVF   FF3,W
5644:  MOVLB  2
5646:  CLRF   xAA
5648:  MOVWF  xA9
564A:  MOVLW  2C
564C:  ADDWF  xA9,W
564E:  MOVWF  01
5650:  MOVLW  00
5652:  ADDWFC xAA,W
5654:  MOVWF  03
5656:  MOVF   01,W
5658:  ADDLW  1B
565A:  MOVWF  FE9
565C:  MOVLW  01
565E:  ADDWFC 03,W
5660:  MOVWF  FEA
5662:  MOVFF  FEF,2AB
5666:  MOVFF  FEC,2AC
566A:  MOVFF  FEC,2AD
566E:  MOVFF  FEC,2AE
5672:  MOVLB  0
5674:  MOVF   x95,W
5676:  MULLW  30
5678:  MOVF   FF3,W
567A:  MOVLB  2
567C:  CLRF   xB0
567E:  MOVWF  xAF
5680:  MOVLW  2C
5682:  ADDWF  xAF,W
5684:  MOVWF  01
5686:  MOVLW  00
5688:  ADDWFC xB0,W
568A:  MOVWF  03
568C:  MOVF   01,W
568E:  ADDLW  DB
5690:  MOVWF  FE9
5692:  MOVLW  01
5694:  ADDWFC 03,W
5696:  MOVWF  FEA
5698:  MOVFF  FEF,2B1
569C:  MOVFF  FEC,2B2
56A0:  MOVFF  FEC,2B3
56A4:  MOVFF  FEC,2B4
56A8:  CLRF   xB5
56AA:  MOVF   xB5,W
56AC:  MOVLB  0
56AE:  CALL   1258
56B2:  MOVLB  2
56B4:  INCF   xB5,F
56B6:  MOVWF  00
56B8:  MOVF   00,W
56BA:  BTFSS  F9E.4
56BC:  BRA    56BA
56BE:  MOVWF  FAD
56C0:  MOVLW  09
56C2:  SUBWF  xB5,W
56C4:  BNZ   56AA
56C6:  MOVLW  1A
56C8:  MOVWF  xB6
56CA:  MOVLW  20
56CC:  BTFSS  F9E.4
56CE:  BRA    56CC
56D0:  MOVWF  FAD
56D2:  DECFSZ xB6,F
56D4:  BRA    56CA
56D6:  MOVLW  02
56D8:  MOVWF  FE9
56DA:  MOVFF  2AE,2BB
56DE:  MOVFF  2AD,2BA
56E2:  MOVFF  2AC,2B9
56E6:  MOVFF  2AB,2B8
56EA:  MOVWF  xBC
56EC:  MOVLB  0
56EE:  CALL   396E
56F2:  MOVLW  35
56F4:  MOVLB  2
56F6:  MOVWF  xB7
56F8:  MOVLW  20
56FA:  BTFSS  F9E.4
56FC:  BRA    56FA
56FE:  MOVWF  FAD
5700:  DECFSZ xB7,F
5702:  BRA    56F8
5704:  MOVLW  02
5706:  MOVWF  FE9
5708:  MOVFF  2B4,2BB
570C:  MOVFF  2B3,2BA
5710:  MOVFF  2B2,2B9
5714:  MOVFF  2B1,2B8
5718:  MOVWF  xBC
571A:  MOVLB  0
571C:  CALL   396E
5720:  MOVLW  0D
5722:  BTFSS  F9E.4
5724:  BRA    5722
5726:  MOVWF  FAD
....................                   printf("--------------------------------------------------------------------------------------------------------------------\r"); 
5728:  MOVLB  2
572A:  CLRF   xA9
572C:  MOVF   xA9,W
572E:  MOVLB  0
5730:  CALL   0F4A
5734:  IORLW  00
5736:  BZ    5746
5738:  MOVLB  2
573A:  INCF   xA9,F
573C:  BTFSS  F9E.4
573E:  BRA    573C
5740:  MOVWF  FAD
5742:  BRA    572C
5744:  MOVLB  0
....................                } 
5746:  INCF   x95,F
5748:  GOTO   4B84
....................  
....................                goto repetir; 
574C:  GOTO   48DE
....................                break; 
5750:  BRA    5752
....................  
....................       //En los tres casos, vuelve a mostrarse el menú tras imprimir las estadísticas 
....................    } 
.................... } 
5752:  GOTO   6B58 (RETURN)
....................  
.................... //----------------------------------------------------------------------------------------------------------------------------------------- 
....................  
.................... void seleccionar_alarma() 
.................... { 
....................    //Contador y variables auxiliares 
....................    int contador; 
....................    int hora, minutos, hora_p, min_p; 
....................  
....................    //Ponemos la posición en el vector de alarmas incialmente a 0 
....................    posicion_alarmas = 0; 
*
3736:  CLRF   5A
....................  
....................    //Leemos el tiempo actual 
....................    PCF8583_read_datetime(&tiempo); 
3738:  CLRF   xA2
373A:  MOVLW  5B
373C:  MOVWF  xA1
373E:  CALL   2764
....................    //Habilitamos interrupciones (se desactivan en el método anterior) 
....................    //enable_interrupts(GLOBAL); 
....................    hora = tiempo.hours; 
3742:  MOVFF  5D,96
....................    minutos = tiempo.minutes; 
3746:  MOVFF  5C,97
....................  
....................    //Recorremos todas las programaciones 
....................    for(contador=0; contador<num_intervalos; contador++) 
374A:  CLRF   x95
374C:  MOVF   59,W
374E:  SUBWF  x95,W
3750:  BC    37B4
....................    { 
....................        hora_p = programaciones[contador].horas_inicio; 
3752:  MOVF   x95,W
3754:  MULLW  05
3756:  MOVF   FF3,W
3758:  CLRF   x9B
375A:  MOVWF  x9A
375C:  MOVLW  3B
375E:  ADDWF  x9A,W
3760:  MOVWF  FE9
3762:  MOVLW  00
3764:  ADDWFC x9B,W
3766:  MOVWF  FEA
3768:  MOVFF  FEF,98
....................        min_p  = programaciones[contador].minutos_inicio; 
376C:  MOVF   x95,W
376E:  MULLW  05
3770:  MOVF   FF3,W
3772:  CLRF   x9B
3774:  MOVWF  x9A
3776:  MOVLW  01
3778:  ADDWF  x9A,W
377A:  MOVWF  01
377C:  MOVLW  00
377E:  ADDWFC x9B,W
3780:  MOVWF  03
3782:  MOVF   01,W
3784:  ADDLW  3B
3786:  MOVWF  FE9
3788:  MOVLW  00
378A:  ADDWFC 03,W
378C:  MOVWF  FEA
378E:  MOVFF  FEF,99
....................  
....................        //Comprobamos las horas y tomamos la primera programación que tenga una 
....................        //hora mayor que la actual 
....................        if(!comprobar_hora(hora_p, min_p, hora, minutos)) 
3792:  MOVFF  98,AB
3796:  MOVFF  99,AC
379A:  MOVFF  96,AD
379E:  MOVFF  97,AE
37A2:  CALL   2AEA
37A6:  MOVF   01,F
37A8:  BNZ   37B0
....................        { 
....................            //Guardamos la posición de esta programación y salimos 
....................            posicion_alarmas = contador; 
37AA:  MOVFF  95,5A
....................            break; 
37AE:  BRA    37B4
....................        } 
....................    } 
37B0:  INCF   x95,F
37B2:  BRA    374C
.................... } 
37B4:  GOTO   69F0 (RETURN)

Configuration Fuses:
   Word  1: 0200   HS NOIESO NOFCMEN RESERVED
   Word  2: 181E   BROWNOUT NOWDT BORV25 PUT WDT4096
   Word  3: 8300   PBADEN CCP2C1 NOLPT1OSC MCLR RESERVED
   Word  4: 0081   STVREN NODEBUG NOLVP NOXINST RESERVED
   Word  5: C00F   NOPROTECT NOCPD NOCPB
   Word  6: E00F   NOWRT NOWRTD NOWRTC NOWRTB
   Word  7: 400F   NOEBTR NOEBTRB
