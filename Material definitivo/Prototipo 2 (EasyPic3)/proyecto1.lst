CCS PCH C Compiler, Version 3.249, 28193               28-ene-10 19:03

               Filename: E:\programming\sed\Proyecto 1\Prototipo 3 (presentación)\proyecto1.lst

               ROM used: 26842 bytes (82%)
                         Largest free fragment is 5922
               RAM used: 94 (6%) at main() level
                         683 (44%) worst case
               Stack:    8 worst case (7 in main + 1 for interrupts)

*
0000:  GOTO   5AB8
*
0008:  MOVWF  05
000A:  MOVFF  FD8,06
000E:  MOVFF  FE0,07
0012:  MOVLB  0
0014:  MOVFF  FE9,0D
0018:  MOVFF  FEA,08
001C:  MOVFF  FE1,09
0020:  MOVFF  FE2,0A
0024:  MOVFF  FD9,0B
0028:  MOVFF  FDA,0C
002C:  MOVFF  FF3,14
0030:  MOVFF  FF4,15
0034:  MOVFF  FFA,16
0038:  MOVFF  00,0F
003C:  MOVFF  01,10
0040:  MOVFF  02,11
0044:  MOVFF  03,12
0048:  MOVFF  04,13
004C:  BTFSS  FF0.3
004E:  GOTO   0058
0052:  BTFSC  FF0.0
0054:  GOTO   10DC
0058:  MOVFF  0F,00
005C:  MOVFF  10,01
0060:  MOVFF  11,02
0064:  MOVFF  12,03
0068:  MOVFF  13,04
006C:  MOVFF  0D,FE9
0070:  MOVFF  08,FEA
0074:  MOVFF  09,FE1
0078:  MOVFF  0A,FE2
007C:  MOVFF  0B,FD9
0080:  MOVFF  0C,FDA
0084:  MOVFF  14,FF3
0088:  MOVFF  15,FF4
008C:  MOVFF  16,FFA
0090:  MOVF   05,W
0092:  MOVFF  07,FE0
0096:  MOVFF  06,FD8
009A:  RETFIE 0
.................... //***************************************************************** 
.................... //***   PROYECTO 1: Control de un sistema de calefacción de una *** 
.................... //***   vivienda utilizando un microcontrolador PIC18F4520      *** 
.................... //***************************************************************** 
.................... //Author: Julio Navarro Lara        2010 
....................  
.................... //En este caso está preparado para probarse en la placa EasyPic3 
....................  
....................  
....................  
.................... #include "18F4520.H" 
.................... //////// Standard Header file for the PIC18F4520 device //////////////// 
.................... #DEVICE PIC18F4520 //Aunque el convertidor A/D es de 10 bits, con esta directiva 
009C:  MOVFF  FF2,0E
00A0:  BCF    FF2.7
00A2:  CLRF   FF7
00A4:  ADDLW  B6
00A6:  MOVWF  FF6
00A8:  MOVLW  00
00AA:  ADDWFC FF7,F
00AC:  TBLRD*+
00AE:  MOVF   FF5,W
00B0:  BTFSC  0E.7
00B2:  BSF    FF2.7
00B4:  RETURN 0
00B6:  DATA 2C,0F
00B8:  DATA 01,06
00BA:  MOVFF  FF2,0E
00BE:  BCF    FF2.7
00C0:  CLRF   FF7
00C2:  ADDLW  D4
00C4:  MOVWF  FF6
00C6:  MOVLW  00
00C8:  ADDWFC FF7,F
00CA:  TBLRD*+
00CC:  MOVF   FF5,W
00CE:  BTFSC  0E.7
00D0:  BSF    FF2.7
00D2:  RETURN 0
00D4:  DATA 49,6E
00D6:  DATA 69,63
00D8:  DATA 69,61
00DA:  DATA 6C,69
00DC:  DATA 7A,61
00DE:  DATA 6E,64
00E0:  DATA 6F,2E
00E2:  DATA 2E,2E
00E4:  DATA 00,00
00E6:  MOVFF  FF2,0E
00EA:  BCF    FF2.7
00EC:  CLRF   FF7
00EE:  ADDLW  00
00F0:  MOVWF  FF6
00F2:  MOVLW  01
00F4:  ADDWFC FF7,F
00F6:  TBLRD*+
00F8:  MOVF   FF5,W
00FA:  BTFSC  0E.7
00FC:  BSF    FF2.7
00FE:  RETURN 0
0100:  DATA 53,69
0102:  DATA 73,74
0104:  DATA 65,6D
0106:  DATA 61,20
0108:  DATA 69,6E
010A:  DATA 69,63
010C:  DATA 69,61
010E:  DATA 6C,69
0110:  DATA 7A,61
0112:  DATA 64,6F
0114:  DATA 20,63
0116:  DATA 6F,6E
0118:  DATA 20,65
011A:  DATA 78,69
011C:  DATA 74,6F
011E:  DATA 21,0D
0120:  DATA 00,00
0122:  MOVFF  FF2,0E
0126:  BCF    FF2.7
0128:  CLRF   FF7
012A:  ADDLW  3C
012C:  MOVWF  FF6
012E:  MOVLW  01
0130:  ADDWFC FF7,F
0132:  TBLRD*+
0134:  MOVF   FF5,W
0136:  BTFSC  0E.7
0138:  BSF    FF2.7
013A:  RETURN 0
013C:  DATA 20,20
013E:  DATA 45,6E
0140:  DATA 63,65
0142:  DATA 6E,64
0144:  DATA 69,65
0146:  DATA 6E,64
0148:  DATA 6F,0A
014A:  DATA 20,20
014C:  DATA 73,69
014E:  DATA 73,74
0150:  DATA 65,6D
0152:  DATA 61,2E
0154:  DATA 2E,2E
0156:  DATA 00,00
0158:  MOVFF  FF2,0E
015C:  BCF    FF2.7
015E:  CLRF   FF7
0160:  ADDLW  72
0162:  MOVWF  FF6
0164:  MOVLW  01
0166:  ADDWFC FF7,F
0168:  TBLRD*+
016A:  MOVF   FF5,W
016C:  BTFSC  0E.7
016E:  BSF    FF2.7
0170:  RETURN 0
0172:  DATA 20,20
0174:  DATA 41,70
0176:  DATA 61,67
0178:  DATA 61,6E
017A:  DATA 64,6F
017C:  DATA 0A,20
017E:  DATA 20,73
0180:  DATA 69,73
0182:  DATA 74,65
0184:  DATA 6D,61
0186:  DATA 2E,2E
0188:  DATA 2E,00
018A:  MOVFF  FF2,0E
018E:  BCF    FF2.7
0190:  CLRF   FF7
0192:  ADDLW  A4
0194:  MOVWF  FF6
0196:  MOVLW  01
0198:  ADDWFC FF7,F
019A:  TBLRD*+
019C:  MOVF   FF5,W
019E:  BTFSC  0E.7
01A0:  BSF    FF2.7
01A2:  RETURN 0
01A4:  DATA 20,20
01A6:  DATA 49,6E
01A8:  DATA 64,69
01AA:  DATA 71,75
01AC:  DATA 65,20
01AE:  DATA 6C,61
01B0:  DATA 20,0A
01B2:  DATA 20,20
01B4:  DATA 6F,70
01B6:  DATA 65,72
01B8:  DATA 61,63
01BA:  DATA 69,6F
01BC:  DATA 6E,20
01BE:  DATA 20,20
01C0:  DATA 31,00
01C2:  MOVFF  FF2,0E
01C6:  BCF    FF2.7
01C8:  CLRF   FF7
01CA:  ADDLW  DC
01CC:  MOVWF  FF6
01CE:  MOVLW  01
01D0:  ADDWFC FF7,F
01D2:  TBLRD*+
01D4:  MOVF   FF5,W
01D6:  BTFSC  0E.7
01D8:  BSF    FF2.7
01DA:  RETURN 0
01DC:  DATA 20,20
01DE:  DATA 41,6E
01E0:  DATA 75,6C
01E2:  DATA 61,6E
01E4:  DATA 64,6F
01E6:  DATA 0A,20
01E8:  DATA 20,6F
01EA:  DATA 70,65
01EC:  DATA 72,61
01EE:  DATA 63,69
01F0:  DATA 6F,6E
01F2:  DATA 2E,2E
01F4:  DATA 2E,00
01F6:  MOVFF  FF2,0E
01FA:  BCF    FF2.7
01FC:  CLRF   FF7
01FE:  ADDLW  10
0200:  MOVWF  FF6
0202:  MOVLW  02
0204:  ADDWFC FF7,F
0206:  TBLRD*+
0208:  MOVF   FF5,W
020A:  BTFSC  0E.7
020C:  BSF    FF2.7
020E:  RETURN 0
0210:  DATA 4D,6F
0212:  DATA 64,69
0214:  DATA 66,69
0216:  DATA 63,61
0218:  DATA 72,0A
021A:  DATA 74,65
021C:  DATA 72,6D
021E:  DATA 6F,73
0220:  DATA 74,61
0222:  DATA 74,6F
0224:  DATA 20,25
0226:  DATA 2E,30
0228:  DATA 66,25
022A:  DATA 63,43
022C:  DATA 00,00
022E:  MOVFF  FF2,0E
0232:  BCF    FF2.7
0234:  CLRF   FF7
0236:  ADDLW  48
0238:  MOVWF  FF6
023A:  MOVLW  02
023C:  ADDWFC FF7,F
023E:  TBLRD*+
0240:  MOVF   FF5,W
0242:  BTFSC  0E.7
0244:  BSF    FF2.7
0246:  RETURN 0
0248:  DATA 4E,75
024A:  DATA 65,76
024C:  DATA 6F,20
024E:  DATA 76,61
0250:  DATA 6C,6F
0252:  DATA 72,3A
0254:  DATA 0A,25
0256:  DATA 63,43
0258:  DATA 00,00
025A:  MOVFF  FF2,0E
025E:  BCF    FF2.7
0260:  CLRF   FF7
0262:  ADDLW  74
0264:  MOVWF  FF6
0266:  MOVLW  02
0268:  ADDWFC FF7,F
026A:  TBLRD*+
026C:  MOVF   FF5,W
026E:  BTFSC  0E.7
0270:  BSF    FF2.7
0272:  RETURN 0
0274:  DATA 20,20
0276:  DATA 41,70
0278:  DATA 6C,69
027A:  DATA 63,61
027C:  DATA 6E,64
027E:  DATA 6F,0A
0280:  DATA 20,20
0282:  DATA 63,61
0284:  DATA 6D,62
0286:  DATA 69,6F
0288:  DATA 73,2E
028A:  DATA 2E,2E
028C:  DATA 00,00
028E:  MOVFF  FF2,0E
0292:  BCF    FF2.7
0294:  CLRF   FF7
0296:  ADDLW  A8
0298:  MOVWF  FF6
029A:  MOVLW  02
029C:  ADDWFC FF7,F
029E:  TBLRD*+
02A0:  MOVF   FF5,W
02A2:  BTFSC  0E.7
02A4:  BSF    FF2.7
02A6:  RETURN 0
02A8:  DATA 20,50
02AA:  DATA 72,6F
02AC:  DATA 67,72
02AE:  DATA 61,6D
02B0:  DATA 61,72
02B2:  DATA 0A,20
02B4:  DATA 73,69
02B6:  DATA 73,74
02B8:  DATA 65,6D
02BA:  DATA 61,00
02BC:  MOVFF  FF2,0E
02C0:  BCF    FF2.7
02C2:  CLRF   FF7
02C4:  ADDLW  D6
02C6:  MOVWF  FF6
02C8:  MOVLW  02
02CA:  ADDWFC FF7,F
02CC:  TBLRD*+
02CE:  MOVF   FF5,W
02D0:  BTFSC  0E.7
02D2:  BSF    FF2.7
02D4:  RETURN 0
02D6:  DATA 20,49
02D8:  DATA 4E,54
02DA:  DATA 45,52
02DC:  DATA 56,41
02DE:  DATA 4C,4F
02E0:  DATA 20,25
02E2:  DATA 69,0A
02E4:  DATA 3A,3A
02E6:  DATA 00,00
02E8:  MOVFF  FF2,0E
02EC:  BCF    FF2.7
02EE:  CLRF   FF7
02F0:  ADDLW  02
02F2:  MOVWF  FF6
02F4:  MOVLW  03
02F6:  ADDWFC FF7,F
02F8:  TBLRD*+
02FA:  MOVF   FF5,W
02FC:  BTFSC  0E.7
02FE:  BSF    FF2.7
0300:  RETURN 0
0302:  DATA 20,20
0304:  DATA 20,56
0306:  DATA 61,6C
0308:  DATA 6F,72
030A:  DATA 65,73
030C:  DATA 0A,20
030E:  DATA 20,20
0310:  DATA 69,6E
0312:  DATA 63,6F
0314:  DATA 72,72
0316:  DATA 65,63
0318:  DATA 74,6F
031A:  DATA 73,00
031C:  MOVFF  FF2,0E
0320:  BCF    FF2.7
0322:  CLRF   FF7
0324:  ADDLW  36
0326:  MOVWF  FF6
0328:  MOVLW  03
032A:  ADDWFC FF7,F
032C:  TBLRD*+
032E:  MOVF   FF5,W
0330:  BTFSC  0E.7
0332:  BSF    FF2.7
0334:  RETURN 0
0336:  DATA 49,6E
0338:  DATA 74,65
033A:  DATA 72,76
033C:  DATA 61,6C
033E:  DATA 6F,20
0340:  DATA 6C,69
0342:  DATA 6D,69
0344:  DATA 74,65
0346:  DATA 0A,64
0348:  DATA 65,20
034A:  DATA 34,20
034C:  DATA 68,6F
034E:  DATA 72,61
0350:  DATA 73,00
0352:  MOVFF  FF2,0E
0356:  BCF    FF2.7
0358:  CLRF   FF7
035A:  ADDLW  6C
035C:  MOVWF  FF6
035E:  MOVLW  03
0360:  ADDWFC FF7,F
0362:  TBLRD*+
0364:  MOVF   FF5,W
0366:  BTFSC  0E.7
0368:  BSF    FF2.7
036A:  RETURN 0
036C:  DATA 54,65
036E:  DATA 72,6D
0370:  DATA 6F,73
0372:  DATA 74,61
0374:  DATA 74,6F
0376:  DATA 20,25
0378:  DATA 69,0A
037A:  DATA 25,63
037C:  DATA 43,00
037E:  MOVFF  FF2,0E
0382:  BCF    FF2.7
0384:  CLRF   FF7
0386:  ADDLW  98
0388:  MOVWF  FF6
038A:  MOVLW  03
038C:  ADDWFC FF7,F
038E:  TBLRD*+
0390:  MOVF   FF5,W
0392:  BTFSC  0E.7
0394:  BSF    FF2.7
0396:  RETURN 0
0398:  DATA 53,6F
039A:  DATA 6C,61
039C:  DATA 70,61
039E:  DATA 6D,69
03A0:  DATA 65,6E
03A2:  DATA 74,6F
03A4:  DATA 0A,64
03A6:  DATA 65,20
03A8:  DATA 69,6E
03AA:  DATA 74,65
03AC:  DATA 72,76
03AE:  DATA 61,6C
03B0:  DATA 6F,73
03B2:  DATA 21,00
03B4:  MOVFF  FF2,0E
03B8:  BCF    FF2.7
03BA:  CLRF   FF7
03BC:  ADDLW  CE
03BE:  MOVWF  FF6
03C0:  MOVLW  03
03C2:  ADDWFC FF7,F
03C4:  TBLRD*+
03C6:  MOVF   FF5,W
03C8:  BTFSC  0E.7
03CA:  BSF    FF2.7
03CC:  RETURN 0
03CE:  DATA 20,20
03D0:  DATA 49,6E
03D2:  DATA 74,72
03D4:  DATA 6F,64
03D6:  DATA 75,7A
03D8:  DATA 63,61
03DA:  DATA 0A,20
03DC:  DATA 20,63
03DE:  DATA 6C,61
03E0:  DATA 76,65
03E2:  DATA 00,00
03E4:  MOVFF  FF2,0E
03E8:  BCF    FF2.7
03EA:  CLRF   FF7
03EC:  ADDLW  FE
03EE:  MOVWF  FF6
03F0:  MOVLW  03
03F2:  ADDWFC FF7,F
03F4:  TBLRD*+
03F6:  MOVF   FF5,W
03F8:  BTFSC  0E.7
03FA:  BSF    FF2.7
03FC:  RETURN 0
03FE:  DATA 20,20
0400:  DATA 43,6C
0402:  DATA 61,76
0404:  DATA 65,0A
0406:  DATA 20,20
0408:  DATA 69,6E
040A:  DATA 63,6F
040C:  DATA 72,72
040E:  DATA 65,63
0410:  DATA 74,61
0412:  DATA 00,00
0414:  MOVFF  FF2,0E
0418:  BCF    FF2.7
041A:  CLRF   FF7
041C:  ADDLW  2E
041E:  MOVWF  FF6
0420:  MOVLW  04
0422:  ADDWFC FF7,F
0424:  TBLRD*+
0426:  MOVF   FF5,W
0428:  BTFSC  0E.7
042A:  BSF    FF2.7
042C:  RETURN 0
042E:  DATA 20,20
0430:  DATA 4D,6F
0432:  DATA 64,6F
0434:  DATA 0A,20
0436:  DATA 20,72
0438:  DATA 65,76
043A:  DATA 69,73
043C:  DATA 69,6F
043E:  DATA 6E,00
0440:  MOVFF  FF2,0E
0444:  BCF    FF2.7
0446:  CLRF   FF7
0448:  ADDLW  5A
044A:  MOVWF  FF6
044C:  MOVLW  04
044E:  ADDWFC FF7,F
0450:  TBLRD*+
0452:  MOVF   FF5,W
0454:  BTFSC  0E.7
0456:  BSF    FF2.7
0458:  RETURN 0
045A:  DATA 44,65
045C:  DATA 6D,61
045E:  DATA 73,69
0460:  DATA 61,64
0462:  DATA 6F,20
0464:  DATA 74,69
0466:  DATA 65,6D
0468:  DATA 70,6F
046A:  DATA 0A,65
046C:  DATA 6E,63
046E:  DATA 65,6E
0470:  DATA 64,69
0472:  DATA 64,6F
0474:  DATA 21,00
0476:  MOVFF  FF2,0E
047A:  BCF    FF2.7
047C:  CLRF   FF7
047E:  ADDLW  90
0480:  MOVWF  FF6
0482:  MOVLW  04
0484:  ADDWFC FF7,F
0486:  TBLRD*+
0488:  MOVF   FF5,W
048A:  BTFSC  0E.7
048C:  BSF    FF2.7
048E:  RETURN 0
0490:  DATA 30,00
0492:  MOVFF  FF2,0E
0496:  BCF    FF2.7
0498:  CLRF   FF7
049A:  ADDLW  AC
049C:  MOVWF  FF6
049E:  MOVLW  04
04A0:  ADDWFC FF7,F
04A2:  TBLRD*+
04A4:  MOVF   FF5,W
04A6:  BTFSC  0E.7
04A8:  BSF    FF2.7
04AA:  RETURN 0
04AC:  DATA 0D,49
04AE:  DATA 6E,69
04B0:  DATA 63,69
04B2:  DATA 61,6C
04B4:  DATA 69,7A
04B6:  DATA 61,63
04B8:  DATA 69,6F
04BA:  DATA 6E,20
04BC:  DATA 64,65
04BE:  DATA 6C,20
04C0:  DATA 73,69
04C2:  DATA 73,74
04C4:  DATA 65,6D
04C6:  DATA 61,0D
04C8:  DATA 00,00
04CA:  MOVFF  FF2,0E
04CE:  BCF    FF2.7
04D0:  CLRF   FF7
04D2:  ADDLW  E4
04D4:  MOVWF  FF6
04D6:  MOVLW  04
04D8:  ADDWFC FF7,F
04DA:  TBLRD*+
04DC:  MOVF   FF5,W
04DE:  BTFSC  0E.7
04E0:  BSF    FF2.7
04E2:  RETURN 0
04E4:  DATA 2A,2A
04E6:  DATA 2A,2A
04E8:  DATA 2A,2A
04EA:  DATA 2A,2A
04EC:  DATA 2A,2A
04EE:  DATA 2A,2A
04F0:  DATA 2A,2A
04F2:  DATA 2A,2A
04F4:  DATA 2A,2A
04F6:  DATA 2A,2A
04F8:  DATA 2A,2A
04FA:  DATA 2A,2A
04FC:  DATA 2A,2A
04FE:  DATA 0D,00
0500:  MOVFF  FF2,0E
0504:  BCF    FF2.7
0506:  CLRF   FF7
0508:  ADDLW  1A
050A:  MOVWF  FF6
050C:  MOVLW  05
050E:  ADDWFC FF7,F
0510:  TBLRD*+
0512:  MOVF   FF5,W
0514:  BTFSC  0E.7
0516:  BSF    FF2.7
0518:  RETURN 0
051A:  DATA 44,69
051C:  DATA 61,20
051E:  DATA 64,65
0520:  DATA 20,6C
0522:  DATA 61,20
0524:  DATA 73,65
0526:  DATA 6D,61
0528:  DATA 6E,61
052A:  DATA 20,28
052C:  DATA 31,2D
052E:  DATA 3E,4C
0530:  DATA 75,6E
0532:  DATA 65,73
0534:  DATA 2C,20
0536:  DATA 32,2D
0538:  DATA 3E,4D
053A:  DATA 61,72
053C:  DATA 74,65
053E:  DATA 73,2C
0540:  DATA 20,2E
0542:  DATA 2E,2E
0544:  DATA 29,3A
0546:  DATA 20,4C
0548:  DATA 55,4E
054A:  DATA 45,53
054C:  DATA 20,20
054E:  DATA 20,20
0550:  DATA 00,00
0552:  MOVFF  FF2,0E
0556:  BCF    FF2.7
0558:  CLRF   FF7
055A:  ADDLW  6C
055C:  MOVWF  FF6
055E:  MOVLW  05
0560:  ADDWFC FF7,F
0562:  TBLRD*+
0564:  MOVF   FF5,W
0566:  BTFSC  0E.7
0568:  BSF    FF2.7
056A:  RETURN 0
056C:  DATA 08,08
056E:  DATA 08,08
0570:  DATA 08,08
0572:  DATA 08,08
0574:  DATA 08,4C
0576:  DATA 55,4E
0578:  DATA 45,53
057A:  DATA 20,20
057C:  DATA 20,20
057E:  DATA 00,00
0580:  MOVFF  FF2,0E
0584:  BCF    FF2.7
0586:  CLRF   FF7
0588:  ADDLW  9A
058A:  MOVWF  FF6
058C:  MOVLW  05
058E:  ADDWFC FF7,F
0590:  TBLRD*+
0592:  MOVF   FF5,W
0594:  BTFSC  0E.7
0596:  BSF    FF2.7
0598:  RETURN 0
059A:  DATA 08,08
059C:  DATA 08,08
059E:  DATA 08,08
05A0:  DATA 08,08
05A2:  DATA 08,4D
05A4:  DATA 41,52
05A6:  DATA 54,45
05A8:  DATA 53,20
05AA:  DATA 20,20
05AC:  DATA 00,00
05AE:  MOVFF  FF2,0E
05B2:  BCF    FF2.7
05B4:  CLRF   FF7
05B6:  ADDLW  C8
05B8:  MOVWF  FF6
05BA:  MOVLW  05
05BC:  ADDWFC FF7,F
05BE:  TBLRD*+
05C0:  MOVF   FF5,W
05C2:  BTFSC  0E.7
05C4:  BSF    FF2.7
05C6:  RETURN 0
05C8:  DATA 08,08
05CA:  DATA 08,08
05CC:  DATA 08,08
05CE:  DATA 08,08
05D0:  DATA 08,4D
05D2:  DATA 49,45
05D4:  DATA 52,43
05D6:  DATA 4F,4C
05D8:  DATA 45,53
05DA:  DATA 00,00
05DC:  MOVFF  FF2,0E
05E0:  BCF    FF2.7
05E2:  CLRF   FF7
05E4:  ADDLW  F6
05E6:  MOVWF  FF6
05E8:  MOVLW  05
05EA:  ADDWFC FF7,F
05EC:  TBLRD*+
05EE:  MOVF   FF5,W
05F0:  BTFSC  0E.7
05F2:  BSF    FF2.7
05F4:  RETURN 0
05F6:  DATA 08,08
05F8:  DATA 08,08
05FA:  DATA 08,08
05FC:  DATA 08,08
05FE:  DATA 08,4A
0600:  DATA 55,45
0602:  DATA 56,45
0604:  DATA 53,20
0606:  DATA 20,20
0608:  DATA 00,00
060A:  MOVFF  FF2,0E
060E:  BCF    FF2.7
0610:  CLRF   FF7
0612:  ADDLW  24
0614:  MOVWF  FF6
0616:  MOVLW  06
0618:  ADDWFC FF7,F
061A:  TBLRD*+
061C:  MOVF   FF5,W
061E:  BTFSC  0E.7
0620:  BSF    FF2.7
0622:  RETURN 0
0624:  DATA 08,08
0626:  DATA 08,08
0628:  DATA 08,08
062A:  DATA 08,08
062C:  DATA 08,56
062E:  DATA 49,45
0630:  DATA 52,4E
0632:  DATA 45,53
0634:  DATA 20,20
0636:  DATA 00,00
0638:  MOVFF  FF2,0E
063C:  BCF    FF2.7
063E:  CLRF   FF7
0640:  ADDLW  52
0642:  MOVWF  FF6
0644:  MOVLW  06
0646:  ADDWFC FF7,F
0648:  TBLRD*+
064A:  MOVF   FF5,W
064C:  BTFSC  0E.7
064E:  BSF    FF2.7
0650:  RETURN 0
0652:  DATA 08,08
0654:  DATA 08,08
0656:  DATA 08,08
0658:  DATA 08,08
065A:  DATA 08,53
065C:  DATA 41,42
065E:  DATA 41,44
0660:  DATA 4F,20
0662:  DATA 20,20
0664:  DATA 00,00
0666:  MOVFF  FF2,0E
066A:  BCF    FF2.7
066C:  CLRF   FF7
066E:  ADDLW  80
0670:  MOVWF  FF6
0672:  MOVLW  06
0674:  ADDWFC FF7,F
0676:  TBLRD*+
0678:  MOVF   FF5,W
067A:  BTFSC  0E.7
067C:  BSF    FF2.7
067E:  RETURN 0
0680:  DATA 08,08
0682:  DATA 08,08
0684:  DATA 08,08
0686:  DATA 08,08
0688:  DATA 08,44
068A:  DATA 4F,4D
068C:  DATA 49,4E
068E:  DATA 47,4F
0690:  DATA 20,20
0692:  DATA 00,00
0694:  MOVFF  FF2,0E
0698:  BCF    FF2.7
069A:  CLRF   FF7
069C:  ADDLW  AE
069E:  MOVWF  FF6
06A0:  MOVLW  06
06A2:  ADDWFC FF7,F
06A4:  TBLRD*+
06A6:  MOVF   FF5,W
06A8:  BTFSC  0E.7
06AA:  BSF    FF2.7
06AC:  RETURN 0
06AE:  DATA 0D,46
06B0:  DATA 45,43
06B2:  DATA 48,41
06B4:  DATA 3A,20
06B6:  DATA 00,00
06B8:  MOVFF  FF2,0E
06BC:  BCF    FF2.7
06BE:  CLRF   FF7
06C0:  ADDLW  D2
06C2:  MOVWF  FF6
06C4:  MOVLW  06
06C6:  ADDWFC FF7,F
06C8:  TBLRD*+
06CA:  MOVF   FF5,W
06CC:  BTFSC  0E.7
06CE:  BSF    FF2.7
06D0:  RETURN 0
06D2:  DATA 0D,52
06D4:  DATA 65,73
06D6:  DATA 65,74
06D8:  DATA 65,61
06DA:  DATA 6E,64
06DC:  DATA 6F,20
06DE:  DATA 69,6E
06E0:  DATA 69,63
06E2:  DATA 69,61
06E4:  DATA 6C,69
06E6:  DATA 7A,61
06E8:  DATA 63,69
06EA:  DATA 6F,6E
06EC:  DATA 2E,2E
06EE:  DATA 2E,0D
06F0:  DATA 00,00
06F2:  MOVFF  FF2,0E
06F6:  BCF    FF2.7
06F8:  CLRF   FF7
06FA:  ADDLW  0C
06FC:  MOVWF  FF6
06FE:  MOVLW  07
0700:  ADDWFC FF7,F
0702:  TBLRD*+
0704:  MOVF   FF5,W
0706:  BTFSC  0E.7
0708:  BSF    FF2.7
070A:  RETURN 0
070C:  DATA 0D,44
070E:  DATA 69,61
0710:  DATA 20,69
0712:  DATA 6E,63
0714:  DATA 6F,72
0716:  DATA 72,65
0718:  DATA 63,74
071A:  DATA 6F,2E
071C:  DATA 20,52
071E:  DATA 65,73
0720:  DATA 65,74
0722:  DATA 65,61
0724:  DATA 6E,64
0726:  DATA 6F,20
0728:  DATA 69,6E
072A:  DATA 69,63
072C:  DATA 69,61
072E:  DATA 6C,69
0730:  DATA 7A,61
0732:  DATA 63,69
0734:  DATA 6F,6E
0736:  DATA 2E,2E
0738:  DATA 2E,0D
073A:  DATA 00,00
073C:  MOVFF  FF2,0E
0740:  BCF    FF2.7
0742:  CLRF   FF7
0744:  ADDLW  56
0746:  MOVWF  FF6
0748:  MOVLW  07
074A:  ADDWFC FF7,F
074C:  TBLRD*+
074E:  MOVF   FF5,W
0750:  BTFSC  0E.7
0752:  BSF    FF2.7
0754:  RETURN 0
0756:  DATA 2F,00
0758:  MOVFF  FF2,0E
075C:  BCF    FF2.7
075E:  CLRF   FF7
0760:  ADDLW  72
0762:  MOVWF  FF6
0764:  MOVLW  07
0766:  ADDWFC FF7,F
0768:  TBLRD*+
076A:  MOVF   FF5,W
076C:  BTFSC  0E.7
076E:  BSF    FF2.7
0770:  RETURN 0
0772:  DATA 0D,4D
0774:  DATA 65,73
0776:  DATA 20,69
0778:  DATA 6E,63
077A:  DATA 6F,72
077C:  DATA 72,65
077E:  DATA 63,74
0780:  DATA 6F,2E
0782:  DATA 20,52
0784:  DATA 65,73
0786:  DATA 65,74
0788:  DATA 65,61
078A:  DATA 6E,64
078C:  DATA 6F,20
078E:  DATA 69,6E
0790:  DATA 69,63
0792:  DATA 69,61
0794:  DATA 6C,69
0796:  DATA 7A,61
0798:  DATA 63,69
079A:  DATA 6F,6E
079C:  DATA 2E,2E
079E:  DATA 2E,0D
07A0:  DATA 00,00
07A2:  MOVFF  FF2,0E
07A6:  BCF    FF2.7
07A8:  CLRF   FF7
07AA:  ADDLW  BC
07AC:  MOVWF  FF6
07AE:  MOVLW  07
07B0:  ADDWFC FF7,F
07B2:  TBLRD*+
07B4:  MOVF   FF5,W
07B6:  BTFSC  0E.7
07B8:  BSF    FF2.7
07BA:  RETURN 0
07BC:  DATA 0D,45
07BE:  DATA 72,72
07C0:  DATA 6F,72
07C2:  DATA 20,65
07C4:  DATA 6E,20
07C6:  DATA 6C,61
07C8:  DATA 20,66
07CA:  DATA 65,63
07CC:  DATA 68,61
07CE:  DATA 2E,20
07D0:  DATA 52,65
07D2:  DATA 73,65
07D4:  DATA 74,65
07D6:  DATA 61,6E
07D8:  DATA 64,6F
07DA:  DATA 20,69
07DC:  DATA 6E,69
07DE:  DATA 63,69
07E0:  DATA 61,6C
07E2:  DATA 69,7A
07E4:  DATA 61,63
07E6:  DATA 69,6F
07E8:  DATA 6E,2E
07EA:  DATA 2E,2E
07EC:  DATA 0D,00
07EE:  MOVFF  FF2,0E
07F2:  BCF    FF2.7
07F4:  CLRF   FF7
07F6:  ADDLW  08
07F8:  MOVWF  FF6
07FA:  MOVLW  08
07FC:  ADDWFC FF7,F
07FE:  TBLRD*+
0800:  MOVF   FF5,W
0802:  BTFSC  0E.7
0804:  BSF    FF2.7
0806:  RETURN 0
0808:  DATA 0D,41
080A:  DATA 6E,6E
080C:  DATA 6F,20
080E:  DATA 69,6E
0810:  DATA 63,6F
0812:  DATA 72,72
0814:  DATA 65,63
0816:  DATA 74,6F
0818:  DATA 2E,20
081A:  DATA 52,65
081C:  DATA 73,65
081E:  DATA 74,65
0820:  DATA 61,6E
0822:  DATA 64,6F
0824:  DATA 20,69
0826:  DATA 6E,69
0828:  DATA 63,69
082A:  DATA 61,6C
082C:  DATA 69,7A
082E:  DATA 61,63
0830:  DATA 69,6F
0832:  DATA 6E,2E
0834:  DATA 2E,2E
0836:  DATA 0D,00
0838:  MOVFF  FF2,0E
083C:  BCF    FF2.7
083E:  CLRF   FF7
0840:  ADDLW  52
0842:  MOVWF  FF6
0844:  MOVLW  08
0846:  ADDWFC FF7,F
0848:  TBLRD*+
084A:  MOVF   FF5,W
084C:  BTFSC  0E.7
084E:  BSF    FF2.7
0850:  RETURN 0
0852:  DATA 0D,45
0854:  DATA 6C,20
0856:  DATA 61,6E
0858:  DATA 6E,6F
085A:  DATA 20,6E
085C:  DATA 6F,20
085E:  DATA 65,73
0860:  DATA 20,62
0862:  DATA 69,73
0864:  DATA 69,65
0866:  DATA 73,74
0868:  DATA 6F,2E
086A:  DATA 20,52
086C:  DATA 65,73
086E:  DATA 65,74
0870:  DATA 65,61
0872:  DATA 6E,64
0874:  DATA 6F,20
0876:  DATA 69,6E
0878:  DATA 69,63
087A:  DATA 69,61
087C:  DATA 6C,69
087E:  DATA 7A,61
0880:  DATA 63,69
0882:  DATA 6F,6E
0884:  DATA 2E,2E
0886:  DATA 2E,0D
0888:  DATA 00,00
088A:  MOVFF  FF2,0E
088E:  BCF    FF2.7
0890:  CLRF   FF7
0892:  ADDLW  A4
0894:  MOVWF  FF6
0896:  MOVLW  08
0898:  ADDWFC FF7,F
089A:  TBLRD*+
089C:  MOVF   FF5,W
089E:  BTFSC  0E.7
08A0:  BSF    FF2.7
08A2:  RETURN 0
08A4:  DATA 0D,48
08A6:  DATA 4F,52
08A8:  DATA 41,3A
08AA:  DATA 20,00
08AC:  MOVFF  FF2,0E
08B0:  BCF    FF2.7
08B2:  CLRF   FF7
08B4:  ADDLW  C6
08B6:  MOVWF  FF6
08B8:  MOVLW  08
08BA:  ADDWFC FF7,F
08BC:  TBLRD*+
08BE:  MOVF   FF5,W
08C0:  BTFSC  0E.7
08C2:  BSF    FF2.7
08C4:  RETURN 0
08C6:  DATA 0D,52
08C8:  DATA 65,73
08CA:  DATA 65,74
08CC:  DATA 65,61
08CE:  DATA 6E,64
08D0:  DATA 6F,20
08D2:  DATA 6C,61
08D4:  DATA 20,69
08D6:  DATA 6E,69
08D8:  DATA 63,69
08DA:  DATA 61,6C
08DC:  DATA 69,7A
08DE:  DATA 61,63
08E0:  DATA 69,6F
08E2:  DATA 6E,2E
08E4:  DATA 2E,2E
08E6:  DATA 0D,00
08E8:  MOVFF  FF2,0E
08EC:  BCF    FF2.7
08EE:  CLRF   FF7
08F0:  ADDLW  02
08F2:  MOVWF  FF6
08F4:  MOVLW  09
08F6:  ADDWFC FF7,F
08F8:  TBLRD*+
08FA:  MOVF   FF5,W
08FC:  BTFSC  0E.7
08FE:  BSF    FF2.7
0900:  RETURN 0
0902:  DATA 20,20
0904:  DATA 48,6F
0906:  DATA 72,61
0908:  DATA 20,69
090A:  DATA 6E,63
090C:  DATA 6F,72
090E:  DATA 72,65
0910:  DATA 63,74
0912:  DATA 61,21
0914:  DATA 00,00
0916:  MOVFF  FF2,0E
091A:  BCF    FF2.7
091C:  CLRF   FF7
091E:  ADDLW  30
0920:  MOVWF  FF6
0922:  MOVLW  09
0924:  ADDWFC FF7,F
0926:  TBLRD*+
0928:  MOVF   FF5,W
092A:  BTFSC  0E.7
092C:  BSF    FF2.7
092E:  RETURN 0
0930:  DATA 3A,00
0932:  MOVFF  FF2,0E
0936:  BCF    FF2.7
0938:  CLRF   FF7
093A:  ADDLW  4C
093C:  MOVWF  FF6
093E:  MOVLW  09
0940:  ADDWFC FF7,F
0942:  TBLRD*+
0944:  MOVF   FF5,W
0946:  BTFSC  0E.7
0948:  BSF    FF2.7
094A:  RETURN 0
094C:  DATA 20,20
094E:  DATA 4D,69
0950:  DATA 6E,75
0952:  DATA 74,6F
0954:  DATA 73,20
0956:  DATA 69,6E
0958:  DATA 63,6F
095A:  DATA 72,72
095C:  DATA 65,63
095E:  DATA 74,6F
0960:  DATA 73,21
0962:  DATA 00,00
0964:  MOVFF  FF2,0E
0968:  BCF    FF2.7
096A:  CLRF   FF7
096C:  ADDLW  7E
096E:  MOVWF  FF6
0970:  MOVLW  09
0972:  ADDWFC FF7,F
0974:  TBLRD*+
0976:  MOVF   FF5,W
0978:  BTFSC  0E.7
097A:  BSF    FF2.7
097C:  RETURN 0
097E:  DATA 0D,47
0980:  DATA 75,61
0982:  DATA 72,64
0984:  DATA 61,6E
0986:  DATA 64,6F
0988:  DATA 20,63
098A:  DATA 6F,6E
098C:  DATA 66,69
098E:  DATA 67,75
0990:  DATA 72,61
0992:  DATA 63,69
0994:  DATA 6F,6E
0996:  DATA 2E,2E
0998:  DATA 2E,00
099A:  MOVFF  FF2,0E
099E:  BCF    FF2.7
09A0:  CLRF   FF7
09A2:  ADDLW  B4
09A4:  MOVWF  FF6
09A6:  MOVLW  09
09A8:  ADDWFC FF7,F
09AA:  TBLRD*+
09AC:  MOVF   FF5,W
09AE:  BTFSC  0E.7
09B0:  BSF    FF2.7
09B2:  RETURN 0
09B4:  DATA 0D,49
09B6:  DATA 6E,69
09B8:  DATA 63,69
09BA:  DATA 61,6E
09BC:  DATA 64,6F
09BE:  DATA 20,73
09C0:  DATA 69,73
09C2:  DATA 74,65
09C4:  DATA 6D,61
09C6:  DATA 2E,2E
09C8:  DATA 2E,0D
09CA:  DATA 00,00
09CC:  MOVFF  FF2,0E
09D0:  BCF    FF2.7
09D2:  CLRF   FF7
09D4:  ADDLW  E6
09D6:  MOVWF  FF6
09D8:  MOVLW  09
09DA:  ADDWFC FF7,F
09DC:  TBLRD*+
09DE:  MOVF   FF5,W
09E0:  BTFSC  0E.7
09E2:  BSF    FF2.7
09E4:  RETURN 0
09E6:  DATA 54,45
09E8:  DATA 4D,50
09EA:  DATA 20,2D
09EC:  DATA 20,25
09EE:  DATA 33,2E
09F0:  DATA 31,66
09F2:  DATA 20,25
09F4:  DATA 63,43
09F6:  DATA 0A,48
09F8:  DATA 4F,52
09FA:  DATA 41,20
09FC:  DATA 2D,20
09FE:  DATA 00,00
0A00:  MOVFF  FF2,0E
0A04:  BCF    FF2.7
0A06:  CLRF   FF7
0A08:  ADDLW  1A
0A0A:  MOVWF  FF6
0A0C:  MOVLW  0A
0A0E:  ADDWFC FF7,F
0A10:  TBLRD*+
0A12:  MOVF   FF5,W
0A14:  BTFSC  0E.7
0A16:  BSF    FF2.7
0A18:  RETURN 0
0A1A:  DATA 0D,52
0A1C:  DATA 45,47
0A1E:  DATA 49,53
0A20:  DATA 54,52
0A22:  DATA 4F,20
0A24:  DATA 44,45
0A26:  DATA 20,45
0A28:  DATA 56,45
0A2A:  DATA 4E,54
0A2C:  DATA 4F,53
0A2E:  DATA 0D,00
0A30:  MOVFF  FF2,0E
0A34:  BCF    FF2.7
0A36:  CLRF   FF7
0A38:  ADDLW  4A
0A3A:  MOVWF  FF6
0A3C:  MOVLW  0A
0A3E:  ADDWFC FF7,F
0A40:  TBLRD*+
0A42:  MOVF   FF5,W
0A44:  BTFSC  0E.7
0A46:  BSF    FF2.7
0A48:  RETURN 0
0A4A:  DATA 2A,2A
0A4C:  DATA 2A,2A
0A4E:  DATA 2A,2A
0A50:  DATA 2A,2A
0A52:  DATA 2A,2A
0A54:  DATA 2A,2A
0A56:  DATA 2A,2A
0A58:  DATA 2A,2A
0A5A:  DATA 2A,2A
0A5C:  DATA 2A,0D
0A5E:  DATA 00,00
0A60:  MOVFF  FF2,0E
0A64:  BCF    FF2.7
0A66:  CLRF   FF7
0A68:  ADDLW  7A
0A6A:  MOVWF  FF6
0A6C:  MOVLW  0A
0A6E:  ADDWFC FF7,F
0A70:  TBLRD*+
0A72:  MOVF   FF5,W
0A74:  BTFSC  0E.7
0A76:  BSF    FF2.7
0A78:  RETURN 0
0A7A:  DATA 46,65
0A7C:  DATA 63,68
0A7E:  DATA 61,20
0A80:  DATA 20,20
0A82:  DATA 20,20
0A84:  DATA 20,20
0A86:  DATA 20,20
0A88:  DATA 20,20
0A8A:  DATA 54,65
0A8C:  DATA 6D,70
0A8E:  DATA 2E,20
0A90:  DATA 20,20
0A92:  DATA 20,54
0A94:  DATA 65,72
0A96:  DATA 6D,2E
0A98:  DATA 20,20
0A9A:  DATA 4D,69
0A9C:  DATA 6E,2E
0A9E:  DATA 53,2E
0AA0:  DATA 20,20
0AA2:  DATA 4D,69
0AA4:  DATA 6E,2E
0AA6:  DATA 43,2E
0AA8:  DATA 0D,00
0AAA:  MOVFF  FF2,0E
0AAE:  BCF    FF2.7
0AB0:  CLRF   FF7
0AB2:  ADDLW  C4
0AB4:  MOVWF  FF6
0AB6:  MOVLW  0A
0AB8:  ADDWFC FF7,F
0ABA:  TBLRD*+
0ABC:  MOVF   FF5,W
0ABE:  BTFSC  0E.7
0AC0:  BSF    FF2.7
0AC2:  RETURN 0
0AC4:  DATA 3D,3D
0AC6:  DATA 3D,3D
0AC8:  DATA 3D,3D
0ACA:  DATA 3D,3D
0ACC:  DATA 3D,3D
0ACE:  DATA 3D,3D
0AD0:  DATA 3D,3D
0AD2:  DATA 3D,3D
0AD4:  DATA 3D,3D
0AD6:  DATA 3D,3D
0AD8:  DATA 3D,3D
0ADA:  DATA 3D,3D
0ADC:  DATA 3D,3D
0ADE:  DATA 3D,3D
0AE0:  DATA 3D,3D
0AE2:  DATA 3D,3D
0AE4:  DATA 3D,3D
0AE6:  DATA 3D,3D
0AE8:  DATA 3D,3D
0AEA:  DATA 3D,3D
0AEC:  DATA 3D,3D
0AEE:  DATA 3D,3D
0AF0:  DATA 3D,3D
0AF2:  DATA 0D,00
0AF4:  MOVFF  FF2,0E
0AF8:  BCF    FF2.7
0AFA:  CLRF   FF7
0AFC:  ADDLW  0E
0AFE:  MOVWF  FF6
0B00:  MOVLW  0B
0B02:  ADDWFC FF7,F
0B04:  TBLRD*+
0B06:  MOVF   FF5,W
0B08:  BTFSC  0E.7
0B0A:  BSF    FF2.7
0B0C:  RETURN 0
0B0E:  DATA 20,00
0B10:  MOVFF  FF2,0E
0B14:  BCF    FF2.7
0B16:  CLRF   FF7
0B18:  ADDLW  2A
0B1A:  MOVWF  FF6
0B1C:  MOVLW  0B
0B1E:  ADDWFC FF7,F
0B20:  TBLRD*+
0B22:  MOVF   FF5,W
0B24:  BTFSC  0E.7
0B26:  BSF    FF2.7
0B28:  RETURN 0
0B2A:  DATA 0D,3D
0B2C:  DATA 3D,3D
0B2E:  DATA 3D,3D
0B30:  DATA 3D,3D
0B32:  DATA 3D,3D
0B34:  DATA 3D,3D
0B36:  DATA 3D,3D
0B38:  DATA 3D,3D
0B3A:  DATA 3D,3D
0B3C:  DATA 3D,3D
0B3E:  DATA 3D,3D
0B40:  DATA 3D,3D
0B42:  DATA 3D,3D
0B44:  DATA 3D,3D
0B46:  DATA 3D,3D
0B48:  DATA 3D,3D
0B4A:  DATA 3D,3D
0B4C:  DATA 3D,3D
0B4E:  DATA 3D,3D
0B50:  DATA 3D,3D
0B52:  DATA 3D,3D
0B54:  DATA 3D,3D
0B56:  DATA 3D,3D
0B58:  DATA 0D,00
0B5A:  MOVFF  FF2,0E
0B5E:  BCF    FF2.7
0B60:  CLRF   FF7
0B62:  ADDLW  74
0B64:  MOVWF  FF6
0B66:  MOVLW  0B
0B68:  ADDWFC FF7,F
0B6A:  TBLRD*+
0B6C:  MOVF   FF5,W
0B6E:  BTFSC  0E.7
0B70:  BSF    FF2.7
0B72:  RETURN 0
0B74:  DATA BF,51
0B76:  DATA 75,65
0B78:  DATA 20,6F
0B7A:  DATA 70,65
0B7C:  DATA 72,61
0B7E:  DATA 63,69
0B80:  DATA 6F,6E
0B82:  DATA 20,64
0B84:  DATA 65,73
0B86:  DATA 65,61
0B88:  DATA 20,72
0B8A:  DATA 65,61
0B8C:  DATA 6C,69
0B8E:  DATA 7A,61
0B90:  DATA 72,3F
0B92:  DATA 0D,00
0B94:  MOVFF  FF2,0E
0B98:  BCF    FF2.7
0B9A:  CLRF   FF7
0B9C:  ADDLW  AE
0B9E:  MOVWF  FF6
0BA0:  MOVLW  0B
0BA2:  ADDWFC FF7,F
0BA4:  TBLRD*+
0BA6:  MOVF   FF5,W
0BA8:  BTFSC  0E.7
0BAA:  BSF    FF2.7
0BAC:  RETURN 0
0BAE:  DATA 30,2E
0BB0:  DATA 20,53
0BB2:  DATA 61,6C
0BB4:  DATA 69,72
0BB6:  DATA 0D,00
0BB8:  MOVFF  FF2,0E
0BBC:  BCF    FF2.7
0BBE:  CLRF   FF7
0BC0:  ADDLW  D2
0BC2:  MOVWF  FF6
0BC4:  MOVLW  0B
0BC6:  ADDWFC FF7,F
0BC8:  TBLRD*+
0BCA:  MOVF   FF5,W
0BCC:  BTFSC  0E.7
0BCE:  BSF    FF2.7
0BD0:  RETURN 0
0BD2:  DATA 31,2E
0BD4:  DATA 20,45
0BD6:  DATA 78,74
0BD8:  DATA 72,61
0BDA:  DATA 65,72
0BDC:  DATA 20,74
0BDE:  DATA 69,65
0BE0:  DATA 6D,70
0BE2:  DATA 6F,73
0BE4:  DATA 20,6D
0BE6:  DATA 65,64
0BE8:  DATA 69,6F
0BEA:  DATA 73,20
0BEC:  DATA 70,6F
0BEE:  DATA 72,20
0BF0:  DATA 64,69
0BF2:  DATA 61,0D
0BF4:  DATA 00,00
0BF6:  MOVFF  FF2,0E
0BFA:  BCF    FF2.7
0BFC:  CLRF   FF7
0BFE:  ADDLW  10
0C00:  MOVWF  FF6
0C02:  MOVLW  0C
0C04:  ADDWFC FF7,F
0C06:  TBLRD*+
0C08:  MOVF   FF5,W
0C0A:  BTFSC  0E.7
0C0C:  BSF    FF2.7
0C0E:  RETURN 0
0C10:  DATA 32,2E
0C12:  DATA 20,45
0C14:  DATA 78,74
0C16:  DATA 72,61
0C18:  DATA 65,72
0C1A:  DATA 20,74
0C1C:  DATA 69,65
0C1E:  DATA 6D,70
0C20:  DATA 6F,73
0C22:  DATA 20,74
0C24:  DATA 6F,74
0C26:  DATA 61,6C
0C28:  DATA 65,73
0C2A:  DATA 0D,00
0C2C:  MOVFF  FF2,0E
0C30:  BCF    FF2.7
0C32:  CLRF   FF7
0C34:  ADDLW  46
0C36:  MOVWF  FF6
0C38:  MOVLW  0C
0C3A:  ADDWFC FF7,F
0C3C:  TBLRD*+
0C3E:  MOVF   FF5,W
0C40:  BTFSC  0E.7
0C42:  BSF    FF2.7
0C44:  RETURN 0
0C46:  DATA 33,2E
0C48:  DATA 20,45
0C4A:  DATA 78,74
0C4C:  DATA 72,61
0C4E:  DATA 65,72
0C50:  DATA 20,64
0C52:  DATA 61,74
0C54:  DATA 6F,73
0C56:  DATA 20,6D
0C58:  DATA 65,6E
0C5A:  DATA 73,75
0C5C:  DATA 61,6C
0C5E:  DATA 65,73
0C60:  DATA 0D,00
0C62:  MOVFF  FF2,0E
0C66:  BCF    FF2.7
0C68:  CLRF   FF7
0C6A:  ADDLW  7C
0C6C:  MOVWF  FF6
0C6E:  MOVLW  0C
0C70:  ADDWFC FF7,F
0C72:  TBLRD*+
0C74:  MOVF   FF5,W
0C76:  BTFSC  0E.7
0C78:  BSF    FF2.7
0C7A:  RETURN 0
0C7C:  DATA 3D,3D
0C7E:  DATA 3D,3D
0C80:  DATA 3D,3D
0C82:  DATA 3D,3D
0C84:  DATA 3D,3D
0C86:  DATA 3D,3D
0C88:  DATA 3D,3D
0C8A:  DATA 3D,3D
0C8C:  DATA 3D,3D
0C8E:  DATA 3D,3D
0C90:  DATA 3D,3D
0C92:  DATA 3D,3D
0C94:  DATA 3D,3D
0C96:  DATA 3D,3D
0C98:  DATA 3D,3D
0C9A:  DATA 3D,3D
0C9C:  DATA 3D,3D
0C9E:  DATA 3D,3D
0CA0:  DATA 3D,3D
0CA2:  DATA 3D,3D
0CA4:  DATA 3D,3D
0CA6:  DATA 3D,3D
0CA8:  DATA 3D,0D
0CAA:  DATA 00,00
0CAC:  MOVFF  FF2,0E
0CB0:  BCF    FF2.7
0CB2:  CLRF   FF7
0CB4:  ADDLW  C6
0CB6:  MOVWF  FF6
0CB8:  MOVLW  0C
0CBA:  ADDWFC FF7,F
0CBC:  TBLRD*+
0CBE:  MOVF   FF5,W
0CC0:  BTFSC  0E.7
0CC2:  BSF    FF2.7
0CC4:  RETURN 0
0CC6:  DATA 0D,53
0CC8:  DATA 61,6C
0CCA:  DATA 69,65
0CCC:  DATA 6E,64
0CCE:  DATA 6F,2E
0CD0:  DATA 2E,2E
0CD2:  DATA 0D,00
0CD4:  MOVFF  FF2,0E
0CD8:  BCF    FF2.7
0CDA:  CLRF   FF7
0CDC:  ADDLW  EE
0CDE:  MOVWF  FF6
0CE0:  MOVLW  0C
0CE2:  ADDWFC FF7,F
0CE4:  TBLRD*+
0CE6:  MOVF   FF5,W
0CE8:  BTFSC  0E.7
0CEA:  BSF    FF2.7
0CEC:  RETURN 0
0CEE:  DATA 0D,54
0CF0:  DATA 2E,20
0CF2:  DATA 6D,65
0CF4:  DATA 64,69
0CF6:  DATA 6F,20
0CF8:  DATA 65,6E
0CFA:  DATA 63,65
0CFC:  DATA 6E,64
0CFE:  DATA 69,64
0D00:  DATA 6F,20
0D02:  DATA 73,69
0D04:  DATA 73,74
0D06:  DATA 65,6D
0D08:  DATA 61,20
0D0A:  DATA 70,6F
0D0C:  DATA 72,20
0D0E:  DATA 64,69
0D10:  DATA 61,3A
0D12:  DATA 20,25
0D14:  DATA 33,2E
0D16:  DATA 32,66
0D18:  DATA 20,6D
0D1A:  DATA 69,6E
0D1C:  DATA 75,74
0D1E:  DATA 6F,73
0D20:  DATA 0D,0D
0D22:  DATA 00,00
0D24:  MOVFF  FF2,0E
0D28:  BCF    FF2.7
0D2A:  CLRF   FF7
0D2C:  ADDLW  3E
0D2E:  MOVWF  FF6
0D30:  MOVLW  0D
0D32:  ADDWFC FF7,F
0D34:  TBLRD*+
0D36:  MOVF   FF5,W
0D38:  BTFSC  0E.7
0D3A:  BSF    FF2.7
0D3C:  RETURN 0
0D3E:  DATA 54,2E
0D40:  DATA 20,6D
0D42:  DATA 65,64
0D44:  DATA 69,6F
0D46:  DATA 20,65
0D48:  DATA 6E,63
0D4A:  DATA 65,6E
0D4C:  DATA 64,69
0D4E:  DATA 64,6F
0D50:  DATA 20,63
0D52:  DATA 61,6C
0D54:  DATA 64,65
0D56:  DATA 72,61
0D58:  DATA 20,70
0D5A:  DATA 6F,72
0D5C:  DATA 20,64
0D5E:  DATA 69,61
0D60:  DATA 3A,20
0D62:  DATA 25,33
0D64:  DATA 2E,32
0D66:  DATA 66,20
0D68:  DATA 6D,69
0D6A:  DATA 6E,75
0D6C:  DATA 74,6F
0D6E:  DATA 73,0D
0D70:  DATA 0D,00
0D72:  MOVFF  FF2,0E
0D76:  BCF    FF2.7
0D78:  CLRF   FF7
0D7A:  ADDLW  8C
0D7C:  MOVWF  FF6
0D7E:  MOVLW  0D
0D80:  ADDWFC FF7,F
0D82:  TBLRD*+
0D84:  MOVF   FF5,W
0D86:  BTFSC  0E.7
0D88:  BSF    FF2.7
0D8A:  RETURN 0
0D8C:  DATA 0D,54
0D8E:  DATA 2E,20
0D90:  DATA 74,6F
0D92:  DATA 74,61
0D94:  DATA 6C,20
0D96:  DATA 65,6E
0D98:  DATA 63,65
0D9A:  DATA 6E,64
0D9C:  DATA 69,64
0D9E:  DATA 6F,20
0DA0:  DATA 73,69
0DA2:  DATA 73,74
0DA4:  DATA 65,6D
0DA6:  DATA 61,3A
0DA8:  DATA 20,25
0DAA:  DATA 6C,75
0DAC:  DATA 20,6D
0DAE:  DATA 69,6E
0DB0:  DATA 75,74
0DB2:  DATA 6F,73
0DB4:  DATA 0D,0D
0DB6:  DATA 00,00
0DB8:  MOVFF  FF2,0E
0DBC:  BCF    FF2.7
0DBE:  CLRF   FF7
0DC0:  ADDLW  D2
0DC2:  MOVWF  FF6
0DC4:  MOVLW  0D
0DC6:  ADDWFC FF7,F
0DC8:  TBLRD*+
0DCA:  MOVF   FF5,W
0DCC:  BTFSC  0E.7
0DCE:  BSF    FF2.7
0DD0:  RETURN 0
0DD2:  DATA 54,2E
0DD4:  DATA 20,74
0DD6:  DATA 6F,74
0DD8:  DATA 61,6C
0DDA:  DATA 20,65
0DDC:  DATA 6E,63
0DDE:  DATA 65,6E
0DE0:  DATA 64,69
0DE2:  DATA 64,6F
0DE4:  DATA 20,63
0DE6:  DATA 61,6C
0DE8:  DATA 64,65
0DEA:  DATA 72,61
0DEC:  DATA 3A,20
0DEE:  DATA 25,6C
0DF0:  DATA 75,20
0DF2:  DATA 6D,69
0DF4:  DATA 6E,75
0DF6:  DATA 74,6F
0DF8:  DATA 73,0D
0DFA:  DATA 0D,00
0DFC:  MOVFF  FF2,0E
0E00:  BCF    FF2.7
0E02:  CLRF   FF7
0E04:  ADDLW  16
0E06:  MOVWF  FF6
0E08:  MOVLW  0E
0E0A:  ADDWFC FF7,F
0E0C:  TBLRD*+
0E0E:  MOVF   FF5,W
0E10:  BTFSC  0E.7
0E12:  BSF    FF2.7
0E14:  RETURN 0
0E16:  DATA 0D,32
0E18:  DATA 30,00
0E1A:  MOVFF  FF2,0E
0E1E:  BCF    FF2.7
0E20:  CLRF   FF7
0E22:  ADDLW  34
0E24:  MOVWF  FF6
0E26:  MOVLW  0E
0E28:  ADDWFC FF7,F
0E2A:  TBLRD*+
0E2C:  MOVF   FF5,W
0E2E:  BTFSC  0E.7
0E30:  BSF    FF2.7
0E32:  RETURN 0
0E34:  DATA 2D,2D
0E36:  DATA 2D,2D
0E38:  DATA 2D,2D
0E3A:  DATA 2D,2D
0E3C:  DATA 2D,2D
0E3E:  DATA 2D,2D
0E40:  DATA 2D,2D
0E42:  DATA 2D,2D
0E44:  DATA 2D,2D
0E46:  DATA 2D,2D
0E48:  DATA 2D,2D
0E4A:  DATA 2D,2D
0E4C:  DATA 2D,2D
0E4E:  DATA 2D,2D
0E50:  DATA 2D,2D
0E52:  DATA 2D,2D
0E54:  DATA 2D,2D
0E56:  DATA 2D,2D
0E58:  DATA 2D,2D
0E5A:  DATA 2D,2D
0E5C:  DATA 2D,2D
0E5E:  DATA 2D,2D
0E60:  DATA 2D,2D
0E62:  DATA 2D,2D
0E64:  DATA 2D,2D
0E66:  DATA 2D,2D
0E68:  DATA 2D,0D
0E6A:  DATA 00,00
0E6C:  MOVFF  FF2,0E
0E70:  BCF    FF2.7
0E72:  CLRF   FF7
0E74:  ADDLW  86
0E76:  MOVWF  FF6
0E78:  MOVLW  0E
0E7A:  ADDWFC FF7,F
0E7C:  TBLRD*+
0E7E:  MOVF   FF5,W
0E80:  BTFSC  0E.7
0E82:  BSF    FF2.7
0E84:  RETURN 0
0E86:  DATA 20,20
0E88:  DATA 20,20
0E8A:  DATA 20,20
0E8C:  DATA 20,20
0E8E:  DATA 20,20
0E90:  DATA 20,54
0E92:  DATA 2E,20
0E94:  DATA 73,69
0E96:  DATA 73,74
0E98:  DATA 65,6D
0E9A:  DATA 61,20
0E9C:  DATA 28,6D
0E9E:  DATA 69,6E
0EA0:  DATA 2F,64
0EA2:  DATA 69,61
0EA4:  DATA 29,20
0EA6:  DATA 20,54
0EA8:  DATA 2E,20
0EAA:  DATA 63,61
0EAC:  DATA 6C,64
0EAE:  DATA 65,72
0EB0:  DATA 61,20
0EB2:  DATA 28,6D
0EB4:  DATA 69,6E
0EB6:  DATA 2F,64
0EB8:  DATA 69,61
0EBA:  DATA 29,0D
0EBC:  DATA 00,00
0EBE:  MOVFF  FF2,0E
0EC2:  BCF    FF2.7
0EC4:  CLRF   FF7
0EC6:  ADDLW  D8
0EC8:  MOVWF  FF6
0ECA:  MOVLW  0E
0ECC:  ADDWFC FF7,F
0ECE:  TBLRD*+
0ED0:  MOVF   FF5,W
0ED2:  BTFSC  0E.7
0ED4:  BSF    FF2.7
0ED6:  RETURN 0
0ED8:  DATA 45,4E
0EDA:  DATA 45,52
0EDC:  DATA 4F,25
0EDE:  DATA 33,2E
0EE0:  DATA 32,66
0EE2:  DATA 25,33
0EE4:  DATA 2E,32
0EE6:  DATA 66,0D
0EE8:  DATA 00,00
0EEA:  MOVFF  FF2,0E
0EEE:  BCF    FF2.7
0EF0:  CLRF   FF7
0EF2:  ADDLW  04
0EF4:  MOVWF  FF6
0EF6:  MOVLW  0F
0EF8:  ADDWFC FF7,F
0EFA:  TBLRD*+
0EFC:  MOVF   FF5,W
0EFE:  BTFSC  0E.7
0F00:  BSF    FF2.7
0F02:  RETURN 0
0F04:  DATA 46,45
0F06:  DATA 42,52
0F08:  DATA 45,52
0F0A:  DATA 4F,25
0F0C:  DATA 33,2E
0F0E:  DATA 32,66
0F10:  DATA 25,33
0F12:  DATA 2E,32
0F14:  DATA 66,0D
0F16:  DATA 00,00
0F18:  MOVFF  FF2,0E
0F1C:  BCF    FF2.7
0F1E:  CLRF   FF7
0F20:  ADDLW  32
0F22:  MOVWF  FF6
0F24:  MOVLW  0F
0F26:  ADDWFC FF7,F
0F28:  TBLRD*+
0F2A:  MOVF   FF5,W
0F2C:  BTFSC  0E.7
0F2E:  BSF    FF2.7
0F30:  RETURN 0
0F32:  DATA 4D,41
0F34:  DATA 52,5A
0F36:  DATA 4F,25
0F38:  DATA 33,2E
0F3A:  DATA 32,66
0F3C:  DATA 25,33
0F3E:  DATA 2E,32
0F40:  DATA 66,0D
0F42:  DATA 00,00
0F44:  MOVFF  FF2,0E
0F48:  BCF    FF2.7
0F4A:  CLRF   FF7
0F4C:  ADDLW  5E
0F4E:  MOVWF  FF6
0F50:  MOVLW  0F
0F52:  ADDWFC FF7,F
0F54:  TBLRD*+
0F56:  MOVF   FF5,W
0F58:  BTFSC  0E.7
0F5A:  BSF    FF2.7
0F5C:  RETURN 0
0F5E:  DATA 41,42
0F60:  DATA 52,49
0F62:  DATA 4C,25
0F64:  DATA 33,2E
0F66:  DATA 32,66
0F68:  DATA 25,33
0F6A:  DATA 2E,32
0F6C:  DATA 66,0D
0F6E:  DATA 00,00
0F70:  MOVFF  FF2,0E
0F74:  BCF    FF2.7
0F76:  CLRF   FF7
0F78:  ADDLW  8A
0F7A:  MOVWF  FF6
0F7C:  MOVLW  0F
0F7E:  ADDWFC FF7,F
0F80:  TBLRD*+
0F82:  MOVF   FF5,W
0F84:  BTFSC  0E.7
0F86:  BSF    FF2.7
0F88:  RETURN 0
0F8A:  DATA 4D,41
0F8C:  DATA 59,4F
0F8E:  DATA 25,33
0F90:  DATA 2E,32
0F92:  DATA 66,25
0F94:  DATA 33,2E
0F96:  DATA 32,66
0F98:  DATA 0D,00
0F9A:  MOVFF  FF2,0E
0F9E:  BCF    FF2.7
0FA0:  CLRF   FF7
0FA2:  ADDLW  B4
0FA4:  MOVWF  FF6
0FA6:  MOVLW  0F
0FA8:  ADDWFC FF7,F
0FAA:  TBLRD*+
0FAC:  MOVF   FF5,W
0FAE:  BTFSC  0E.7
0FB0:  BSF    FF2.7
0FB2:  RETURN 0
0FB4:  DATA 4A,55
0FB6:  DATA 4E,49
0FB8:  DATA 4F,25
0FBA:  DATA 33,2E
0FBC:  DATA 32,66
0FBE:  DATA 25,33
0FC0:  DATA 2E,32
0FC2:  DATA 66,0D
0FC4:  DATA 00,00
0FC6:  MOVFF  FF2,0E
0FCA:  BCF    FF2.7
0FCC:  CLRF   FF7
0FCE:  ADDLW  E0
0FD0:  MOVWF  FF6
0FD2:  MOVLW  0F
0FD4:  ADDWFC FF7,F
0FD6:  TBLRD*+
0FD8:  MOVF   FF5,W
0FDA:  BTFSC  0E.7
0FDC:  BSF    FF2.7
0FDE:  RETURN 0
0FE0:  DATA 4A,55
0FE2:  DATA 4C,49
0FE4:  DATA 4F,25
0FE6:  DATA 33,2E
0FE8:  DATA 32,66
0FEA:  DATA 25,33
0FEC:  DATA 2E,32
0FEE:  DATA 66,0D
0FF0:  DATA 00,00
0FF2:  MOVFF  FF2,0E
0FF6:  BCF    FF2.7
0FF8:  CLRF   FF7
0FFA:  ADDLW  0C
0FFC:  MOVWF  FF6
0FFE:  MOVLW  10
1000:  ADDWFC FF7,F
1002:  TBLRD*+
1004:  MOVF   FF5,W
1006:  BTFSC  0E.7
1008:  BSF    FF2.7
100A:  RETURN 0
100C:  DATA 41,47
100E:  DATA 4F,53
1010:  DATA 54,4F
1012:  DATA 25,33
1014:  DATA 2E,32
1016:  DATA 66,25
1018:  DATA 33,2E
101A:  DATA 32,66
101C:  DATA 0D,00
101E:  MOVFF  FF2,0E
1022:  BCF    FF2.7
1024:  CLRF   FF7
1026:  ADDLW  38
1028:  MOVWF  FF6
102A:  MOVLW  10
102C:  ADDWFC FF7,F
102E:  TBLRD*+
1030:  MOVF   FF5,W
1032:  BTFSC  0E.7
1034:  BSF    FF2.7
1036:  RETURN 0
1038:  DATA 53,45
103A:  DATA 50,54
103C:  DATA 49,45
103E:  DATA 4D,42
1040:  DATA 52,45
1042:  DATA 25,33
1044:  DATA 2E,32
1046:  DATA 66,25
1048:  DATA 33,2E
104A:  DATA 32,66
104C:  DATA 0D,00
104E:  MOVFF  FF2,0E
1052:  BCF    FF2.7
1054:  CLRF   FF7
1056:  ADDLW  68
1058:  MOVWF  FF6
105A:  MOVLW  10
105C:  ADDWFC FF7,F
105E:  TBLRD*+
1060:  MOVF   FF5,W
1062:  BTFSC  0E.7
1064:  BSF    FF2.7
1066:  RETURN 0
1068:  DATA 4F,43
106A:  DATA 54,55
106C:  DATA 42,52
106E:  DATA 45,25
1070:  DATA 33,2E
1072:  DATA 32,66
1074:  DATA 25,33
1076:  DATA 2E,32
1078:  DATA 66,0D
107A:  DATA 00,00
107C:  MOVFF  FF2,0E
1080:  BCF    FF2.7
1082:  CLRF   FF7
1084:  ADDLW  96
1086:  MOVWF  FF6
1088:  MOVLW  10
108A:  ADDWFC FF7,F
108C:  TBLRD*+
108E:  MOVF   FF5,W
1090:  BTFSC  0E.7
1092:  BSF    FF2.7
1094:  RETURN 0
1096:  DATA 4E,4F
1098:  DATA 56,49
109A:  DATA 45,4D
109C:  DATA 42,52
109E:  DATA 45,25
10A0:  DATA 33,2E
10A2:  DATA 32,66
10A4:  DATA 25,33
10A6:  DATA 2E,32
10A8:  DATA 66,0D
10AA:  DATA 00,00
10AC:  MOVFF  FF2,0E
10B0:  BCF    FF2.7
10B2:  CLRF   FF7
10B4:  ADDLW  C6
10B6:  MOVWF  FF6
10B8:  MOVLW  10
10BA:  ADDWFC FF7,F
10BC:  TBLRD*+
10BE:  MOVF   FF5,W
10C0:  BTFSC  0E.7
10C2:  BSF    FF2.7
10C4:  RETURN 0
10C6:  DATA 44,49
10C8:  DATA 43,49
10CA:  DATA 45,4D
10CC:  DATA 42,52
10CE:  DATA 45,25
10D0:  DATA 33,2E
10D2:  DATA 32,66
10D4:  DATA 25,33
10D6:  DATA 2E,32
10D8:  DATA 66,0D
10DA:  DATA 00,00
*
1242:  CLRF   00
1244:  CLRF   01
1246:  MOVF   x81,W
1248:  BCF    FD8.0
124A:  BTFSC  x82.0
124C:  ADDWF  00,F
124E:  RRCF   00,F
1250:  RRCF   01,F
1252:  BTFSC  x82.1
1254:  ADDWF  00,F
1256:  RRCF   00,F
1258:  RRCF   01,F
125A:  BTFSC  x82.2
125C:  ADDWF  00,F
125E:  RRCF   00,F
1260:  RRCF   01,F
1262:  BTFSC  x82.3
1264:  ADDWF  00,F
1266:  RRCF   00,F
1268:  RRCF   01,F
126A:  BTFSC  x82.4
126C:  ADDWF  00,F
126E:  RRCF   00,F
1270:  RRCF   01,F
1272:  BTFSC  x82.5
1274:  ADDWF  00,F
1276:  RRCF   00,F
1278:  RRCF   01,F
127A:  BTFSC  x82.6
127C:  ADDWF  00,F
127E:  RRCF   00,F
1280:  RRCF   01,F
1282:  BTFSC  x82.7
1284:  ADDWF  00,F
1286:  RRCF   00,F
1288:  RRCF   01,F
128A:  GOTO   1366 (RETURN)
*
16B2:  MOVLW  8E
16B4:  MOVWF  00
16B6:  MOVF   x87,W
16B8:  SUBWF  00,F
16BA:  MOVFF  88,02
16BE:  MOVFF  89,01
16C2:  BSF    02.7
16C4:  MOVF   00,F
16C6:  BZ    16DA
16C8:  BCF    FD8.0
16CA:  MOVF   02,F
16CC:  BNZ   16D2
16CE:  MOVF   01,F
16D0:  BZ    16DA
16D2:  RRCF   02,F
16D4:  RRCF   01,F
16D6:  DECFSZ 00,F
16D8:  BRA    16C8
16DA:  BTFSS  x88.7
16DC:  BRA    16E8
16DE:  COMF   01,F
16E0:  COMF   02,F
16E2:  INCF   01,F
16E4:  BTFSC  FD8.2
16E6:  INCF   02,F
16E8:  NOP   
16EA:  RETLW  00
*
1754:  MOVLB  2
1756:  MOVF   x9E,W
1758:  BTFSC  FD8.2
175A:  BRA    183E
175C:  MOVWF  00
175E:  MOVF   xA2,W
1760:  BTFSC  FD8.2
1762:  BRA    183E
1764:  ADDWF  00,F
1766:  BNC   1770
1768:  MOVLW  81
176A:  ADDWF  00,F
176C:  BC    183E
176E:  BRA    1778
1770:  MOVLW  7F
1772:  SUBWF  00,F
1774:  BNC   183E
1776:  BZ    183E
1778:  MOVFF  29F,2A6
177C:  MOVF   xA3,W
177E:  XORWF  xA6,F
1780:  BSF    x9F.7
1782:  BSF    xA3.7
1784:  MOVF   xA1,W
1786:  MULWF  xA5
1788:  MOVFF  FF4,2A8
178C:  MOVF   xA0,W
178E:  MULWF  xA4
1790:  MOVFF  FF4,03
1794:  MOVFF  FF3,2A7
1798:  MULWF  xA5
179A:  MOVF   FF3,W
179C:  ADDWF  xA8,F
179E:  MOVF   FF4,W
17A0:  ADDWFC xA7,F
17A2:  MOVLW  00
17A4:  ADDWFC 03,F
17A6:  MOVF   xA1,W
17A8:  MULWF  xA4
17AA:  MOVF   FF3,W
17AC:  ADDWF  xA8,F
17AE:  MOVF   FF4,W
17B0:  ADDWFC xA7,F
17B2:  MOVLW  00
17B4:  CLRF   02
17B6:  ADDWFC 03,F
17B8:  ADDWFC 02,F
17BA:  MOVF   x9F,W
17BC:  MULWF  xA5
17BE:  MOVF   FF3,W
17C0:  ADDWF  xA7,F
17C2:  MOVF   FF4,W
17C4:  ADDWFC 03,F
17C6:  MOVLW  00
17C8:  ADDWFC 02,F
17CA:  MOVF   x9F,W
17CC:  MULWF  xA4
17CE:  MOVF   FF3,W
17D0:  ADDWF  03,F
17D2:  MOVF   FF4,W
17D4:  ADDWFC 02,F
17D6:  MOVLW  00
17D8:  CLRF   01
17DA:  ADDWFC 01,F
17DC:  MOVF   xA1,W
17DE:  MULWF  xA3
17E0:  MOVF   FF3,W
17E2:  ADDWF  xA7,F
17E4:  MOVF   FF4,W
17E6:  ADDWFC 03,F
17E8:  MOVLW  00
17EA:  ADDWFC 02,F
17EC:  ADDWFC 01,F
17EE:  MOVF   xA0,W
17F0:  MULWF  xA3
17F2:  MOVF   FF3,W
17F4:  ADDWF  03,F
17F6:  MOVF   FF4,W
17F8:  ADDWFC 02,F
17FA:  MOVLW  00
17FC:  ADDWFC 01,F
17FE:  MOVF   x9F,W
1800:  MULWF  xA3
1802:  MOVF   FF3,W
1804:  ADDWF  02,F
1806:  MOVF   FF4,W
1808:  ADDWFC 01,F
180A:  INCF   00,F
180C:  BTFSC  01.7
180E:  BRA    181A
1810:  RLCF   xA7,F
1812:  RLCF   03,F
1814:  RLCF   02,F
1816:  RLCF   01,F
1818:  DECF   00,F
181A:  MOVLW  00
181C:  BTFSS  xA7.7
181E:  BRA    1834
1820:  INCF   03,F
1822:  ADDWFC 02,F
1824:  ADDWFC 01,F
1826:  MOVF   01,W
1828:  BNZ   1834
182A:  MOVF   02,W
182C:  BNZ   1834
182E:  MOVF   03,W
1830:  BNZ   1834
1832:  INCF   00,F
1834:  BTFSC  xA6.7
1836:  BSF    01.7
1838:  BTFSS  xA6.7
183A:  BCF    01.7
183C:  BRA    1846
183E:  CLRF   00
1840:  CLRF   01
1842:  CLRF   02
1844:  CLRF   03
1846:  NOP   
1848:  MOVLB  0
184A:  RETLW  00
*
1EC4:  MOVFF  FF2,0E
1EC8:  BCF    FF2.7
1ECA:  ADDWF  FE8,W
1ECC:  ADDLW  E9
1ECE:  MOVWF  FF6
1ED0:  MOVLW  1E
1ED2:  MOVWF  FF7
1ED4:  BTFSC  FD8.0
1ED6:  INCF   FF7,F
1ED8:  TBLRD*-
1EDA:  MOVF   FF5,W
1EDC:  MOVWF  FFA
1EDE:  TBLRD*
1EE0:  MOVF   FF5,W
1EE2:  BTFSC  0E.7
1EE4:  BSF    FF2.7
1EE6:  MOVWF  FF9
1EE8:  DATA 8E,19
1EEA:  DATA A6,19
1EEC:  DATA BE,19
1EEE:  DATA D6,19
1EF0:  DATA EE,19
1EF2:  DATA 06,1A
1EF4:  DATA 1E,1A
*
1F3E:  MOVLW  8E
1F40:  MOVWF  00
1F42:  MOVFF  81,01
1F46:  MOVFF  80,02
1F4A:  CLRF   03
1F4C:  BTFSS  x81.7
1F4E:  BRA    1F5A
1F50:  COMF   01,F
1F52:  COMF   02,F
1F54:  INCF   02,F
1F56:  BNZ   1F5A
1F58:  INCF   01,F
1F5A:  MOVF   01,F
1F5C:  BNZ   1F70
1F5E:  MOVFF  02,01
1F62:  CLRF   02
1F64:  MOVLW  08
1F66:  SUBWF  00,F
1F68:  MOVF   01,F
1F6A:  BNZ   1F70
1F6C:  CLRF   00
1F6E:  BRA    1F84
1F70:  BCF    FD8.0
1F72:  BTFSC  01.7
1F74:  BRA    1F7E
1F76:  RLCF   02,F
1F78:  RLCF   01,F
1F7A:  DECF   00,F
1F7C:  BRA    1F70
1F7E:  BTFSC  x81.7
1F80:  BRA    1F84
1F82:  BCF    01.7
1F84:  NOP   
1F86:  GOTO   213E (RETURN)
1F8A:  MOVLB  2
1F8C:  MOVF   x88,W
1F8E:  BTFSC  FD8.2
1F90:  BRA    20DC
1F92:  MOVWF  x94
1F94:  MOVF   x8C,W
1F96:  BTFSC  FD8.2
1F98:  BRA    20DC
1F9A:  SUBWF  x94,F
1F9C:  BNC   1FA8
1F9E:  MOVLW  7F
1FA0:  ADDWF  x94,F
1FA2:  BTFSC  FD8.0
1FA4:  BRA    20DC
1FA6:  BRA    1FB4
1FA8:  MOVLW  81
1FAA:  SUBWF  x94,F
1FAC:  BTFSS  FD8.0
1FAE:  BRA    20DC
1FB0:  BTFSC  FD8.2
1FB2:  BRA    20DC
1FB4:  MOVFF  294,00
1FB8:  CLRF   01
1FBA:  CLRF   02
1FBC:  CLRF   03
1FBE:  CLRF   x93
1FC0:  MOVFF  289,292
1FC4:  BSF    x92.7
1FC6:  MOVFF  28A,291
1FCA:  MOVFF  28B,290
1FCE:  MOVLW  19
1FD0:  MOVWF  x94
1FD2:  MOVF   x8F,W
1FD4:  SUBWF  x90,F
1FD6:  BC    1FF2
1FD8:  MOVLW  01
1FDA:  SUBWF  x91,F
1FDC:  BC    1FF2
1FDE:  SUBWF  x92,F
1FE0:  BC    1FF2
1FE2:  SUBWF  x93,F
1FE4:  BC    1FF2
1FE6:  INCF   x93,F
1FE8:  INCF   x92,F
1FEA:  INCF   x91,F
1FEC:  MOVF   x8F,W
1FEE:  ADDWF  x90,F
1FF0:  BRA    2042
1FF2:  MOVF   x8E,W
1FF4:  SUBWF  x91,F
1FF6:  BC    201C
1FF8:  MOVLW  01
1FFA:  SUBWF  x92,F
1FFC:  BC    201C
1FFE:  SUBWF  x93,F
2000:  BC    201C
2002:  INCF   x93,F
2004:  INCF   x92,F
2006:  MOVF   x8E,W
2008:  ADDWF  x91,F
200A:  MOVF   x8F,W
200C:  ADDWF  x90,F
200E:  BNC   2042
2010:  INCF   x91,F
2012:  BNZ   2042
2014:  INCF   x92,F
2016:  BNZ   2042
2018:  INCF   x93,F
201A:  BRA    2042
201C:  MOVF   x8D,W
201E:  IORLW  80
2020:  SUBWF  x92,F
2022:  BC    2040
2024:  MOVLW  01
2026:  SUBWF  x93,F
2028:  BC    2040
202A:  INCF   x93,F
202C:  MOVF   x8D,W
202E:  IORLW  80
2030:  ADDWF  x92,F
2032:  MOVF   x8E,W
2034:  ADDWF  x91,F
2036:  BNC   200A
2038:  INCF   x92,F
203A:  BNZ   200A
203C:  INCF   x93,F
203E:  BRA    200A
2040:  BSF    03.0
2042:  DECFSZ x94,F
2044:  BRA    2048
2046:  BRA    205E
2048:  BCF    FD8.0
204A:  RLCF   x90,F
204C:  RLCF   x91,F
204E:  RLCF   x92,F
2050:  RLCF   x93,F
2052:  BCF    FD8.0
2054:  RLCF   03,F
2056:  RLCF   02,F
2058:  RLCF   01,F
205A:  RLCF   x95,F
205C:  BRA    1FD2
205E:  BTFSS  x95.0
2060:  BRA    206E
2062:  BCF    FD8.0
2064:  RRCF   01,F
2066:  RRCF   02,F
2068:  RRCF   03,F
206A:  RRCF   x95,F
206C:  BRA    2072
206E:  DECF   00,F
2070:  BZ    20DC
2072:  BTFSC  x95.7
2074:  BRA    20B2
2076:  BCF    FD8.0
2078:  RLCF   x90,F
207A:  RLCF   x91,F
207C:  RLCF   x92,F
207E:  RLCF   x93,F
2080:  MOVF   x8F,W
2082:  SUBWF  x90,F
2084:  BC    2094
2086:  MOVLW  01
2088:  SUBWF  x91,F
208A:  BC    2094
208C:  SUBWF  x92,F
208E:  BC    2094
2090:  SUBWF  x93,F
2092:  BNC   20C8
2094:  MOVF   x8E,W
2096:  SUBWF  x91,F
2098:  BC    20A4
209A:  MOVLW  01
209C:  SUBWF  x92,F
209E:  BC    20A4
20A0:  SUBWF  x93,F
20A2:  BNC   20C8
20A4:  MOVF   x8D,W
20A6:  IORLW  80
20A8:  SUBWF  x92,F
20AA:  BC    20B2
20AC:  MOVLW  01
20AE:  SUBWF  x93,F
20B0:  BNC   20C8
20B2:  INCF   03,F
20B4:  BNZ   20C8
20B6:  INCF   02,F
20B8:  BNZ   20C8
20BA:  INCF   01,F
20BC:  BNZ   20C8
20BE:  INCF   00,F
20C0:  BZ    20DC
20C2:  RRCF   01,F
20C4:  RRCF   02,F
20C6:  RRCF   03,F
20C8:  MOVFF  289,294
20CC:  MOVF   x8D,W
20CE:  XORWF  x94,F
20D0:  BTFSS  x94.7
20D2:  BRA    20D8
20D4:  BSF    01.7
20D6:  BRA    20E4
20D8:  BCF    01.7
20DA:  BRA    20E4
20DC:  CLRF   00
20DE:  CLRF   01
20E0:  CLRF   02
20E2:  CLRF   03
20E4:  NOP   
20E6:  MOVLB  0
20E8:  RETLW  00
*
2244:  MOVLW  80
2246:  BTFSS  FD8.1
2248:  BRA    224E
224A:  MOVLB  2
224C:  XORWF  x87,F
224E:  MOVLB  2
2250:  CLRF   x8C
2252:  CLRF   x8D
2254:  MOVFF  283,28B
2258:  MOVF   x87,W
225A:  XORWF  x8B,F
225C:  MOVF   x82,W
225E:  BTFSC  FD8.2
2260:  BRA    2420
2262:  MOVWF  x8A
2264:  MOVWF  00
2266:  MOVF   x86,W
2268:  BTFSC  FD8.2
226A:  BRA    2432
226C:  SUBWF  x8A,F
226E:  BTFSC  FD8.2
2270:  BRA    2378
2272:  BNC   22F0
2274:  MOVFF  287,290
2278:  BSF    x90.7
227A:  MOVFF  288,28F
227E:  MOVFF  289,28E
2282:  CLRF   x8D
2284:  BCF    FD8.0
2286:  RRCF   x90,F
2288:  RRCF   x8F,F
228A:  RRCF   x8E,F
228C:  RRCF   x8D,F
228E:  DECFSZ x8A,F
2290:  BRA    2282
2292:  BTFSS  x8B.7
2294:  BRA    229C
2296:  BSF    x8C.0
2298:  BRA    245A
229A:  BCF    x8C.0
229C:  BCF    x8A.0
229E:  BSF    x8C.4
22A0:  MOVLW  02
22A2:  MOVWF  FEA
22A4:  MOVLW  85
22A6:  MOVWF  FE9
22A8:  BRA    2480
22AA:  BCF    x8C.4
22AC:  BTFSC  x8B.7
22AE:  BRA    22C4
22B0:  BTFSS  x8A.0
22B2:  BRA    22DA
22B4:  RRCF   x90,F
22B6:  RRCF   x8F,F
22B8:  RRCF   x8E,F
22BA:  RRCF   x8D,F
22BC:  INCF   00,F
22BE:  BTFSC  FD8.2
22C0:  BRA    2450
22C2:  BRA    22DA
22C4:  BTFSC  x90.7
22C6:  BRA    22E0
22C8:  BCF    FD8.0
22CA:  RLCF   x8D,F
22CC:  RLCF   x8E,F
22CE:  RLCF   x8F,F
22D0:  RLCF   x90,F
22D2:  DECF   00,F
22D4:  BTFSC  FD8.2
22D6:  BRA    2450
22D8:  BRA    22C4
22DA:  BSF    x8C.6
22DC:  BRA    23B8
22DE:  BCF    x8C.6
22E0:  MOVFF  283,28B
22E4:  BTFSS  x83.7
22E6:  BRA    22EC
22E8:  BSF    x90.7
22EA:  BRA    2442
22EC:  BCF    x90.7
22EE:  BRA    2442
22F0:  MOVFF  286,28A
22F4:  MOVFF  286,00
22F8:  MOVF   x82,W
22FA:  SUBWF  x8A,F
22FC:  MOVFF  283,290
2300:  BSF    x90.7
2302:  MOVFF  284,28F
2306:  MOVFF  285,28E
230A:  CLRF   x8D
230C:  BCF    FD8.0
230E:  RRCF   x90,F
2310:  RRCF   x8F,F
2312:  RRCF   x8E,F
2314:  RRCF   x8D,F
2316:  DECFSZ x8A,F
2318:  BRA    230A
231A:  BTFSS  x8B.7
231C:  BRA    2324
231E:  BSF    x8C.1
2320:  BRA    245A
2322:  BCF    x8C.1
2324:  BCF    x8A.0
2326:  BSF    x8C.5
2328:  MOVLW  02
232A:  MOVWF  FEA
232C:  MOVLW  89
232E:  MOVWF  FE9
2330:  BRA    2480
2332:  BCF    x8C.5
2334:  BTFSC  x8B.7
2336:  BRA    234C
2338:  BTFSS  x8A.0
233A:  BRA    2362
233C:  RRCF   x90,F
233E:  RRCF   x8F,F
2340:  RRCF   x8E,F
2342:  RRCF   x8D,F
2344:  INCF   00,F
2346:  BTFSC  FD8.2
2348:  BRA    2450
234A:  BRA    2362
234C:  BTFSC  x90.7
234E:  BRA    2368
2350:  BCF    FD8.0
2352:  RLCF   x8D,F
2354:  RLCF   x8E,F
2356:  RLCF   x8F,F
2358:  RLCF   x90,F
235A:  DECF   00,F
235C:  BTFSC  FD8.2
235E:  BRA    2450
2360:  BRA    234C
2362:  BSF    x8C.7
2364:  BRA    23B8
2366:  BCF    x8C.7
2368:  MOVFF  287,28B
236C:  BTFSS  x87.7
236E:  BRA    2374
2370:  BSF    x90.7
2372:  BRA    2442
2374:  BCF    x90.7
2376:  BRA    2442
2378:  MOVFF  287,290
237C:  BSF    x90.7
237E:  MOVFF  288,28F
2382:  MOVFF  289,28E
2386:  BTFSS  x8B.7
2388:  BRA    2392
238A:  BCF    x90.7
238C:  BSF    x8C.2
238E:  BRA    245A
2390:  BCF    x8C.2
2392:  CLRF   x8D
2394:  BCF    x8A.0
2396:  MOVLW  02
2398:  MOVWF  FEA
239A:  MOVLW  85
239C:  MOVWF  FE9
239E:  BRA    2480
23A0:  BTFSC  x8B.7
23A2:  BRA    23DC
23A4:  MOVFF  283,28B
23A8:  BTFSS  x8A.0
23AA:  BRA    23B8
23AC:  RRCF   x90,F
23AE:  RRCF   x8F,F
23B0:  RRCF   x8E,F
23B2:  RRCF   x8D,F
23B4:  INCF   00,F
23B6:  BZ    2450
23B8:  BTFSS  x8D.7
23BA:  BRA    23D2
23BC:  INCF   x8E,F
23BE:  BNZ   23D2
23C0:  INCF   x8F,F
23C2:  BNZ   23D2
23C4:  INCF   x90,F
23C6:  BNZ   23D2
23C8:  RRCF   x90,F
23CA:  RRCF   x8F,F
23CC:  RRCF   x8E,F
23CE:  INCF   00,F
23D0:  BZ    2450
23D2:  BTFSC  x8C.6
23D4:  BRA    22DE
23D6:  BTFSC  x8C.7
23D8:  BRA    2366
23DA:  BRA    2414
23DC:  MOVLW  80
23DE:  XORWF  x90,F
23E0:  BTFSS  x90.7
23E2:  BRA    23EC
23E4:  BRA    245A
23E6:  MOVFF  287,28B
23EA:  BRA    2400
23EC:  MOVFF  283,28B
23F0:  MOVF   x90,F
23F2:  BNZ   2400
23F4:  MOVF   x8F,F
23F6:  BNZ   2400
23F8:  MOVF   x8E,F
23FA:  BNZ   2400
23FC:  CLRF   00
23FE:  BRA    2442
2400:  BTFSC  x90.7
2402:  BRA    2414
2404:  BCF    FD8.0
2406:  RLCF   x8D,F
2408:  RLCF   x8E,F
240A:  RLCF   x8F,F
240C:  RLCF   x90,F
240E:  DECFSZ 00,F
2410:  BRA    2400
2412:  BRA    2450
2414:  BTFSS  x8B.7
2416:  BRA    241C
2418:  BSF    x90.7
241A:  BRA    2442
241C:  BCF    x90.7
241E:  BRA    2442
2420:  MOVFF  286,00
2424:  MOVFF  287,290
2428:  MOVFF  288,28F
242C:  MOVFF  289,28E
2430:  BRA    2442
2432:  MOVFF  282,00
2436:  MOVFF  283,290
243A:  MOVFF  284,28F
243E:  MOVFF  285,28E
2442:  MOVFF  290,01
2446:  MOVFF  28F,02
244A:  MOVFF  28E,03
244E:  BRA    24B8
2450:  CLRF   00
2452:  CLRF   01
2454:  CLRF   02
2456:  CLRF   03
2458:  BRA    24B8
245A:  CLRF   x8D
245C:  COMF   x8E,F
245E:  COMF   x8F,F
2460:  COMF   x90,F
2462:  COMF   x8D,F
2464:  INCF   x8D,F
2466:  BNZ   2472
2468:  INCF   x8E,F
246A:  BNZ   2472
246C:  INCF   x8F,F
246E:  BNZ   2472
2470:  INCF   x90,F
2472:  BTFSC  x8C.0
2474:  BRA    229A
2476:  BTFSC  x8C.1
2478:  BRA    2322
247A:  BTFSC  x8C.2
247C:  BRA    2390
247E:  BRA    23E6
2480:  MOVF   FEF,W
2482:  ADDWF  x8E,F
2484:  BNC   2490
2486:  INCF   x8F,F
2488:  BNZ   2490
248A:  INCF   x90,F
248C:  BTFSC  FD8.2
248E:  BSF    x8A.0
2490:  MOVF   FED,F
2492:  MOVF   FEF,W
2494:  ADDWF  x8F,F
2496:  BNC   249E
2498:  INCF   x90,F
249A:  BTFSC  FD8.2
249C:  BSF    x8A.0
249E:  MOVF   FED,F
24A0:  MOVF   FEF,W
24A2:  BTFSC  FEF.7
24A4:  BRA    24A8
24A6:  XORLW  80
24A8:  ADDWF  x90,F
24AA:  BTFSC  FD8.0
24AC:  BSF    x8A.0
24AE:  BTFSC  x8C.4
24B0:  BRA    22AA
24B2:  BTFSC  x8C.5
24B4:  BRA    2332
24B6:  BRA    23A0
24B8:  NOP   
24BA:  MOVLB  0
24BC:  RETLW  00
24BE:  MOVLW  8E
24C0:  MOVWF  00
24C2:  MOVFF  289,01
24C6:  MOVFF  288,02
24CA:  CLRF   03
24CC:  MOVF   01,F
24CE:  BNZ   24E2
24D0:  MOVFF  02,01
24D4:  CLRF   02
24D6:  MOVLW  08
24D8:  SUBWF  00,F
24DA:  MOVF   01,F
24DC:  BNZ   24E2
24DE:  CLRF   00
24E0:  BRA    24F2
24E2:  BCF    FD8.0
24E4:  BTFSC  01.7
24E6:  BRA    24F0
24E8:  RLCF   02,F
24EA:  RLCF   01,F
24EC:  DECF   00,F
24EE:  BRA    24E2
24F0:  BCF    01.7
24F2:  NOP   
24F4:  RETLW  00
24F6:  MOVFF  78,7F
24FA:  MOVF   7C,W
24FC:  XORWF  7F,F
24FE:  BTFSS  7F.7
2500:  BRA    250C
2502:  BCF    FD8.2
2504:  BCF    FD8.0
2506:  BTFSC  78.7
2508:  BSF    FD8.0
250A:  BRA    256A
250C:  MOVFF  78,7F
2510:  MOVFF  7B,80
2514:  MOVF   77,W
2516:  SUBWF  x80,F
2518:  BZ    2526
251A:  BTFSS  7F.7
251C:  BRA    256A
251E:  MOVF   FD8,W
2520:  XORLW  01
2522:  MOVWF  FD8
2524:  BRA    256A
2526:  MOVFF  7C,80
252A:  MOVF   78,W
252C:  SUBWF  x80,F
252E:  BZ    253C
2530:  BTFSS  7F.7
2532:  BRA    256A
2534:  MOVF   FD8,W
2536:  XORLW  01
2538:  MOVWF  FD8
253A:  BRA    256A
253C:  MOVFF  7D,80
2540:  MOVF   79,W
2542:  SUBWF  x80,F
2544:  BZ    2552
2546:  BTFSS  7F.7
2548:  BRA    256A
254A:  MOVF   FD8,W
254C:  XORLW  01
254E:  MOVWF  FD8
2550:  BRA    256A
2552:  MOVFF  7E,80
2556:  MOVF   7A,W
2558:  SUBWF  x80,F
255A:  BZ    2568
255C:  BTFSS  7F.7
255E:  BRA    256A
2560:  MOVF   FD8,W
2562:  XORLW  01
2564:  MOVWF  FD8
2566:  BRA    256A
2568:  BCF    FD8.0
256A:  RETLW  00
*
2AB0:  MOVF   x88,W
2AB2:  MULWF  x8A
2AB4:  MOVFF  FF3,01
2AB8:  MOVFF  FF4,00
2ABC:  MULWF  x8B
2ABE:  MOVF   FF3,W
2AC0:  ADDWF  00,F
2AC2:  MOVF   x89,W
2AC4:  MULWF  x8A
2AC6:  MOVF   FF3,W
2AC8:  ADDWFC 00,W
2ACA:  MOVWF  02
2ACC:  RETLW  00
*
2D0C:  CLRF   01
2D0E:  CLRF   02
2D10:  CLRF   00
2D12:  CLRF   03
2D14:  MOVF   7C,W
2D16:  BNZ   2D1C
2D18:  MOVF   7B,W
2D1A:  BZ    2D4C
2D1C:  MOVLW  10
2D1E:  MOVWF  7D
2D20:  BCF    FD8.0
2D22:  RLCF   79,F
2D24:  RLCF   7A,F
2D26:  RLCF   00,F
2D28:  RLCF   03,F
2D2A:  MOVF   7C,W
2D2C:  SUBWF  03,W
2D2E:  BNZ   2D34
2D30:  MOVF   7B,W
2D32:  SUBWF  00,W
2D34:  BNC   2D44
2D36:  MOVF   7B,W
2D38:  SUBWF  00,F
2D3A:  BTFSS  FD8.0
2D3C:  DECF   03,F
2D3E:  MOVF   7C,W
2D40:  SUBWF  03,F
2D42:  BSF    FD8.0
2D44:  RLCF   01,F
2D46:  RLCF   02,F
2D48:  DECFSZ 7D,F
2D4A:  BRA    2D20
2D4C:  NOP   
2D4E:  GOTO   305A (RETURN)
*
3184:  MOVLB  2
3186:  MOVF   x86,W
3188:  CLRF   01
318A:  SUBWF  x85,W
318C:  BC    3194
318E:  MOVFF  285,00
3192:  BRA    31AC
3194:  CLRF   00
3196:  MOVLW  08
3198:  MOVWF  x87
319A:  RLCF   x85,F
319C:  RLCF   00,F
319E:  MOVF   x86,W
31A0:  SUBWF  00,W
31A2:  BTFSC  FD8.0
31A4:  MOVWF  00
31A6:  RLCF   01,F
31A8:  DECFSZ x87,F
31AA:  BRA    319A
31AC:  MOVLB  0
31AE:  RETLW  00
31B0:  MOVLW  20
31B2:  BTFSS  7B.4
31B4:  MOVLW  30
31B6:  MOVWF  7C
31B8:  MOVFF  7A,00
31BC:  BTFSS  7A.7
31BE:  BRA    31CE
31C0:  COMF   00,F
31C2:  INCF   00,F
31C4:  MOVFF  00,7A
31C8:  MOVLW  2D
31CA:  MOVWF  7C
31CC:  BSF    7B.7
31CE:  MOVF   01,W
31D0:  MOVFF  7A,285
31D4:  MOVLW  64
31D6:  MOVLB  2
31D8:  MOVWF  x86
31DA:  MOVLB  0
31DC:  RCALL  3184
31DE:  MOVFF  00,7A
31E2:  MOVLW  30
31E4:  ADDWF  01,W
31E6:  MOVWF  7D
31E8:  MOVFF  7A,285
31EC:  MOVLW  0A
31EE:  MOVLB  2
31F0:  MOVWF  x86
31F2:  MOVLB  0
31F4:  RCALL  3184
31F6:  MOVLW  30
31F8:  ADDWF  00,W
31FA:  MOVWF  7F
31FC:  MOVLW  30
31FE:  ADDWF  01,W
3200:  MOVWF  7E
3202:  MOVFF  7C,00
3206:  BTFSS  7B.3
3208:  BRA    320E
320A:  BTFSS  7B.7
320C:  BCF    7B.2
320E:  BTFSC  7B.4
3210:  BRA    3228
3212:  BTFSS  7B.7
3214:  BRA    325A
3216:  BTFSC  7B.2
3218:  BRA    325A
321A:  MOVFF  00,7D
321E:  BTFSC  7B.1
3220:  BRA    325A
3222:  MOVFF  00,7E
3226:  BRA    325A
3228:  MOVLW  30
322A:  SUBWF  7D,W
322C:  BNZ   325A
322E:  MOVFF  00,7D
3232:  MOVLW  20
3234:  MOVWF  7C
3236:  BTFSS  7B.3
3238:  BRA    3242
323A:  BCF    7B.2
323C:  BSF    7B.1
323E:  BTFSS  7B.7
3240:  BCF    7B.1
3242:  MOVLW  30
3244:  SUBWF  7E,W
3246:  BNZ   325A
3248:  MOVFF  00,7E
324C:  MOVLW  20
324E:  MOVWF  7D
3250:  BTFSS  7B.3
3252:  BRA    3242
3254:  BCF    7B.1
3256:  BTFSS  7B.7
3258:  BCF    7B.0
325A:  BTFSS  7B.2
325C:  BRA    3266
325E:  MOVFF  7C,81
3262:  CALL   11FE
3266:  BTFSS  7B.1
3268:  BRA    3272
326A:  MOVFF  7D,81
326E:  CALL   11FE
3272:  BTFSS  7B.0
3274:  BRA    327E
3276:  MOVFF  7E,81
327A:  CALL   11FE
327E:  MOVFF  7F,81
3282:  CALL   11FE
3286:  RETLW  00
3288:  MOVLB  2
328A:  MOVF   x9E,W
328C:  SUBLW  B6
328E:  MOVWF  x9E
3290:  CLRF   03
3292:  MOVFF  29F,2A2
3296:  BSF    x9F.7
3298:  BCF    FD8.0
329A:  RRCF   x9F,F
329C:  RRCF   xA0,F
329E:  RRCF   xA1,F
32A0:  RRCF   03,F
32A2:  RRCF   02,F
32A4:  RRCF   01,F
32A6:  RRCF   00,F
32A8:  DECFSZ x9E,F
32AA:  BRA    3298
32AC:  BTFSS  xA2.7
32AE:  BRA    32C6
32B0:  COMF   00,F
32B2:  COMF   01,F
32B4:  COMF   02,F
32B6:  COMF   03,F
32B8:  INCF   00,F
32BA:  BTFSC  FD8.2
32BC:  INCF   01,F
32BE:  BTFSC  FD8.2
32C0:  INCF   02,F
32C2:  BTFSC  FD8.2
32C4:  INCF   03,F
32C6:  MOVLB  0
32C8:  RETLW  00
32CA:  CLRF   00
32CC:  CLRF   01
32CE:  CLRF   02
32D0:  CLRF   03
32D2:  MOVLB  2
32D4:  CLRF   xA6
32D6:  CLRF   xA7
32D8:  CLRF   xA8
32DA:  CLRF   xA9
32DC:  MOVF   xA5,W
32DE:  IORWF  xA4,W
32E0:  IORWF  xA3,W
32E2:  IORWF  xA2,W
32E4:  BZ    333E
32E6:  MOVLW  20
32E8:  MOVWF  xAA
32EA:  BCF    FD8.0
32EC:  RLCF   x9E,F
32EE:  RLCF   x9F,F
32F0:  RLCF   xA0,F
32F2:  RLCF   xA1,F
32F4:  RLCF   xA6,F
32F6:  RLCF   xA7,F
32F8:  RLCF   xA8,F
32FA:  RLCF   xA9,F
32FC:  MOVF   xA5,W
32FE:  SUBWF  xA9,W
3300:  BNZ   3312
3302:  MOVF   xA4,W
3304:  SUBWF  xA8,W
3306:  BNZ   3312
3308:  MOVF   xA3,W
330A:  SUBWF  xA7,W
330C:  BNZ   3312
330E:  MOVF   xA2,W
3310:  SUBWF  xA6,W
3312:  BNC   3332
3314:  MOVF   xA2,W
3316:  SUBWF  xA6,F
3318:  MOVF   xA3,W
331A:  BTFSS  FD8.0
331C:  INCFSZ xA3,W
331E:  SUBWF  xA7,F
3320:  MOVF   xA4,W
3322:  BTFSS  FD8.0
3324:  INCFSZ xA4,W
3326:  SUBWF  xA8,F
3328:  MOVF   xA5,W
332A:  BTFSS  FD8.0
332C:  INCFSZ xA5,W
332E:  SUBWF  xA9,F
3330:  BSF    FD8.0
3332:  RLCF   00,F
3334:  RLCF   01,F
3336:  RLCF   02,F
3338:  RLCF   03,F
333A:  DECFSZ xAA,F
333C:  BRA    32EA
333E:  NOP   
3340:  MOVLW  02
3342:  MOVWF  FEA
3344:  MOVLW  A6
3346:  MOVWF  FE9
3348:  MOVLB  0
334A:  RETLW  00
334C:  MOVF   FE9,W
334E:  MOVWF  79
3350:  MOVF   78,W
3352:  MOVWF  7B
3354:  BZ    338E
3356:  MOVFF  77,2A1
335A:  MOVFF  76,2A0
335E:  MOVFF  75,29F
3362:  MOVFF  74,29E
3366:  MOVLB  2
3368:  CLRF   xA5
336A:  CLRF   xA4
336C:  MOVLW  20
336E:  MOVWF  xA3
3370:  MOVLW  82
3372:  MOVWF  xA2
3374:  MOVLB  0
3376:  CALL   1754
337A:  MOVFF  03,77
337E:  MOVFF  02,76
3382:  MOVFF  01,75
3386:  MOVFF  00,74
338A:  DECFSZ 7B,F
338C:  BRA    3356
338E:  MOVFF  77,2A1
3392:  MOVFF  76,2A0
3396:  MOVFF  75,29F
339A:  MOVFF  74,29E
339E:  RCALL  3288
33A0:  MOVFF  03,77
33A4:  MOVFF  02,76
33A8:  MOVFF  01,75
33AC:  MOVFF  00,74
33B0:  BTFSS  77.7
33B2:  BRA    33CE
33B4:  DECF   79,F
33B6:  BSF    79.5
33B8:  COMF   74,F
33BA:  COMF   75,F
33BC:  COMF   76,F
33BE:  COMF   77,F
33C0:  INCF   74,F
33C2:  BTFSC  FD8.2
33C4:  INCF   75,F
33C6:  BTFSC  FD8.2
33C8:  INCF   76,F
33CA:  BTFSC  FD8.2
33CC:  INCF   77,F
33CE:  MOVLW  3B
33D0:  MOVWF  x80
33D2:  MOVLW  9A
33D4:  MOVWF  7F
33D6:  MOVLW  CA
33D8:  MOVWF  7E
33DA:  CLRF   7D
33DC:  MOVLW  0A
33DE:  MOVWF  7B
33E0:  MOVF   78,W
33E2:  BTFSC  FD8.2
33E4:  INCF   79,F
33E6:  MOVFF  77,2A1
33EA:  MOVFF  76,2A0
33EE:  MOVFF  75,29F
33F2:  MOVFF  74,29E
33F6:  MOVFF  80,2A5
33FA:  MOVFF  7F,2A4
33FE:  MOVFF  7E,2A3
3402:  MOVFF  7D,2A2
3406:  RCALL  32CA
3408:  MOVF   01,W
340A:  MOVFF  FEF,74
340E:  MOVFF  FEC,75
3412:  MOVFF  FEC,76
3416:  MOVFF  FEC,77
341A:  MOVF   00,F
341C:  BNZ   343C
341E:  INCF   78,W
3420:  SUBWF  7B,W
3422:  BZ    343C
3424:  MOVF   79,W
3426:  BZ    3440
3428:  ANDLW  0F
342A:  SUBWF  7B,W
342C:  BZ    3430
342E:  BC    34A6
3430:  BTFSC  79.7
3432:  BRA    34A6
3434:  BTFSC  79.6
3436:  BRA    3440
3438:  MOVLW  20
343A:  BRA    349C
343C:  MOVLW  20
343E:  ANDWF  79,F
3440:  BTFSS  79.5
3442:  BRA    345E
3444:  BCF    79.5
3446:  MOVF   78,W
3448:  BTFSS  FD8.2
344A:  DECF   79,F
344C:  MOVF   00,W
344E:  MOVWF  79
3450:  MOVLW  2D
3452:  MOVWF  x81
3454:  CALL   11FE
3458:  MOVF   79,W
345A:  MOVWF  00
345C:  CLRF   79
345E:  MOVF   78,W
3460:  SUBWF  7B,W
3462:  BNZ   347A
3464:  MOVF   00,W
3466:  MOVWF  79
3468:  MOVLW  2E
346A:  MOVWF  x81
346C:  CALL   11FE
3470:  MOVF   79,W
3472:  MOVWF  00
3474:  MOVLW  20
3476:  ANDWF  79,F
3478:  MOVLW  00
347A:  MOVLW  30
347C:  BTFSS  79.5
347E:  BRA    349C
3480:  BCF    79.5
3482:  MOVF   78,W
3484:  BTFSS  FD8.2
3486:  DECF   79,F
3488:  MOVF   00,W
348A:  MOVWF  79
348C:  MOVLW  2D
348E:  MOVWF  x81
3490:  CALL   11FE
3494:  MOVF   79,W
3496:  MOVWF  00
3498:  CLRF   79
349A:  MOVLW  30
349C:  ADDWF  00,F
349E:  MOVFF  00,81
34A2:  CALL   11FE
34A6:  MOVFF  80,2A1
34AA:  MOVFF  7F,2A0
34AE:  MOVFF  7E,29F
34B2:  MOVFF  7D,29E
34B6:  MOVLB  2
34B8:  CLRF   xA5
34BA:  CLRF   xA4
34BC:  CLRF   xA3
34BE:  MOVLW  0A
34C0:  MOVWF  xA2
34C2:  MOVLB  0
34C4:  RCALL  32CA
34C6:  MOVFF  03,80
34CA:  MOVFF  02,7F
34CE:  MOVFF  01,7E
34D2:  MOVFF  00,7D
34D6:  DECFSZ 7B,F
34D8:  BRA    33E6
34DA:  RETLW  00
*
3A28:  MOVF   01,W
3A2A:  MOVFF  283,285
3A2E:  MOVLW  64
3A30:  MOVLB  2
3A32:  MOVWF  x86
3A34:  MOVLB  0
3A36:  CALL   3184
3A3A:  MOVFF  00,283
3A3E:  MOVF   01,W
3A40:  MOVLW  30
3A42:  BNZ   3A54
3A44:  MOVLB  2
3A46:  BTFSS  x84.1
3A48:  BRA    3A66
3A4A:  BTFSC  x84.3
3A4C:  BRA    3A66
3A4E:  BTFSC  x84.4
3A50:  MOVLW  20
3A52:  BRA    3A5C
3A54:  MOVLB  2
3A56:  BCF    x84.3
3A58:  BCF    x84.4
3A5A:  BSF    x84.0
3A5C:  ADDWF  01,F
3A5E:  MOVF   01,W
3A60:  BTFSS  F9E.4
3A62:  BRA    3A60
3A64:  MOVWF  FAD
3A66:  MOVFF  283,285
3A6A:  MOVLW  0A
3A6C:  MOVWF  x86
3A6E:  MOVLB  0
3A70:  CALL   3184
3A74:  MOVFF  00,283
3A78:  MOVF   01,W
3A7A:  MOVLW  30
3A7C:  BNZ   3A8E
3A7E:  MOVLB  2
3A80:  BTFSC  x84.3
3A82:  BRA    3A9A
3A84:  BTFSS  x84.0
3A86:  BRA    3A9A
3A88:  BTFSC  x84.4
3A8A:  MOVLW  20
3A8C:  MOVLB  0
3A8E:  ADDWF  01,F
3A90:  MOVF   01,W
3A92:  BTFSS  F9E.4
3A94:  BRA    3A92
3A96:  MOVWF  FAD
3A98:  MOVLB  2
3A9A:  MOVLW  30
3A9C:  ADDWF  x83,F
3A9E:  MOVF   x83,W
3AA0:  BTFSS  F9E.4
3AA2:  BRA    3AA0
3AA4:  MOVWF  FAD
3AA6:  MOVLB  0
3AA8:  RETLW  00
3AAA:  MOVF   FE9,W
3AAC:  MOVLB  2
3AAE:  MOVWF  x96
3AB0:  MOVF   x95,W
3AB2:  MOVWF  x98
3AB4:  BZ    3AEE
3AB6:  MOVFF  294,2A1
3ABA:  MOVFF  293,2A0
3ABE:  MOVFF  292,29F
3AC2:  MOVFF  291,29E
3AC6:  CLRF   xA5
3AC8:  CLRF   xA4
3ACA:  MOVLW  20
3ACC:  MOVWF  xA3
3ACE:  MOVLW  82
3AD0:  MOVWF  xA2
3AD2:  MOVLB  0
3AD4:  CALL   1754
3AD8:  MOVFF  03,294
3ADC:  MOVFF  02,293
3AE0:  MOVFF  01,292
3AE4:  MOVFF  00,291
3AE8:  MOVLB  2
3AEA:  DECFSZ x98,F
3AEC:  BRA    3AB6
3AEE:  MOVFF  294,2A1
3AF2:  MOVFF  293,2A0
3AF6:  MOVFF  292,29F
3AFA:  MOVFF  291,29E
3AFE:  MOVLB  0
3B00:  CALL   3288
3B04:  MOVFF  03,294
3B08:  MOVFF  02,293
3B0C:  MOVFF  01,292
3B10:  MOVFF  00,291
3B14:  MOVLB  2
3B16:  BTFSS  x94.7
3B18:  BRA    3B34
3B1A:  DECF   x96,F
3B1C:  BSF    x96.5
3B1E:  COMF   x91,F
3B20:  COMF   x92,F
3B22:  COMF   x93,F
3B24:  COMF   x94,F
3B26:  INCF   x91,F
3B28:  BTFSC  FD8.2
3B2A:  INCF   x92,F
3B2C:  BTFSC  FD8.2
3B2E:  INCF   x93,F
3B30:  BTFSC  FD8.2
3B32:  INCF   x94,F
3B34:  MOVLW  3B
3B36:  MOVWF  x9D
3B38:  MOVLW  9A
3B3A:  MOVWF  x9C
3B3C:  MOVLW  CA
3B3E:  MOVWF  x9B
3B40:  CLRF   x9A
3B42:  MOVLW  0A
3B44:  MOVWF  x98
3B46:  MOVF   x95,W
3B48:  BTFSC  FD8.2
3B4A:  INCF   x96,F
3B4C:  MOVFF  294,2A1
3B50:  MOVFF  293,2A0
3B54:  MOVFF  292,29F
3B58:  MOVFF  291,29E
3B5C:  MOVFF  29D,2A5
3B60:  MOVFF  29C,2A4
3B64:  MOVFF  29B,2A3
3B68:  MOVFF  29A,2A2
3B6C:  MOVLB  0
3B6E:  CALL   32CA
3B72:  MOVF   01,W
3B74:  MOVFF  FEF,291
3B78:  MOVFF  FEC,292
3B7C:  MOVFF  FEC,293
3B80:  MOVFF  FEC,294
3B84:  MOVF   00,F
3B86:  BNZ   3BAE
3B88:  MOVLB  2
3B8A:  INCF   x95,W
3B8C:  SUBWF  x98,W
3B8E:  BTFSS  FD8.2
3B90:  BRA    3B96
3B92:  MOVLB  0
3B94:  BRA    3BAE
3B96:  MOVF   x96,W
3B98:  BZ    3BB4
3B9A:  ANDLW  0F
3B9C:  SUBWF  x98,W
3B9E:  BZ    3BA2
3BA0:  BC    3C1A
3BA2:  BTFSC  x96.7
3BA4:  BRA    3C1A
3BA6:  BTFSC  x96.6
3BA8:  BRA    3BB4
3BAA:  MOVLW  20
3BAC:  BRA    3C10
3BAE:  MOVLW  20
3BB0:  MOVLB  2
3BB2:  ANDWF  x96,F
3BB4:  BTFSS  x96.5
3BB6:  BRA    3BD2
3BB8:  BCF    x96.5
3BBA:  MOVF   x95,W
3BBC:  BTFSS  FD8.2
3BBE:  DECF   x96,F
3BC0:  MOVF   00,W
3BC2:  MOVWF  x96
3BC4:  MOVLW  2D
3BC6:  BTFSS  F9E.4
3BC8:  BRA    3BC6
3BCA:  MOVWF  FAD
3BCC:  MOVF   x96,W
3BCE:  MOVWF  00
3BD0:  CLRF   x96
3BD2:  MOVF   x95,W
3BD4:  SUBWF  x98,W
3BD6:  BNZ   3BEE
3BD8:  MOVF   00,W
3BDA:  MOVWF  x96
3BDC:  MOVLW  2E
3BDE:  BTFSS  F9E.4
3BE0:  BRA    3BDE
3BE2:  MOVWF  FAD
3BE4:  MOVF   x96,W
3BE6:  MOVWF  00
3BE8:  MOVLW  20
3BEA:  ANDWF  x96,F
3BEC:  MOVLW  00
3BEE:  MOVLW  30
3BF0:  BTFSS  x96.5
3BF2:  BRA    3C10
3BF4:  BCF    x96.5
3BF6:  MOVF   x95,W
3BF8:  BTFSS  FD8.2
3BFA:  DECF   x96,F
3BFC:  MOVF   00,W
3BFE:  MOVWF  x96
3C00:  MOVLW  2D
3C02:  BTFSS  F9E.4
3C04:  BRA    3C02
3C06:  MOVWF  FAD
3C08:  MOVF   x96,W
3C0A:  MOVWF  00
3C0C:  CLRF   x96
3C0E:  MOVLW  30
3C10:  ADDWF  00,F
3C12:  MOVF   00,W
3C14:  BTFSS  F9E.4
3C16:  BRA    3C14
3C18:  MOVWF  FAD
3C1A:  MOVFF  29D,2A1
3C1E:  MOVFF  29C,2A0
3C22:  MOVFF  29B,29F
3C26:  MOVFF  29A,29E
3C2A:  CLRF   xA5
3C2C:  CLRF   xA4
3C2E:  CLRF   xA3
3C30:  MOVLW  0A
3C32:  MOVWF  xA2
3C34:  MOVLB  0
3C36:  CALL   32CA
3C3A:  MOVFF  03,29D
3C3E:  MOVFF  02,29C
3C42:  MOVFF  01,29B
3C46:  MOVFF  00,29A
3C4A:  MOVLB  2
3C4C:  DECFSZ x98,F
3C4E:  BRA    3B4C
3C50:  MOVLB  0
3C52:  RETLW  00
3C54:  MOVFF  FEA,28B
3C58:  MOVFF  FE9,28A
3C5C:  MOVLB  2
3C5E:  SWAPF  x84,W
3C60:  IORLW  F0
3C62:  MOVWF  x86
3C64:  ADDWF  x86,F
3C66:  ADDLW  E2
3C68:  MOVWF  x87
3C6A:  ADDLW  32
3C6C:  MOVWF  x89
3C6E:  MOVF   x84,W
3C70:  ANDLW  0F
3C72:  ADDWF  x87,F
3C74:  ADDWF  x87,F
3C76:  ADDWF  x89,F
3C78:  ADDLW  E9
3C7A:  MOVWF  x88
3C7C:  ADDWF  x88,F
3C7E:  ADDWF  x88,F
3C80:  SWAPF  x83,W
3C82:  ANDLW  0F
3C84:  ADDWF  x88,F
3C86:  ADDWF  x89,F
3C88:  RLCF   x88,F
3C8A:  RLCF   x89,F
3C8C:  COMF   x89,F
3C8E:  RLCF   x89,F
3C90:  MOVF   x83,W
3C92:  ANDLW  0F
3C94:  ADDWF  x89,F
3C96:  RLCF   x86,F
3C98:  MOVLW  07
3C9A:  MOVWF  x85
3C9C:  MOVLW  0A
3C9E:  DECF   x88,F
3CA0:  ADDWF  x89,F
3CA2:  BNC   3C9E
3CA4:  DECF   x87,F
3CA6:  ADDWF  x88,F
3CA8:  BNC   3CA4
3CAA:  DECF   x86,F
3CAC:  ADDWF  x87,F
3CAE:  BNC   3CAA
3CB0:  DECF   x85,F
3CB2:  ADDWF  x86,F
3CB4:  BNC   3CB0
3CB6:  MOVLW  02
3CB8:  MOVWF  FEA
3CBA:  MOVLW  85
3CBC:  MOVWF  FE9
3CBE:  MOVLW  07
3CC0:  ANDWF  x8A,W
3CC2:  BCF    x8A.6
3CC4:  ADDWF  FE9,F
3CC6:  MOVLW  89
3CC8:  SUBWF  FE9,W
3CCA:  BTFSC  FD8.2
3CCC:  BSF    x8A.6
3CCE:  MOVF   FEF,W
3CD0:  MOVWF  00
3CD2:  BNZ   3CE4
3CD4:  BTFSC  x8A.6
3CD6:  BRA    3CE4
3CD8:  BTFSC  x8A.4
3CDA:  BRA    3CF4
3CDC:  BTFSC  x8A.3
3CDE:  BRA    3CE4
3CE0:  MOVLW  20
3CE2:  BRA    3CEA
3CE4:  BSF    x8A.3
3CE6:  BCF    x8A.4
3CE8:  MOVLW  30
3CEA:  ADDWF  00,F
3CEC:  MOVF   00,W
3CEE:  BTFSS  F9E.4
3CF0:  BRA    3CEE
3CF2:  MOVWF  FAD
3CF4:  MOVF   FEE,W
3CF6:  BTFSS  x8A.6
3CF8:  BRA    3CC6
3CFA:  MOVLB  0
3CFC:  RETLW  00
*
5802:  MOVFF  FF2,0E
5806:  BCF    FF2.7
5808:  ADDWF  FE8,W
580A:  ADDLW  27
580C:  MOVWF  FF6
580E:  MOVLW  58
5810:  MOVWF  FF7
5812:  BTFSC  FD8.0
5814:  INCF   FF7,F
5816:  TBLRD*-
5818:  MOVF   FF5,W
581A:  MOVWF  FFA
581C:  TBLRD*
581E:  MOVF   FF5,W
5820:  BTFSC  0E.7
5822:  BSF    FF2.7
5824:  MOVWF  FF9
5826:  DATA CE,4A
5828:  DATA F0,4A
582A:  DATA B2,4B
582C:  DATA 60,4C
*
588A:  MOVF   01,W
588C:  MOVFF  6F,285
5890:  MOVLW  64
5892:  MOVLB  2
5894:  MOVWF  x86
5896:  MOVLB  0
5898:  CALL   3184
589C:  MOVFF  00,6F
58A0:  MOVF   01,W
58A2:  MOVLW  30
58A4:  BNZ   58B4
58A6:  BTFSS  70.1
58A8:  BRA    58C4
58AA:  BTFSC  70.3
58AC:  BRA    58C4
58AE:  BTFSC  70.4
58B0:  MOVLW  20
58B2:  BRA    58BA
58B4:  BCF    70.3
58B6:  BCF    70.4
58B8:  BSF    70.0
58BA:  ADDWF  01,F
58BC:  MOVFF  01,81
58C0:  CALL   11FE
58C4:  MOVFF  6F,285
58C8:  MOVLW  0A
58CA:  MOVLB  2
58CC:  MOVWF  x86
58CE:  MOVLB  0
58D0:  CALL   3184
58D4:  MOVFF  00,6F
58D8:  MOVF   01,W
58DA:  MOVLW  30
58DC:  BNZ   58EA
58DE:  BTFSC  70.3
58E0:  BRA    58F4
58E2:  BTFSS  70.0
58E4:  BRA    58F4
58E6:  BTFSC  70.4
58E8:  MOVLW  20
58EA:  ADDWF  01,F
58EC:  MOVFF  01,81
58F0:  CALL   11FE
58F4:  MOVLW  30
58F6:  ADDWF  6F,F
58F8:  MOVFF  6F,81
58FC:  CALL   11FE
5900:  RETLW  00
....................                   //fijamos que el valor leído esté representado con 8 bits 
....................                   //(es decir de 00 a FF). 
....................                   //Para cambiar el rango de salida usamos: ADC=10 (000 a 3FF) 
....................                   //                                      ó ADC=16 (0000 a FFC0) 
.................... #list 
....................  
.................... #include "proyecto1.h" 
.................... //****************************************** 
.................... //Archivo de cabecera del Proyecto 1 
.................... //****************************************** 
.................... //Author: Julio Navarro Lara         2010 
....................  
.................... //Definimos los puertos del microcontrolador 
.................... #byte port_a = 0xF80 
.................... #byte port_b = 0xF81 
.................... #byte port_c = 0xF82 
.................... #byte port_d = 0xF83 
.................... #byte port_e = 0xF84 
....................  
.................... #bit sistema_encendido = 0xF83.2    //Pin que indica el encendido del sistema con un valor alto 
.................... #bit motor = 0xF83.1                //Pin que indica el encendido del motor de circulación del agua con un valor alto 
.................... #bit caldera_encendida = 0xF83.0    //Pin que indica el encendido de la caldera con un valor alto 
.................... #bit menos =    0xF82.1             //Pines para gestionar la entrada de los pulsadores 
.................... #bit mas   =    0xF82.0             //'' 
.................... #bit si    =    0xF82.2             //'' 
.................... #bit no    =    0xF82.5             //'' 
....................  
.................... //Código para definir el botón NO 
.................... #define NOCODE          100 
....................  
.................... //Parámetros de la pantalla LCD 
.................... #define LCD_ORDEN       0    //Código para enviar un orden 
.................... #define LCD_DATO        1    //Código para enviar un dato 
....................  
.................... #define LCD_CLEAR       0x01  //Orden para borrar la pantalla 
.................... #define LCD_NO_CURSOR   0x0C  //Orden para eliminar el cursor de la pantalla 
.................... #define LCD_CURSOR      0x0E  //Orden para visualizar el cursor en la pantalla 
.................... #define LCD_PARPADEAR   0x0D  //Orden para que parpadee el cursor 
....................  
.................... //Tiempo que se mantienen los mensajes temporales en pantalla (ms) 
.................... //En ocasiones este retardo se introduce simplemente para que el usuario o el técnico visualicen los propios 
.................... //valores que han introducido por pantalla sin ser atosigados por la siguiente operación. 
.................... #define LCD_T_RETARDO   500 
....................  
.................... //Parámetros del conversor AD 
.................... #define termostato_caldera   3   //Entrada AD que se refiere a la temperatura de referencia de la caldera 
.................... #define temperatura_caldera  2   //Entrada AD que se refiere a la temperatura del agua en la caldera 
.................... #define histeresis_caldera   5   //Diferencia de histéresis para el agua de la caldera 
.................... //Para probar en el PROTEUS, poner una histeresis de 10 ºC (los potenciómetros simulados no tienen más sensibilidad) 
.................... #define t_max_caldera        100  //Temperatura máxima a la que puede regularse la caldera 
.................... #define t_min_caldera        0  //Temperatura mínima a la que puede regularse la caldera 
.................... #define AD_num_valores       255 //Número de valores de escala del conversor (sensibilidad de los potenciómetros) 
....................  
.................... //Parámetros de control de temperatura 
.................... //Datos suministrados por el aparato de aire acondicionado (con bomba de calor) de mi casa 
.................... #define temp_max          32  //Temperatura máxima de regulación del termostato 
.................... #define temp_min          16  //Temperatura mínima de regulación del termostato 
....................  
.................... //Direcciones para la EEPROM 
.................... #define eeprom_termostato        0x00  //Valor del termostato 
.................... #define eeprom_num_intervalos    0x01  //Número de intervalos de programación de los que disponemos 
.................... #define eeprom_num_registros     0x02  //Número de registros de desconexión de los que se disponen 
.................... #define eeprom_anno_actual       0x03  //Año en el que nos encontramos 
.................... #define eeprom_anno_0_to_3       0x04  //Año en el que nos encontramos medido de 0 a 3 (llamado 1_to_3 por razones "históricas") 
.................... #define eeprom_programaciones    0x05  //Posición a partir de la cual se almacenan las programaciones de alarmas 
.................... #define eeprom_registros         0x14  //Posición a partir de la cual se almacenan los registros 
....................                                        //En este caso, por usar la memoria interna del microprocesador, caben sólo 26 registros 
....................  
.................... #fuses HS, NOPROTECT, BROWNOUT, PUT, NOLVP, NOXINST, WDT4096, NOWDT 
.................... //El watchdog-timer salta cada 16.384 segundos, aproximadamente 
.................... #use delay(clock=8000000, restart_wdt) 
*
10E6:  CLRF   FEA
10E8:  MOVLW  88
10EA:  MOVWF  FE9
10EC:  MOVF   FEF,W
10EE:  BZ    1114
10F0:  MOVLW  02
10F2:  MOVWF  01
10F4:  MOVLW  BF
10F6:  MOVWF  00
10F8:  CLRWDT
10FA:  DECFSZ 00,F
10FC:  BRA    10F8
10FE:  DECFSZ 01,F
1100:  BRA    10F4
1102:  MOVLW  96
1104:  MOVWF  00
1106:  DECFSZ 00,F
1108:  BRA    1106
110A:  NOP   
110C:  NOP   
110E:  CLRWDT
1110:  DECFSZ FEF,F
1112:  BRA    10F0
1114:  RETLW  00
*
1134:  MOVLW  09
1136:  SUBWF  x89,F
1138:  BNC   1150
113A:  CLRF   FEA
113C:  MOVLW  89
113E:  MOVWF  FE9
1140:  BCF    FD8.0
1142:  RRCF   FEF,F
1144:  MOVF   FEF,W
1146:  BZ    1150
1148:  BRA    114C
114A:  CLRWDT
114C:  DECFSZ FEF,F
114E:  BRA    114A
1150:  RETLW  00
.................... #use rs232(baud=4800, xmit=PIN_C6,rcv=PIN_C7) 
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  (x==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  (x<' ') 
.................... #define isprint(x)  (x>=' ') 
.................... #define isgraph(x)  (x>' ') 
.................... #define ispunct(x)  ((x>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(int *)==1 
.................... #define ptrdiff_t int 
.................... #else 
.................... #define ptrdiff_t long 
.................... #endif 
....................  
.................... #define size_t int 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: float atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... float atof(char * s); 
....................  
.................... /* Standard template: float atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... float atoe(char * s); 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int32 atoi32(char *s); 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, int8 base, char * s); 
....................  
.................... /* Standard template: signed long  atol(char * s) 
....................  * converts the initial portion of the string s to a signed long 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: float strtol(char * s,char *endptr) 
....................  * converts the initial portion of the string s to a float 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... float strtod(char *s,char *endptr); 
....................  
.................... /* Standard template: long strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr,signed int base); 
....................  
.................... /* Standard template: long strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... long strtoul(char *s,char *endptr,signed int base); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... long rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer,signed int denom); 
.................... ldiv_t ldiv(signed long numer,signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(int *)==1 
.................... #define ptrdiff_t int 
.................... #else 
.................... #define ptrdiff_t long 
.................... #endif 
....................  
.................... #define size_t int 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(int *)==1 
.................... #define ptrdiff_t int 
.................... #else 
.................... #define ptrdiff_t long 
.................... #endif 
....................  
.................... #define size_t int 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  (x==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  (x<' ') 
.................... #define isprint(x)  (x>=' ') 
.................... #define isgraph(x)  (x>' ') 
.................... #define ispunct(x)  ((x>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* compiler ignored the name 'strcpy()'; perhaps, it's reserved? 
....................    Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1*/ 
....................  
.................... char *strcopy(char *s1, char *s2) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; *s2 != 0; s++, s2++) { 
.................... 	  *s = *s2; 
....................   } 
....................   *s = *s2; 
....................   return(s1); 
.................... } 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   int n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,int c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, int c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... int *strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, int c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... int *strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
.................... 	 if (*sc2 == '\0') 
.................... 	    return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
.................... 	char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
.................... 	while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && *s == *t; ++s, ++t); 
....................  
.................... 		if (*t == '\0') 
.................... 			return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
.................... 	} 
.................... 	return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(int errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... int *strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer,signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer,signed long denom) 
.................... { 
....................    ldiv_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... float atof(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int sign = 0; 
....................    char c; 
....................    int ptr = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
....................  
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int sign = 0; 
....................    int expsign = 0; 
....................    char c; 
....................    int ptr = 0; 
....................    int i; 
....................    float exp = 1.0; 
....................    int expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
128E:  CLRF   7F
....................    sign = 0; 
1290:  CLRF   7D
....................    base = 10; 
1292:  MOVLW  0A
1294:  MOVWF  7E
....................    result = 0; 
1296:  CLRF   7C
....................  
....................    if (!s) 
1298:  MOVF   7A,W
129A:  IORWF  7B,W
129C:  BNZ   12A4
....................       return 0; 
129E:  MOVLW  00
12A0:  MOVWF  01
12A2:  BRA    1426
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
12A4:  MOVF   7F,W
12A6:  INCF   7F,F
12A8:  CLRF   03
12AA:  ADDWF  7A,W
12AC:  MOVWF  FE9
12AE:  MOVF   7B,W
12B0:  ADDWFC 03,W
12B2:  MOVWF  FEA
12B4:  MOVFF  FEF,80
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
12B8:  MOVF   x80,W
12BA:  SUBLW  2D
12BC:  BNZ   12D8
....................    { 
....................       sign = 1;         // Set the sign to negative 
12BE:  MOVLW  01
12C0:  MOVWF  7D
....................       c = s[index++]; 
12C2:  MOVF   7F,W
12C4:  INCF   7F,F
12C6:  CLRF   03
12C8:  ADDWF  7A,W
12CA:  MOVWF  FE9
12CC:  MOVF   7B,W
12CE:  ADDWFC 03,W
12D0:  MOVWF  FEA
12D2:  MOVFF  FEF,80
....................    } 
....................    else if (c == '+') 
12D6:  BRA    12F2
12D8:  MOVF   x80,W
12DA:  SUBLW  2B
12DC:  BNZ   12F2
....................    { 
....................       c = s[index++]; 
12DE:  MOVF   7F,W
12E0:  INCF   7F,F
12E2:  CLRF   03
12E4:  ADDWF  7A,W
12E6:  MOVWF  FE9
12E8:  MOVF   7B,W
12EA:  ADDWFC 03,W
12EC:  MOVWF  FEA
12EE:  MOVFF  FEF,80
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
12F2:  MOVF   x80,W
12F4:  SUBLW  2F
12F6:  BTFSC  FD8.0
12F8:  BRA    1416
12FA:  MOVF   x80,W
12FC:  SUBLW  39
12FE:  BTFSS  FD8.0
1300:  BRA    1416
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
1302:  MOVF   x80,W
1304:  SUBLW  30
1306:  BNZ   134A
1308:  CLRF   03
130A:  MOVF   7F,W
130C:  ADDWF  7A,W
130E:  MOVWF  FE9
1310:  MOVF   7B,W
1312:  ADDWFC 03,W
1314:  MOVWF  FEA
1316:  MOVF   FEF,W
1318:  SUBLW  78
131A:  BZ    1330
131C:  CLRF   03
131E:  MOVF   7F,W
1320:  ADDWF  7A,W
1322:  MOVWF  FE9
1324:  MOVF   7B,W
1326:  ADDWFC 03,W
1328:  MOVWF  FEA
132A:  MOVF   FEF,W
132C:  SUBLW  58
132E:  BNZ   134A
....................       { 
....................          base = 16; 
1330:  MOVLW  10
1332:  MOVWF  7E
....................          index++; 
1334:  INCF   7F,F
....................          c = s[index++]; 
1336:  MOVF   7F,W
1338:  INCF   7F,F
133A:  CLRF   03
133C:  ADDWF  7A,W
133E:  MOVWF  FE9
1340:  MOVF   7B,W
1342:  ADDWFC 03,W
1344:  MOVWF  FEA
1346:  MOVFF  FEF,80
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
134A:  MOVF   7E,W
134C:  SUBLW  0A
134E:  BNZ   1386
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
1350:  MOVF   x80,W
1352:  SUBLW  2F
1354:  BC    1384
1356:  MOVF   x80,W
1358:  SUBLW  39
135A:  BNC   1384
....................             result = 10*result + (c - '0'); 
135C:  MOVLW  0A
135E:  MOVWF  x81
1360:  MOVFF  7C,82
1364:  BRA    1242
1366:  MOVLW  30
1368:  SUBWF  x80,W
136A:  ADDWF  01,W
136C:  MOVWF  7C
....................             c = s[index++]; 
136E:  MOVF   7F,W
1370:  INCF   7F,F
1372:  CLRF   03
1374:  ADDWF  7A,W
1376:  MOVWF  FE9
1378:  MOVF   7B,W
137A:  ADDWFC 03,W
137C:  MOVWF  FEA
137E:  MOVFF  FEF,80
....................          } 
1382:  BRA    1350
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
1384:  BRA    1416
1386:  MOVF   7E,W
1388:  SUBLW  10
138A:  BNZ   1416
....................       { 
....................          c = toupper(c); 
138C:  MOVF   x80,W
138E:  SUBLW  60
1390:  BC    139E
1392:  MOVF   x80,W
1394:  SUBLW  7A
1396:  BNC   139E
1398:  MOVF   x80,W
139A:  ANDLW  DF
139C:  BRA    13A0
139E:  MOVF   x80,W
13A0:  MOVWF  x80
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
13A2:  MOVF   x80,W
13A4:  SUBLW  2F
13A6:  BC    13AE
13A8:  MOVF   x80,W
13AA:  SUBLW  39
13AC:  BC    13BA
13AE:  MOVF   x80,W
13B0:  SUBLW  40
13B2:  BC    1416
13B4:  MOVF   x80,W
13B6:  SUBLW  46
13B8:  BNC   1416
....................             if (c >= '0' && c <= '9') 
13BA:  MOVF   x80,W
13BC:  SUBLW  2F
13BE:  BC    13D8
13C0:  MOVF   x80,W
13C2:  SUBLW  39
13C4:  BNC   13D8
....................                result = (result << 4) + (c - '0'); 
13C6:  SWAPF  7C,W
13C8:  MOVWF  x81
13CA:  MOVLW  F0
13CC:  ANDWF  x81,F
13CE:  MOVLW  30
13D0:  SUBWF  x80,W
13D2:  ADDWF  x81,W
13D4:  MOVWF  7C
....................             else 
13D6:  BRA    13EA
....................                result = (result << 4) + (c - 'A' + 10); 
13D8:  SWAPF  7C,W
13DA:  MOVWF  x81
13DC:  MOVLW  F0
13DE:  ANDWF  x81,F
13E0:  MOVLW  41
13E2:  SUBWF  x80,W
13E4:  ADDLW  0A
13E6:  ADDWF  x81,W
13E8:  MOVWF  7C
....................  
....................             c = s[index++]; 
13EA:  MOVF   7F,W
13EC:  INCF   7F,F
13EE:  CLRF   03
13F0:  ADDWF  7A,W
13F2:  MOVWF  FE9
13F4:  MOVF   7B,W
13F6:  ADDWFC 03,W
13F8:  MOVWF  FEA
13FA:  MOVFF  FEF,80
....................             c = toupper(c); 
13FE:  MOVF   x80,W
1400:  SUBLW  60
1402:  BC    1410
1404:  MOVF   x80,W
1406:  SUBLW  7A
1408:  BNC   1410
140A:  MOVF   x80,W
140C:  ANDLW  DF
140E:  BRA    1412
1410:  MOVF   x80,W
1412:  MOVWF  x80
....................          } 
1414:  BRA    13A2
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
1416:  DECFSZ 7D,W
1418:  BRA    1422
141A:  MOVF   7E,W
141C:  SUBLW  0A
141E:  BNZ   1422
....................        result = -result; 
1420:  NEGF   7C
....................  
....................    return(result); 
1422:  MOVFF  7C,01
.................... } 
1426:  RETLW  00
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... char * itoa(signed int32 num, int8 base, char *s) 
.................... { 
....................      int32 temp=1; 
....................      int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... float strtod(char *s,char *endptr) { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int sign = 0, point = 0; 
....................    char c; 
....................    int ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c=s[ptr++]; 
....................  
....................  
....................    while((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 0) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          point = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 1) { 
....................          pow10 = pow10*10; 
....................          result += (c - '0')/pow10; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '+') { 
....................          c = s[ptr++]; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................          *((char *)endptr)=s+ptr; 
....................       } 
....................       else 
....................          *((char *)endptr)=s; 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... long strtoul(char *s,char *endptr,signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-') 
....................    { 
....................       if (endptr) 
....................       { 
....................         *((char *)endptr)=s; 
....................       } 
....................       return 0; 
....................    } 
....................  
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    { 
....................       if (endptr) 
....................       { 
....................         *((char *)endptr)=s; 
....................       } 
....................       return 0; 
....................    } 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................       if (endptr) 
....................       { 
....................         *((char *)endptr)=s; 
....................       } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................         *((char *)endptr)=sc; 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr,signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    { 
....................       if (endptr) 
....................       { 
....................         *((char *)endptr)=s; 
....................       } 
....................       return 0; 
....................    } 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................       if (endptr) 
....................       { 
....................         *((char *)endptr)=s; 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................         *((char *)endptr)=sc; 
....................    return x; 
.................... } 
....................  
.................... signed int system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed = 1; 
....................  
.................... long rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned long)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... typedef signed int (*_Cmpfun)(char * p1,char * p2); 
....................  
.................... void qsort(char * qdata, int qitems, int qsize, _Cmpfun cmp) { 
....................    int m,j,i,l; 
....................    short done; 
....................    BYTE t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=TRUE; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = FALSE; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include "PCF8583.c" 
.................... // Funciones para el RTC I2c: PCF8583 
.................... // Este código no procede de CCS (no está totalmente verificado) 
.................... // Inluye funciones de conversión BCD-Binario 
.................... // y de lectura/escritura a través de I2C. 
....................  
.................... //Vamos a eliminar todos los casos en los que se habiliten las interrupciones globales 
.................... //Estas sentencias nos impedían utilizar estos métodos en las interrupciones 
....................  
.................... #ifndef PCF8583_SDA 
.................... #define PCF8583_SDA  PIN_C4 
.................... #define PCF8583_SCL  PIN_C3 
.................... #endif 
....................  
.................... #use i2c(master, sda=PCF8583_SDA, scl=PCF8583_SCL) 
*
14BE:  MOVLW  08
14C0:  MOVWF  01
14C2:  NOP   
14C4:  NOP   
14C6:  NOP   
14C8:  BCF    F8B.3
14CA:  BCF    F94.3
14CC:  NOP   
14CE:  NOP   
14D0:  NOP   
14D2:  RLCF   x82,F
14D4:  BCF    F8B.4
14D6:  BTFSC  FD8.0
14D8:  BSF    F94.4
14DA:  BTFSS  FD8.0
14DC:  BCF    F94.4
14DE:  BSF    F94.3
14E0:  BTFSS  F82.3
14E2:  BRA    14E0
14E4:  DECFSZ 01,F
14E6:  BRA    14C2
14E8:  NOP   
14EA:  NOP   
14EC:  BCF    F8B.3
14EE:  BCF    F94.3
14F0:  NOP   
14F2:  BSF    F94.4
14F4:  NOP   
14F6:  NOP   
14F8:  NOP   
14FA:  NOP   
14FC:  NOP   
14FE:  NOP   
1500:  BSF    F94.3
1502:  BTFSS  F82.3
1504:  BRA    1502
1506:  CLRF   01
1508:  NOP   
150A:  NOP   
150C:  NOP   
150E:  BTFSC  F82.4
1510:  BSF    01.0
1512:  BCF    F8B.3
1514:  BCF    F94.3
1516:  BCF    F8B.4
1518:  BCF    F94.4
151A:  RETLW  00
*
275C:  MOVLW  08
275E:  MOVWF  x83
2760:  MOVFF  00,84
2764:  BSF    F94.4
2766:  NOP   
2768:  NOP   
276A:  NOP   
276C:  BSF    F94.3
276E:  BTFSS  F82.3
2770:  BRA    276E
2772:  BTFSC  F82.4
2774:  BSF    FD8.0
2776:  BTFSS  F82.4
2778:  BCF    FD8.0
277A:  RLCF   01,F
277C:  NOP   
277E:  NOP   
2780:  BCF    F94.3
2782:  BCF    F8B.3
2784:  DECFSZ x83,F
2786:  BRA    2764
2788:  BSF    F94.4
278A:  NOP   
278C:  NOP   
278E:  NOP   
2790:  BCF    F8B.4
2792:  MOVF   x84,W
2794:  BTFSS  FD8.2
2796:  BCF    F94.4
2798:  NOP   
279A:  BSF    F94.3
279C:  BTFSS  F82.3
279E:  BRA    279C
27A0:  NOP   
27A2:  NOP   
27A4:  BCF    F8B.3
27A6:  BCF    F94.3
27A8:  NOP   
27AA:  NOP   
27AC:  NOP   
27AE:  BCF    F8B.4
27B0:  BCF    F94.4
27B2:  RETLW  00
....................  
.................... #ifndef PCF8583_WRITE_ADDRESS 
.................... #define PCF8583_WRITE_ADDRESS 0xA0 
.................... #define PCF8583_READ_ADDRESS  0xA1 
.................... #endif 
....................  
.................... // Register addresses 
.................... #define PCF8583_CTRL_STATUS_REG    0x00 
.................... #define PCF8583_100S_REG           0x01 
.................... #define PCF8583_SECONDS_REG        0x02 
.................... #define PCF8583_MINUTES_REG        0x03 
.................... #define PCF8583_HOURS_REG          0x04 
.................... #define PCF8583_DATE_REG           0x05 
.................... #define PCF8583_MONTHS_REG         0x06 
.................... #define PCF8583_TIMER_REG          0x07 
....................  
.................... #define PCF8583_ALARM_CONTROL_REG  0x08 
.................... #define PCF8583_ALARM_100S_REG     0x09 
.................... #define PCF8583_ALARM_SECS_REG     0x0A 
.................... #define PCF8583_ALARM_MINS_REG     0x0B 
.................... #define PCF8583_ALARM_HOURS_REG    0x0C 
.................... #define PCF8583_ALARM_DATE_REG     0x0D 
.................... #define PCF8583_ALARM_MONTHS_REG   0x0E 
.................... #define PCF8583_ALARM_TIMER_REG    0x0F 
....................  
.................... // Use the first NVRAM address for the year byte. 
.................... #define PCF8583_YEAR_REG           0x10 
....................  
....................  
.................... // Commands for the Control/Status register. 
.................... #define PCF8583_START_COUNTING     0x00 
.................... #define PCF8583_STOP_COUNTING      0x80 
.................... #define PCF8583_ACTIVAR_ALARMA     0b00000100  //Palabra de activación de la alarma 
.................... #define PCF8583_DEFINIR_ALARMA     0b10010000  //Palabra para definir el comportamiento 
....................                                                //de la alarma en su registro 
....................  
.................... #define PCF8583_DESACTIVAR_INT     0b00010000 
....................  
....................  
....................  
....................  
.................... char const weekday_names[7][10] = 
.................... { 
.................... {"DOM"}, 
.................... {"LUN"}, 
.................... {"MAR"}, 
.................... {"MIE"}, 
.................... {"JUE"}, 
.................... {"VIE"}, 
.................... {"SAB"} 
.................... }; 
....................  
.................... // This structure defines the user's date and time data. 
.................... // The values are stored as unsigned integers.  The user 
.................... // should declare a structure of this type in the application 
.................... // program. Then the address of the structure should be 
.................... // passed to the PCF8583 read/write functions in this 
.................... // driver, whenever you want to talk to the chip. 
.................... typedef struct 
.................... { 
.................... int8 seconds;    // 0 to 59 
.................... int8 minutes;    // 0 to 59 
.................... int8 hours;      // 0 to 23  (24-hour time) 
.................... int8 day;        // 1 to 31 
.................... int8 month;      // 1 to 12 
.................... int8 year;       // 00 to 99 
.................... int8 weekday;    // 0 = Sunday, 1 = Monday, etc. 
.................... }date_time_t; 
....................  
....................  
.................... //---------------------------------------------- 
.................... void PCF8583_write_byte(int8 address, int8 data) 
.................... { 
.................... disable_interrupts(GLOBAL); 
*
151C:  BCF    FF2.6
151E:  BCF    FF2.7
1520:  BTFSC  FF2.7
1522:  BRA    151E
.................... i2c_start(); 
1524:  BSF    F94.4
1526:  NOP   
1528:  NOP   
152A:  BSF    F94.3
152C:  NOP   
152E:  NOP   
1530:  NOP   
1532:  BCF    F8B.4
1534:  BCF    F94.4
1536:  NOP   
1538:  NOP   
153A:  BCF    F8B.3
153C:  BCF    F94.3
.................... i2c_write(PCF8583_WRITE_ADDRESS); 
153E:  MOVLW  A0
1540:  MOVWF  x82
1542:  RCALL  14BE
.................... i2c_write(address); 
1544:  MOVFF  80,82
1548:  RCALL  14BE
.................... i2c_write(data); 
154A:  MOVFF  81,82
154E:  RCALL  14BE
.................... i2c_stop(); 
1550:  BCF    F94.4
1552:  NOP   
1554:  BSF    F94.3
1556:  BTFSS  F82.3
1558:  BRA    1556
155A:  NOP   
155C:  NOP   
155E:  NOP   
1560:  NOP   
1562:  NOP   
1564:  BSF    F94.4
1566:  NOP   
1568:  NOP   
.................... } 
156A:  RETLW  00
....................  
.................... //---------------------------------------------- 
.................... int8 PCF8583_read_byte(int8 address) 
.................... { 
.................... int8 retval; 
....................  
.................... disable_interrupts(GLOBAL); 
*
27DA:  BCF    FF2.6
27DC:  BCF    FF2.7
27DE:  BTFSC  FF2.7
27E0:  BRA    27DC
.................... i2c_start(); 
27E2:  BSF    F94.4
27E4:  NOP   
27E6:  NOP   
27E8:  BSF    F94.3
27EA:  NOP   
27EC:  NOP   
27EE:  NOP   
27F0:  BCF    F8B.4
27F2:  BCF    F94.4
27F4:  NOP   
27F6:  NOP   
27F8:  BCF    F8B.3
27FA:  BCF    F94.3
.................... i2c_write(PCF8583_WRITE_ADDRESS); 
27FC:  MOVLW  A0
27FE:  MOVWF  x82
2800:  CALL   14BE
.................... i2c_write(address); 
2804:  MOVFF  80,82
2808:  CALL   14BE
.................... i2c_start(); 
280C:  BSF    F94.4
280E:  NOP   
2810:  NOP   
2812:  BSF    F94.3
2814:  NOP   
2816:  NOP   
2818:  NOP   
281A:  BTFSS  F82.3
281C:  BRA    281A
281E:  BCF    F8B.4
2820:  BCF    F94.4
2822:  NOP   
2824:  NOP   
2826:  BCF    F8B.3
2828:  BCF    F94.3
.................... i2c_write(PCF8583_READ_ADDRESS); 
282A:  MOVLW  A1
282C:  MOVWF  x82
282E:  CALL   14BE
.................... retval = i2c_read(0); 
2832:  CLRF   00
2834:  RCALL  275C
2836:  MOVFF  01,81
.................... i2c_stop(); 
283A:  BCF    F94.4
283C:  NOP   
283E:  BSF    F94.3
2840:  BTFSS  F82.3
2842:  BRA    2840
2844:  NOP   
2846:  NOP   
2848:  NOP   
284A:  NOP   
284C:  NOP   
284E:  BSF    F94.4
2850:  NOP   
2852:  NOP   
....................  
.................... return(retval); 
2854:  MOVFF  81,01
.................... } 
2858:  GOTO   29E8 (RETURN)
....................  
....................  
.................... void PCF8583_init(void) 
.................... { 
.................... PCF8583_write_byte(PCF8583_CTRL_STATUS_REG, 
....................                               PCF8583_START_COUNTING); 
.................... } 
....................  
.................... //---------------------------------------------- 
.................... // This function converts an 8 bit binary value 
.................... // to an 8 bit BCD value. 
.................... // The input range must be from 0 to 99. 
....................  
.................... int8 bin2bcd(int8 value) 
.................... { 
.................... char retval; 
....................  
.................... retval = 0; 
*
149E:  CLRF   x80
....................  
.................... while(1) 
....................   { 
....................    // Get the tens digit by doing multiple subtraction 
....................    // of 10 from the binary value. 
....................    if(value >= 10) 
14A0:  MOVF   7F,W
14A2:  SUBLW  09
14A4:  BC    14B0
....................      { 
....................       value -= 10; 
14A6:  MOVLW  0A
14A8:  SUBWF  7F,F
....................       retval += 0x10; 
14AA:  MOVLW  10
14AC:  ADDWF  x80,F
....................      } 
....................    else // Get the ones digit by adding the remainder. 
14AE:  BRA    14B6
....................      { 
....................       retval += value; 
14B0:  MOVF   7F,W
14B2:  ADDWF  x80,F
....................       break; 
14B4:  BRA    14B8
....................      } 
....................    } 
14B6:  BRA    14A0
....................  
.................... return(retval); 
14B8:  MOVFF  80,01
.................... } 
14BC:  RETLW  00
....................  
.................... //---------------------------------------------- 
.................... // This function converts an 8 bit BCD value to 
.................... // an 8 bit binary value. 
.................... // The input range must be from 00 to 99. 
....................  
.................... char bcd2bin(char bcd_value) 
.................... { 
.................... char temp; 
....................  
.................... temp = bcd_value; 
*
27B4:  MOVFF  83,84
....................  
.................... // Shifting the upper digit right by 1 is 
.................... // the same as multiplying it by 8. 
.................... temp >>= 1; 
27B8:  BCF    FD8.0
27BA:  RRCF   x84,F
....................  
.................... // Isolate the bits for the upper digit. 
.................... temp &= 0x78; 
27BC:  MOVLW  78
27BE:  ANDWF  x84,F
....................  
.................... // Now return: (Tens * 8) + (Tens * 2) + Ones 
.................... return(temp + (temp >> 2) + (bcd_value & 0x0f)); 
27C0:  RRCF   x84,W
27C2:  MOVWF  00
27C4:  RRCF   00,F
27C6:  MOVLW  3F
27C8:  ANDWF  00,F
27CA:  MOVF   00,W
27CC:  ADDWF  x84,W
27CE:  MOVWF  x85
27D0:  MOVF   x83,W
27D2:  ANDLW  0F
27D4:  ADDWF  x85,W
27D6:  MOVWF  01
....................  
.................... } 
27D8:  RETLW  00
....................  
.................... //---------------------------------------------- 
.................... void PCF8583_set_datetime(date_time_t *dt) 
.................... { 
.................... int8 bcd_sec; 
.................... int8 bcd_min; 
.................... int8 bcd_hrs; 
.................... int8 bcd_day; 
.................... int8 bcd_mon; 
....................  
.................... // Convert the input date/time into BCD values 
.................... // that are formatted for the PCF8583 registers. 
.................... bcd_sec = bin2bcd(dt->seconds); 
*
156C:  MOVF   77,W
156E:  MOVWF  FE9
1570:  MOVFF  78,FEA
1574:  MOVFF  FEF,7E
1578:  MOVFF  7E,7F
157C:  RCALL  149E
157E:  MOVFF  01,79
.................... bcd_min = bin2bcd(dt->minutes); 
1582:  MOVLW  01
1584:  ADDWF  77,W
1586:  MOVWF  FE9
1588:  MOVLW  00
158A:  ADDWFC 78,W
158C:  MOVWF  FEA
158E:  MOVFF  FEF,7E
1592:  MOVFF  7E,7F
1596:  RCALL  149E
1598:  MOVFF  01,7A
.................... bcd_hrs = bin2bcd(dt->hours); 
159C:  MOVLW  02
159E:  ADDWF  77,W
15A0:  MOVWF  FE9
15A2:  MOVLW  00
15A4:  ADDWFC 78,W
15A6:  MOVWF  FEA
15A8:  MOVFF  FEF,7E
15AC:  MOVFF  7E,7F
15B0:  RCALL  149E
15B2:  MOVFF  01,7B
.................... bcd_day = bin2bcd(dt->day) | (dt->year << 6); 
15B6:  MOVLW  03
15B8:  ADDWF  77,W
15BA:  MOVWF  FE9
15BC:  MOVLW  00
15BE:  ADDWFC 78,W
15C0:  MOVWF  FEA
15C2:  MOVFF  FEF,7E
15C6:  MOVFF  7E,7F
15CA:  RCALL  149E
15CC:  MOVLW  05
15CE:  ADDWF  77,W
15D0:  MOVWF  FE9
15D2:  MOVLW  00
15D4:  ADDWFC 78,W
15D6:  MOVWF  FEA
15D8:  SWAPF  FEF,W
15DA:  MOVWF  00
15DC:  RLCF   00,F
15DE:  RLCF   00,F
15E0:  MOVLW  C0
15E2:  ANDWF  00,F
15E4:  MOVF   00,W
15E6:  IORWF  01,W
15E8:  MOVWF  7C
.................... bcd_mon = bin2bcd(dt->month) | (dt->weekday << 5); 
15EA:  MOVLW  04
15EC:  ADDWF  77,W
15EE:  MOVWF  FE9
15F0:  MOVLW  00
15F2:  ADDWFC 78,W
15F4:  MOVWF  FEA
15F6:  MOVFF  FEF,7E
15FA:  MOVFF  7E,7F
15FE:  RCALL  149E
1600:  MOVLW  06
1602:  ADDWF  77,W
1604:  MOVWF  FE9
1606:  MOVLW  00
1608:  ADDWFC 78,W
160A:  MOVWF  FEA
160C:  SWAPF  FEF,W
160E:  MOVWF  00
1610:  RLCF   00,F
1612:  MOVLW  E0
1614:  ANDWF  00,F
1616:  MOVF   00,W
1618:  IORWF  01,W
161A:  MOVWF  7D
....................  
.................... // Stop the RTC from counting, before we write to 
.................... // the date and time registers. 
.................... PCF8583_write_byte(PCF8583_CTRL_STATUS_REG, 
....................                               PCF8583_STOP_COUNTING); 
161C:  CLRF   x80
161E:  MOVLW  80
1620:  MOVWF  x81
1622:  RCALL  151C
....................  
.................... // Write to the date and time registers.  Disable interrupts 
.................... // so they can't disrupt the i2c operations. 
.................... disable_interrupts(GLOBAL); 
1624:  BCF    FF2.6
1626:  BCF    FF2.7
1628:  BTFSC  FF2.7
162A:  BRA    1626
.................... i2c_start(); 
162C:  BSF    F94.4
162E:  NOP   
1630:  NOP   
1632:  BSF    F94.3
1634:  NOP   
1636:  NOP   
1638:  NOP   
163A:  BCF    F8B.4
163C:  BCF    F94.4
163E:  NOP   
1640:  NOP   
1642:  BCF    F8B.3
1644:  BCF    F94.3
.................... i2c_write(PCF8583_WRITE_ADDRESS); 
1646:  MOVLW  A0
1648:  MOVWF  x82
164A:  RCALL  14BE
.................... i2c_write(PCF8583_100S_REG);   // Start at 100's reg. 
164C:  MOVLW  01
164E:  MOVWF  x82
1650:  RCALL  14BE
.................... i2c_write(0x00);               // Set 100's reg = 0 
1652:  CLRF   x82
1654:  RCALL  14BE
.................... i2c_write(bcd_sec); 
1656:  MOVFF  79,82
165A:  RCALL  14BE
.................... i2c_write(bcd_min); 
165C:  MOVFF  7A,82
1660:  RCALL  14BE
.................... i2c_write(bcd_hrs); 
1662:  MOVFF  7B,82
1666:  RCALL  14BE
.................... i2c_write(bcd_day); 
1668:  MOVFF  7C,82
166C:  RCALL  14BE
.................... i2c_write(bcd_mon); 
166E:  MOVFF  7D,82
1672:  RCALL  14BE
.................... i2c_stop(); 
1674:  BCF    F94.4
1676:  NOP   
1678:  BSF    F94.3
167A:  BTFSS  F82.3
167C:  BRA    167A
167E:  NOP   
1680:  NOP   
1682:  NOP   
1684:  NOP   
1686:  NOP   
1688:  BSF    F94.4
168A:  NOP   
168C:  NOP   
....................  
.................... // Write the year byte to the first NVRAM location. 
.................... // Leave it in binary format. 
.................... PCF8583_write_byte(PCF8583_YEAR_REG, dt->year); 
168E:  MOVLW  05
1690:  ADDWF  77,W
1692:  MOVWF  FE9
1694:  MOVLW  00
1696:  ADDWFC 78,W
1698:  MOVWF  FEA
169A:  MOVFF  FEF,7E
169E:  MOVLW  10
16A0:  MOVWF  x80
16A2:  MOVFF  7E,81
16A6:  RCALL  151C
....................  
.................... // Now allow the PCF8583 to start counting again. 
.................... PCF8583_write_byte(PCF8583_CTRL_STATUS_REG, 
....................                               PCF8583_START_COUNTING); 
16A8:  CLRF   x80
16AA:  CLRF   x81
16AC:  RCALL  151C
.................... } 
16AE:  GOTO   1D98 (RETURN)
....................  
.................... //---------------------------------------------- 
.................... // Read the Date and Time from the hardware registers 
.................... // in the PCF8583.   We don't have to disable counting 
.................... // during read operations, because according to the data 
.................... // sheet, if any of the lower registers (1 to 7) is read, 
.................... // all of them are loaded into "capture" registers. 
.................... // All further reading within that cycle is done from 
.................... // those registers. 
....................  
.................... void PCF8583_read_datetime(date_time_t *dt) 
.................... { 
.................... int8 year_bits; 
.................... int8 year; 
....................  
.................... int8 bcd_sec; 
.................... int8 bcd_min; 
.................... int8 bcd_hrs; 
.................... int8 bcd_day; 
.................... int8 bcd_mon; 
....................  
.................... // Disable interrupts so the i2c process is not disrupted. 
.................... disable_interrupts(GLOBAL); 
*
285C:  BCF    FF2.6
285E:  BCF    FF2.7
2860:  BTFSC  FF2.7
2862:  BRA    285E
....................  
.................... // Read the date/time registers inside the PCF8583. 
.................... i2c_start(); 
2864:  BSF    F94.4
2866:  NOP   
2868:  NOP   
286A:  BSF    F94.3
286C:  NOP   
286E:  NOP   
2870:  NOP   
2872:  BCF    F8B.4
2874:  BCF    F94.4
2876:  NOP   
2878:  NOP   
287A:  BCF    F8B.3
287C:  BCF    F94.3
.................... i2c_write(PCF8583_WRITE_ADDRESS); 
287E:  MOVLW  A0
2880:  MOVWF  x82
2882:  CALL   14BE
.................... i2c_write(PCF8583_SECONDS_REG);   // Start at seconds reg. 
2886:  MOVLW  02
2888:  MOVWF  x82
288A:  CALL   14BE
.................... i2c_start(); 
288E:  BSF    F94.4
2890:  NOP   
2892:  NOP   
2894:  BSF    F94.3
2896:  NOP   
2898:  NOP   
289A:  NOP   
289C:  BTFSS  F82.3
289E:  BRA    289C
28A0:  BCF    F8B.4
28A2:  BCF    F94.4
28A4:  NOP   
28A6:  NOP   
28A8:  BCF    F8B.3
28AA:  BCF    F94.3
.................... i2c_write(PCF8583_READ_ADDRESS); 
28AC:  MOVLW  A1
28AE:  MOVWF  x82
28B0:  CALL   14BE
....................  
.................... bcd_sec = i2c_read(); 
28B4:  MOVLW  01
28B6:  MOVWF  00
28B8:  RCALL  275C
28BA:  MOVFF  01,7B
.................... bcd_min = i2c_read(); 
28BE:  MOVLW  01
28C0:  MOVWF  00
28C2:  RCALL  275C
28C4:  MOVFF  01,7C
.................... bcd_hrs = i2c_read(); 
28C8:  MOVLW  01
28CA:  MOVWF  00
28CC:  RCALL  275C
28CE:  MOVFF  01,7D
.................... bcd_day = i2c_read(); 
28D2:  MOVLW  01
28D4:  MOVWF  00
28D6:  RCALL  275C
28D8:  MOVFF  01,7E
.................... bcd_mon = i2c_read(0); 
28DC:  CLRF   00
28DE:  RCALL  275C
28E0:  MOVFF  01,7F
.................... i2c_stop(); 
28E4:  BCF    F94.4
28E6:  NOP   
28E8:  BSF    F94.3
28EA:  BTFSS  F82.3
28EC:  BRA    28EA
28EE:  NOP   
28F0:  NOP   
28F2:  NOP   
28F4:  NOP   
28F6:  NOP   
28F8:  BSF    F94.4
28FA:  NOP   
28FC:  NOP   
....................  
....................  
.................... // Convert the date/time values from BCD to 
.................... // unsigned 8-bit integers.  Unpack the bits 
.................... // in the PCF8583 registers where required. 
.................... dt->seconds = bcd2bin(bcd_sec); 
28FE:  MOVFF  77,01
2902:  MOVFF  78,03
2906:  MOVFF  77,80
290A:  MOVFF  78,81
290E:  MOVFF  7B,83
2912:  RCALL  27B4
2914:  MOVFF  81,FEA
2918:  MOVFF  80,FE9
291C:  MOVFF  01,FEF
.................... dt->minutes = bcd2bin(bcd_min); 
2920:  MOVLW  01
2922:  ADDWF  77,W
2924:  MOVWF  01
2926:  MOVLW  00
2928:  ADDWFC 78,W
292A:  MOVWF  03
292C:  MOVFF  01,80
2930:  MOVWF  x81
2932:  MOVFF  7C,83
2936:  RCALL  27B4
2938:  MOVFF  81,FEA
293C:  MOVFF  80,FE9
2940:  MOVFF  01,FEF
.................... dt->hours   = bcd2bin(bcd_hrs & 0x3F); 
2944:  MOVLW  02
2946:  ADDWF  77,W
2948:  MOVWF  01
294A:  MOVLW  00
294C:  ADDWFC 78,W
294E:  MOVWF  03
2950:  MOVFF  01,80
2954:  MOVWF  x81
2956:  MOVF   7D,W
2958:  ANDLW  3F
295A:  MOVWF  x82
295C:  MOVWF  x83
295E:  RCALL  27B4
2960:  MOVFF  81,FEA
2964:  MOVFF  80,FE9
2968:  MOVFF  01,FEF
.................... dt->day     = bcd2bin(bcd_day & 0x3F); 
296C:  MOVLW  03
296E:  ADDWF  77,W
2970:  MOVWF  01
2972:  MOVLW  00
2974:  ADDWFC 78,W
2976:  MOVWF  03
2978:  MOVFF  01,80
297C:  MOVWF  x81
297E:  MOVF   7E,W
2980:  ANDLW  3F
2982:  MOVWF  x82
2984:  MOVWF  x83
2986:  RCALL  27B4
2988:  MOVFF  81,FEA
298C:  MOVFF  80,FE9
2990:  MOVFF  01,FEF
.................... dt->month   = bcd2bin(bcd_mon & 0x1F); 
2994:  MOVLW  04
2996:  ADDWF  77,W
2998:  MOVWF  01
299A:  MOVLW  00
299C:  ADDWFC 78,W
299E:  MOVWF  03
29A0:  MOVFF  01,80
29A4:  MOVWF  x81
29A6:  MOVF   7F,W
29A8:  ANDLW  1F
29AA:  MOVWF  x82
29AC:  MOVWF  x83
29AE:  RCALL  27B4
29B0:  MOVFF  81,FEA
29B4:  MOVFF  80,FE9
29B8:  MOVFF  01,FEF
.................... dt->weekday = bcd_mon >> 5; 
29BC:  MOVLW  06
29BE:  ADDWF  77,W
29C0:  MOVWF  FE9
29C2:  MOVLW  00
29C4:  ADDWFC 78,W
29C6:  MOVWF  FEA
29C8:  SWAPF  7F,W
29CA:  MOVWF  00
29CC:  RRCF   00,F
29CE:  MOVLW  07
29D0:  ANDWF  00,F
29D2:  MOVFF  00,FEF
.................... year_bits   = bcd_day >> 6; 
29D6:  SWAPF  7E,W
29D8:  MOVWF  79
29DA:  RRCF   79,F
29DC:  RRCF   79,F
29DE:  MOVLW  03
29E0:  ANDWF  79,F
....................  
.................... // Read the year byte from NVRAM. 
.................... // This is an added feature of this driver. 
.................... year = PCF8583_read_byte(PCF8583_YEAR_REG); 
29E2:  MOVLW  10
29E4:  MOVWF  x80
29E6:  BRA    27DA
29E8:  MOVFF  01,7A
....................  
.................... // Check if the two "year bits" were incremented by 
.................... // the PCF8583.  If so, increment the 8-bit year 
.................... // byte (read from NVRAM) by the same amount. 
.................... while(year_bits != (year & 3)) 
....................       year++; 
29EC:  MOVF   7A,W
29EE:  ANDLW  03
29F0:  SUBWF  79,W
29F2:  BZ    29F8
29F4:  INCF   7A,F
29F6:  BRA    29EC
....................  
.................... dt->year = year; 
29F8:  MOVLW  05
29FA:  ADDWF  77,W
29FC:  MOVWF  FE9
29FE:  MOVLW  00
2A00:  ADDWFC 78,W
2A02:  MOVWF  FEA
2A04:  MOVFF  7A,FEF
....................  
.................... // Now update the year byte in the NVRAM 
.................... // inside the PCF8583. 
.................... PCF8583_write_byte(PCF8583_YEAR_REG, year); 
2A08:  MOVLW  10
2A0A:  MOVWF  x80
2A0C:  MOVFF  7A,81
2A10:  CALL   151C
....................  
.................... } 
2A14:  RETLW  00
....................  
....................  
.................... #include "LCDeasy.c" 
.................... ////----------------------------------------------------------------------------//// 
.................... // 	Funciones para la gestion del display LCD de la EasyPIC3 
.................... //	con el compilador de CCS. 
.................... //	Es una adaptación del archivo LCD.c de CCS para las prácticas de la 
.................... //	asignatura, y por tanto no distribuible a usuarios no autorizados. 
.................... //------------------------------------------------------------------------------//// 
....................  
.................... //  lcd_init()   Inicializa el LCD: debe ser llamada antes que las otras funciones. 
.................... // 
.................... //  lcd_putc(c)  Visualiza c en la siguiente posición del display. 
.................... //               Caracteres especiales de control: 
.................... //                      \f  Borrar display 
.................... //                      \n  Saltar a la segunda linea 
.................... //                      \b  Retroceder una posición. 
.................... // 
.................... //  lcd_gotoxy(x,y) Selecciona la nueva posicion de escritura en el display. 
.................... //                  (la esquina superior izquierda es 1,1) 
.................... // 
.................... //  lcd_getc(x,y)   Devuelve el caracter de la posicion x,y del display. 
.................... //			(esta función no va en la EASYPIC3, pues R/W=0) 
.................... // 
.................... //  lcd_send_byte(rs,byte)	escribe byte en el registro de datos(con rs=1) o de 
.................... //				instrucciones (con rs=0). 
.................... //------------------------------------------------------------------------------// 
.................... // Conexion del LCD con el PIC: 
.................... //     RB0 -- 
.................... //     RB1 -- 
.................... //     RB2  rs 
.................... //     RB3  Enable 
.................... //     RB4  D4 
.................... //     RB5  D5 
.................... //     RB6  D6 
.................... //     RB7  D7 
.................... // 
.................... // Los pines D0-D3 del LCD no se usan 
.................... // El pin RB0 del PIC no se usa 
.................... // El pin RB1 no está conectado en la tarjeta, 
.................... // podría ser para r/w 
....................  
.................... // Un-comment the following define to use port B 
.................... #define use_portb_lcd TRUE 		//LINEA DES-COMENTADA---------------- 
....................  
....................  
.................... struct lcd_pin_map {                 // This structure is overlayed 
....................            int unused : 2 ;	//MODIFICADA PARA EASYPIC-------------------- 
.................... 	   //BOOLEAN rw;		//MODIFICADA PARA EASYPIC-------------------- 
.................... 	   BOOLEAN rs;           // on to an I/O port to gain 
....................            BOOLEAN ENABLE;            // access to the LCD pins. 
....................            		           	// The bits are allocated from 
....................            			          // low order up.  ENABLE will 
....................            int     data : 4;         	// be pin B3------------------------- 
....................         } lcd; 
....................  
....................  
.................... #if defined(__PCH__) 
.................... #if defined use_portb_lcd 
....................    #byte lcd = 0xF81                   // This puts the entire structure 
.................... #else 
....................    #byte lcd = 0xF83                   // This puts the entire structure 
.................... #endif 
.................... #else 
.................... #if defined use_portb_lcd 
....................    #byte lcd = 6                  // on to port B (at address 6) 
.................... #else 
....................    #byte lcd = 8                 // on to port D (at address 8) 
.................... #endif 
.................... #endif 
....................  
.................... #if defined use_portb_lcd 
....................    #define set_tris_lcd(x) set_tris_b(x) 
.................... #else 
....................    #define set_tris_lcd(x) set_tris_d(x) 
.................... #endif 
....................  
....................  
.................... #define lcd_type 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #define lcd_line_two 0x40    // LCD RAM address for the second line 
....................  
....................  
.................... BYTE const LCD_INIT_STRING[4] = {0x24 | (lcd_type << 2), 0xF, 1, 6}; 
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................  
....................  
....................                              // The following are used for setting 
....................                              // the I/O port direction register. 
....................  
.................... struct lcd_pin_map const LCD_WRITE = {3,0,0,0}; // For write mode all pins are out 
.................... struct lcd_pin_map const LCD_READ = {3,0,0,15}; // For read mode data pins are in 
....................  
....................  
....................  
.................... BYTE lcd_read_byte() { 
....................       BYTE low,high; 
....................       set_tris_lcd(LCD_READ); 
....................       //////lcd.rw = 1; 
....................       delay_cycles(1); 
....................       lcd.enable = 1; 
....................       delay_cycles(1); 
....................       high = lcd.data; 
....................       lcd.enable = 0; 
....................       delay_cycles(1); 
....................       lcd.enable = 1; 
....................       delay_us(1); 
....................       low = lcd.data; 
....................       lcd.enable = 0; 
....................       set_tris_lcd(LCD_WRITE); 
....................       return( (high<<4) | low); 
.................... } 
....................  
....................  
.................... void lcd_send_nibble( BYTE n ) { 
....................       lcd.data = n; 
*
1116:  SWAPF  x89,W
1118:  ANDLW  F0
111A:  MOVWF  00
111C:  MOVLW  0F
111E:  ANDWF  F81,W
1120:  IORWF  00,W
1122:  MOVWF  F81
....................       delay_cycles(1); 
1124:  NOP   
....................       lcd.enable = 1; 
1126:  BSF    F81.3
....................       delay_us(2); 
1128:  CLRWDT
112A:  NOP   
112C:  NOP   
112E:  NOP   
....................       lcd.enable = 0; 
1130:  BCF    F81.3
.................... } 
1132:  RETLW  00
....................  
....................  
.................... void lcd_send_byte( BYTE address, BYTE n ) { 
....................  
....................       lcd.rs = 0; 
*
1152:  BCF    F81.2
....................       delay_us(3000); 
1154:  CLRWDT
1156:  MOVLW  02
1158:  MOVWF  x88
115A:  RCALL  10E6
115C:  MOVLW  09
115E:  MOVWF  x88
1160:  MOVLW  6D
1162:  MOVWF  x89
1164:  RCALL  1134
1166:  DECFSZ x88,F
1168:  BRA    1160
.................... //      while ( bit_test(lcd_read_byte(),7) ) ; 
....................       lcd.rs = address; 
116A:  BTFSS  x86.0
116C:  BCF    F81.2
116E:  BTFSC  x86.0
1170:  BSF    F81.2
....................       delay_cycles(1); 
1172:  NOP   
....................       //////////lcd.rw = 0; 
....................       delay_cycles(1); 
1174:  NOP   
....................       lcd.enable = 0; 
1176:  BCF    F81.3
....................       lcd_send_nibble(n >> 4); 
1178:  SWAPF  x87,W
117A:  MOVWF  x88
117C:  MOVLW  0F
117E:  ANDWF  x88,F
1180:  MOVFF  88,89
1184:  RCALL  1116
....................       lcd_send_nibble(n & 0xf); 
1186:  MOVF   x87,W
1188:  ANDLW  0F
118A:  MOVWF  x88
118C:  MOVWF  x89
118E:  RCALL  1116
.................... } 
1190:  RETLW  00
....................  
....................  
.................... void lcd_init() { 
....................     BYTE i; 
....................     set_tris_lcd(LCD_WRITE); 
1192:  MOVLW  03
1194:  MOVWF  F93
....................     lcd.rs = 0; 
1196:  BCF    F81.2
....................     /////lcd.rw = 0; 
....................     lcd.enable = 0; 
1198:  BCF    F81.3
....................     delay_ms(50); 
119A:  MOVLW  32
119C:  MOVWF  x88
119E:  RCALL  10E6
....................     //for(i=1;i<=3;++i) { 
....................     //   lcd_send_nibble(3); 
....................     //  delay_ms(5); 
....................     //} 
....................     lcd_send_nibble(2); 
11A0:  MOVLW  02
11A2:  MOVWF  x89
11A4:  RCALL  1116
....................     delay_ms(5); 
11A6:  MOVLW  05
11A8:  MOVWF  x88
11AA:  RCALL  10E6
....................     for(i=0;i<=3;++i) 
11AC:  CLRF   6F
11AE:  MOVF   6F,W
11B0:  SUBLW  03
11B2:  BNC   11D8
....................        { lcd_send_byte(0,LCD_INIT_STRING[i]); 
11B4:  CLRF   03
11B6:  MOVF   6F,W
11B8:  MOVFF  FF2,70
11BC:  BCF    FF2.7
11BE:  CALL   009C
11C2:  BTFSC  70.7
11C4:  BSF    FF2.7
11C6:  MOVWF  71
11C8:  CLRF   x86
11CA:  MOVWF  x87
11CC:  RCALL  1152
....................         delay_ms(5); } 
11CE:  MOVLW  05
11D0:  MOVWF  x88
11D2:  RCALL  10E6
11D4:  INCF   6F,F
11D6:  BRA    11AE
.................... } 
11D8:  GOTO   5B14 (RETURN)
....................  
....................  
.................... void lcd_gotoxy( BYTE x, BYTE y) { 
....................    BYTE address; 
....................  
....................    if(y!=1) 
11DC:  DECFSZ x83,W
11DE:  BRA    11E2
11E0:  BRA    11E8
....................      address=lcd_line_two; 
11E2:  MOVLW  40
11E4:  MOVWF  x84
....................    else 
11E6:  BRA    11EA
....................      address=0; 
11E8:  CLRF   x84
....................    address+=x-1; 
11EA:  MOVLW  01
11EC:  SUBWF  x82,W
11EE:  ADDWF  x84,F
....................    lcd_send_byte(0,0x80|address); 
11F0:  MOVF   x84,W
11F2:  IORLW  80
11F4:  MOVWF  x85
11F6:  CLRF   x86
11F8:  MOVWF  x87
11FA:  RCALL  1152
.................... } 
11FC:  RETLW  00
....................  
.................... void lcd_putc( char c) { 
....................    switch (c) { 
11FE:  MOVF   x81,W
1200:  XORLW  0C
1202:  BZ    120E
1204:  XORLW  06
1206:  BZ    121E
1208:  XORLW  02
120A:  BZ    122A
120C:  BRA    1234
....................      case '\f'   : lcd_send_byte(0,1); 
120E:  CLRF   x86
1210:  MOVLW  01
1212:  MOVWF  x87
1214:  RCALL  1152
....................                    delay_ms(2); 
1216:  MOVLW  02
1218:  MOVWF  x88
121A:  RCALL  10E6
....................                                            break; 
121C:  BRA    1240
....................      case '\n'   : lcd_gotoxy(1,2);        break; 
121E:  MOVLW  01
1220:  MOVWF  x82
1222:  MOVLW  02
1224:  MOVWF  x83
1226:  RCALL  11DC
1228:  BRA    1240
....................      case '\b'   : lcd_send_byte(0,0x10);  break; 
122A:  CLRF   x86
122C:  MOVLW  10
122E:  MOVWF  x87
1230:  RCALL  1152
1232:  BRA    1240
....................      default     : lcd_send_byte(1,c);     break; 
1234:  MOVLW  01
1236:  MOVWF  x86
1238:  MOVFF  81,87
123C:  RCALL  1152
123E:  BRA    1240
....................    } 
.................... } 
1240:  RETLW  00
....................  
.................... char lcd_getc( BYTE x, BYTE y) { 
....................    char value; 
....................  
....................     lcd_gotoxy(x,y); 
....................     while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................     lcd.rs=1; 
....................     value = lcd_read_byte(); 
....................     lcd.rs=0; 
....................     return(value); 
.................... } 
....................  
.................... #include "1wire.c" 
.................... /***********************1Wire Class***********************/ 
.................... /*Funciones básicas para comunicación con un solo sensor 1wire */ 
.................... /*********************************************************/ 
.................... /*-------1-wire definitions-------*/ 
....................  
.................... #define ONE_WIRE_PIN PIN_A5 //modificar de acuerdo con la tarjeta 
....................  
....................  
.................... /************onewire_reset*************************************************/ 
.................... void onewire_reset()  // OK if just using a single permanently connected device 
.................... { 
....................  output_low(ONE_WIRE_PIN); 
*
16EC:  BCF    F92.5
16EE:  BCF    F89.5
....................  delay_us( 500 ); // pull 1-wire low for reset pulse 
16F0:  CLRWDT
16F2:  MOVLW  02
16F4:  MOVWF  x87
16F6:  MOVLW  F7
16F8:  MOVWF  x89
16FA:  RCALL  1134
16FC:  DECFSZ x87,F
16FE:  BRA    16F6
....................  output_float(ONE_WIRE_PIN); // float 1-wire high 
1700:  BSF    F92.5
....................  delay_us( 500 ); // wait-out remaining initialisation window. 
1702:  CLRWDT
1704:  MOVLW  02
1706:  MOVWF  x87
1708:  MOVLW  F7
170A:  MOVWF  x89
170C:  RCALL  1134
170E:  DECFSZ x87,F
1710:  BRA    1708
....................  output_float(ONE_WIRE_PIN); 
1712:  BSF    F92.5
.................... } 
1714:  RETLW  00
....................  
.................... /*********************** onewire_write() ********************************/ 
.................... /*Esta función escribe un byte en el sensor.*/ 
.................... /* */ 
.................... /*Parametros: byte - el byte a escribir en el 1wire */ 
....................  
.................... void onewire_write(int data) 
.................... { 
....................  int count; 
....................  
....................  for (count=0; count<8; ++count) 
1716:  CLRF   x89
1718:  MOVF   x89,W
171A:  SUBLW  07
171C:  BNC   1752
....................  { 
....................   output_low(ONE_WIRE_PIN); 
171E:  BCF    F92.5
1720:  BCF    F89.5
....................   delay_us( 2 ); // pull 1-wire low to initiate write time-slot. 
1722:  CLRWDT
1724:  NOP   
1726:  NOP   
1728:  NOP   
....................   output_bit(ONE_WIRE_PIN, shift_right(&data,1,0)); // set output bit on 1-wire 
172A:  BCF    FD8.0
172C:  RRCF   x88,F
172E:  BC    1734
1730:  BCF    F89.5
1732:  BRA    1736
1734:  BSF    F89.5
1736:  BCF    F92.5
....................   delay_us( 60 ); // wait until end of write slot. 
1738:  CLRWDT
173A:  MOVLW  27
173C:  MOVWF  00
173E:  DECFSZ 00,F
1740:  BRA    173E
1742:  NOP   
....................   output_float(ONE_WIRE_PIN); // set 1-wire high again, 
1744:  BSF    F92.5
....................   delay_us( 2 ); // for more than 1us minimum. 
1746:  CLRWDT
1748:  NOP   
174A:  NOP   
174C:  NOP   
....................  } 
174E:  INCF   x89,F
1750:  BRA    1718
.................... } 
1752:  RETLW  00
....................  
.................... /*********************** read1wire() *********************************/ 
.................... /*Esta función lee un dato de 8 bits del sensor.*/ 
.................... /*Devuelve: dato de 8-bit (1-byte)*/ 
....................  
.................... int onewire_read() 
.................... { 
....................  int count, data; 
....................  
....................  for (count=0; count<8; ++count) 
*
1EF6:  CLRF   x80
1EF8:  MOVF   x80,W
1EFA:  SUBLW  07
1EFC:  BNC   1F38
....................  { 
....................   output_low(ONE_WIRE_PIN); 
1EFE:  BCF    F92.5
1F00:  BCF    F89.5
....................   delay_us( 2 ); // pull 1-wire low to initiate read time-slot. 
1F02:  CLRWDT
1F04:  NOP   
1F06:  NOP   
1F08:  NOP   
....................   output_float(ONE_WIRE_PIN); // now let 1-wire float high, 
1F0A:  BSF    F92.5
....................   delay_us( 8 ); // let device state stabilise, 
1F0C:  CLRWDT
1F0E:  MOVLW  04
1F10:  MOVWF  00
1F12:  DECFSZ 00,F
1F14:  BRA    1F12
1F16:  NOP   
1F18:  NOP   
....................   shift_right(&data,1,input(ONE_WIRE_PIN)); // and load result. 
1F1A:  BSF    F92.5
1F1C:  BTFSC  F80.5
1F1E:  BRA    1F24
1F20:  BCF    FD8.0
1F22:  BRA    1F26
1F24:  BSF    FD8.0
1F26:  RRCF   x81,F
....................   delay_us( 120 ); // wait until end of read slot. 
1F28:  CLRWDT
1F2A:  MOVLW  4F
1F2C:  MOVWF  00
1F2E:  DECFSZ 00,F
1F30:  BRA    1F2E
1F32:  NOP   
....................  } 
1F34:  INCF   x80,F
1F36:  BRA    1EF8
....................  
....................  return( data ); 
1F38:  MOVFF  81,01
.................... } 
1F3C:  RETLW  00
....................  
.................... /////////////////////////////////////////////////////////////////// 
....................  
....................  
....................  
.................... #include "ds1820.c" 
....................  
.................... /***************************************************/ 
.................... /*Driver básico del termómetro/termostato ds1820.c */ 
.................... // 
.................... //Realiza una secuencia completa de incialización, conversión 
.................... //de temperatura, y lectura del (único) sensor de temperatura 
.................... //con alimentación externa (no parásita). 
.................... // 
.................... /***************************************************/ 
....................  
.................... float ds1820_read() 
.................... { 
....................  int8 busy=0, temp1, temp2; 
*
20EA:  CLRF   77
....................  signed int16 temp3; 
....................  float result; 
....................  
....................  onewire_reset();     // Cada acceso al sensor debe iniciarse con reset 
20EC:  CALL   16EC
....................  onewire_write(0xCC); //Instrucción SKIP ROM (selecciona todos los dispositivos del 1wire) 
20F0:  MOVLW  CC
20F2:  MOVWF  x88
20F4:  CALL   1716
....................  onewire_write(0x44); //Orden de inicio de conversión de temperatura 
20F8:  MOVLW  44
20FA:  MOVWF  x88
20FC:  CALL   1716
....................  
....................  while (busy == 0) 	//el sensor mantiene la linea a 0 mientras realiza la conversión 
....................   busy = onewire_read(); //y la deja a 1 al completarla 
2100:  MOVF   77,F
2102:  BNZ   210C
2104:  RCALL  1EF6
2106:  MOVFF  01,77
210A:  BRA    2100
....................  
....................  onewire_reset(); 
210C:  CALL   16EC
....................  onewire_write(0xCC); 
2110:  MOVLW  CC
2112:  MOVWF  x88
2114:  CALL   1716
....................  onewire_write(0xBE); //Envío de la orden READ SCRATCHPAD (lectura de la memoria temporal) 
2118:  MOVLW  BE
211A:  MOVWF  x88
211C:  CALL   1716
....................  temp1 = onewire_read(); //lectura del LSB de la temperatura 
2120:  RCALL  1EF6
2122:  MOVFF  01,78
....................  temp2 = onewire_read(); //lectura del MSB de la temperatura 
2126:  RCALL  1EF6
2128:  MOVFF  01,79
....................  
....................  temp3 = make16(temp2, temp1); // 
212C:  MOVFF  79,7B
2130:  MOVFF  78,7A
....................  result = (float) temp3 / 2.0;   //Calculation for DS18S20 with 0.5 deg C resolution 
2134:  MOVFF  7B,81
2138:  MOVFF  7A,80
213C:  BRA    1F3E
213E:  MOVFF  00,80
2142:  MOVFF  01,81
2146:  MOVFF  02,82
214A:  MOVFF  03,83
214E:  MOVFF  03,28B
2152:  MOVFF  02,28A
2156:  MOVFF  01,289
215A:  MOVFF  00,288
215E:  MOVLB  2
2160:  CLRF   x8F
2162:  CLRF   x8E
2164:  CLRF   x8D
2166:  MOVLW  80
2168:  MOVWF  x8C
216A:  MOVLB  0
216C:  RCALL  1F8A
216E:  MOVFF  03,7F
2172:  MOVFF  02,7E
2176:  MOVFF  01,7D
217A:  MOVFF  00,7C
.................... // result = (float) temp3 / 16.0;  //Calculation for DS18B20 with 0.1 deg C resolution 
....................  
....................  delay_ms(200); 
217E:  MOVLW  C8
2180:  MOVWF  x88
2182:  CALL   10E6
....................  return(result); 
2186:  MOVFF  7C,00
218A:  MOVFF  7D,01
218E:  MOVFF  7E,02
2192:  MOVFF  7F,03
.................... } 
2196:  RETLW  00
....................  
.................... //Establece la temperatura máxima y mínima para el termostato 
.................... void ds1820_establecer_TH_TL(float th, float tl){ 
....................    float th2, tl2; 
....................    onewire_reset(); 
*
184C:  RCALL  16EC
....................    onewire_write(0xCC); //Accedemos a todos los dispositivos 
184E:  MOVLW  CC
1850:  MOVWF  x88
1852:  RCALL  1716
....................    onewire_write(0x4E); //Envío de la orden Write Scratchpad (escritura en la memoria principal) 
1854:  MOVLW  4E
1856:  MOVWF  x88
1858:  RCALL  1716
....................    th2=2*th; 
185A:  MOVLB  2
185C:  CLRF   xA1
185E:  CLRF   xA0
1860:  CLRF   x9F
1862:  MOVLW  80
1864:  MOVWF  x9E
1866:  MOVFF  7A,2A5
186A:  MOVFF  79,2A4
186E:  MOVFF  78,2A3
1872:  MOVFF  77,2A2
1876:  MOVLB  0
1878:  RCALL  1754
187A:  MOVFF  03,82
187E:  MOVFF  02,81
1882:  MOVFF  01,80
1886:  MOVFF  00,7F
....................    tl2=2*tl; 
188A:  MOVLB  2
188C:  CLRF   xA1
188E:  CLRF   xA0
1890:  CLRF   x9F
1892:  MOVLW  80
1894:  MOVWF  x9E
1896:  MOVFF  7E,2A5
189A:  MOVFF  7D,2A4
189E:  MOVFF  7C,2A3
18A2:  MOVFF  7B,2A2
18A6:  MOVLB  0
18A8:  RCALL  1754
18AA:  MOVFF  03,86
18AE:  MOVFF  02,85
18B2:  MOVFF  01,84
18B6:  MOVFF  00,83
....................    onewire_write((int8)th2); 
18BA:  MOVFF  82,8A
18BE:  MOVFF  81,89
18C2:  MOVFF  80,88
18C6:  MOVFF  7F,87
18CA:  RCALL  16B2
18CC:  MOVFF  01,87
18D0:  MOVFF  01,88
18D4:  RCALL  1716
....................    onewire_write((int8)tl2); 
18D6:  MOVFF  86,8A
18DA:  MOVFF  85,89
18DE:  MOVFF  84,88
18E2:  MOVFF  83,87
18E6:  RCALL  16B2
18E8:  MOVFF  01,87
18EC:  MOVFF  01,88
18F0:  RCALL  1716
....................  
....................    //Copiamos los valores en la ROM 
....................    onewire_reset(); 
18F2:  RCALL  16EC
....................    onewire_write(0xCC); 
18F4:  MOVLW  CC
18F6:  MOVWF  x88
18F8:  RCALL  1716
....................    onewire_write(0x48); 
18FA:  MOVLW  48
18FC:  MOVWF  x88
18FE:  RCALL  1716
....................  
....................    //Dejamos un poco de tiempo para que se escriba en la EEPROM 
....................    //El tiempo ha sido calculado a partir de la simulación en Proteus 
....................    delay_us(10600); 
1900:  CLRWDT
1902:  MOVLW  0A
1904:  MOVWF  x88
1906:  CALL   10E6
190A:  MOVLW  0D
190C:  MOVWF  x87
190E:  MOVLW  2C
1910:  MOVWF  x89
1912:  RCALL  1134
1914:  DECFSZ x87,F
1916:  BRA    190E
....................  
.................... } 
1918:  RETLW  00
....................  
.................... //Intenta buscar la alarma del único sensor conectado por si ha saltado 
.................... //el termostato. Si lo ha hecho, devuelve TRUE, y en caso contrario, FALSE. 
.................... int1 ds1820_termostato(){ 
....................    int busy=0; 
*
2198:  CLRF   6F
....................    int1 bit1, bit2; 
....................  
....................    //Primero forzamos la conversión de la temperatura 
....................    onewire_reset(); 
219A:  CALL   16EC
....................    onewire_write(0xCC); 
219E:  MOVLW  CC
21A0:  MOVWF  x88
21A2:  CALL   1716
....................    onewire_write(0x44); 
21A6:  MOVLW  44
21A8:  MOVWF  x88
21AA:  CALL   1716
....................  
....................    while(busy == 0) 
....................       busy = onewire_read(); 
21AE:  MOVF   6F,F
21B0:  BNZ   21BA
21B2:  RCALL  1EF6
21B4:  MOVFF  01,6F
21B8:  BRA    21AE
....................  
....................    onewire_reset(); 
21BA:  CALL   16EC
....................    onewire_write(0xEC); //Buscamos la alarma de algún dispositivo (función ALARM SEARCH) 
21BE:  MOVLW  EC
21C0:  MOVWF  x88
21C2:  CALL   1716
....................  
....................    //Leemos dos bits consecutivos. Si el dispositivo tiene el flag de alarma activado, escribirá 
....................    //en la línea el bit más bajo de su dirección ROM y, después, su complemento. Si no, no hará 
....................    //nada. Por eso, si ambos bits leídos son diferentes, la alarma estará activada, mientras que 
....................    //si son iguales, no lo estarán. No es necesario continuar leyendo toda la dirección del dispositivo. 
....................    output_low(ONE_WIRE_PIN); 
21C6:  BCF    F92.5
21C8:  BCF    F89.5
....................    delay_us( 2 ); 
21CA:  CLRWDT
21CC:  NOP   
21CE:  NOP   
21D0:  NOP   
....................    output_float(ONE_WIRE_PIN); 
21D2:  BSF    F92.5
....................    delay_us( 8 ); 
21D4:  CLRWDT
21D6:  MOVLW  04
21D8:  MOVWF  00
21DA:  DECFSZ 00,F
21DC:  BRA    21DA
21DE:  NOP   
21E0:  NOP   
....................    bit1 = input(ONE_WIRE_PIN); //Leemos el bit menos significativo de la dirección ROM 
21E2:  BSF    F92.5
21E4:  BCF    70.0
21E6:  BTFSC  F80.5
21E8:  BSF    70.0
....................    delay_us( 120 ); 
21EA:  CLRWDT
21EC:  MOVLW  4F
21EE:  MOVWF  00
21F0:  DECFSZ 00,F
21F2:  BRA    21F0
21F4:  NOP   
....................  
....................    output_low(ONE_WIRE_PIN); 
21F6:  BCF    F92.5
21F8:  BCF    F89.5
....................    delay_us( 2 ); 
21FA:  CLRWDT
21FC:  NOP   
21FE:  NOP   
2200:  NOP   
....................    output_float(ONE_WIRE_PIN); 
2202:  BSF    F92.5
....................    delay_us( 8 ); 
2204:  CLRWDT
2206:  MOVLW  04
2208:  MOVWF  00
220A:  DECFSZ 00,F
220C:  BRA    220A
220E:  NOP   
2210:  NOP   
....................    bit2 = input(ONE_WIRE_PIN); //Leemos su complemento (si la alarma está activada) 
2212:  BSF    F92.5
2214:  BCF    70.1
2216:  BTFSC  F80.5
2218:  BSF    70.1
....................    delay_us( 120 ); 
221A:  CLRWDT
221C:  MOVLW  4F
221E:  MOVWF  00
2220:  DECFSZ 00,F
2222:  BRA    2220
2224:  NOP   
....................  
....................    if(bit1 != bit2) 
2226:  CLRF   00
2228:  BTFSC  70.1
222A:  BSF    00.0
222C:  MOVF   70,W
222E:  XORWF  00,W
2230:  ANDLW  01
2232:  BZ    223C
....................       return TRUE; 
2234:  MOVLW  01
2236:  MOVWF  01
2238:  BRA    2242
....................    else 
223A:  BRA    2242
....................       return FALSE; 
223C:  MOVLW  00
223E:  MOVWF  01
2240:  BRA    2242
....................  
....................  
.................... } 
2242:  RETLW  00
....................  
.................... ////////////////////////////////////////////////////////////////////////////////////// 
....................  
....................  
....................  
....................  
.................... #use fast_io(A) 
.................... #use fast_io(B) 
.................... #use fast_io(C) 
.................... #use fast_io(D) 
....................  
.................... int1 temperatura_caldera_superada; //Control de la histéresis en la caldera 
.................... int1 temp_habitacion_superada;  //Control de la histéresis del ambiente 
.................... int1 encendido_por_alarma; //Indica si la última vez que se encendió fue en respuesta o no a una alarma 
.................... int1 toca_encender; //Indica si la próxima alarma es de encendido o de apagado 
.................... float termostato; //Temperatura límite de la vivienda 
.................... float termostato_provisional; //Valor de termostato provisional para cuando saltan las alarmas 
.................... float temperatura; //Temperatura de la vivienda 
.................... float histeresis_vivienda = 0.5; //Intervalo de histéresis de la vivienda 
....................  
.................... //Estructura de un intervalo de programación 
.................... typedef struct 
.................... { 
....................    unsigned int horas_inicio;    //Hora a la que se inicia el encendido 
....................    unsigned int minutos_inicio;  // 
....................    unsigned int horas_fin;       //Hora a la que se apaga el sistema 
....................    unsigned int minutos_fin;     // 
....................    unsigned int termostato;      //Termostato vigente en ese intervalo 
.................... }programacion; 
....................  
.................... //Vector que incluye todas las programaciones horarias 
.................... //La información se distribuye en grupos de 5: hora_inicio, minutos_inicio, 
.................... //hora_fin, minutos_fin y termostato. 
.................... programacion programaciones[3]; 
....................  
.................... //Programación en curso en este momento 
.................... programacion prg; 
.................... int num_intervalos; //Número de intervalos de programación con los que contamos 
.................... int posicion_alarmas; //Variable que apunta a la posición de la próxima alarma 
....................  
.................... //Estructura para leer el tiempo del reloj 
.................... date_time_t tiempo; 
....................  
.................... //Registro de la hora en la que se enciende el sistema 
.................... int hora_encendido; 
.................... int minutos_encendido; 
....................  
.................... //Registro de la hora en la que se enciende la caldera 
.................... //Se supone que el encendido de la caldera se realiza en intervalos cortos, 
.................... //que se alcanza la temperatura deseada relativamente rápido. 
.................... int hora_caldera; 
.................... int minutos_caldera; 
.................... int segundos_caldera; 
.................... //Tiempo total de encendido de la caldera en cada intervalo de encendido del sistema 
.................... long t_total_caldera; 
....................  
.................... //Variables para el registro en memoria 
.................... unsigned int num_registros;  //Número de registros de fechas almacenados 
.................... int anno_actual;             //Año en el que estamos (de 0 a 99) 
.................... int anno_actual_0_to_3;      //Año en el que estamos (de 0 a 3, a pesar de 
....................                               //que la variable se llame 1_to_3 por razones "históricas") 
....................  
.................... //Flag para activar las interrupciones de interfaz con el teclado y alarma 
.................... int1 lcd_int; 
.................... int1 alarma_int; 
....................  
.................... //Variables para gestionar las alarmas por software 
.................... int hora_alarma; 
.................... int minutos_alarma; 
.................... int1 alarma; 
....................  
....................  
.................... //Listado de métodos utilizados ordenados por orden alfabético 
.................... //************************************************************ 
.................... //Mostramos aquí una breve explicación de cada uno. El interior de los métodos está 
.................... //descrito después del método main. 
....................  
.................... //apagar_caldera() -> Apaga la caldera, almacenando el tiempo que ha estado encendida. 
.................... void apagar_caldera(); 
.................... //apagar_sistema() -> Realiza todas las operaciones necesarias para el apagado 
.................... //del sistema, como el almacenamiento de los datos necesarios en memoria. 
.................... void apagar_sistema(); 
.................... //buscar_numero(int led_unidades, int min, int max, int valor_inicial) -> Busca un número introducido con los 
.................... //botones + y - y se va mostrando el valor en la posición led_unidades del display (siempre en la fila 2). El 
.................... //rango de variación del valor está limitado por el intervalo [min,max]. Valor_inicial es el valor con el que 
.................... //se muestra la variable al principio. Si se pulsa SI, se aprueba el valor que aparece, y si aparece NO, se 
.................... //devuelve el código correspondiente. 
.................... int buscar_numero(int led_unidades, int min, int max, int valor_inicial); 
.................... //buscar_numero_rs232() -> Registra la introducción de un número de dos cifras mediante la interfaz RS232 y 
.................... //lo devuelve. Además, si se pulsa el "backspace" durante el proceso, devuelve el código correspondiente a NO 
.................... int buscar_numero_rs232(); 
.................... //comp_caldera() -> Devuelve TRUE si debemos apagar la caldera. Esta función tiene en cuenta 
.................... //cierta histéresis para evitar ciclos continuos de apagado-encendido. 
.................... int comp_caldera(); 
.................... //comprobar_hora(int hora1, int min1, int hora2, int min2) -> Devuelve TRUE 
.................... //si hora1:min1 corresponde a un tiempo menor o igual que hora2:min2. 
.................... int comprobar_hora(int hora1,int min1, int hora2, int min2); 
.................... //comprobar_temperatura() -> Devuelve TRUE si la temperatura de la habitación es menor 
.................... //que la indicada en el termostato, y FALSE en caso contrario. 
.................... int comprobar_temperatura(); 
.................... //diferencia_tiempo(int hora1, int min1, int hora2, int min2) -> Calcula la 
.................... //diferencia de tiempo en minutos entre hora1:min1 y hora2:min2. 
.................... //Si hora1:min1 es mayor que hora2:min2, los considera en días consecutivos. 
.................... long diferencia_tiempo(int hora1,int min1, int hora2, int min2); 
.................... //diferencia_tiempo_sec(int hora1, int min1, int sec1, int hora2, int min2, int sec2) -> 
.................... //Calcula la diferencia de tiempo en segundos entre hora1:min1:sec1 y hora2:min2:sec2 
.................... //Si hora1:min1:sec1 es mayor que hora2:min2:sec2, los considera en días consecutivos 
.................... long diferencia_tiempo_sec(int hora1,int min1, int sec1, int hora2, int min2, int sec2); 
.................... //encender_caldera() -> Enciende la caldera, almacenando el tiempo de encendido en 
.................... //las variables correspondientes. 
.................... void encender_caldera(); 
.................... //encender_sistema() -> Realiza todas las operaciones necesarias para el encendido 
.................... //del sistema, como registro del tiempo de inicio. 
.................... void encender_sistema(); 
.................... //grabar_programaciones() -> Graba los datos de las programaciones en la memoria EEPROM. 
.................... void grabar_programaciones(); 
.................... //inicializacion() -> Gestiona la inicialización del sistema por parte del técnico. 
.................... void inicializacion(); 
.................... //leer_programaciones() -> Recupera de la memoria los datos de las programaciones. 
.................... void leer_programaciones(); 
.................... //mostrar_temperatura() -> Muestra en la pantalla LCD la temperatura actual y la hora. 
.................... void mostrar_temperatura(); 
.................... //ordenar_programaciones -> Ordena las programaciones por orden creciente de hora. 
.................... void ordenar_programaciones(); 
.................... //programar_proxima_alarma() -> Programa la próxima alarma que tendrá lugar. 
.................... //Siempre se tratará de una alarma para el encendido. 
.................... void programar_proxima_alarma(); 
.................... //representar_registros() -> Representa la información de los registros en el puerto RS232 
.................... //Nunca guardamos la información de los registros para no saturar la memoria y 
.................... //aprovechamos la representación de los datos para calcular medias y demás y así 
.................... //no tener que realizar un segundo barrido de lectura en memoria. 
.................... void representar_registros(); 
.................... //seleccionar_alarma() -> Selecciona la alarma más cercana a la hora en la que nos encontramos, 
.................... //en el caso de que las hubiese. 
.................... void seleccionar_alarma(); 
....................  
.................... //-------------------------------------------------------------------------------- 
....................  
.................... //Gestión de interrupciones de activación de la interfaz de usuario 
.................... #INT_EXT1 
.................... activacion_led(){ 
....................    clear_interrupt(INT_EXT1); 
*
10DC:  BCF    FF0.0
....................    //Se activa el flag correspondiente 
....................    lcd_int = TRUE; 
10DE:  BSF    1E.4
.................... } 
....................  
.................... //*********************************************************** 
.................... //Método main 
.................... //*********************************************************** 
10E0:  BCF    FF0.0
10E2:  GOTO   0058
.................... main() 
.................... { 
*
5AB8:  CLRF   FF8
5ABA:  BCF    FD0.7
5ABC:  BSF    0D.7
5ABE:  CLRF   FEA
5AC0:  CLRF   FE9
5AC2:  BCF    FB8.3
5AC4:  MOVLW  19
5AC6:  MOVWF  FAF
5AC8:  MOVLW  22
5ACA:  MOVWF  FAC
5ACC:  MOVLW  90
5ACE:  MOVWF  FAB
5AD0:  MOVF   FC1,W
5AD2:  ANDLW  C0
5AD4:  IORLW  0F
5AD6:  MOVWF  FC1
5AD8:  MOVLW  07
5ADA:  MOVWF  FB4
5ADC:  CLRF   18
5ADE:  CLRF   19
5AE0:  MOVLW  01
5AE2:  MOVWF  1A
5AE4:  CLRF   1B
5AE6:  CLRF   1C
5AE8:  CLRF   1D
5AEA:  MOVLW  7E
5AEC:  MOVWF  2B
5AEE:  CLRF   2C
5AF0:  CLRF   2D
5AF2:  CLRF   2E
....................    //Variable auxiliar 
....................    int aux; 
....................  
....................    //Determinamos que las patilla de interrupción se activen al pasar de alta a baja 
....................    ext_int_edge(1, H_TO_L); 
5AF4:  BCF    FF1.5
....................  
....................    clear_interrupt(INT_EXT1); 
5AF6:  BCF    FF0.0
....................  
....................    //Inicializamos salidas 
....................    //Comenzamos con todo apagado (sistema, motor y caldera) 
....................    sistema_encendido = FALSE; 
5AF8:  BCF    F83.2
....................    motor = FALSE; 
5AFA:  BCF    F83.1
....................    caldera_encendida = FALSE; 
5AFC:  BCF    F83.0
....................    encendido_por_alarma = FALSE; 
5AFE:  BCF    1E.2
....................    t_total_caldera = 0; //El tiempo total de encendido de la caldera también lo ponemos a 0 
5B00:  CLRF   52
5B02:  CLRF   51
....................  
....................    //Establecemos el estado de los puertos como entradas o salidas 
....................    set_tris_b(0x03); 
5B04:  MOVLW  03
5B06:  MOVWF  F93
....................    set_tris_d(0x00); 
5B08:  MOVLW  00
5B0A:  MOVWF  F95
....................    set_tris_c(0xE7); 
5B0C:  MOVLW  E7
5B0E:  MOVWF  F94
....................  
....................    //Inicializamos la pantalla lcd 
....................    lcd_init(); 
5B10:  GOTO   1192
....................  
....................    //Mostramos un mensaje de inicio 
....................    lcd_send_byte(LCD_ORDEN, LCD_CLEAR); 
5B14:  CLRF   x86
5B16:  MOVLW  01
5B18:  MOVWF  x87
5B1A:  CALL   1152
....................    lcd_send_byte(LCD_ORDEN, LCD_NO_CURSOR); 
5B1E:  CLRF   x86
5B20:  MOVLW  0C
5B22:  MOVWF  x87
5B24:  CALL   1152
....................    printf(lcd_putc, "Inicializando..."); 
5B28:  CLRF   6F
5B2A:  MOVF   6F,W
5B2C:  CALL   00BA
5B30:  IORLW  00
5B32:  BZ    5B3E
5B34:  INCF   6F,F
5B36:  MOVWF  x81
5B38:  CALL   11FE
5B3C:  BRA    5B2A
....................  
....................    //----------------------------------------------------------- 
....................    //Rutina de inicialización del sistema por parte del técnico 
....................    //----------------------------------------------------------- 
....................    inicializacion(); 
5B3E:  GOTO   191A
....................  
....................    //Propiedades de conversión analógico digital 
....................    //Caracterizamos los puertos A0 a A3 como entradas analógicas 
....................    setup_adc_ports(AN0_TO_AN3); 
5B42:  MOVF   FC1,W
5B44:  ANDLW  C0
5B46:  IORLW  0B
5B48:  MOVWF  FC1
....................    //Definimos el reloj de conversión 
....................    setup_adc(adc_clock_div_32); 
5B4A:  MOVF   FC0,W
5B4C:  ANDLW  C0
5B4E:  IORLW  02
5B50:  MOVWF  FC0
5B52:  BCF    FC0.7
5B54:  BSF    FC2.0
....................  
....................    /* 
....................    //El siguiente fragmento de código se descomentaría en el caso de que quiera obviarse la fase 
....................    //de inicialización del sistema y quieran leerse datos conservados en memoria, si, por ejemplo, 
....................    //ya tenemos el reloj configurado. En ese caso, debemos borrar la sentencia de "inicializacion" de arriba. 
....................    //******************************************************************************** 
....................  
....................    //Recuperación de datos de la memoria 
....................    //Recuperamos a partir de la dirección eeprom_termostato los datos en 
....................    //el siguiente orden: termostato, número de intervalos de alarma, número de registros 
....................    //de encendido de la caldera, año actual en valores de 0 a 99 y año actual en valores de 0 a 3. 
....................    termostato = read_eeprom(eeprom_termostato); 
....................    num_intervalos = read_eeprom(eeprom_num_intervalos); 
....................    num_registros = read_eeprom(eeprom_num_registros); 
....................    anno_actual = read_eeprom(eeprom_anno_actual); 
....................    anno_actual_0_to_3 = read_eeprom(eeprom_anno_0_to_3); 
....................  
....................  
....................    //Lee las programaciones de alarmas guardadas en memoria 
....................    leer_programaciones(); 
....................  
....................  
....................    //Comprobamos si hay alarmas programadas en memoria 
....................    if(num_intervalos!=0) 
....................    { 
....................       //Si las hay, seleccionamos la siguiente y programamos su activación 
....................       seleccionar_alarma(); 
....................       programar_proxima_alarma(); 
....................       toca_encender = TRUE; 
....................    } 
....................  
....................    //Iniciamos la cuenta del reloj 
....................    PCF8583_write_byte(PCF8583_CTRL_STATUS_REG, 
....................                            PCF8583_START_COUNTING); 
....................  
....................    */ 
....................  
....................  
....................    //Leemos la temperatura 
....................    temperatura = ds1820_read(); 
5B56:  CALL   20EA
5B5A:  MOVFF  03,2A
5B5E:  MOVFF  02,29
5B62:  MOVFF  01,28
5B66:  MOVFF  00,27
....................    if(!ds1820_termostato()) 
5B6A:  CALL   2198
5B6E:  MOVF   01,F
5B70:  BNZ   5BCC
....................    { 
....................       //Si supera el valor del termostato, lo indicamos con el flag 
....................       temp_habitacion_superada = TRUE; 
5B72:  BSF    1E.1
....................       //Tendremos que establecer un nuevo termostato teniendo en cuenta la histéresis de la temperatura 
....................       termostato = termostato - histeresis_vivienda; 
5B74:  BSF    FD8.1
5B76:  MOVFF  22,285
5B7A:  MOVFF  21,284
5B7E:  MOVFF  20,283
5B82:  MOVFF  1F,282
5B86:  MOVFF  2E,289
5B8A:  MOVFF  2D,288
5B8E:  MOVFF  2C,287
5B92:  MOVFF  2B,286
5B96:  CALL   2244
5B9A:  MOVFF  03,22
5B9E:  MOVFF  02,21
5BA2:  MOVFF  01,20
5BA6:  MOVFF  00,1F
....................       //Guardamos el dato en el sensor 
....................       //La TH la configuramos con un valor muy alto (127.5ºC) 
....................       ds1820_establecer_TH_TL(127.5, termostato); 
5BAA:  CLRF   7A
5BAC:  CLRF   79
5BAE:  MOVLW  7F
5BB0:  MOVWF  78
5BB2:  MOVLW  85
5BB4:  MOVWF  77
5BB6:  MOVFF  22,7E
5BBA:  MOVFF  21,7D
5BBE:  MOVFF  20,7C
5BC2:  MOVFF  1F,7B
5BC6:  CALL   184C
....................    }else 
5BCA:  BRA    5BCE
....................       //Si no se supera, se indica también 
....................       temp_habitacion_superada = FALSE; 
5BCC:  BCF    1E.1
....................  
....................  
....................    //Asumimos que en principio la temperatura de la caldera no ha sido superada 
....................    temperatura_caldera_superada = FALSE; 
5BCE:  BCF    1E.0
....................    if(comp_caldera()) 
5BD0:  CALL   256C
5BD4:  MOVF   01,F
5BD6:  BZ    5BDA
....................       //Si la temperatura del agua en la caldera supera el termostato, activamos el flag 
....................       temperatura_caldera_superada = TRUE; 
5BD8:  BSF    1E.0
....................  
....................    //Desactivamos los flag de las interrupciones 
....................    alarma_int = lcd_int = FALSE; 
5BDA:  BCF    1E.4
5BDC:  BCF    1E.5
....................  
....................  
....................  
....................    //Activamos las interrupciones del puerto B1 
....................    enable_interrupts(INT_EXT1); 
5BDE:  BSF    FF0.3
....................    enable_interrupts(GLOBAL); 
5BE0:  MOVLW  C0
5BE2:  IORWF  FF2,F
....................  
....................    //Mostramos un mensaje que indica al técnico el éxito en la inicialización 
....................    printf("Sistema inicializado con exito!\r"); 
5BE4:  CLRF   6F
5BE6:  MOVF   6F,W
5BE8:  CALL   00E6
5BEC:  IORLW  00
5BEE:  BZ    5BFA
5BF0:  INCF   6F,F
5BF2:  BTFSS  F9E.4
5BF4:  BRA    5BF2
5BF6:  MOVWF  FAD
5BF8:  BRA    5BE6
....................  
....................    //Repetimos la siguiente rutina hasta que se desconecte el micro 
....................    while(1){ 
....................       inicio: 
....................       //Inhabilitamos el perro guardián para que no interfiera con las gestión de interrupciones y 
....................       //con la medida de la temperatura 
....................       setup_wdt(WDT_OFF); 
5BFA:  BCF    FD1.0
....................  
....................       //Borramos los flags de interrupción que pudiesen estar activos 
....................       clear_interrupt(INT_EXT1); 
5BFC:  BCF    FF0.0
....................  
....................       //Si la interrupción de alarma se activa, gestionamos el proceso. En realidad no se trata de una 
....................       //interrupción propiamente dicha, pues se activa por software según lo que apunto en el comentario 
....................       //correspondiente a la activación (al final del main). 
....................       if(alarma_int) 
5BFE:  BTFSS  1E.5
5C00:  BRA    5D70
....................       { 
....................          //Variables para almacenar el tiempo 
....................          int hora, minutos; 
....................  
....................          //Desactivamos interrupciones 
....................          disable_interrupts(GLOBAL); 
5C02:  BCF    FF2.6
5C04:  BCF    FF2.7
5C06:  BTFSC  FF2.7
5C08:  BRA    5C04
....................  
....................          if(toca_encender) 
5C0A:  BTFSS  1E.3
5C0C:  BRA    5CF2
....................          { 
....................             if(!sistema_encendido) 
5C0E:  BTFSC  F83.2
5C10:  BRA    5CD8
....................             { 
....................                //Ejecutamos esto si se trata de una alarma de encendido y el sistema 
....................                //está apagado. 
....................                //Actualizamos el termostato, guardando el valor que había ya (teniendo 
....................                //en cuenta la histéresis) 
....................                if(temp_habitacion_superada) 
5C12:  BTFSS  1E.1
5C14:  BRA    5C4E
....................                   termostato_provisional = termostato + histeresis_vivienda; 
5C16:  BCF    FD8.1
5C18:  MOVFF  22,285
5C1C:  MOVFF  21,284
5C20:  MOVFF  20,283
5C24:  MOVFF  1F,282
5C28:  MOVFF  2E,289
5C2C:  MOVFF  2D,288
5C30:  MOVFF  2C,287
5C34:  MOVFF  2B,286
5C38:  CALL   2244
5C3C:  MOVFF  03,26
5C40:  MOVFF  02,25
5C44:  MOVFF  01,24
5C48:  MOVFF  00,23
....................                else 
5C4C:  BRA    5C5E
....................                   termostato_provisional = termostato; 
5C4E:  MOVFF  22,26
5C52:  MOVFF  21,25
5C56:  MOVFF  20,24
5C5A:  MOVFF  1F,23
....................                termostato = prg.termostato; 
5C5E:  MOVLB  2
5C60:  CLRF   x89
5C62:  MOVFF  42,288
5C66:  MOVLB  0
5C68:  CALL   24BE
5C6C:  MOVFF  03,22
5C70:  MOVFF  02,21
5C74:  MOVFF  01,20
5C78:  MOVFF  00,1F
....................                //Grabamos el termostato en el sensor como valor TL 
....................                ds1820_establecer_TH_TL(127.5, termostato); 
5C7C:  CLRF   7A
5C7E:  CLRF   79
5C80:  MOVLW  7F
5C82:  MOVWF  78
5C84:  MOVLW  85
5C86:  MOVWF  77
5C88:  MOVFF  22,7E
5C8C:  MOVFF  21,7D
5C90:  MOVFF  20,7C
5C94:  MOVFF  1F,7B
5C98:  CALL   184C
....................  
....................                //Si la temperatura no está superada, desactivamos el flag por si acaso 
....................                //lo estaba con el otro valor de termostato. 
....................                if(ds1820_termostato()) 
5C9C:  CALL   2198
5CA0:  MOVF   01,F
5CA2:  BZ    5CA6
....................                   temp_habitacion_superada = FALSE; 
5CA4:  BCF    1E.1
....................  
....................                //Determinamos la próxima alarma como de apagado 
....................                toca_encender = FALSE; 
5CA6:  BCF    1E.3
....................  
....................                //Activamos el flag de sistema encendido por alarma 
....................                encendido_por_alarma = TRUE; 
5CA8:  BSF    1E.2
....................                //Mostramos un mensaje 
....................                lcd_send_byte(LCD_ORDEN,LCD_CLEAR); 
5CAA:  CLRF   x86
5CAC:  MOVLW  01
5CAE:  MOVWF  x87
5CB0:  CALL   1152
....................                printf(lcd_putc, "  Encendiendo\n  sistema..."); 
5CB4:  CLRF   6F
5CB6:  MOVF   6F,W
5CB8:  CALL   0122
5CBC:  IORLW  00
5CBE:  BZ    5CCA
5CC0:  INCF   6F,F
5CC2:  MOVWF  x81
5CC4:  CALL   11FE
5CC8:  BRA    5CB6
....................                //Encendemos el sistema 
....................                encender_sistema(); 
5CCA:  CALL   2A16
....................  
....................                //Recogemos el tiempo en el que debe de saltar la alarma de apagado. 
....................                hora_alarma = prg.horas_fin; 
5CCE:  MOVFF  40,56
....................                minutos_alarma = prg.minutos_fin; 
5CD2:  MOVFF  41,57
....................  
....................  
....................             }else 
5CD6:  BRA    5CF0
....................             { 
....................                //Si se trata de una alarma de encendido y el sistema está encendido 
....................                delay_ms(250); //Retraso para evitar solapamiento de alarmas 
5CD8:  MOVLW  FA
5CDA:  MOVWF  x88
5CDC:  CALL   10E6
....................  
....................                //Nos vamos a la siguiente alarma 
....................                posicion_alarmas++; 
5CE0:  INCF   44,F
....................                //Si hemos llegado al final de la lista, volvemos al principio 
....................                if(posicion_alarmas==num_intervalos) 
5CE2:  MOVF   43,W
5CE4:  SUBWF  44,W
5CE6:  BNZ   5CEA
....................                   posicion_alarmas = 0; 
5CE8:  CLRF   44
....................  
....................                //Programamos la próxima alarma de encendido 
....................                programar_proxima_alarma(); 
5CEA:  CALL   2A3E
....................  
....................                //Determinamos que la siguiente es de encendido 
....................                toca_encender = TRUE; 
5CEE:  BSF    1E.3
....................             } 
....................          }else 
5CF0:  BRA    5D68
....................          { 
....................             //Si se trata de una alarma de apagado 
....................  
....................             delay_ms(250); //Retraso para evitar el solapamiento de alarmas 
5CF2:  MOVLW  FA
5CF4:  MOVWF  x88
5CF6:  CALL   10E6
....................  
....................             if(sistema_encendido && encendido_por_alarma) 
5CFA:  BTFSS  F83.2
5CFC:  BRA    5D58
5CFE:  BTFSS  1E.2
5D00:  BRA    5D58
....................             { 
....................                //Si el sistema está encendido y se trata de un encendido por alarma: 
....................                //Restauramos el valor del termostato que había antes de la alarma 
....................                termostato=termostato_provisional; 
5D02:  MOVFF  26,22
5D06:  MOVFF  25,21
5D0A:  MOVFF  24,20
5D0E:  MOVFF  23,1F
....................                //Grabamos la información en el sensor 
....................                ds1820_establecer_TH_TL(127.5, termostato); 
5D12:  CLRF   7A
5D14:  CLRF   79
5D16:  MOVLW  7F
5D18:  MOVWF  78
5D1A:  MOVLW  85
5D1C:  MOVWF  77
5D1E:  MOVFF  22,7E
5D22:  MOVFF  21,7D
5D26:  MOVFF  20,7C
5D2A:  MOVFF  1F,7B
5D2E:  CALL   184C
....................                //Determinamos que la próxima vez que se encienda no sea por alarma 
....................                encendido_por_alarma = FALSE; 
5D32:  BCF    1E.2
....................                //Mostramos un mensaje 
....................                lcd_send_byte(LCD_ORDEN,LCD_CLEAR); 
5D34:  CLRF   x86
5D36:  MOVLW  01
5D38:  MOVWF  x87
5D3A:  CALL   1152
....................                printf(lcd_putc, "  Apagando\n  sistema..."); 
5D3E:  CLRF   6F
5D40:  MOVF   6F,W
5D42:  CALL   0158
5D46:  IORLW  00
5D48:  BZ    5D54
5D4A:  INCF   6F,F
5D4C:  MOVWF  x81
5D4E:  CALL   11FE
5D52:  BRA    5D40
....................                //Apagamos el sistema 
....................                apagar_sistema(); 
5D54:  CALL   2D52
....................             } 
....................  
....................             //Nos vamos a la siguiente alarma 
....................             posicion_alarmas++; 
5D58:  INCF   44,F
....................             //Si llegamos al final de la lista, volvemos al principio 
....................             if(posicion_alarmas==num_intervalos) 
5D5A:  MOVF   43,W
5D5C:  SUBWF  44,W
5D5E:  BNZ   5D62
....................                posicion_alarmas = 0; 
5D60:  CLRF   44
....................  
....................             //Programamos la próxima alarma de encendido 
....................             programar_proxima_alarma(); 
5D62:  CALL   2A3E
....................  
....................             //Y activamos que, efectivamente, se trata de una alarma de encendido 
....................             toca_encender = TRUE; 
5D66:  BSF    1E.3
....................          } 
....................  
....................          //Activamos de nuevo la alarma 
....................          alarma = TRUE; 
5D68:  BSF    1E.6
....................  
....................          //Desactivamos el flag de interrupción 
....................          alarma_int = FALSE; 
5D6A:  BCF    1E.5
....................  
....................          //Activamos de nuevo las interrupciones 
....................          enable_interrupts(GLOBAL); 
5D6C:  MOVLW  C0
5D6E:  IORWF  FF2,F
....................       } 
....................  
....................  
....................       //Si se activa la interrupción de interfaz con el usuario, se gestiona el proceso 
....................       if(lcd_int) 
5D70:  BTFSS  1E.4
5D72:  GOTO   679C
....................       { 
....................          //Contadores y valores auxiliares 
....................          int contador, contador2, valor, input; 
....................          //Variable para almacenar el nuevo valor del termostato 
....................          float term; 
....................          //Variable para la conversión de los valores de teclado 
....................          long numero; 
....................          //Variables provisionales para buscar en la lista de programaciones 
....................          programacion pr, pr2; 
....................  
....................          //Desactivamos interrupciones 
....................          disable_interrupts(GLOBAL); 
5D76:  BCF    FF2.6
5D78:  BCF    FF2.7
5D7A:  BTFSC  FF2.7
5D7C:  BRA    5D78
....................  
....................          //Mostramos un mensaje al usuario para que elija su opción 
....................          lcd_send_byte(LCD_ORDEN,LCD_CLEAR); 
5D7E:  CLRF   x86
5D80:  MOVLW  01
5D82:  MOVWF  x87
5D84:  CALL   1152
....................          printf(lcd_putc, "  Indique la \n  operacion   1"); 
5D88:  CLRF   6F
5D8A:  MOVF   6F,W
5D8C:  CALL   018A
5D90:  IORLW  00
5D92:  BZ    5D9E
5D94:  INCF   6F,F
5D96:  MOVWF  x81
5D98:  CALL   11FE
5D9C:  BRA    5D8A
....................          lcd_gotoxy(15,2); 
5D9E:  MOVLW  0F
5DA0:  MOVWF  x82
5DA2:  MOVLW  02
5DA4:  MOVWF  x83
5DA6:  CALL   11DC
....................          lcd_send_byte(LCD_ORDEN,LCD_CURSOR); //Activamos el parpadeo del cursor 
5DAA:  CLRF   x86
5DAC:  MOVLW  0E
5DAE:  MOVWF  x87
5DB0:  CALL   1152
....................  
....................          input = 1; 
5DB4:  MOVLW  01
5DB6:  MOVWF  5E
....................          //Mientras que no se pulse SI o NO, esperamos a que el usuario introduzca un número con los cursores 
....................          while(1) 
....................          { 
....................             if(!mas) 
5DB8:  BTFSC  F82.0
5DBA:  BRA    5DE8
....................             { 
....................                //Si se pulsa el botón de +, se aumenta el valor de input 
....................                input++; 
5DBC:  INCF   5E,F
....................                //Si llegamos al límite de las opciones, reseteamos 
....................                if(input>4) 
5DBE:  MOVF   5E,W
5DC0:  SUBLW  04
5DC2:  BC    5DC8
....................                   input = 1; 
5DC4:  MOVLW  01
5DC6:  MOVWF  5E
....................                //Se muestra por pantalla 
....................                printf(lcd_putc,"%i",input); 
5DC8:  MOVFF  5E,7A
5DCC:  MOVLW  1F
5DCE:  MOVWF  7B
5DD0:  CALL   31B0
....................                //Regresamos el cursor a su posición 
....................                lcd_gotoxy(15,2); 
5DD4:  MOVLW  0F
5DD6:  MOVWF  x82
5DD8:  MOVLW  02
5DDA:  MOVWF  x83
5DDC:  CALL   11DC
....................                //Esperamos a que se levante la tecla 
....................                while(!mas){} 
5DE0:  BTFSC  F82.0
5DE2:  BRA    5DE6
5DE4:  BRA    5DE0
....................                continue; 
5DE6:  BRA    5DB8
....................             } 
....................             if(!menos) 
5DE8:  BTFSC  F82.1
5DEA:  BRA    5E16
....................             { 
....................                //Si se pulsa el botón de -, se decrementa el valor de input 
....................                input--; 
5DEC:  DECF   5E,F
....................                //Si llegamos al límite de las opciones, reseteamos 
....................                if(input<1) 
5DEE:  MOVF   5E,F
5DF0:  BNZ   5DF6
....................                   input = 4; 
5DF2:  MOVLW  04
5DF4:  MOVWF  5E
....................                //Se muestra por pantalla 
....................                printf(lcd_putc,"%i",input); 
5DF6:  MOVFF  5E,7A
5DFA:  MOVLW  1F
5DFC:  MOVWF  7B
5DFE:  CALL   31B0
....................                //Regresamos el cursor a su posición 
....................                lcd_gotoxy(15,2); 
5E02:  MOVLW  0F
5E04:  MOVWF  x82
5E06:  MOVLW  02
5E08:  MOVWF  x83
5E0A:  CALL   11DC
....................                //Esperamos a que se levante la tecla 
....................                while(!menos){} 
5E0E:  BTFSC  F82.1
5E10:  BRA    5E14
5E12:  BRA    5E0E
....................                continue; 
5E14:  BRA    5DB8
....................             } 
....................             if(!si) 
5E16:  BTFSC  F82.2
5E18:  BRA    5E22
....................             { 
....................                //Si se pulsa Si, nos quedamos con el valor seleccionado 
....................                //Esperamos a que se suelte la tecla 
....................                while(!si){} 
5E1A:  BTFSC  F82.2
5E1C:  BRA    5E20
5E1E:  BRA    5E1A
....................                break; 
5E20:  BRA    5E6C
....................             } 
....................             if(!no) 
5E22:  BTFSC  F82.5
5E24:  BRA    5E6A
....................             { 
....................                //Si se pulsa No, salimos 
....................                //Esperamos... 
....................                while(!no){} 
5E26:  BTFSC  F82.5
5E28:  BRA    5E2C
5E2A:  BRA    5E26
....................                //Se muestra un mensaje de finalización 
....................                lcd_send_byte(LCD_ORDEN,LCD_CLEAR); 
5E2C:  CLRF   x86
5E2E:  MOVLW  01
5E30:  MOVWF  x87
5E32:  CALL   1152
....................                lcd_send_byte(LCD_ORDEN,LCD_NO_CURSOR); 
5E36:  CLRF   x86
5E38:  MOVLW  0C
5E3A:  MOVWF  x87
5E3C:  CALL   1152
....................                printf(lcd_putc, "  Anulando\n  operacion..."); 
5E40:  CLRF   6F
5E42:  MOVF   6F,W
5E44:  CALL   01C2
5E48:  IORLW  00
5E4A:  BZ    5E56
5E4C:  INCF   6F,F
5E4E:  MOVWF  x81
5E50:  CALL   11FE
5E54:  BRA    5E42
....................                delay_ms(LCD_T_RETARDO); 
5E56:  MOVLW  02
5E58:  MOVWF  6F
5E5A:  MOVLW  FA
5E5C:  MOVWF  x88
5E5E:  CALL   10E6
5E62:  DECFSZ 6F,F
5E64:  BRA    5E5A
....................                lcd_int = FALSE; //Desactivamos el flag de interrupción 
5E66:  BCF    1E.4
....................                goto inicio; 
5E68:  BRA    5BFA
....................             } 
....................          } 
5E6A:  BRA    5DB8
....................  
....................          lcd_send_byte(LCD_ORDEN, LCD_NO_CURSOR); 
5E6C:  CLRF   x86
5E6E:  MOVLW  0C
5E70:  MOVWF  x87
5E72:  CALL   1152
....................  
....................          //Se elige la opción pertinente 
....................          switch(input) 
....................          { 
5E76:  MOVF   5E,W
5E78:  XORLW  01
5E7A:  BZ    5E92
5E7C:  XORLW  03
5E7E:  BZ    5F20
5E80:  XORLW  01
5E82:  BTFSC  FD8.2
5E84:  BRA    6206
5E86:  XORLW  07
5E88:  BTFSC  FD8.2
5E8A:  GOTO   6640
5E8E:  GOTO   675C
....................             //Si es 1, entramos en la opción de apagado y encendido manual del sistema 
....................             case 1: 
....................                      //Si el sistema está apagado, lo encendemos 
....................                      if(!sistema_encendido) 
5E92:  BTFSC  F83.2
5E94:  BRA    5EBC
....................                      { 
....................                         lcd_send_byte(LCD_ORDEN,LCD_CLEAR); 
5E96:  CLRF   x86
5E98:  MOVLW  01
5E9A:  MOVWF  x87
5E9C:  CALL   1152
....................                         printf(lcd_putc, "  Encendiendo\n  sistema..."); 
5EA0:  CLRF   6F
5EA2:  MOVF   6F,W
5EA4:  CALL   0122
5EA8:  IORLW  00
5EAA:  BZ    5EB6
5EAC:  INCF   6F,F
5EAE:  MOVWF  x81
5EB0:  CALL   11FE
5EB4:  BRA    5EA2
....................                         encender_sistema(); 
5EB6:  CALL   2A16
....................                      }else 
5EBA:  BRA    5F1C
....................                      //Si está encendido, lo apagamos 
....................                      { 
....................                         lcd_send_byte(LCD_ORDEN,LCD_CLEAR); 
5EBC:  CLRF   x86
5EBE:  MOVLW  01
5EC0:  MOVWF  x87
5EC2:  CALL   1152
....................                         printf(lcd_putc, "  Apagando\n  sistema..."); 
5EC6:  CLRF   6F
5EC8:  MOVF   6F,W
5ECA:  CALL   0158
5ECE:  IORLW  00
5ED0:  BZ    5EDC
5ED2:  INCF   6F,F
5ED4:  MOVWF  x81
5ED6:  CALL   11FE
5EDA:  BRA    5EC8
....................                         apagar_sistema(); 
5EDC:  CALL   2D52
....................                         //Si el motor estaba en marcha, debemos apagarlo 
....................                         if(motor) 
5EE0:  BTFSS  F83.1
5EE2:  BRA    5EE6
....................                            motor = FALSE; 
5EE4:  BCF    F83.1
....................  
....................                         //Si estaba encendido por alguna alarma debemos indicarlo 
....................                         if(encendido_por_alarma) 
5EE6:  BTFSS  1E.2
5EE8:  BRA    5F1C
....................                         { 
....................                            //Recuperamos el valor del termostato 
....................                            termostato=termostato_provisional; 
5EEA:  MOVFF  26,22
5EEE:  MOVFF  25,21
5EF2:  MOVFF  24,20
5EF6:  MOVFF  23,1F
....................                            //Almacenamos el valor en el sensor 
....................                            ds1820_establecer_TH_TL(127.5, termostato); 
5EFA:  CLRF   7A
5EFC:  CLRF   79
5EFE:  MOVLW  7F
5F00:  MOVWF  78
5F02:  MOVLW  85
5F04:  MOVWF  77
5F06:  MOVFF  22,7E
5F0A:  MOVFF  21,7D
5F0E:  MOVFF  20,7C
5F12:  MOVFF  1F,7B
5F16:  CALL   184C
....................  
....................                            encendido_por_alarma = FALSE; 
5F1A:  BCF    1E.2
....................                         } 
....................                      } 
....................                      break; 
5F1C:  GOTO   6796
....................  
....................  
....................             //Si es 2, entramos en la opción de configuración del termostato 
....................             case 2: 
....................  
....................                      //Mostramos el valor del termostato actual 
....................                      lcd_send_byte(LCD_ORDEN, LCD_CLEAR); 
5F20:  CLRF   x86
5F22:  MOVLW  01
5F24:  MOVWF  x87
5F26:  CALL   1152
....................                      //Para considerar el valor del termostato hay que tener en cuenta el valor de la histéresis. 
....................                      //Extraemos la parte entera del termostato para así poder trabajar con la función buscar_numero(). 
....................                      //Tampoco es una limitación trabajar con valores enteros del termostato, pues nuestro cuerpo no notará 
....................                      //demasiado la diferencia. 
....................                      if(temp_habitacion_superada) 
5F2A:  BTFSS  1E.1
5F2C:  BRA    5FE6
....................                      { 
....................                         valor = (int)(termostato+histeresis_vivienda); 
5F2E:  BCF    FD8.1
5F30:  MOVFF  22,285
5F34:  MOVFF  21,284
5F38:  MOVFF  20,283
5F3C:  MOVFF  1F,282
5F40:  MOVFF  2E,289
5F44:  MOVFF  2D,288
5F48:  MOVFF  2C,287
5F4C:  MOVFF  2B,286
5F50:  CALL   2244
5F54:  MOVFF  03,8A
5F58:  MOVFF  02,89
5F5C:  MOVFF  01,88
5F60:  MOVFF  00,87
5F64:  CALL   16B2
5F68:  MOVFF  01,5D
....................                         printf(lcd_putc, "Modificar\ntermostato %.0f%cC",termostato+histeresis_vivienda,223); 
5F6C:  BCF    FD8.1
5F6E:  MOVFF  22,285
5F72:  MOVFF  21,284
5F76:  MOVFF  20,283
5F7A:  MOVFF  1F,282
5F7E:  MOVFF  2E,289
5F82:  MOVFF  2D,288
5F86:  MOVFF  2C,287
5F8A:  MOVFF  2B,286
5F8E:  CALL   2244
5F92:  MOVFF  00,6F
5F96:  MOVFF  01,70
5F9A:  MOVFF  02,71
5F9E:  MOVFF  03,72
5FA2:  CLRF   73
5FA4:  MOVF   73,W
5FA6:  CALL   01F6
5FAA:  INCF   73,F
5FAC:  MOVWF  00
5FAE:  MOVWF  x81
5FB0:  CALL   11FE
5FB4:  MOVLW  15
5FB6:  SUBWF  73,W
5FB8:  BNZ   5FA4
5FBA:  MOVLW  89
5FBC:  MOVWF  FE9
5FBE:  MOVFF  72,77
5FC2:  MOVFF  71,76
5FC6:  MOVFF  70,75
5FCA:  MOVFF  6F,74
5FCE:  CLRF   78
5FD0:  CALL   334C
5FD4:  MOVLW  DF
5FD6:  MOVWF  x81
5FD8:  CALL   11FE
5FDC:  MOVLW  43
5FDE:  MOVWF  x81
5FE0:  CALL   11FE
....................                      } 
....................                      else 
5FE4:  BRA    6040
....................                      { 
....................                         valor = (int)termostato; 
5FE6:  MOVFF  22,8A
5FEA:  MOVFF  21,89
5FEE:  MOVFF  20,88
5FF2:  MOVFF  1F,87
5FF6:  CALL   16B2
5FFA:  MOVFF  01,5D
....................                         printf(lcd_putc, "Modificar\ntermostato %.0f%cC",termostato,223); 
5FFE:  CLRF   6F
6000:  MOVF   6F,W
6002:  CALL   01F6
6006:  INCF   6F,F
6008:  MOVWF  00
600A:  MOVWF  x81
600C:  CALL   11FE
6010:  MOVLW  15
6012:  SUBWF  6F,W
6014:  BNZ   6000
6016:  MOVLW  89
6018:  MOVWF  FE9
601A:  MOVFF  22,77
601E:  MOVFF  21,76
6022:  MOVFF  20,75
6026:  MOVFF  1F,74
602A:  CLRF   78
602C:  CALL   334C
6030:  MOVLW  DF
6032:  MOVWF  x81
6034:  CALL   11FE
6038:  MOVLW  43
603A:  MOVWF  x81
603C:  CALL   11FE
....................                      } 
....................  
....................                      //Retardamos cierto tiempo para que el usuario vea correctamente los datos de la pantalla 
....................                      delay_ms(LCD_T_RETARDO*2); 
6040:  MOVLW  04
6042:  MOVWF  6F
6044:  MOVLW  FA
6046:  MOVWF  x88
6048:  CALL   10E6
604C:  DECFSZ 6F,F
604E:  BRA    6044
....................  
....................                      //Pedimos la introducción de nuevo valor 
....................                      lcd_send_byte(LCD_ORDEN, LCD_CLEAR); 
6050:  CLRF   x86
6052:  MOVLW  01
6054:  MOVWF  x87
6056:  CALL   1152
....................                      printf(lcd_putc, "Nuevo valor:\n       %cC",223); 
605A:  CLRF   6F
605C:  MOVF   6F,W
605E:  CALL   022E
6062:  INCF   6F,F
6064:  MOVWF  00
6066:  MOVWF  x81
6068:  CALL   11FE
606C:  MOVLW  0D
606E:  SUBWF  6F,W
6070:  BNZ   605C
6072:  MOVLW  07
6074:  MOVWF  70
6076:  MOVLW  20
6078:  MOVWF  x81
607A:  CALL   11FE
607E:  DECFSZ 70,F
6080:  BRA    6076
6082:  MOVLW  DF
6084:  MOVWF  x81
6086:  CALL   11FE
608A:  MOVLW  43
608C:  MOVWF  x81
608E:  CALL   11FE
....................  
....................                      //Recogemos el número de dos cifras introducido por el teclado 
....................                      term=(float)buscar_numero(6, temp_min, temp_max, valor); 
6092:  MOVLW  06
6094:  MOVWF  71
6096:  MOVLW  10
6098:  MOVWF  72
609A:  MOVLW  20
609C:  MOVWF  73
609E:  MOVFF  5D,74
60A2:  CALL   34DC
60A6:  MOVLB  2
60A8:  CLRF   x89
60AA:  MOVFF  01,288
60AE:  MOVLB  0
60B0:  CALL   24BE
60B4:  MOVFF  03,62
60B8:  MOVFF  02,61
60BC:  MOVFF  01,60
60C0:  MOVFF  00,5F
....................  
....................                      //Si se pulsa la tecla SI o NO, salimos 
....................                      if(term==NOCODE) 
60C4:  MOVFF  62,7A
60C8:  MOVFF  61,79
60CC:  MOVFF  60,78
60D0:  MOVFF  5F,77
60D4:  CLRF   7E
60D6:  CLRF   7D
60D8:  MOVLW  48
60DA:  MOVWF  7C
60DC:  MOVLW  85
60DE:  MOVWF  7B
60E0:  CALL   24F6
60E4:  BNZ   60EA
....................                         goto salir; 
60E6:  BRA    675C
....................                      else 
60E8:  BRA    6204
....................                      { 
....................                         //Retardamos cierto tiempo para permitir al usuario visualizar el valor que ha introducido 
....................                         delay_ms(LCD_T_RETARDO); 
60EA:  MOVLW  02
60EC:  MOVWF  6F
60EE:  MOVLW  FA
60F0:  MOVWF  x88
60F2:  CALL   10E6
60F6:  DECFSZ 6F,F
60F8:  BRA    60EE
....................  
....................                         //Mostramos un mensaje de aplicación de cambios 
....................                         lcd_send_byte(LCD_ORDEN, LCD_CLEAR); 
60FA:  CLRF   x86
60FC:  MOVLW  01
60FE:  MOVWF  x87
6100:  CALL   1152
....................                         printf(lcd_putc, "  Aplicando\n  cambios..."); 
6104:  CLRF   6F
6106:  MOVF   6F,W
6108:  CALL   025A
610C:  IORLW  00
610E:  BZ    611A
6110:  INCF   6F,F
6112:  MOVWF  x81
6114:  CALL   11FE
6118:  BRA    6106
....................  
....................                         //Aquí, a diferencia que con el teclado matricial, no es necesario comprobar los límites de temperatura después 
....................  
....................                         //Leemos la temperatura 
....................                         temperatura = ds1820_read(); 
611A:  CALL   20EA
611E:  MOVFF  03,2A
6122:  MOVFF  02,29
6126:  MOVFF  01,28
612A:  MOVFF  00,27
....................                         if(temperatura >= term) 
612E:  MOVFF  62,7A
6132:  MOVFF  61,79
6136:  MOVFF  60,78
613A:  MOVFF  5F,77
613E:  MOVFF  2A,7E
6142:  MOVFF  29,7D
6146:  MOVFF  28,7C
614A:  MOVFF  27,7B
614E:  CALL   24F6
6152:  BC    6156
6154:  BNZ   6190
....................                         { 
....................                            //Si supera el valor del termostato, lo indicamos con el flag 
....................                            temp_habitacion_superada = TRUE; 
6156:  BSF    1E.1
....................                            //Guardamos el termostato nuevo teniendo en cuenta la histeresis de la vivienda 
....................                            termostato = term - histeresis_vivienda; 
6158:  BSF    FD8.1
615A:  MOVFF  62,285
615E:  MOVFF  61,284
6162:  MOVFF  60,283
6166:  MOVFF  5F,282
616A:  MOVFF  2E,289
616E:  MOVFF  2D,288
6172:  MOVFF  2C,287
6176:  MOVFF  2B,286
617A:  CALL   2244
617E:  MOVFF  03,22
6182:  MOVFF  02,21
6186:  MOVFF  01,20
618A:  MOVFF  00,1F
....................                         }else 
618E:  BRA    61A2
....................                         { 
....................                            //Si no se supera, se indica también 
....................                            temp_habitacion_superada = FALSE; 
6190:  BCF    1E.1
....................                            //Se guarda el valor tal cual 
....................                            termostato = term; 
6192:  MOVFF  62,22
6196:  MOVFF  61,21
619A:  MOVFF  60,20
619E:  MOVFF  5F,1F
....................                         } 
....................  
....................                         //Escribimos en el sensor el nuevo valor del termostato 
....................                         ds1820_establecer_TH_TL(127.5, termostato); 
61A2:  CLRF   7A
61A4:  CLRF   79
61A6:  MOVLW  7F
61A8:  MOVWF  78
61AA:  MOVLW  85
61AC:  MOVWF  77
61AE:  MOVFF  22,7E
61B2:  MOVFF  21,7D
61B6:  MOVFF  20,7C
61BA:  MOVFF  1F,7B
61BE:  CALL   184C
....................  
....................                         //Guardamos el nuevo valor del termostato en memoria 
....................                         write_eeprom(eeprom_termostato, (int)term); 
61C2:  MOVFF  62,8A
61C6:  MOVFF  61,89
61CA:  MOVFF  60,88
61CE:  MOVFF  5F,87
61D2:  CALL   16B2
61D6:  MOVFF  01,6F
61DA:  CLRF   FA9
61DC:  MOVFF  01,FA8
61E0:  BCF    FA6.6
61E2:  BCF    FA6.7
61E4:  BSF    FA6.2
61E6:  MOVFF  FF2,00
61EA:  BCF    FF2.7
61EC:  MOVLB  F
61EE:  MOVLW  55
61F0:  MOVWF  FA7
61F2:  MOVLW  AA
61F4:  MOVWF  FA7
61F6:  BSF    FA6.1
61F8:  BTFSC  FA6.1
61FA:  BRA    61F8
61FC:  BCF    FA6.2
61FE:  MOVF   00,W
6200:  IORWF  FF2,F
6202:  MOVLB  0
....................  
....................  
....................                      } 
....................  
....................                      break; 
6204:  BRA    6796
....................  
....................  
....................             //Si es 3, entramos en la opción de configuración de las alarmas 
....................             case 3: 
....................  
....................                      //Mostramos el encabezamiento de la operación 
....................                      lcd_send_byte(LCD_ORDEN, LCD_CLEAR); 
6206:  CLRF   x86
6208:  MOVLW  01
620A:  MOVWF  x87
620C:  CALL   1152
....................                      printf(lcd_putc," Programar\n sistema"); 
6210:  CLRF   6F
6212:  MOVF   6F,W
6214:  CALL   028E
6218:  IORLW  00
621A:  BZ    6226
621C:  INCF   6F,F
621E:  MOVWF  x81
6220:  CALL   11FE
6224:  BRA    6212
....................                      delay_ms(LCD_T_RETARDO); 
6226:  MOVLW  02
6228:  MOVWF  6F
622A:  MOVLW  FA
622C:  MOVWF  x88
622E:  CALL   10E6
6232:  DECFSZ 6F,F
6234:  BRA    622A
....................  
....................                      //Tenemos la posibilidad de introducir 5 intervalos de alarma. 
....................                      //Se va guiando al usuario por la configuración de cada intervalo mediante el siguiente bucle 
....................                      for(contador=0; contador<3; contador++) 
6236:  CLRF   5B
6238:  MOVF   5B,W
623A:  SUBLW  02
623C:  BTFSS  FD8.0
623E:  BRA    6628
....................                      { 
....................                         //Se muestra el intervalo a configurar 
....................                         lcd_send_byte(LCD_ORDEN, LCD_CLEAR); 
6240:  CLRF   x86
6242:  MOVLW  01
6244:  MOVWF  x87
6246:  CALL   1152
....................                         printf(lcd_putc, " INTERVALO %i\n   :      :",contador+1); 
624A:  MOVLW  01
624C:  ADDWF  5B,W
624E:  MOVWF  6F
6250:  CLRF   70
6252:  MOVF   70,W
6254:  CALL   02BC
6258:  INCF   70,F
625A:  MOVWF  00
625C:  MOVWF  x81
625E:  CALL   11FE
6262:  MOVLW  0B
6264:  SUBWF  70,W
6266:  BNZ   6252
6268:  MOVFF  6F,7A
626C:  MOVLW  1F
626E:  MOVWF  7B
6270:  CALL   31B0
6274:  MOVLW  0A
6276:  MOVWF  x81
6278:  CALL   11FE
627C:  MOVLW  03
627E:  MOVWF  71
6280:  MOVLW  20
6282:  MOVWF  x81
6284:  CALL   11FE
6288:  DECFSZ 71,F
628A:  BRA    6280
628C:  MOVLW  3A
628E:  MOVWF  x81
6290:  CALL   11FE
6294:  MOVLW  06
6296:  MOVWF  72
6298:  MOVLW  20
629A:  MOVWF  x81
629C:  CALL   11FE
62A0:  DECFSZ 72,F
62A2:  BRA    6298
62A4:  MOVLW  3A
62A6:  MOVWF  x81
62A8:  CALL   11FE
....................  
....................                         //Se pide al usuario el valor de hora de inicio de la alarma 
....................                         pr.horas_inicio = buscar_numero(2, 0, 23, 0); 
62AC:  MOVLW  02
62AE:  MOVWF  71
62B0:  CLRF   72
62B2:  MOVLW  17
62B4:  MOVWF  73
62B6:  CLRF   74
62B8:  CALL   34DC
62BC:  MOVFF  01,65
....................  
....................                         //Si se pulsa No, se indica que no quieren introducirse más alarmas. 
....................                         //En el otro código esto se gestionaba pulsando sí y con no simplemente se salía, 
....................                         //pero aquí debemos hacerlo así por falta de botones... 
....................                         if(pr.horas_inicio==NOCODE) 
62C0:  MOVF   65,W
62C2:  SUBLW  64
62C4:  BNZ   62D2
....................                         { 
....................                            //Si era la primera alarma que se gestionaba, se interpreta como que 
....................                            //no se quiere activar ninguna alarma 
....................                            if(contador==0) 
62C6:  MOVF   5B,F
62C8:  BNZ   62D0
....................                            { 
....................                               //Desactivamos las alarmas 
....................                               alarma = FALSE; 
62CA:  BCF    1E.6
....................                               //Salimos 
....................                               goto salir; 
62CC:  BRA    675C
....................                            } 
....................                            else 
62CE:  BRA    62D2
....................                               //Salimos simplemente del bucle 
....................                               break; 
62D0:  BRA    6628
....................                         } 
....................  
....................                         //Se pide al usuario el valor de los minutos de inicio 
....................                         pr.minutos_inicio = buscar_numero(5, 0, 59, 0); 
62D2:  MOVLW  05
62D4:  MOVWF  71
62D6:  CLRF   72
62D8:  MOVLW  3B
62DA:  MOVWF  73
62DC:  CLRF   74
62DE:  CALL   34DC
62E2:  MOVFF  01,66
....................  
....................                         //Si se pulsa NO, interrumpimos la introducción de alarmas 
....................                         if(pr.minutos_inicio==NOCODE) 
62E6:  MOVF   66,W
62E8:  SUBLW  64
62EA:  BNZ   62F8
....................                         { 
....................                            //Si es el primer intervalo, interpretamos como que el usuario 
....................                            //no quiere programar alarmas 
....................                            if(contador==0) 
62EC:  MOVF   5B,F
62EE:  BNZ   62F6
....................                            { 
....................                               //Desactivamos las alarmas 
....................                               alarma = FALSE; 
62F0:  BCF    1E.6
....................                               goto salir; 
62F2:  BRA    675C
....................                            } 
....................                            else 
62F4:  BRA    62F8
....................                               //Salimos del bucle 
....................                               break; 
62F6:  BRA    6628
....................                         } 
....................  
....................                         //Al contrario que ocurría en el Proyecto 1 que contaba con teclado matricial, 
....................                         //en este caso comprobamos que la hora final sea posterior a la inicial en el momento. 
....................                         //Para ello debemos establecer el límite inferior de la hora de fin correctamente. 
....................  
....................                         //Si la hora de inicio corresponde a la última hora del día, no podrá programarse nada 
....................                         if(pr.horas_inicio==23 && pr.minutos_inicio==59) 
62F8:  MOVF   65,W
62FA:  SUBLW  17
62FC:  BNZ   6338
62FE:  MOVF   66,W
6300:  SUBLW  3B
6302:  BNZ   6338
....................                         { 
....................                            //Si se produce un error de este tipo, se indica 
....................                            lcd_send_byte(LCD_ORDEN, LCD_CLEAR); 
6304:  CLRF   x86
6306:  MOVLW  01
6308:  MOVWF  x87
630A:  CALL   1152
....................                            printf(lcd_putc, "   Valores\n   incorrectos"); 
630E:  CLRF   6F
6310:  MOVF   6F,W
6312:  CALL   02E8
6316:  IORLW  00
6318:  BZ    6324
631A:  INCF   6F,F
631C:  MOVWF  x81
631E:  CALL   11FE
6322:  BRA    6310
....................                            delay_ms(LCD_T_RETARDO); 
6324:  MOVLW  02
6326:  MOVWF  6F
6328:  MOVLW  FA
632A:  MOVWF  x88
632C:  CALL   10E6
6330:  DECFSZ 6F,F
6332:  BRA    6328
....................                            //Se repite la última iteración del bloque 
....................                            contador--; 
6334:  DECF   5B,F
....................                            continue; 
6336:  BRA    6624
....................                         } 
....................  
....................                         //Si los minutos son 59, tendremos que irnos a la siguiente hora 
....................                         if(pr.minutos_inicio==59) 
6338:  MOVF   66,W
633A:  SUBLW  3B
633C:  BNZ   6364
....................                         { 
....................                            pr.horas_fin = buscar_numero(9, pr.horas_inicio+1, 23, pr.horas_inicio+1); 
633E:  MOVLW  01
6340:  ADDWF  65,W
6342:  MOVWF  6F
6344:  MOVLW  01
6346:  ADDWF  65,W
6348:  MOVWF  70
634A:  MOVLW  09
634C:  MOVWF  71
634E:  MOVFF  6F,72
6352:  MOVLW  17
6354:  MOVWF  73
6356:  MOVFF  70,74
635A:  CALL   34DC
635E:  MOVFF  01,67
....................                         }else 
6362:  BRA    637C
....................                         { 
....................                            pr.horas_fin = buscar_numero(9, pr.horas_inicio, 23, pr.horas_inicio); 
6364:  MOVLW  09
6366:  MOVWF  71
6368:  MOVFF  65,72
636C:  MOVLW  17
636E:  MOVWF  73
6370:  MOVFF  65,74
6374:  CALL   34DC
6378:  MOVFF  01,67
....................                         } 
....................  
....................                         if(pr.horas_fin==NOCODE) 
637C:  MOVF   67,W
637E:  SUBLW  64
6380:  BNZ   638E
....................                         { 
....................                            if(contador==0) 
6382:  MOVF   5B,F
6384:  BNZ   638C
....................                            { 
....................                               alarma = FALSE; 
6386:  BCF    1E.6
....................                               goto salir; 
6388:  BRA    675C
....................                            } 
....................                            else 
638A:  BRA    638E
....................                               break; 
638C:  BRA    6628
....................                         } 
....................  
....................                         //Si las horas de inicio y fin son las mismas, habrá que limitar que los minutos de finalización 
....................                         //tengan un valor mayor 
....................                         if(pr.horas_inicio == pr.horas_fin) 
638E:  MOVF   67,W
6390:  SUBWF  65,W
6392:  BNZ   63BA
....................                            pr.minutos_fin = buscar_numero(12, pr.minutos_inicio+1, 59, pr.minutos_inicio+1); 
6394:  MOVLW  01
6396:  ADDWF  66,W
6398:  MOVWF  6F
639A:  MOVLW  01
639C:  ADDWF  66,W
639E:  MOVWF  70
63A0:  MOVLW  0C
63A2:  MOVWF  71
63A4:  MOVFF  6F,72
63A8:  MOVLW  3B
63AA:  MOVWF  73
63AC:  MOVFF  70,74
63B0:  CALL   34DC
63B4:  MOVFF  01,68
....................                         else 
63B8:  BRA    63CE
....................                            pr.minutos_fin = buscar_numero(12, 0, 59, 0); 
63BA:  MOVLW  0C
63BC:  MOVWF  71
63BE:  CLRF   72
63C0:  MOVLW  3B
63C2:  MOVWF  73
63C4:  CLRF   74
63C6:  CALL   34DC
63CA:  MOVFF  01,68
....................  
....................                         if(pr.minutos_fin==NOCODE) 
63CE:  MOVF   68,W
63D0:  SUBLW  64
63D2:  BNZ   63E0
....................                         { 
....................                            if(contador==0) 
63D4:  MOVF   5B,F
63D6:  BNZ   63DE
....................                            { 
....................                               alarma = FALSE; 
63D8:  BCF    1E.6
....................                               goto salir; 
63DA:  BRA    675C
....................                            } 
....................                            else 
63DC:  BRA    63E0
....................                               break; 
63DE:  BRA    6628
....................                         } 
....................  
....................                         //Introducimos cierto retardo para que el usuario pueda visualizar los valores introducidos en la pantalla 
....................                         delay_ms(LCD_T_RETARDO); 
63E0:  MOVLW  02
63E2:  MOVWF  6F
63E4:  MOVLW  FA
63E6:  MOVWF  x88
63E8:  CALL   10E6
63EC:  DECFSZ 6F,F
63EE:  BRA    63E4
....................  
....................                         //No puede haber un intervalo de encendido de más de 4 horas. 
....................                         //Esto deriva de un problema propio de almacenamiento de números enteros, pero es perfectamente lógico 
....................                         //que un sistema de calefacción tenga un tiempo máximo de encendido para regular el uso abusivo del sistema 
....................                         //y evitar averías por un funcionamiento muy prolongado. 
....................                         if(diferencia_tiempo(pr.horas_inicio, pr.minutos_inicio, pr.horas_fin, pr.minutos_fin)>240) 
63F0:  MOVFF  65,77
63F4:  MOVFF  66,78
63F8:  MOVFF  67,79
63FC:  MOVFF  68,7A
6400:  CALL   2ACE
6404:  MOVFF  02,70
6408:  MOVFF  01,6F
640C:  MOVF   70,F
640E:  BNZ   6416
6410:  MOVF   6F,W
6412:  SUBLW  F0
6414:  BC    644A
....................                         { 
....................                            //Mostramos un aviso 
....................                            lcd_send_byte(LCD_ORDEN, LCD_CLEAR); 
6416:  CLRF   x86
6418:  MOVLW  01
641A:  MOVWF  x87
641C:  CALL   1152
....................                            printf(lcd_putc, "Intervalo limite\nde 4 horas"); 
6420:  CLRF   6F
6422:  MOVF   6F,W
6424:  CALL   031C
6428:  IORLW  00
642A:  BZ    6436
642C:  INCF   6F,F
642E:  MOVWF  x81
6430:  CALL   11FE
6434:  BRA    6422
....................                            delay_ms(LCD_T_RETARDO); 
6436:  MOVLW  02
6438:  MOVWF  6F
643A:  MOVLW  FA
643C:  MOVWF  x88
643E:  CALL   10E6
6442:  DECFSZ 6F,F
6444:  BRA    643A
....................                            //Se repite la última iteración del bloque 
....................                            contador--; 
6446:  DECF   5B,F
....................                            continue; 
6448:  BRA    6624
....................  
....................                         } 
....................  
....................                         //El usuario debe ahora introducir el valor del temostato para ese periodo de encendido 
....................                         lcd_send_byte(LCD_ORDEN, LCD_CLEAR); 
644A:  CLRF   x86
644C:  MOVLW  01
644E:  MOVWF  x87
6450:  CALL   1152
....................                         printf(lcd_putc, "Termostato %i\n      %cC", contador+1, 223); 
6454:  MOVLW  01
6456:  ADDWF  5B,W
6458:  MOVWF  6F
645A:  CLRF   70
645C:  MOVF   70,W
645E:  CALL   0352
6462:  INCF   70,F
6464:  MOVWF  00
6466:  MOVWF  x81
6468:  CALL   11FE
646C:  MOVLW  0B
646E:  SUBWF  70,W
6470:  BNZ   645C
6472:  MOVFF  6F,7A
6476:  MOVLW  1F
6478:  MOVWF  7B
647A:  CALL   31B0
647E:  MOVLW  0A
6480:  MOVWF  x81
6482:  CALL   11FE
6486:  MOVLW  06
6488:  MOVWF  71
648A:  MOVLW  20
648C:  MOVWF  x81
648E:  CALL   11FE
6492:  DECFSZ 71,F
6494:  BRA    648A
6496:  MOVLW  DF
6498:  MOVWF  x81
649A:  CALL   11FE
649E:  MOVLW  43
64A0:  MOVWF  x81
64A2:  CALL   11FE
....................  
....................                         //Recogemos el número introducido por el usuario 
....................                         pr.termostato = buscar_numero(4, temp_min, temp_max, 20); 
64A6:  MOVLW  04
64A8:  MOVWF  71
64AA:  MOVLW  10
64AC:  MOVWF  72
64AE:  MOVLW  20
64B0:  MOVWF  73
64B2:  MOVLW  14
64B4:  MOVWF  74
64B6:  CALL   34DC
64BA:  MOVFF  01,69
....................  
....................                         //Retardamos para que el usuario pueda ver el valor que ha introducido 
....................                         delay_ms(LCD_T_RETARDO); 
64BE:  MOVLW  02
64C0:  MOVWF  6F
64C2:  MOVLW  FA
64C4:  MOVWF  x88
64C6:  CALL   10E6
64CA:  DECFSZ 6F,F
64CC:  BRA    64C2
....................  
....................                         //Comprobamos que los intervalos sean correctos respecto a los otros, es decir, 
....................                         //que no haya solapamiento entre los distintos intervalos programados. 
....................                         for(contador2=0; contador2<contador; contador2++) 
64CE:  CLRF   5C
64D0:  MOVF   5B,W
64D2:  SUBWF  5C,W
64D4:  BTFSC  FD8.0
64D6:  BRA    6600
....................                         { 
....................                            //Tomamos las programaciones almacenadas anteriormente 
....................                            pr2 = programaciones[contador2]; 
64D8:  MOVF   5C,W
64DA:  MULLW  05
64DC:  MOVF   FF3,W
64DE:  CLRF   03
64E0:  ADDLW  2F
64E2:  MOVWF  01
64E4:  MOVLW  00
64E6:  ADDWFC 03,F
64E8:  MOVFF  01,6F
64EC:  MOVFF  03,70
64F0:  CLRF   FEA
64F2:  MOVLW  6A
64F4:  MOVWF  FE9
64F6:  MOVFF  03,FE2
64FA:  MOVFF  01,FE1
64FE:  MOVLW  05
6500:  MOVWF  01
6502:  MOVFF  FE6,FEE
6506:  DECFSZ 01,F
6508:  BRA    6502
....................  
....................                            //Controlamos todas las posibilidades de solapamiento 
....................                            if( 
....................                               (comprobar_hora(pr2.horas_inicio, pr2.minutos_inicio, pr.horas_fin, pr.minutos_fin) && 
....................                               !comprobar_hora(pr2.horas_inicio, pr2.minutos_inicio, pr.horas_inicio, pr.minutos_inicio)) 
....................  
....................                               ||(comprobar_hora(pr2.horas_fin, pr2.minutos_fin, pr.horas_fin, pr.minutos_fin) && 
....................                                 !comprobar_hora(pr2.horas_fin, pr2.minutos_fin, pr.horas_inicio, pr.minutos_inicio)) 
....................  
....................                               ||(comprobar_hora(pr.horas_inicio, pr.minutos_inicio, pr2.horas_fin, pr2.minutos_fin) && 
....................                                 !comprobar_hora(pr.horas_inicio, pr.minutos_inicio, pr2.horas_inicio, pr2.minutos_inicio)) 
....................  
....................                               ||(comprobar_hora(pr.horas_fin, pr.minutos_fin, pr2.horas_fin, pr2.minutos_fin) && 
....................                                 !comprobar_hora(pr.horas_fin, pr.minutos_fin, pr2.horas_inicio, pr2.minutos_inicio)) 
....................                            ) 
650A:  MOVFF  6A,81
650E:  MOVFF  6B,82
6512:  MOVFF  67,83
6516:  MOVFF  68,84
651A:  CALL   2A7C
651E:  MOVF   01,F
6520:  BZ    653A
6522:  MOVFF  6A,81
6526:  MOVFF  6B,82
652A:  MOVFF  65,83
652E:  MOVFF  66,84
6532:  CALL   2A7C
6536:  MOVF   01,F
6538:  BZ    65CA
653A:  MOVFF  6C,81
653E:  MOVFF  6D,82
6542:  MOVFF  67,83
6546:  MOVFF  68,84
654A:  CALL   2A7C
654E:  MOVF   01,F
6550:  BZ    656A
6552:  MOVFF  6C,81
6556:  MOVFF  6D,82
655A:  MOVFF  65,83
655E:  MOVFF  66,84
6562:  CALL   2A7C
6566:  MOVF   01,F
6568:  BZ    65CA
656A:  MOVFF  65,81
656E:  MOVFF  66,82
6572:  MOVFF  6C,83
6576:  MOVFF  6D,84
657A:  CALL   2A7C
657E:  MOVF   01,F
6580:  BZ    659A
6582:  MOVFF  65,81
6586:  MOVFF  66,82
658A:  MOVFF  6A,83
658E:  MOVFF  6B,84
6592:  CALL   2A7C
6596:  MOVF   01,F
6598:  BZ    65CA
659A:  MOVFF  67,81
659E:  MOVFF  68,82
65A2:  MOVFF  6C,83
65A6:  MOVFF  6D,84
65AA:  CALL   2A7C
65AE:  MOVF   01,F
65B0:  BZ    65FC
65B2:  MOVFF  67,81
65B6:  MOVFF  68,82
65BA:  MOVFF  6A,83
65BE:  MOVFF  6B,84
65C2:  CALL   2A7C
65C6:  MOVF   01,F
65C8:  BNZ   65FC
....................                            { 
....................                               //Si hay solapamiento, mostramos un mensaje de error y salimos 
....................                               lcd_send_byte(LCD_ORDEN, LCD_CLEAR); 
65CA:  CLRF   x86
65CC:  MOVLW  01
65CE:  MOVWF  x87
65D0:  CALL   1152
....................                               printf(lcd_putc, "Solapamiento\nde intervalos!"); 
65D4:  CLRF   6F
65D6:  MOVF   6F,W
65D8:  CALL   037E
65DC:  IORLW  00
65DE:  BZ    65EA
65E0:  INCF   6F,F
65E2:  MOVWF  x81
65E4:  CALL   11FE
65E8:  BRA    65D6
....................                               delay_ms(LCD_T_RETARDO*2); 
65EA:  MOVLW  04
65EC:  MOVWF  6F
65EE:  MOVLW  FA
65F0:  MOVWF  x88
65F2:  CALL   10E6
65F6:  DECFSZ 6F,F
65F8:  BRA    65EE
....................                               goto salir; 
65FA:  BRA    675C
....................                            } 
....................                         } 
65FC:  INCF   5C,F
65FE:  BRA    64D0
....................  
....................                         //Añadimos esta programación a la lista de programaciones 
....................                         programaciones[contador]=pr; 
6600:  MOVF   5B,W
6602:  MULLW  05
6604:  MOVF   FF3,W
6606:  CLRF   03
6608:  ADDLW  2F
660A:  MOVWF  FE9
660C:  MOVLW  00
660E:  ADDWFC 03,W
6610:  MOVWF  FEA
6612:  CLRF   FE2
6614:  MOVLW  65
6616:  MOVWF  FE1
6618:  MOVLW  05
661A:  MOVWF  01
661C:  MOVFF  FE6,FEE
6620:  DECFSZ 01,F
6622:  BRA    661C
....................                      } 
6624:  INCF   5B,F
6626:  BRA    6238
....................  
....................                      //Habilitamos la alarma 
....................                      alarma=TRUE; 
6628:  BSF    1E.6
....................  
....................                      //Guardamos el número de intervalos configurados 
....................                      num_intervalos = contador; 
662A:  MOVFF  5B,43
....................  
....................                      //Ordenamos las programaciones por orden de hora de inicio 
....................                      ordenar_programaciones(); 
662E:  GOTO   3702
....................  
....................                      //Seleccionamos la próxima alarma a ejecutar 
....................                      seleccionar_alarma(); 
6632:  GOTO   383A
....................  
....................                      //Programamos la próxima alarma para que salte el reloj en el momento indicado 
....................                      programar_proxima_alarma(); 
6636:  CALL   2A3E
....................  
....................                      //Indicamos que se trata de una alarma de encendido 
....................                      toca_encender = TRUE; 
663A:  BSF    1E.3
....................  
....................                      //Guardamos las programaciones introducidas 
....................                      grabar_programaciones(); 
663C:  GOTO   38BC
....................  
....................                      break; 
....................  
....................  
....................             //Si es 4, entramos en el modo de revisión y obtención de datos históricos 
....................             case 4: 
....................  
....................                      //Solicitamos la introducción de una clave. 
....................                      //Al contrario de lo que ocurría cuando disponíamos de teclado matricial, 
....................                      //en este caso la clave es una combinación de botones: {+,-,-,SI} 
....................                      lcd_send_byte(LCD_ORDEN, LCD_CLEAR); 
6640:  CLRF   x86
6642:  MOVLW  01
6644:  MOVWF  x87
6646:  CALL   1152
....................                      printf(lcd_putc, "  Introduzca\n  clave"); 
664A:  CLRF   6F
664C:  MOVF   6F,W
664E:  CALL   03B4
6652:  IORLW  00
6654:  BZ    6660
6656:  INCF   6F,F
6658:  MOVWF  x81
665A:  CALL   11FE
665E:  BRA    664C
....................  
....................                      //Realizamos todo el proceso de comprobación de clave correcta según los botones pulsados 
....................                      while(1) 
....................                      { 
....................                         if(!mas) 
6660:  BTFSC  F82.0
6662:  BRA    66E4
....................                         { 
....................                            while(!mas){} 
6664:  BTFSC  F82.0
6666:  BRA    666A
6668:  BRA    6664
....................                            while(1) 
....................                            { 
....................                               if(!menos) 
666A:  BTFSC  F82.1
666C:  BRA    66C6
....................                               { 
....................                                  while(!menos){} 
666E:  BTFSC  F82.1
6670:  BRA    6674
6672:  BRA    666E
....................                                  while(1) 
....................                                  { 
....................                                     if(!menos) 
6674:  BTFSC  F82.1
6676:  BRA    66A8
....................                                     { 
....................                                        while(!menos){} 
6678:  BTFSC  F82.1
667A:  BRA    667E
667C:  BRA    6678
....................                                        while(1) 
....................                                        { 
....................                                           if(!si) 
667E:  BTFSC  F82.2
6680:  BRA    668A
....................                                           { 
....................                                              while(!si){} 
6682:  BTFSC  F82.2
6684:  BRA    6688
6686:  BRA    6682
....................                                              goto clave_correcta; 
6688:  BRA    6734
....................                                           } 
....................                                           if(!mas || !menos || !no) 
668A:  BTFSS  F82.0
668C:  BRA    6696
668E:  BTFSS  F82.1
6690:  BRA    6696
6692:  BTFSC  F82.5
6694:  BRA    66A6
....................                                           { 
....................                                              while(!mas || !menos || !no){} 
6696:  BTFSS  F82.0
6698:  BRA    66A2
669A:  BTFSS  F82.1
669C:  BRA    66A2
669E:  BTFSC  F82.5
66A0:  BRA    66A4
66A2:  BRA    6696
....................                                              goto clave_incorrecta; 
66A4:  BRA    6702
....................                                           } 
....................                                        } 
66A6:  BRA    667E
....................                                     } 
....................                                     if(!mas || !si || !no) 
66A8:  BTFSS  F82.0
66AA:  BRA    66B4
66AC:  BTFSS  F82.2
66AE:  BRA    66B4
66B0:  BTFSC  F82.5
66B2:  BRA    66C4
....................                                     { 
....................                                        while(!mas || !si || !no){} 
66B4:  BTFSS  F82.0
66B6:  BRA    66C0
66B8:  BTFSS  F82.2
66BA:  BRA    66C0
66BC:  BTFSC  F82.5
66BE:  BRA    66C2
66C0:  BRA    66B4
....................                                        goto clave_incorrecta; 
66C2:  BRA    6702
....................                                     } 
....................                                  } 
66C4:  BRA    6674
....................                               } 
....................                               if(!mas || !si || !no) 
66C6:  BTFSS  F82.0
66C8:  BRA    66D2
66CA:  BTFSS  F82.2
66CC:  BRA    66D2
66CE:  BTFSC  F82.5
66D0:  BRA    66E2
....................                               { 
....................                                  while(!mas || !si || !no){} 
66D2:  BTFSS  F82.0
66D4:  BRA    66DE
66D6:  BTFSS  F82.2
66D8:  BRA    66DE
66DA:  BTFSC  F82.5
66DC:  BRA    66E0
66DE:  BRA    66D2
....................                                  goto clave_incorrecta; 
66E0:  BRA    6702
....................                               } 
....................                            } 
66E2:  BRA    666A
....................                         } 
....................                         if(!menos || !si || !no) 
66E4:  BTFSS  F82.1
66E6:  BRA    66F0
66E8:  BTFSS  F82.2
66EA:  BRA    66F0
66EC:  BTFSC  F82.5
66EE:  BRA    6700
....................                         { 
....................                            while(!menos || !si || !no){} 
66F0:  BTFSS  F82.1
66F2:  BRA    66FC
66F4:  BTFSS  F82.2
66F6:  BRA    66FC
66F8:  BTFSC  F82.5
66FA:  BRA    66FE
66FC:  BRA    66F0
....................                            goto clave_incorrecta; 
66FE:  BRA    6702
....................                         } 
....................                      } 
6700:  BRA    6660
....................  
....................                      clave_incorrecta: 
....................  
....................                      //Si la clave es incorrecta, lo indicamos y salimos 
....................                      lcd_send_byte(LCD_ORDEN, LCD_CLEAR); 
6702:  CLRF   x86
6704:  MOVLW  01
6706:  MOVWF  x87
6708:  CALL   1152
....................                      printf(lcd_putc, "  Clave\n  incorrecta"); 
670C:  CLRF   6F
670E:  MOVF   6F,W
6710:  CALL   03E4
6714:  IORLW  00
6716:  BZ    6722
6718:  INCF   6F,F
671A:  MOVWF  x81
671C:  CALL   11FE
6720:  BRA    670E
....................                      delay_ms(LCD_T_RETARDO); 
6722:  MOVLW  02
6724:  MOVWF  6F
6726:  MOVLW  FA
6728:  MOVWF  x88
672A:  CALL   10E6
672E:  DECFSZ 6F,F
6730:  BRA    6726
....................                      goto salir; 
6732:  BRA    675C
....................  
....................                      clave_correcta: 
....................  
....................                      //Si la clave es correcta, entramos en el modo revisión 
....................                      lcd_send_byte(LCD_ORDEN, LCD_CLEAR); 
6734:  CLRF   x86
6736:  MOVLW  01
6738:  MOVWF  x87
673A:  CALL   1152
....................                      printf(lcd_putc, "  Modo\n  revision"); 
673E:  CLRF   6F
6740:  MOVF   6F,W
6742:  CALL   0414
6746:  IORLW  00
6748:  BZ    6754
674A:  INCF   6F,F
674C:  MOVWF  x81
674E:  CALL   11FE
6752:  BRA    6740
....................  
....................                      //Dejamos la pantalla lcd fija 
....................                      set_tris_d(0xFF); 
6754:  MOVLW  FF
6756:  MOVWF  F95
....................  
....................                      //Representamos el contenido de los registros y activamos la interfaz RS-232 
....................                      representar_registros(); 
6758:  GOTO   3CFE
....................  
....................  
....................                      break; 
....................  
....................               default: 
....................  
....................                         //Aquí confluyen todas las salidas de la rutina de interfaz con el usuario 
....................                         salir: 
....................                         //Se muestra un mensaje de finalización 
....................                         lcd_send_byte(LCD_ORDEN,LCD_CLEAR); 
675C:  CLRF   x86
675E:  MOVLW  01
6760:  MOVWF  x87
6762:  CALL   1152
....................                         lcd_send_byte(LCD_ORDEN,LCD_NO_CURSOR); 
6766:  CLRF   x86
6768:  MOVLW  0C
676A:  MOVWF  x87
676C:  CALL   1152
....................                         printf(lcd_putc, "  Anulando\n  operacion..."); 
6770:  CLRF   6F
6772:  MOVF   6F,W
6774:  CALL   01C2
6778:  IORLW  00
677A:  BZ    6786
677C:  INCF   6F,F
677E:  MOVWF  x81
6780:  CALL   11FE
6784:  BRA    6772
....................                         delay_ms(LCD_T_RETARDO); 
6786:  MOVLW  02
6788:  MOVWF  6F
678A:  MOVLW  FA
678C:  MOVWF  x88
678E:  CALL   10E6
6792:  DECFSZ 6F,F
6794:  BRA    678A
....................  
....................          } 
....................  
....................          //Se desactiva el flag de indicación de la interrupción 
....................          lcd_int = FALSE; 
6796:  BCF    1E.4
....................  
....................          //Volvemos a activar las interrupciones 
....................          enable_interrupts(GLOBAL); 
6798:  MOVLW  C0
679A:  IORWF  FF2,F
....................       } 
....................  
....................       //Comenzamos el bloque de comprobación de parámetros y activación de los procesos necesarios. 
....................  
....................       //Comparamos primero la temperatura del agua en la caldera. Esta comprobación se 
....................       //realiza siempre, independientemente de que el sistema esté o no encendido. 
....................       if(!comp_caldera()) 
679C:  CALL   256C
67A0:  MOVF   01,F
67A2:  BNZ   67B4
....................       { 
....................          //Entramos aquí si la temperatura de la caldera es menor que la necesaria 
....................          if(temperatura_caldera_superada) 
67A4:  BTFSS  1E.0
67A6:  BRA    67AA
....................            //Si el flag estaba activado, lo desactivamos 
....................            temperatura_caldera_superada = FALSE; 
67A8:  BCF    1E.0
....................          if(!caldera_encendida) 
67AA:  BTFSC  F83.0
67AC:  BRA    67B2
....................             //Si no estaba encendida, la encendemos 
....................             encender_caldera(); 
67AE:  GOTO   582E
....................       } 
....................       else 
67B2:  BRA    67C2
....................       { 
....................          //Si la temperatura de la caldera es mayor que la necesaria, apagamos la caldera si está encendida 
....................          //y activamos el flag correspondiente 
....................          if(!temperatura_caldera_superada) 
67B4:  BTFSC  1E.0
67B6:  BRA    67BA
....................             temperatura_caldera_superada = TRUE; 
67B8:  BSF    1E.0
....................          if(caldera_encendida) 
67BA:  BTFSS  F83.0
67BC:  BRA    67C2
....................             apagar_caldera(); 
67BE:  GOTO   584A
....................       } 
....................  
....................       //Comprobamos la temperatura y almacenamos el resultado en una variable 
....................       aux = comprobar_temperatura(); 
67C2:  GOTO   59D0
67C6:  MOVFF  01,58
....................  
....................       //Comprobamos que el sistema no lleve encendido más de 4 horas, ya que en ese caso hay riesgo de avería 
....................       //(en realidad esta limitación deriva de un problema propio de representación en memoria). 
....................       //Ya leimos el tiempo en comprobar_temperatura(), así que no necesitamos leerlo de nuevo. 
....................       if(sistema_encendido && diferencia_tiempo(hora_encendido, minutos_encendido, tiempo.hours, tiempo.minutes)>240) 
67CA:  BTFSS  F83.2
67CC:  BRA    6888
67CE:  MOVFF  4C,77
67D2:  MOVFF  4D,78
67D6:  MOVFF  47,79
67DA:  MOVFF  46,7A
67DE:  CALL   2ACE
67E2:  MOVFF  02,70
67E6:  MOVFF  01,6F
67EA:  MOVF   70,F
67EC:  BNZ   67F4
67EE:  MOVF   6F,W
67F0:  SUBLW  F0
67F2:  BC    6888
....................       { 
....................          //Si la diferencia de tiempo es mayor que 4 horas, lo indicamos y apagamos el motor y el sistema 
....................          lcd_send_byte(LCD_ORDEN,LCD_CLEAR); 
67F4:  CLRF   x86
67F6:  MOVLW  01
67F8:  MOVWF  x87
67FA:  CALL   1152
....................          printf(lcd_putc, "Demasiado tiempo\nencendido!"); 
67FE:  CLRF   6F
6800:  MOVF   6F,W
6802:  CALL   0440
6806:  IORLW  00
6808:  BZ    6814
680A:  INCF   6F,F
680C:  MOVWF  x81
680E:  CALL   11FE
6812:  BRA    6800
....................          delay_ms(2*LCD_T_RETARDO); 
6814:  MOVLW  04
6816:  MOVWF  6F
6818:  MOVLW  FA
681A:  MOVWF  x88
681C:  CALL   10E6
6820:  DECFSZ 6F,F
6822:  BRA    6818
....................          lcd_send_byte(LCD_ORDEN,LCD_CLEAR); 
6824:  CLRF   x86
6826:  MOVLW  01
6828:  MOVWF  x87
682A:  CALL   1152
....................          printf(lcd_putc, "  Apagando\n  sistema..."); 
682E:  CLRF   6F
6830:  MOVF   6F,W
6832:  CALL   0158
6836:  IORLW  00
6838:  BZ    6844
683A:  INCF   6F,F
683C:  MOVWF  x81
683E:  CALL   11FE
6842:  BRA    6830
....................          apagar_sistema(); 
6844:  CALL   2D52
....................  
....................          if(motor) 
6848:  BTFSS  F83.1
684A:  BRA    684E
....................            motor = FALSE; 
684C:  BCF    F83.1
....................  
....................          //Si estaba encendido por alguna alarma, recuperamos el termostato anterior. 
....................          if(encendido_por_alarma) 
684E:  BTFSS  1E.2
6850:  BRA    6884
....................          { 
....................             termostato = termostato_provisional; 
6852:  MOVFF  26,22
6856:  MOVFF  25,21
685A:  MOVFF  24,20
685E:  MOVFF  23,1F
....................             //Almacenamos el valor en el sensor 
....................             ds1820_establecer_TH_TL(127.5, termostato); 
6862:  CLRF   7A
6864:  CLRF   79
6866:  MOVLW  7F
6868:  MOVWF  78
686A:  MOVLW  85
686C:  MOVWF  77
686E:  MOVFF  22,7E
6872:  MOVFF  21,7D
6876:  MOVFF  20,7C
687A:  MOVFF  1F,7B
687E:  CALL   184C
....................             encendido_por_alarma = FALSE; 
6882:  BCF    1E.2
....................          } 
....................  
....................          goto inicio; 
6884:  GOTO   5BFA
....................  
....................       } 
....................  
....................       //Comprobamos ahora la temperatura de la vivienda. Esto se realiza sólo si el sistema está encendido 
....................       if(aux && sistema_encendido && temperatura_caldera_superada) 
6888:  MOVF   58,F
688A:  BZ    689C
688C:  BTFSS  F83.2
688E:  BRA    689C
6890:  BTFSS  1E.0
6892:  BRA    689C
....................       { 
....................          //Si la temperatura es menor que la necesaria, el sistema está encendido y la temperatura del 
....................          //agua en la caldera es la adecuada, encendemos el motor de circulación del agua 
....................          if(!motor) 
6894:  BTFSC  F83.1
6896:  BRA    689A
....................             motor = TRUE; 
6898:  BSF    F83.1
....................  
....................       } 
....................       else if(motor) 
689A:  BRA    68A2
689C:  BTFSS  F83.1
689E:  BRA    68A2
....................          //Si no se cumplen las condiciones, apagamos el motor si está encendido 
....................          motor = FALSE; 
68A0:  BCF    F83.1
....................  
....................       //Comprobamos si ha saltado la alarma. Esta comprobación la hacemos por software en lugar de por 
....................       //interrupciones porque he tenido muchos problemas con las interrupciones de reloj en la placa 
....................       //que cogí el día de las pruebas, problemas relacionados con el borrado del flag de alarma del 
....................       //reloj. Ante esto, por tanto, aplico la solución gordiana de hacerlo por software para asegurar 
....................       //que funcione en la defensa. Puede verse un ejemplo de aplicación de las interrupciones de reloj 
....................       //en el modelo de PROTEUS del proyecto final. 
....................       //Para detectar si la alarma ha saltado vemos si la diferencia de tiempo entre ambas horas es igual. 
....................       //Esto no nos dará ningún problema en el tiempo de respuesta de la alarma (que se pase al minuto siguiente) 
....................       //ya que el WDT despierta al PIC varias veces por minuto. 
....................       if(alarma && (diferencia_tiempo(hora_alarma, minutos_alarma, tiempo.hours, tiempo.minutes)==0)) 
68A2:  BTFSS  1E.6
68A4:  BRA    68CC
68A6:  MOVFF  56,77
68AA:  MOVFF  57,78
68AE:  MOVFF  47,79
68B2:  MOVFF  46,7A
68B6:  CALL   2ACE
68BA:  MOVFF  02,70
68BE:  MOVFF  01,6F
68C2:  MOVF   6F,F
68C4:  BNZ   68CC
68C6:  MOVF   70,F
68C8:  BNZ   68CC
....................       { 
....................          alarma_int=TRUE; 
68CA:  BSF    1E.5
....................       } 
....................  
....................       //Activamos el perro guardián 
....................       setup_wdt(WDT_ON); 
68CC:  BSF    FD1.0
....................  
....................       //Ponemos a "dormir" al microcontrolador para que el gasto de energía sea menor 
....................       //Esto lo hacemos sólo si no se han levantado los flags de interrupción en estos segundos, 
....................       //ya que esto provocaría que se aplazase la gestión de la interrupción hasta que saltase el 
....................       //perro guardián. 
....................       if(!alarma_int && !lcd_int) 
68CE:  BTFSC  1E.5
68D0:  BRA    68D8
68D2:  BTFSC  1E.4
68D4:  BRA    68D8
....................          sleep(); 
68D6:  SLEEP 
....................  
....................    } 
68D8:  GOTO   5BFA
....................  
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 
.................... //*************************************************************************** 
.................... //    Descripción de los métodos utilizados ordenados en orden alfabético 
.................... //*************************************************************************** 
.................... //Puede verse una explicación general de la función de cada método al principio del programa 
....................  
.................... void apagar_caldera() 
.................... { 
68DC:  SLEEP 
....................    int hora, minutos, segundos; //Variables para el tiempo 
....................  
....................    //Leemos el tiempo 
....................    PCF8583_read_datetime(&tiempo); 
*
584A:  CLRF   78
584C:  MOVLW  45
584E:  MOVWF  77
5850:  CALL   285C
....................  
....................    //Copiamos en las variables 
....................    hora = tiempo.hours; 
5854:  MOVFF  47,6F
....................    minutos = tiempo.minutes; 
5858:  MOVFF  46,70
....................    segundos = tiempo.seconds; 
585C:  MOVFF  45,71
....................  
....................    //Sumamos al tiempo total de encendido de la caldera el tiempo que ha estado encendida esta vez 
....................    t_total_caldera = t_total_caldera + diferencia_tiempo_sec(hora_caldera, minutos_caldera, segundos_caldera, hora, minutos, segundos); 
5860:  MOVFF  4E,77
5864:  MOVFF  4F,78
5868:  MOVFF  50,79
586C:  MOVFF  6F,7A
5870:  MOVFF  70,7B
5874:  MOVFF  71,7C
5878:  CALL   2BBA
587C:  MOVF   01,W
587E:  ADDWF  51,F
5880:  MOVF   02,W
5882:  ADDWFC 52,F
....................  
....................    //Apagamos la caldera 
....................    caldera_encendida = FALSE; 
5884:  BCF    F83.0
.................... } 
5886:  GOTO   67C2 (RETURN)
....................  
.................... //------------------------------------------------------------------------------------------------------------------------------------ 
....................  
.................... void apagar_sistema() 
.................... { 
....................    long minutos_trans;  //Minutos transcurridos desde el encendido del sistema 
....................    int t_entera, t_decimal; //Temperatura del hogar en ese momento (parte entera y decimal) 
....................    float temperatura;  //Temperatura leída 
....................  
....................  
....................    //Si llegamos al límite de la memoria, se resetea el indicador 
....................    //Por utilizar la memoria del PIC sólo contamos con 26 registros de fecha 
....................    if(num_registros > 26) 
*
2D52:  MOVF   53,W
2D54:  SUBLW  1A
2D56:  BC    2D5A
....................       num_registros = 0; 
2D58:  CLRF   53
....................  
....................    //Leemos el tiempo actual 
....................    PCF8583_read_datetime(&tiempo); 
2D5A:  CLRF   78
2D5C:  MOVLW  45
2D5E:  MOVWF  77
2D60:  RCALL  285C
....................  
....................    //Calculamos los minutos transcurridos desde el encendido como una diferencia de tiempos 
....................    minutos_trans = diferencia_tiempo(hora_encendido, minutos_encendido, tiempo.hours, tiempo.minutes); 
2D62:  MOVFF  4C,77
2D66:  MOVFF  4D,78
2D6A:  MOVFF  47,79
2D6E:  MOVFF  46,7A
2D72:  RCALL  2ACE
2D74:  MOVFF  02,70
2D78:  MOVFF  01,6F
....................  
....................    //Leemos la temperatura en ese momento 
....................    temperatura = ds1820_read(); 
2D7C:  CALL   20EA
2D80:  MOVFF  03,76
2D84:  MOVFF  02,75
2D88:  MOVFF  01,74
2D8C:  MOVFF  00,73
....................  
....................    //Descomponemos la temperatura en su parte entera y parte decimal para almacenarla 
....................    t_entera = (int)temperatura; 
2D90:  MOVFF  76,8A
2D94:  MOVFF  75,89
2D98:  MOVFF  74,88
2D9C:  MOVFF  73,87
2DA0:  CALL   16B2
2DA4:  MOVFF  01,71
....................    t_decimal = (int)((temperatura-t_entera)*100); 
2DA8:  MOVLB  2
2DAA:  CLRF   x89
2DAC:  MOVFF  71,288
2DB0:  MOVLB  0
2DB2:  CALL   24BE
2DB6:  BSF    FD8.1
2DB8:  MOVFF  76,285
2DBC:  MOVFF  75,284
2DC0:  MOVFF  74,283
2DC4:  MOVFF  73,282
2DC8:  MOVFF  03,289
2DCC:  MOVFF  02,288
2DD0:  MOVFF  01,287
2DD4:  MOVFF  00,286
2DD8:  CALL   2244
2DDC:  MOVFF  00,77
2DE0:  MOVFF  01,78
2DE4:  MOVFF  02,79
2DE8:  MOVFF  03,7A
2DEC:  MOVFF  03,2A1
2DF0:  MOVFF  02,2A0
2DF4:  MOVFF  01,29F
2DF8:  MOVFF  00,29E
2DFC:  MOVLB  2
2DFE:  CLRF   xA5
2E00:  CLRF   xA4
2E02:  MOVLW  48
2E04:  MOVWF  xA3
2E06:  MOVLW  85
2E08:  MOVWF  xA2
2E0A:  MOVLB  0
2E0C:  CALL   1754
2E10:  MOVFF  03,8A
2E14:  MOVFF  02,89
2E18:  MOVFF  01,88
2E1C:  MOVFF  00,87
2E20:  CALL   16B2
2E24:  MOVFF  01,72
....................  
....................    //Si la caldera estaba encendida, sumamos el último intervalo de encendido al tiempo total 
....................    if(caldera_encendida) 
2E28:  BTFSS  F83.0
2E2A:  BRA    2E4E
....................       t_total_caldera = t_total_caldera + diferencia_tiempo_sec(hora_caldera, minutos_caldera, segundos_caldera, tiempo.hours, tiempo.minutes, tiempo.seconds); 
2E2C:  MOVFF  4E,77
2E30:  MOVFF  4F,78
2E34:  MOVFF  50,79
2E38:  MOVFF  47,7A
2E3C:  MOVFF  46,7B
2E40:  MOVFF  45,7C
2E44:  RCALL  2BBA
2E46:  MOVF   01,W
2E48:  ADDWF  51,F
2E4A:  MOVF   02,W
2E4C:  ADDWFC 52,F
....................  
....................    //Calculamos el año en el que nos encontramos 
....................    if(anno_actual_0_to_3 != tiempo.year) 
2E4E:  MOVF   4A,W
2E50:  SUBWF  55,W
2E52:  BZ    2EAC
....................    { 
....................       //Si el año que teníamos almacenado no es igual que el que marca el reloj, 
....................       //debemos de actualizar las variables correspondientes. 
....................       //Suponemos que al menos se conecta el sistema una vez al año 
....................       anno_actual++; 
2E54:  INCF   54,F
....................       anno_actual_0_to_3++; 
2E56:  INCF   55,F
....................  
....................       //Guardamos los valores en memoria 
....................       write_eeprom(eeprom_anno_actual, anno_actual); 
2E58:  MOVLW  03
2E5A:  MOVWF  FA9
2E5C:  MOVFF  54,FA8
2E60:  BCF    FA6.6
2E62:  BCF    FA6.7
2E64:  BSF    FA6.2
2E66:  MOVFF  FF2,00
2E6A:  BCF    FF2.7
2E6C:  MOVLB  F
2E6E:  MOVLW  55
2E70:  MOVWF  FA7
2E72:  MOVLW  AA
2E74:  MOVWF  FA7
2E76:  BSF    FA6.1
2E78:  BTFSC  FA6.1
2E7A:  BRA    2E78
2E7C:  BCF    FA6.2
2E7E:  MOVF   00,W
2E80:  IORWF  FF2,F
....................       write_eeprom(eeprom_anno_0_to_3, anno_actual_0_to_3); 
2E82:  MOVLW  04
2E84:  MOVWF  FA9
2E86:  MOVFF  55,FA8
2E8A:  BCF    FA6.6
2E8C:  BCF    FA6.7
2E8E:  BSF    FA6.2
2E90:  MOVFF  FF2,00
2E94:  BCF    FF2.7
2E96:  MOVLW  55
2E98:  MOVWF  FA7
2E9A:  MOVLW  AA
2E9C:  MOVWF  FA7
2E9E:  BSF    FA6.1
2EA0:  BTFSC  FA6.1
2EA2:  BRA    2EA0
2EA4:  BCF    FA6.2
2EA6:  MOVF   00,W
2EA8:  IORWF  FF2,F
2EAA:  MOVLB  0
....................    } 
....................  
....................  
....................    //Almacenamos todos los datos requeridos 
....................    write_eeprom(eeprom_registros + (num_registros)*10    , tiempo.day);                  //Día de desconexión 
2EAC:  MOVF   53,W
2EAE:  MULLW  0A
2EB0:  MOVF   FF3,W
2EB2:  ADDLW  14
2EB4:  MOVWF  77
2EB6:  MOVWF  FA9
2EB8:  MOVFF  48,FA8
2EBC:  BCF    FA6.6
2EBE:  BCF    FA6.7
2EC0:  BSF    FA6.2
2EC2:  MOVFF  FF2,00
2EC6:  BCF    FF2.7
2EC8:  MOVLB  F
2ECA:  MOVLW  55
2ECC:  MOVWF  FA7
2ECE:  MOVLW  AA
2ED0:  MOVWF  FA7
2ED2:  BSF    FA6.1
2ED4:  BTFSC  FA6.1
2ED6:  BRA    2ED4
2ED8:  BCF    FA6.2
2EDA:  MOVF   00,W
2EDC:  IORWF  FF2,F
....................    write_eeprom(eeprom_registros + (num_registros)*10 + 1, tiempo.month);                //Mes de desconexión 
2EDE:  MOVF   53,W
2EE0:  MULLW  0A
2EE2:  MOVF   FF3,W
2EE4:  ADDLW  14
2EE6:  ADDLW  01
2EE8:  MOVWF  78
2EEA:  MOVWF  FA9
2EEC:  MOVFF  49,FA8
2EF0:  BCF    FA6.6
2EF2:  BCF    FA6.7
2EF4:  BSF    FA6.2
2EF6:  MOVFF  FF2,00
2EFA:  BCF    FF2.7
2EFC:  MOVLW  55
2EFE:  MOVWF  FA7
2F00:  MOVLW  AA
2F02:  MOVWF  FA7
2F04:  BSF    FA6.1
2F06:  BTFSC  FA6.1
2F08:  BRA    2F06
2F0A:  BCF    FA6.2
2F0C:  MOVF   00,W
2F0E:  IORWF  FF2,F
....................    write_eeprom(eeprom_registros + (num_registros)*10 + 2, anno_actual);                 //Año de desconexión 
2F10:  MOVF   53,W
2F12:  MULLW  0A
2F14:  MOVF   FF3,W
2F16:  ADDLW  14
2F18:  ADDLW  02
2F1A:  MOVWF  78
2F1C:  MOVWF  FA9
2F1E:  MOVFF  54,FA8
2F22:  BCF    FA6.6
2F24:  BCF    FA6.7
2F26:  BSF    FA6.2
2F28:  MOVFF  FF2,00
2F2C:  BCF    FF2.7
2F2E:  MOVLW  55
2F30:  MOVWF  FA7
2F32:  MOVLW  AA
2F34:  MOVWF  FA7
2F36:  BSF    FA6.1
2F38:  BTFSC  FA6.1
2F3A:  BRA    2F38
2F3C:  BCF    FA6.2
2F3E:  MOVF   00,W
2F40:  IORWF  FF2,F
....................    write_eeprom(eeprom_registros + (num_registros)*10 + 3, tiempo.hours);                //Hora de desconexión 
2F42:  MOVF   53,W
2F44:  MULLW  0A
2F46:  MOVF   FF3,W
2F48:  ADDLW  14
2F4A:  ADDLW  03
2F4C:  MOVWF  78
2F4E:  MOVWF  FA9
2F50:  MOVFF  47,FA8
2F54:  BCF    FA6.6
2F56:  BCF    FA6.7
2F58:  BSF    FA6.2
2F5A:  MOVFF  FF2,00
2F5E:  BCF    FF2.7
2F60:  MOVLW  55
2F62:  MOVWF  FA7
2F64:  MOVLW  AA
2F66:  MOVWF  FA7
2F68:  BSF    FA6.1
2F6A:  BTFSC  FA6.1
2F6C:  BRA    2F6A
2F6E:  BCF    FA6.2
2F70:  MOVF   00,W
2F72:  IORWF  FF2,F
....................    write_eeprom(eeprom_registros + (num_registros)*10 + 4, tiempo.minutes);              //Minutos de desconexión 
2F74:  MOVF   53,W
2F76:  MULLW  0A
2F78:  MOVF   FF3,W
2F7A:  ADDLW  14
2F7C:  ADDLW  04
2F7E:  MOVWF  78
2F80:  MOVWF  FA9
2F82:  MOVFF  46,FA8
2F86:  BCF    FA6.6
2F88:  BCF    FA6.7
2F8A:  BSF    FA6.2
2F8C:  MOVFF  FF2,00
2F90:  BCF    FF2.7
2F92:  MOVLW  55
2F94:  MOVWF  FA7
2F96:  MOVLW  AA
2F98:  MOVWF  FA7
2F9A:  BSF    FA6.1
2F9C:  BTFSC  FA6.1
2F9E:  BRA    2F9C
2FA0:  BCF    FA6.2
2FA2:  MOVF   00,W
2FA4:  IORWF  FF2,F
....................    write_eeprom(eeprom_registros + (num_registros)*10 + 5, t_entera);                    //Valor entero de última temperatura medida 
2FA6:  MOVF   53,W
2FA8:  MULLW  0A
2FAA:  MOVF   FF3,W
2FAC:  ADDLW  14
2FAE:  ADDLW  05
2FB0:  MOVWF  78
2FB2:  MOVWF  FA9
2FB4:  MOVFF  71,FA8
2FB8:  BCF    FA6.6
2FBA:  BCF    FA6.7
2FBC:  BSF    FA6.2
2FBE:  MOVFF  FF2,00
2FC2:  BCF    FF2.7
2FC4:  MOVLW  55
2FC6:  MOVWF  FA7
2FC8:  MOVLW  AA
2FCA:  MOVWF  FA7
2FCC:  BSF    FA6.1
2FCE:  BTFSC  FA6.1
2FD0:  BRA    2FCE
2FD2:  BCF    FA6.2
2FD4:  MOVF   00,W
2FD6:  IORWF  FF2,F
....................    write_eeprom(eeprom_registros + (num_registros)*10 + 6, t_decimal);                   //Valor decimal de última temperatura medida 
2FD8:  MOVF   53,W
2FDA:  MULLW  0A
2FDC:  MOVF   FF3,W
2FDE:  ADDLW  14
2FE0:  ADDLW  06
2FE2:  MOVWF  78
2FE4:  MOVWF  FA9
2FE6:  MOVFF  72,FA8
2FEA:  BCF    FA6.6
2FEC:  BCF    FA6.7
2FEE:  BSF    FA6.2
2FF0:  MOVFF  FF2,00
2FF4:  BCF    FF2.7
2FF6:  MOVLW  55
2FF8:  MOVWF  FA7
2FFA:  MOVLW  AA
2FFC:  MOVWF  FA7
2FFE:  BSF    FA6.1
3000:  BTFSC  FA6.1
3002:  BRA    3000
3004:  BCF    FA6.2
3006:  MOVF   00,W
3008:  IORWF  FF2,F
....................    write_eeprom(eeprom_registros + (num_registros)*10 + 7, (unsigned int)minutos_trans);          //Minutos transcurridos desde el encendido 
300A:  MOVF   53,W
300C:  MULLW  0A
300E:  MOVF   FF3,W
3010:  ADDLW  14
3012:  ADDLW  07
3014:  MOVWF  78
3016:  MOVWF  FA9
3018:  MOVFF  6F,FA8
301C:  BCF    FA6.6
301E:  BCF    FA6.7
3020:  BSF    FA6.2
3022:  MOVFF  FF2,00
3026:  BCF    FF2.7
3028:  MOVLW  55
302A:  MOVWF  FA7
302C:  MOVLW  AA
302E:  MOVWF  FA7
3030:  BSF    FA6.1
3032:  BTFSC  FA6.1
3034:  BRA    3032
3036:  BCF    FA6.2
3038:  MOVF   00,W
303A:  IORWF  FF2,F
....................    write_eeprom(eeprom_registros + (num_registros)*10 + 8, (unsigned int)(t_total_caldera/60));   //Tiempo total que ha estado encendida la caldera 
303C:  MOVF   53,W
303E:  MULLW  0A
3040:  MOVF   FF3,W
3042:  ADDLW  14
3044:  ADDLW  08
3046:  MOVWF  78
3048:  MOVFF  52,7A
304C:  MOVFF  51,79
3050:  CLRF   7C
3052:  MOVLW  3C
3054:  MOVWF  7B
3056:  MOVLB  0
3058:  BRA    2D0C
305A:  MOVFF  01,79
305E:  MOVFF  78,FA9
3062:  MOVFF  01,FA8
3066:  BCF    FA6.6
3068:  BCF    FA6.7
306A:  BSF    FA6.2
306C:  MOVFF  FF2,00
3070:  BCF    FF2.7
3072:  MOVLB  F
3074:  MOVLW  55
3076:  MOVWF  FA7
3078:  MOVLW  AA
307A:  MOVWF  FA7
307C:  BSF    FA6.1
307E:  BTFSC  FA6.1
3080:  BRA    307E
3082:  BCF    FA6.2
3084:  MOVF   00,W
3086:  IORWF  FF2,F
....................                                                                                                  //en este intervalo (en minutos) 
....................  
....................    //Guardamos también el último valor del termostato, teniendo en cuenta la histéresis del sistema 
....................    if(temp_habitacion_superada) 
3088:  BTFSS  1E.1
308A:  BRA    3104
....................       write_eeprom(eeprom_registros + (num_registros)*10 + 9, (unsigned int)(termostato+histeresis_vivienda)); 
308C:  MOVF   53,W
308E:  MULLW  0A
3090:  MOVF   FF3,W
3092:  ADDLW  14
3094:  ADDLW  09
3096:  MOVWF  78
3098:  BCF    FD8.1
309A:  MOVFF  22,285
309E:  MOVFF  21,284
30A2:  MOVFF  20,283
30A6:  MOVFF  1F,282
30AA:  MOVFF  2E,289
30AE:  MOVFF  2D,288
30B2:  MOVFF  2C,287
30B6:  MOVFF  2B,286
30BA:  MOVLB  0
30BC:  CALL   2244
30C0:  MOVFF  03,8A
30C4:  MOVFF  02,89
30C8:  MOVFF  01,88
30CC:  MOVFF  00,87
30D0:  CALL   16B2
30D4:  MOVFF  01,79
30D8:  MOVFF  78,FA9
30DC:  MOVFF  01,FA8
30E0:  BCF    FA6.6
30E2:  BCF    FA6.7
30E4:  BSF    FA6.2
30E6:  MOVFF  FF2,00
30EA:  BCF    FF2.7
30EC:  MOVLB  F
30EE:  MOVLW  55
30F0:  MOVWF  FA7
30F2:  MOVLW  AA
30F4:  MOVWF  FA7
30F6:  BSF    FA6.1
30F8:  BTFSC  FA6.1
30FA:  BRA    30F8
30FC:  BCF    FA6.2
30FE:  MOVF   00,W
3100:  IORWF  FF2,F
....................    else 
3102:  BRA    3154
....................       write_eeprom(eeprom_registros + (num_registros)*10 + 9, (unsigned int)termostato); 
3104:  MOVF   53,W
3106:  MULLW  0A
3108:  MOVF   FF3,W
310A:  ADDLW  14
310C:  ADDLW  09
310E:  MOVWF  78
3110:  MOVFF  22,8A
3114:  MOVFF  21,89
3118:  MOVFF  20,88
311C:  MOVFF  1F,87
3120:  MOVLB  0
3122:  CALL   16B2
3126:  MOVFF  01,79
312A:  MOVFF  78,FA9
312E:  MOVFF  01,FA8
3132:  BCF    FA6.6
3134:  BCF    FA6.7
3136:  BSF    FA6.2
3138:  MOVFF  FF2,00
313C:  BCF    FF2.7
313E:  MOVLB  F
3140:  MOVLW  55
3142:  MOVWF  FA7
3144:  MOVLW  AA
3146:  MOVWF  FA7
3148:  BSF    FA6.1
314A:  BTFSC  FA6.1
314C:  BRA    314A
314E:  BCF    FA6.2
3150:  MOVF   00,W
3152:  IORWF  FF2,F
....................  
....................    //Aumentamos en uno el número de registros 
....................    num_registros++; 
3154:  INCF   53,F
....................  
....................    //Guardamos el número de registros en memoria 
....................    write_eeprom(eeprom_num_registros, num_registros); 
3156:  MOVLW  02
3158:  MOVWF  FA9
315A:  MOVFF  53,FA8
315E:  BCF    FA6.6
3160:  BCF    FA6.7
3162:  BSF    FA6.2
3164:  MOVFF  FF2,00
3168:  BCF    FF2.7
316A:  MOVLW  55
316C:  MOVWF  FA7
316E:  MOVLW  AA
3170:  MOVWF  FA7
3172:  BSF    FA6.1
3174:  BTFSC  FA6.1
3176:  BRA    3174
3178:  BCF    FA6.2
317A:  MOVF   00,W
317C:  IORWF  FF2,F
....................  
....................    //Finalmente, apagamos el sistema 
....................    sistema_encendido = FALSE; 
317E:  BCF    F83.2
.................... } 
3180:  MOVLB  0
3182:  RETLW  00
....................  
.................... //------------------------------------------------------------------------------------------------------------------------------------ 
....................  
.................... int buscar_numero(int led_unidades, int min, int max, int valor_inicial){ 
....................    signed int input; 
....................    unsigned int32 contador; 
....................  
....................    //Iniciamos al valor indicado 
....................    input = valor_inicial; 
*
34DC:  MOVFF  74,75
....................  
....................    //Activamos el cursor de la pantalla 
....................    lcd_send_byte(LCD_ORDEN, LCD_CURSOR); 
34E0:  CLRF   x86
34E2:  MOVLW  0E
34E4:  MOVWF  x87
34E6:  CALL   1152
....................  
....................    //Se muestra por pantalla 
....................    lcd_gotoxy(led_unidades,2); 
34EA:  MOVFF  71,82
34EE:  MOVLW  02
34F0:  MOVWF  x83
34F2:  CALL   11DC
....................    //Si el número es menor que 10, le añadimos antes un 0 
....................    if(input<10) 
34F6:  BTFSC  75.7
34F8:  BRA    3500
34FA:  MOVF   75,W
34FC:  SUBLW  09
34FE:  BNC   3516
....................       printf(lcd_putc, "0"); 
3500:  CLRF   7A
3502:  MOVF   7A,W
3504:  CALL   0476
3508:  IORLW  00
350A:  BZ    3516
350C:  INCF   7A,F
350E:  MOVWF  x81
3510:  CALL   11FE
3514:  BRA    3502
....................    printf(lcd_putc,"%i",input); 
3516:  MOVFF  75,7A
351A:  MOVLW  1F
351C:  MOVWF  7B
351E:  RCALL  31B0
....................    //Regresamos el cursor a su posición 
....................    lcd_gotoxy(led_unidades,2); 
3520:  MOVFF  71,82
3524:  MOVLW  02
3526:  MOVWF  x83
3528:  CALL   11DC
....................  
....................    while(1) 
....................    { 
....................       if(!mas) 
352C:  BTFSC  F82.0
352E:  BRA    3600
....................       { 
....................          //Si se pulsa el botón de +, se aumenta el valor de input 
....................          input++; 
3530:  INCF   75,F
....................          //Si llegamos al límite de los valores, reseteamos 
....................          if(input>max) 
3532:  BTFSC  75.7
3534:  BRA    3540
3536:  MOVF   75,W
3538:  SUBWF  73,W
353A:  BC    3540
....................             input = min; 
353C:  MOVFF  72,75
....................          //Si es un número menor que 10, añadimos un 0 antes 
....................          if(input<10) 
3540:  BTFSC  75.7
3542:  BRA    354A
3544:  MOVF   75,W
3546:  SUBLW  09
3548:  BNC   3560
....................             printf(lcd_putc,"0"); 
354A:  CLRF   7A
354C:  MOVF   7A,W
354E:  CALL   0476
3552:  IORLW  00
3554:  BZ    3560
3556:  INCF   7A,F
3558:  MOVWF  x81
355A:  CALL   11FE
355E:  BRA    354C
....................          //Se muestra por pantalla 
....................          printf(lcd_putc,"%i",input); 
3560:  MOVFF  75,7A
3564:  MOVLW  1F
3566:  MOVWF  7B
3568:  RCALL  31B0
....................          //Regresamos el cursor a su posición 
....................          lcd_gotoxy(led_unidades,2); 
356A:  MOVFF  71,82
356E:  MOVLW  02
3570:  MOVWF  x83
3572:  CALL   11DC
....................          //Esperamos a que se levante la tecla 
....................          //Además introducimos un mecanismo de avance rápido que permite pasar de un 
....................          //valor a otro rápidamente sin más que mantener pulsada la tecla 
....................          contador = 1; 
3576:  CLRF   79
3578:  CLRF   78
357A:  CLRF   77
357C:  MOVLW  01
357E:  MOVWF  76
....................          while(!mas) 
....................          { 
3580:  BTFSC  F82.0
3582:  BRA    35FE
....................           if(contador>40000) 
3584:  MOVF   79,F
3586:  BNZ   359C
3588:  MOVF   78,F
358A:  BNZ   359C
358C:  MOVF   77,W
358E:  SUBLW  9B
3590:  BC    35EC
3592:  XORLW  FF
3594:  BNZ   359C
3596:  MOVF   76,W
3598:  SUBLW  40
359A:  BC    35EC
....................           { 
....................             input++; 
359C:  INCF   75,F
....................             //Si llegamos al límite de los valores, reseteamos 
....................             if(input>max) 
359E:  BTFSC  75.7
35A0:  BRA    35AC
35A2:  MOVF   75,W
35A4:  SUBWF  73,W
35A6:  BC    35AC
....................                input = min; 
35A8:  MOVFF  72,75
....................             //Si es un número menor que 10, añadimos un 0 antes 
....................             if(input<10) 
35AC:  BTFSC  75.7
35AE:  BRA    35B6
35B0:  MOVF   75,W
35B2:  SUBLW  09
35B4:  BNC   35CC
....................                printf(lcd_putc,"0"); 
35B6:  CLRF   7A
35B8:  MOVF   7A,W
35BA:  CALL   0476
35BE:  IORLW  00
35C0:  BZ    35CC
35C2:  INCF   7A,F
35C4:  MOVWF  x81
35C6:  CALL   11FE
35CA:  BRA    35B8
....................             //Se muestra por pantalla 
....................             printf(lcd_putc,"%i",input); 
35CC:  MOVFF  75,7A
35D0:  MOVLW  1F
35D2:  MOVWF  7B
35D4:  RCALL  31B0
....................             //Regresamos el cursor a su posición 
....................             lcd_gotoxy(led_unidades,2); 
35D6:  MOVFF  71,82
35DA:  MOVLW  02
35DC:  MOVWF  x83
35DE:  CALL   11DC
....................             //Introducimos un poco de retraso 
....................             delay_ms(200); 
35E2:  MOVLW  C8
35E4:  MOVWF  x88
35E6:  CALL   10E6
....................           }else 
35EA:  BRA    35FC
....................             contador++; 
35EC:  MOVLW  01
35EE:  ADDWF  76,F
35F0:  BTFSC  FD8.0
35F2:  INCF   77,F
35F4:  BTFSC  FD8.2
35F6:  INCF   78,F
35F8:  BTFSC  FD8.2
35FA:  INCF   79,F
....................          } 
35FC:  BRA    3580
....................          continue; 
35FE:  BRA    352C
....................       } 
....................       if(!menos) 
3600:  BTFSC  F82.1
3602:  BRA    36D4
....................       { 
....................          //Si se pulsa el botón de -, se decrementa el valor de input 
....................          input--; 
3604:  DECF   75,F
....................          //Si llegamos al límite de las opciones, reseteamos 
....................          if(input<min) 
3606:  BTFSC  75.7
3608:  BRA    3610
360A:  MOVF   72,W
360C:  SUBWF  75,W
360E:  BC    3614
....................             input = max; 
3610:  MOVFF  73,75
....................          //Si es un número menor que 10, añadimos un 0 antes 
....................          if(input<10) 
3614:  BTFSC  75.7
3616:  BRA    361E
3618:  MOVF   75,W
361A:  SUBLW  09
361C:  BNC   3634
....................             printf(lcd_putc,"0"); 
361E:  CLRF   7A
3620:  MOVF   7A,W
3622:  CALL   0476
3626:  IORLW  00
3628:  BZ    3634
362A:  INCF   7A,F
362C:  MOVWF  x81
362E:  CALL   11FE
3632:  BRA    3620
....................          //Se muestra por pantalla 
....................          printf(lcd_putc,"%i",input); 
3634:  MOVFF  75,7A
3638:  MOVLW  1F
363A:  MOVWF  7B
363C:  RCALL  31B0
....................          //Regresamos el cursor a su posición 
....................          lcd_gotoxy(led_unidades,2); 
363E:  MOVFF  71,82
3642:  MOVLW  02
3644:  MOVWF  x83
3646:  CALL   11DC
....................          //Esperamos a que se levante la tecla 
....................          //Además introducimos un mecanismo de avance rápido que permite pasar de un 
....................          //valor a otro rápidamente sin más que mantener pulsada la tecla 
....................          contador = 1; 
364A:  CLRF   79
364C:  CLRF   78
364E:  CLRF   77
3650:  MOVLW  01
3652:  MOVWF  76
....................          while(!menos){ 
3654:  BTFSC  F82.1
3656:  BRA    36D2
....................           if(contador>40000) 
3658:  MOVF   79,F
365A:  BNZ   3670
365C:  MOVF   78,F
365E:  BNZ   3670
3660:  MOVF   77,W
3662:  SUBLW  9B
3664:  BC    36C0
3666:  XORLW  FF
3668:  BNZ   3670
366A:  MOVF   76,W
366C:  SUBLW  40
366E:  BC    36C0
....................           { 
....................             input--; 
3670:  DECF   75,F
....................             //Si llegamos al límite de las opciones, reseteamos 
....................             if(input<min) 
3672:  BTFSC  75.7
3674:  BRA    367C
3676:  MOVF   72,W
3678:  SUBWF  75,W
367A:  BC    3680
....................                input = max; 
367C:  MOVFF  73,75
....................             //Si es un número menor que 10, añadimos un 0 antes 
....................             if(input<10) 
3680:  BTFSC  75.7
3682:  BRA    368A
3684:  MOVF   75,W
3686:  SUBLW  09
3688:  BNC   36A0
....................                printf(lcd_putc,"0"); 
368A:  CLRF   7A
368C:  MOVF   7A,W
368E:  CALL   0476
3692:  IORLW  00
3694:  BZ    36A0
3696:  INCF   7A,F
3698:  MOVWF  x81
369A:  CALL   11FE
369E:  BRA    368C
....................             //Se muestra por pantalla 
....................             printf(lcd_putc,"%i",input); 
36A0:  MOVFF  75,7A
36A4:  MOVLW  1F
36A6:  MOVWF  7B
36A8:  RCALL  31B0
....................             //Regresamos el cursor a su posición 
....................             lcd_gotoxy(led_unidades,2); 
36AA:  MOVFF  71,82
36AE:  MOVLW  02
36B0:  MOVWF  x83
36B2:  CALL   11DC
....................             //Introducimos un poco de retraso 
....................             delay_ms(200); 
36B6:  MOVLW  C8
36B8:  MOVWF  x88
36BA:  CALL   10E6
....................           }else 
36BE:  BRA    36D0
....................             contador++; 
36C0:  MOVLW  01
36C2:  ADDWF  76,F
36C4:  BTFSC  FD8.0
36C6:  INCF   77,F
36C8:  BTFSC  FD8.2
36CA:  INCF   78,F
36CC:  BTFSC  FD8.2
36CE:  INCF   79,F
....................          } 
36D0:  BRA    3654
....................          continue; 
36D2:  BRA    352C
....................       } 
....................       if(!si) 
36D4:  BTFSC  F82.2
36D6:  BRA    36E0
....................       { 
....................          //Esperamos a que se suelte la tecla 
....................          while(!si){} 
36D8:  BTFSC  F82.2
36DA:  BRA    36DE
36DC:  BRA    36D8
....................          break; 
36DE:  BRA    36F2
....................       } 
....................       if(!no) 
36E0:  BTFSC  F82.5
36E2:  BRA    36F0
....................       { 
....................          //Si se pulsa No, devolvemos el valor correspondiente 
....................          input = NOCODE; 
36E4:  MOVLW  64
36E6:  MOVWF  75
....................          //Esperamos... 
....................          while(!no){} 
36E8:  BTFSC  F82.5
36EA:  BRA    36EE
36EC:  BRA    36E8
....................          break; 
36EE:  BRA    36F2
....................       } 
....................  
....................    } 
36F0:  BRA    352C
....................  
....................    //Inhabilitamos el cursor de nuevo 
....................    lcd_send_byte(LCD_ORDEN, LCD_NO_CURSOR); 
36F2:  CLRF   x86
36F4:  MOVLW  0C
36F6:  MOVWF  x87
36F8:  CALL   1152
....................  
....................    //Devolvemos el valor correspondiente 
....................    return input; 
36FC:  MOVFF  75,01
.................... } 
3700:  RETLW  00
....................  
.................... //------------------------------------------------------------------------------------------------------------------------------------ 
....................  
.................... int buscar_numero_rs232(){ 
....................    char c[3]; //Cadena que contendrá los números en caracteres 
....................  
....................    //Iniciamos los caracteres a valores nulos que no se correspondan con números 
....................    //Además, esto nos servirá para que c[2] marque el fin de la cadena a la hora de aplicar 
....................    //el método atoi(). 
....................    c[0]=c[1]=c[2]='\0'; 
*
1428:  CLRF   79
142A:  MOVFF  79,78
142E:  MOVFF  78,77
....................  
....................    //Leemos la primera cifra del número 
....................    while(!isdigit(c[0]) && c[0]!='\b') 
....................       c[0]=getch(); 
1432:  MOVF   77,W
1434:  SUBLW  2F
1436:  BC    143E
1438:  MOVF   77,W
143A:  SUBLW  39
143C:  BC    144E
143E:  MOVF   77,W
1440:  SUBLW  08
1442:  BZ    144E
1444:  BTFSS  F9E.5
1446:  BRA    1444
1448:  MOVFF  FAE,77
144C:  BRA    1432
....................    //Si se trata de un "backspace", devolvemos un mensaje de anulación de operación 
....................    if(c[0]=='\b') 
144E:  MOVF   77,W
1450:  SUBLW  08
1452:  BNZ   145A
....................       return NOCODE; 
1454:  MOVLW  64
1456:  MOVWF  01
1458:  BRA    149C
....................    //Imprimimos la primera cifra 
....................    printf("%c", c[0]); 
145A:  MOVF   77,W
145C:  BTFSS  F9E.4
145E:  BRA    145C
1460:  MOVWF  FAD
....................  
....................    //Leemos la segunda cifra del número, procediendo de la misma manera 
....................    while(!isdigit(c[1]) && c[1]!='\b') 
....................       c[1]=getch(); 
1462:  MOVF   78,W
1464:  SUBLW  2F
1466:  BC    146E
1468:  MOVF   78,W
146A:  SUBLW  39
146C:  BC    147E
146E:  MOVF   78,W
1470:  SUBLW  08
1472:  BZ    147E
1474:  BTFSS  F9E.5
1476:  BRA    1474
1478:  MOVFF  FAE,78
147C:  BRA    1462
....................    if(c[1]=='\b') 
147E:  MOVF   78,W
1480:  SUBLW  08
1482:  BNZ   148A
....................       return NOCODE; 
1484:  MOVLW  64
1486:  MOVWF  01
1488:  BRA    149C
....................    printf("%c", c[1]); 
148A:  MOVF   78,W
148C:  BTFSS  F9E.4
148E:  BRA    148C
1490:  MOVWF  FAD
....................  
....................    //Transformamos a entero la cadena y la devolvemos 
....................    return atoi(c); 
1492:  CLRF   7B
1494:  MOVLW  77
1496:  MOVWF  7A
1498:  RCALL  128E
149A:  MOVF   01,W
....................  
.................... } 
149C:  RETLW  00
....................  
.................... //------------------------------------------------------------------------------------------------------------------------------------ 
....................  
.................... int comp_caldera() 
.................... { 
....................    //Suponemos una variación de la temperatura del agua en la caldera de t_max_calderaºC 
....................    //a t_min_calderaºC, con una precisión que depende del potenciómetro. 
....................  
....................    //Variables para registrar el termostato y la temperatura de la caldera 
....................    float termo, temp; 
....................  
....................    //Establecemos como entrada analógica a analizar la del termostato 
....................    set_adc_channel(termostato_caldera); 
*
256C:  MOVLW  0C
256E:  MOVWF  01
2570:  MOVF   FC2,W
2572:  ANDLW  C3
2574:  IORWF  01,W
2576:  MOVWF  FC2
....................    delay_us(10);  //Retraso para posibilitar la lectura 
2578:  CLRWDT
257A:  MOVLW  06
257C:  MOVWF  00
257E:  DECFSZ 00,F
2580:  BRA    257E
....................    //Transformamos el valor analógico leído en la escala utilizada por el termostato 
....................    termo = t_min_caldera + ((t_max_caldera-t_min_caldera)*(float)read_adc())/AD_num_valores; 
2582:  BSF    FC2.1
2584:  BTFSC  FC2.1
2586:  BRA    2584
2588:  MOVF   FC4,W
258A:  MOVLB  2
258C:  CLRF   x89
258E:  MOVWF  x88
2590:  MOVLB  0
2592:  RCALL  24BE
2594:  MOVLB  2
2596:  CLRF   xA1
2598:  CLRF   xA0
259A:  MOVLW  48
259C:  MOVWF  x9F
259E:  MOVLW  85
25A0:  MOVWF  x9E
25A2:  MOVFF  03,2A5
25A6:  MOVFF  02,2A4
25AA:  MOVFF  01,2A3
25AE:  MOVFF  00,2A2
25B2:  MOVLB  0
25B4:  CALL   1754
25B8:  MOVFF  00,77
25BC:  MOVFF  01,78
25C0:  MOVFF  02,79
25C4:  MOVFF  03,7A
25C8:  MOVFF  03,28B
25CC:  MOVFF  02,28A
25D0:  MOVFF  01,289
25D4:  MOVFF  00,288
25D8:  MOVLB  2
25DA:  CLRF   x8F
25DC:  CLRF   x8E
25DE:  MOVLW  7F
25E0:  MOVWF  x8D
25E2:  MOVLW  86
25E4:  MOVWF  x8C
25E6:  MOVLB  0
25E8:  RCALL  1F8A
25EA:  BCF    FD8.1
25EC:  MOVLB  2
25EE:  CLRF   x85
25F0:  CLRF   x84
25F2:  CLRF   x83
25F4:  CLRF   x82
25F6:  MOVFF  03,289
25FA:  MOVFF  02,288
25FE:  MOVFF  01,287
2602:  MOVFF  00,286
2606:  MOVLB  0
2608:  RCALL  2244
260A:  MOVFF  03,72
260E:  MOVFF  02,71
2612:  MOVFF  01,70
2616:  MOVFF  00,6F
....................  
....................    //Establecemos como entrada analógica a analizar la de la temperatura del agua 
....................    set_adc_channel(temperatura_caldera); 
261A:  MOVLW  08
261C:  MOVWF  01
261E:  MOVF   FC2,W
2620:  ANDLW  C3
2622:  IORWF  01,W
2624:  MOVWF  FC2
....................    delay_us(10); //Retraso para posibilitar la lectura 
2626:  CLRWDT
2628:  MOVLW  06
262A:  MOVWF  00
262C:  DECFSZ 00,F
262E:  BRA    262C
....................    //Transformamos el valor analógico leído a la escala utlizada en la temperatura 
....................    temp = t_min_caldera + ((t_max_caldera-t_min_caldera)*(float)read_adc())/AD_num_valores; 
2630:  BSF    FC2.1
2632:  BTFSC  FC2.1
2634:  BRA    2632
2636:  MOVF   FC4,W
2638:  MOVLB  2
263A:  CLRF   x89
263C:  MOVWF  x88
263E:  MOVLB  0
2640:  RCALL  24BE
2642:  MOVLB  2
2644:  CLRF   xA1
2646:  CLRF   xA0
2648:  MOVLW  48
264A:  MOVWF  x9F
264C:  MOVLW  85
264E:  MOVWF  x9E
2650:  MOVFF  03,2A5
2654:  MOVFF  02,2A4
2658:  MOVFF  01,2A3
265C:  MOVFF  00,2A2
2660:  MOVLB  0
2662:  CALL   1754
2666:  MOVFF  00,77
266A:  MOVFF  01,78
266E:  MOVFF  02,79
2672:  MOVFF  03,7A
2676:  MOVFF  03,28B
267A:  MOVFF  02,28A
267E:  MOVFF  01,289
2682:  MOVFF  00,288
2686:  MOVLB  2
2688:  CLRF   x8F
268A:  CLRF   x8E
268C:  MOVLW  7F
268E:  MOVWF  x8D
2690:  MOVLW  86
2692:  MOVWF  x8C
2694:  MOVLB  0
2696:  RCALL  1F8A
2698:  BCF    FD8.1
269A:  MOVLB  2
269C:  CLRF   x85
269E:  CLRF   x84
26A0:  CLRF   x83
26A2:  CLRF   x82
26A4:  MOVFF  03,289
26A8:  MOVFF  02,288
26AC:  MOVFF  01,287
26B0:  MOVFF  00,286
26B4:  MOVLB  0
26B6:  RCALL  2244
26B8:  MOVFF  03,76
26BC:  MOVFF  02,75
26C0:  MOVFF  01,74
26C4:  MOVFF  00,73
....................  
....................    //Comparamos ambas temperaturas teniendo en cuenta la histéresis de la caldera 
....................    if(temperatura_caldera_superada) 
26C8:  BTFSS  1E.0
26CA:  BRA    2726
....................    { 
....................       if(temp >= termo-histeresis_caldera) 
26CC:  BSF    FD8.1
26CE:  MOVFF  72,285
26D2:  MOVFF  71,284
26D6:  MOVFF  70,283
26DA:  MOVFF  6F,282
26DE:  MOVLB  2
26E0:  CLRF   x89
26E2:  CLRF   x88
26E4:  MOVLW  20
26E6:  MOVWF  x87
26E8:  MOVLW  81
26EA:  MOVWF  x86
26EC:  MOVLB  0
26EE:  RCALL  2244
26F0:  MOVFF  03,7A
26F4:  MOVFF  02,79
26F8:  MOVFF  01,78
26FC:  MOVFF  00,77
2700:  MOVFF  76,7E
2704:  MOVFF  75,7D
2708:  MOVFF  74,7C
270C:  MOVFF  73,7B
2710:  RCALL  24F6
2712:  BC    2716
2714:  BNZ   271E
....................          return TRUE; 
2716:  MOVLW  01
2718:  MOVWF  01
271A:  BRA    275A
....................       else 
271C:  BRA    2724
....................          return FALSE; 
271E:  MOVLW  00
2720:  MOVWF  01
2722:  BRA    275A
....................    }else 
2724:  BRA    275A
....................    { 
....................       if(temp >= termo) 
2726:  MOVFF  72,7A
272A:  MOVFF  71,79
272E:  MOVFF  70,78
2732:  MOVFF  6F,77
2736:  MOVFF  76,7E
273A:  MOVFF  75,7D
273E:  MOVFF  74,7C
2742:  MOVFF  73,7B
2746:  RCALL  24F6
2748:  BC    274C
274A:  BNZ   2754
....................          return TRUE; 
274C:  MOVLW  01
274E:  MOVWF  01
2750:  BRA    275A
....................       else 
2752:  BRA    275A
....................          return FALSE; 
2754:  MOVLW  00
2756:  MOVWF  01
2758:  BRA    275A
....................    } 
.................... } 
275A:  RETLW  00
....................  
.................... //------------------------------------------------------------------------------------------------------------------------------------ 
....................  
.................... int comprobar_hora(int hora1, int min1, int hora2, int min2) 
.................... { 
....................    //Si hora1 es menor, devolvemos TRUE 
....................    if(hora1 < hora2) 
*
2A7C:  MOVF   x83,W
2A7E:  SUBWF  x81,W
2A80:  BC    2A88
....................       return TRUE; 
2A82:  MOVLW  01
2A84:  MOVWF  01
2A86:  BRA    2AAE
....................    //Si hora1 es mayor, devolvemos FALSE 
....................    if(hora1 > hora2) 
2A88:  MOVF   x81,W
2A8A:  SUBWF  x83,W
2A8C:  BC    2A94
....................       return FALSE; 
2A8E:  MOVLW  00
2A90:  MOVWF  01
2A92:  BRA    2AAE
....................    //Si las horas coinciden habrá que comparar los minutos 
....................    if(hora1==hora2) 
2A94:  MOVF   x83,W
2A96:  SUBWF  x81,W
2A98:  BNZ   2AAE
....................    { 
....................       //Se sigue el mismo criterio de antes con la comparación 
....................       //de los minutos. 
....................       if(min1 <= min2) 
2A9A:  MOVF   x82,W
2A9C:  SUBWF  x84,W
2A9E:  BNC   2AA8
....................          return TRUE; 
2AA0:  MOVLW  01
2AA2:  MOVWF  01
2AA4:  BRA    2AAE
....................       else 
2AA6:  BRA    2AAE
....................          return FALSE; 
2AA8:  MOVLW  00
2AAA:  MOVWF  01
2AAC:  BRA    2AAE
....................    } 
.................... } 
2AAE:  RETLW  00
....................  
.................... //------------------------------------------------------------------------------------------------------------------------------------ 
....................  
.................... int1 comprobar_temperatura() 
.................... { 
....................    //Leemos la temperatura 
....................    temperatura = ds1820_read(); 
*
59D0:  CALL   20EA
59D4:  MOVFF  03,2A
59D8:  MOVFF  02,29
59DC:  MOVFF  01,28
59E0:  MOVFF  00,27
....................  
....................    //Mostramos la información en la pantalla lcd 
....................    mostrar_temperatura(); 
59E4:  BRA    5902
....................  
....................    if(ds1820_termostato()) 
59E6:  CALL   2198
59EA:  MOVF   01,F
59EC:  BZ    5A52
....................    { 
....................       //Si la temperatura es menor que la del termostato, devolvemos TRUE 
....................       if(temp_habitacion_superada) 
59EE:  BTFSS  1E.1
59F0:  BRA    5A4A
....................       { 
....................          //Si la temperatura antes era mayor, indicamos el cambio en el flag 
....................          temp_habitacion_superada = FALSE; 
59F2:  BCF    1E.1
....................          //Tenemos en cuenta la histéresis para el nuevo valor del termostato 
....................          termostato = termostato + histeresis_vivienda; 
59F4:  BCF    FD8.1
59F6:  MOVFF  22,285
59FA:  MOVFF  21,284
59FE:  MOVFF  20,283
5A02:  MOVFF  1F,282
5A06:  MOVFF  2E,289
5A0A:  MOVFF  2D,288
5A0E:  MOVFF  2C,287
5A12:  MOVFF  2B,286
5A16:  CALL   2244
5A1A:  MOVFF  03,22
5A1E:  MOVFF  02,21
5A22:  MOVFF  01,20
5A26:  MOVFF  00,1F
....................          //Guardamos la información también en el sensor de temperatura 
....................          //Ponemos como TH una temperatura muy grande (127.5ºC) 
....................          ds1820_establecer_TH_TL(127.5, termostato); 
5A2A:  CLRF   7A
5A2C:  CLRF   79
5A2E:  MOVLW  7F
5A30:  MOVWF  78
5A32:  MOVLW  85
5A34:  MOVWF  77
5A36:  MOVFF  22,7E
5A3A:  MOVFF  21,7D
5A3E:  MOVFF  20,7C
5A42:  MOVFF  1F,7B
5A46:  CALL   184C
....................       } 
....................       return TRUE; 
5A4A:  MOVLW  01
5A4C:  MOVWF  01
5A4E:  BRA    5AB4
....................    } 
....................    else 
5A50:  BRA    5AB4
....................    { 
....................       //Si la temperatura es mayor que la del termostato, devolvemos FALSE 
....................       if(!temp_habitacion_superada) 
5A52:  BTFSC  1E.1
5A54:  BRA    5AAE
....................       { 
....................          //Si antes era menor, cambiamos el flag 
....................          temp_habitacion_superada = TRUE; 
5A56:  BSF    1E.1
....................          //Guardamos el nuevo valor del termostato teniendo en cuenta la histéresis 
....................          termostato = termostato - histeresis_vivienda; 
5A58:  BSF    FD8.1
5A5A:  MOVFF  22,285
5A5E:  MOVFF  21,284
5A62:  MOVFF  20,283
5A66:  MOVFF  1F,282
5A6A:  MOVFF  2E,289
5A6E:  MOVFF  2D,288
5A72:  MOVFF  2C,287
5A76:  MOVFF  2B,286
5A7A:  CALL   2244
5A7E:  MOVFF  03,22
5A82:  MOVFF  02,21
5A86:  MOVFF  01,20
5A8A:  MOVFF  00,1F
....................          //Guardamos la información también en el sensor de temperatura 
....................          //Ponemos como TH una temperatura muy grande (127.5ºC) 
....................          ds1820_establecer_TH_TL(127.5, termostato); 
5A8E:  CLRF   7A
5A90:  CLRF   79
5A92:  MOVLW  7F
5A94:  MOVWF  78
5A96:  MOVLW  85
5A98:  MOVWF  77
5A9A:  MOVFF  22,7E
5A9E:  MOVFF  21,7D
5AA2:  MOVFF  20,7C
5AA6:  MOVFF  1F,7B
5AAA:  CALL   184C
....................       } 
....................       return FALSE; 
5AAE:  MOVLW  00
5AB0:  MOVWF  01
5AB2:  BRA    5AB4
....................    } 
.................... } 
5AB4:  GOTO   67C6 (RETURN)
....................  
.................... //------------------------------------------------------------------------------------------------------------------------------------ 
....................  
.................... long diferencia_tiempo(int hora1, int min1, int hora2, int min2) 
.................... { 
....................    long dif; 
....................  
....................    //Si hora1:min1 es menor que hora2:min2, devolvemos simplemente la diferencia en minutos 
....................    if(comprobar_hora(hora1,min1,hora2,min2)) 
*
2ACE:  MOVFF  77,81
2AD2:  MOVFF  78,82
2AD6:  MOVFF  79,83
2ADA:  MOVFF  7A,84
2ADE:  RCALL  2A7C
2AE0:  MOVF   01,F
2AE2:  BZ    2B44
....................       dif = ((long)hora2*60 + (long)min2) - ((long)hora1*60 + (long)min1); 
2AE4:  CLRF   7E
2AE6:  MOVFF  79,7D
2AEA:  MOVFF  7E,89
2AEE:  MOVFF  79,88
2AF2:  CLRF   x8B
2AF4:  MOVLW  3C
2AF6:  MOVWF  x8A
2AF8:  RCALL  2AB0
2AFA:  MOVFF  02,7F
2AFE:  MOVFF  01,7E
2B02:  CLRF   03
2B04:  MOVF   7A,W
2B06:  ADDWF  01,W
2B08:  MOVWF  x80
2B0A:  MOVF   03,W
2B0C:  ADDWFC 02,W
2B0E:  MOVWF  x81
2B10:  CLRF   x83
2B12:  MOVFF  77,82
2B16:  MOVFF  83,89
2B1A:  MOVFF  77,88
2B1E:  CLRF   x8B
2B20:  MOVLW  3C
2B22:  MOVWF  x8A
2B24:  RCALL  2AB0
2B26:  MOVFF  01,83
2B2A:  CLRF   03
2B2C:  MOVF   78,W
2B2E:  ADDWF  01,W
2B30:  MOVWF  01
2B32:  MOVF   02,W
2B34:  ADDWFC 03,F
2B36:  MOVF   01,W
2B38:  SUBWF  x80,W
2B3A:  MOVWF  7B
2B3C:  MOVF   03,W
2B3E:  SUBWFB x81,W
2B40:  MOVWF  7C
....................    //Si no es así, habrá que tener en cuenta que hora1:min1 se encuentra en el día anterior 
....................    //al de hora2:min2 
....................    else 
2B42:  BRA    2BB0
....................       dif = (24*60-((long)hora1*60 + (long)min1)) + (long)hora2*60 + (long)min2; 
2B44:  CLRF   7E
2B46:  MOVFF  77,7D
2B4A:  MOVFF  7E,89
2B4E:  MOVFF  77,88
2B52:  CLRF   x8B
2B54:  MOVLW  3C
2B56:  MOVWF  x8A
2B58:  RCALL  2AB0
2B5A:  MOVFF  02,7F
2B5E:  MOVFF  01,7E
2B62:  CLRF   03
2B64:  MOVF   78,W
2B66:  ADDWF  01,W
2B68:  MOVWF  01
2B6A:  MOVF   02,W
2B6C:  ADDWFC 03,F
2B6E:  MOVF   01,W
2B70:  XORLW  FF
2B72:  ADDLW  A1
2B74:  MOVWF  x80
2B76:  MOVLW  05
2B78:  SUBFWB 03,W
2B7A:  MOVWF  x81
2B7C:  CLRF   x83
2B7E:  MOVFF  79,82
2B82:  MOVFF  83,89
2B86:  MOVFF  79,88
2B8A:  CLRF   x8B
2B8C:  MOVLW  3C
2B8E:  MOVWF  x8A
2B90:  RCALL  2AB0
2B92:  MOVFF  02,03
2B96:  MOVF   01,W
2B98:  ADDWF  x80,W
2B9A:  MOVWF  x83
2B9C:  MOVF   02,W
2B9E:  ADDWFC x81,W
2BA0:  MOVWF  x84
2BA2:  CLRF   03
2BA4:  MOVF   7A,W
2BA6:  ADDWF  x83,W
2BA8:  MOVWF  7B
2BAA:  MOVF   03,W
2BAC:  ADDWFC x84,W
2BAE:  MOVWF  7C
....................  
....................    //Devolvemos el resultado 
....................    return dif; 
2BB0:  MOVFF  7B,01
2BB4:  MOVFF  7C,02
.................... } 
2BB8:  RETLW  00
....................  
.................... //------------------------------------------------------------------------------------------------------------------------------------ 
....................  
.................... long diferencia_tiempo_sec(int hora1, int min1, int sec1, int hora2, int min2, int sec2) 
.................... { 
....................    unsigned long dif; 
....................    unsigned long dif2; 
....................  
....................    //Si hora1:min1 es menor que hora2:min2, ambas horas están en el mismo día 
....................    if(comprobar_hora(hora1,min1,hora2,min2)) 
2BBA:  MOVFF  77,81
2BBE:  MOVFF  78,82
2BC2:  MOVFF  7A,83
2BC6:  MOVFF  7B,84
2BCA:  RCALL  2A7C
2BCC:  MOVF   01,F
2BCE:  BZ    2C6E
....................    { 
....................       //Si la hora y los minutos son iguales, devolvemos simplemente la diferencia en segundos 
....................       if(hora1==hora2 && min1==min2) 
2BD0:  MOVF   7A,W
2BD2:  SUBWF  77,W
2BD4:  BNZ   2BE6
2BD6:  MOVF   7B,W
2BD8:  SUBWF  78,W
2BDA:  BNZ   2BE6
....................          dif = abs(sec2-sec1); 
2BDC:  MOVF   79,W
2BDE:  SUBWF  7C,W
2BE0:  CLRF   7E
2BE2:  MOVWF  7D
....................       else 
2BE4:  BRA    2C6C
....................       { 
....................          //Si no habrá que tener en cuenta también la diferencia entre horas y minutos 
....................          dif2 = ((long)hora2*60 + (long)min2) - ((long)hora1*60 + (long)min1); 
2BE6:  CLRF   x82
2BE8:  MOVFF  7A,81
2BEC:  MOVFF  82,89
2BF0:  MOVFF  7A,88
2BF4:  CLRF   x8B
2BF6:  MOVLW  3C
2BF8:  MOVWF  x8A
2BFA:  RCALL  2AB0
2BFC:  MOVFF  02,83
2C00:  MOVFF  01,82
2C04:  CLRF   03
2C06:  MOVF   7B,W
2C08:  ADDWF  01,W
2C0A:  MOVWF  x84
2C0C:  MOVF   03,W
2C0E:  ADDWFC 02,W
2C10:  MOVWF  x85
2C12:  CLRF   x87
2C14:  MOVFF  77,86
2C18:  MOVFF  87,89
2C1C:  MOVFF  77,88
2C20:  CLRF   x8B
2C22:  MOVLW  3C
2C24:  MOVWF  x8A
2C26:  RCALL  2AB0
2C28:  MOVFF  01,87
2C2C:  CLRF   03
2C2E:  MOVF   78,W
2C30:  ADDWF  01,W
2C32:  MOVWF  01
2C34:  MOVF   02,W
2C36:  ADDWFC 03,F
2C38:  MOVF   01,W
2C3A:  SUBWF  x84,W
2C3C:  MOVWF  7F
2C3E:  MOVF   03,W
2C40:  SUBWFB x85,W
2C42:  MOVWF  x80
....................          //No hacemos la diferencia en segundos directamente porque el long no da de sí 
....................          dif = dif2*60 + sec2 - sec1; 
2C44:  MOVFF  80,89
2C48:  MOVFF  7F,88
2C4C:  CLRF   x8B
2C4E:  MOVLW  3C
2C50:  MOVWF  x8A
2C52:  RCALL  2AB0
2C54:  MOVF   7C,W
2C56:  ADDWF  01,W
2C58:  MOVWF  x83
2C5A:  MOVLW  00
2C5C:  ADDWFC 02,W
2C5E:  MOVWF  x84
2C60:  MOVF   79,W
2C62:  SUBWF  x83,W
2C64:  MOVWF  7D
2C66:  MOVLW  00
2C68:  SUBWFB x84,W
2C6A:  MOVWF  7E
....................       } 
....................    } 
....................    else{ 
2C6C:  BRA    2D02
....................       //Si no, simplemente tenemos en cuenta que están en días diferentes y luego le añadimos la 
....................       //diferencia en segundos 
....................       dif2 = (24*60-((long)hora1*60 + (long)min1)) + (long)hora2*60 + (long)min2; 
2C6E:  CLRF   x82
2C70:  MOVFF  77,81
2C74:  MOVFF  82,89
2C78:  MOVFF  77,88
2C7C:  CLRF   x8B
2C7E:  MOVLW  3C
2C80:  MOVWF  x8A
2C82:  RCALL  2AB0
2C84:  MOVFF  02,83
2C88:  MOVFF  01,82
2C8C:  CLRF   03
2C8E:  MOVF   78,W
2C90:  ADDWF  01,W
2C92:  MOVWF  01
2C94:  MOVF   02,W
2C96:  ADDWFC 03,F
2C98:  MOVF   01,W
2C9A:  XORLW  FF
2C9C:  ADDLW  A1
2C9E:  MOVWF  x84
2CA0:  MOVLW  05
2CA2:  SUBFWB 03,W
2CA4:  MOVWF  x85
2CA6:  CLRF   x87
2CA8:  MOVFF  7A,86
2CAC:  MOVFF  87,89
2CB0:  MOVFF  7A,88
2CB4:  CLRF   x8B
2CB6:  MOVLW  3C
2CB8:  MOVWF  x8A
2CBA:  RCALL  2AB0
2CBC:  MOVFF  02,03
2CC0:  MOVF   01,W
2CC2:  ADDWF  x84,W
2CC4:  MOVWF  x87
2CC6:  MOVF   02,W
2CC8:  ADDWFC x85,W
2CCA:  MOVWF  x88
2CCC:  CLRF   03
2CCE:  MOVF   7B,W
2CD0:  ADDWF  x87,W
2CD2:  MOVWF  7F
2CD4:  MOVF   03,W
2CD6:  ADDWFC x88,W
2CD8:  MOVWF  x80
....................       dif = dif2*60 + sec2 - sec1; 
2CDA:  MOVFF  80,89
2CDE:  MOVFF  7F,88
2CE2:  CLRF   x8B
2CE4:  MOVLW  3C
2CE6:  MOVWF  x8A
2CE8:  RCALL  2AB0
2CEA:  MOVF   7C,W
2CEC:  ADDWF  01,W
2CEE:  MOVWF  x83
2CF0:  MOVLW  00
2CF2:  ADDWFC 02,W
2CF4:  MOVWF  x84
2CF6:  MOVF   79,W
2CF8:  SUBWF  x83,W
2CFA:  MOVWF  7D
2CFC:  MOVLW  00
2CFE:  SUBWFB x84,W
2D00:  MOVWF  7E
....................    } 
....................  
....................    //Devolvemos el resultado 
....................    return dif; 
2D02:  MOVFF  7D,01
2D06:  MOVFF  7E,02
.................... } 
2D0A:  RETLW  00
....................  
.................... //------------------------------------------------------------------------------------------------------------------------------------ 
....................  
.................... void encender_caldera() 
.................... { 
....................    //Leemos el tiempo actual 
....................    PCF8583_read_datetime(&tiempo); 
*
582E:  CLRF   78
5830:  MOVLW  45
5832:  MOVWF  77
5834:  CALL   285C
....................  
....................    //Guardamos los datos en las variables correspondientes 
....................    hora_caldera = tiempo.hours; 
5838:  MOVFF  47,4E
....................    minutos_caldera = tiempo.minutes; 
583C:  MOVFF  46,4F
....................    segundos_caldera = tiempo.seconds; 
5840:  MOVFF  45,50
....................  
....................    //Encendemos la caldera 
....................    caldera_encendida = TRUE; 
5844:  BSF    F83.0
.................... } 
5846:  GOTO   67B2 (RETURN)
....................  
.................... //------------------------------------------------------------------------------------------------------------------------------------ 
....................  
.................... void encender_sistema() 
.................... { 
....................    //Leemos el tiempo actual 
....................    PCF8583_read_datetime(&tiempo); 
*
2A16:  CLRF   78
2A18:  MOVLW  45
2A1A:  MOVWF  77
2A1C:  RCALL  285C
....................  
....................    //Registramos la hora y minutos en los que se enciende el sistema 
....................    hora_encendido    = tiempo.hours; 
2A1E:  MOVFF  47,4C
....................    minutos_encendido = tiempo.minutes; 
2A22:  MOVFF  46,4D
....................  
....................    //Inicializamos a 0 el tiempo total que está encendida la caldera 
....................    t_total_caldera = 0; 
2A26:  CLRF   52
2A28:  CLRF   51
....................  
....................    //Si la caldera está encendida, inicializamos el instante de encendido a 
....................    //éste. 
....................    if(caldera_encendida) 
2A2A:  BTFSS  F83.0
2A2C:  BRA    2A3A
....................    { 
....................       hora_caldera = tiempo.hours; 
2A2E:  MOVFF  47,4E
....................       minutos_caldera = tiempo.minutes; 
2A32:  MOVFF  46,4F
....................       segundos_caldera = tiempo.seconds; 
2A36:  MOVFF  45,50
....................    } 
....................  
....................    //Encendemos el sistema 
....................    sistema_encendido = TRUE; 
2A3A:  BSF    F83.2
.................... } 
2A3C:  RETLW  00
....................  
.................... //------------------------------------------------------------------------------------------------------------------------------------ 
....................  
.................... void grabar_programaciones() 
.................... { 
....................  
....................    int datos[5];   //Vector para contener los datos a grabar 
....................    programacion pr; //Variable temporal de programacion 
....................    int contador;   //Contador para el bucle 
....................  
....................    //Recorremos todo el vector de programaciones (hasta el número de programaciones que tengamos) 
....................    for(contador=0; contador<num_intervalos; contador++) 
*
38BC:  CLRF   79
38BE:  MOVF   43,W
38C0:  SUBWF  79,W
38C2:  BTFSC  FD8.0
38C4:  BRA    39F8
....................    { 
....................       //Seleccionamos la programación 
....................       pr = programaciones[contador]; 
38C6:  MOVF   79,W
38C8:  MULLW  05
38CA:  MOVF   FF3,W
38CC:  CLRF   03
38CE:  ADDLW  2F
38D0:  MOVWF  01
38D2:  MOVLW  00
38D4:  ADDWFC 03,F
38D6:  MOVFF  01,7A
38DA:  MOVFF  03,7B
38DE:  CLRF   FEA
38E0:  MOVLW  74
38E2:  MOVWF  FE9
38E4:  MOVFF  03,FE2
38E8:  MOVFF  01,FE1
38EC:  MOVLW  05
38EE:  MOVWF  01
38F0:  MOVFF  FE6,FEE
38F4:  DECFSZ 01,F
38F6:  BRA    38F0
....................  
....................       //Guardamos en la memoria EEPROM dato a dato 
....................       write_eeprom(eeprom_programaciones + (contador)*5    , pr.horas_inicio); 
38F8:  MOVF   79,W
38FA:  MULLW  05
38FC:  MOVF   FF3,W
38FE:  ADDLW  05
3900:  MOVWF  7A
3902:  MOVWF  FA9
3904:  MOVFF  74,FA8
3908:  BCF    FA6.6
390A:  BCF    FA6.7
390C:  BSF    FA6.2
390E:  MOVFF  FF2,00
3912:  BCF    FF2.7
3914:  MOVLB  F
3916:  MOVLW  55
3918:  MOVWF  FA7
391A:  MOVLW  AA
391C:  MOVWF  FA7
391E:  BSF    FA6.1
3920:  BTFSC  FA6.1
3922:  BRA    3920
3924:  BCF    FA6.2
3926:  MOVF   00,W
3928:  IORWF  FF2,F
....................       write_eeprom(eeprom_programaciones + (contador)*5 + 1, pr.minutos_inicio); 
392A:  MOVF   79,W
392C:  MULLW  05
392E:  MOVF   FF3,W
3930:  ADDLW  05
3932:  ADDLW  01
3934:  MOVWF  7B
3936:  MOVWF  FA9
3938:  MOVFF  75,FA8
393C:  BCF    FA6.6
393E:  BCF    FA6.7
3940:  BSF    FA6.2
3942:  MOVFF  FF2,00
3946:  BCF    FF2.7
3948:  MOVLW  55
394A:  MOVWF  FA7
394C:  MOVLW  AA
394E:  MOVWF  FA7
3950:  BSF    FA6.1
3952:  BTFSC  FA6.1
3954:  BRA    3952
3956:  BCF    FA6.2
3958:  MOVF   00,W
395A:  IORWF  FF2,F
....................       write_eeprom(eeprom_programaciones + (contador)*5 + 2, pr.horas_fin); 
395C:  MOVF   79,W
395E:  MULLW  05
3960:  MOVF   FF3,W
3962:  ADDLW  05
3964:  ADDLW  02
3966:  MOVWF  7B
3968:  MOVWF  FA9
396A:  MOVFF  76,FA8
396E:  BCF    FA6.6
3970:  BCF    FA6.7
3972:  BSF    FA6.2
3974:  MOVFF  FF2,00
3978:  BCF    FF2.7
397A:  MOVLW  55
397C:  MOVWF  FA7
397E:  MOVLW  AA
3980:  MOVWF  FA7
3982:  BSF    FA6.1
3984:  BTFSC  FA6.1
3986:  BRA    3984
3988:  BCF    FA6.2
398A:  MOVF   00,W
398C:  IORWF  FF2,F
....................       write_eeprom(eeprom_programaciones + (contador)*5 + 3, pr.minutos_fin); 
398E:  MOVF   79,W
3990:  MULLW  05
3992:  MOVF   FF3,W
3994:  ADDLW  05
3996:  ADDLW  03
3998:  MOVWF  7B
399A:  MOVWF  FA9
399C:  MOVFF  77,FA8
39A0:  BCF    FA6.6
39A2:  BCF    FA6.7
39A4:  BSF    FA6.2
39A6:  MOVFF  FF2,00
39AA:  BCF    FF2.7
39AC:  MOVLW  55
39AE:  MOVWF  FA7
39B0:  MOVLW  AA
39B2:  MOVWF  FA7
39B4:  BSF    FA6.1
39B6:  BTFSC  FA6.1
39B8:  BRA    39B6
39BA:  BCF    FA6.2
39BC:  MOVF   00,W
39BE:  IORWF  FF2,F
....................       write_eeprom(eeprom_programaciones + (contador)*5 + 4, pr.termostato); 
39C0:  MOVF   79,W
39C2:  MULLW  05
39C4:  MOVF   FF3,W
39C6:  ADDLW  05
39C8:  ADDLW  04
39CA:  MOVWF  7B
39CC:  MOVWF  FA9
39CE:  MOVFF  78,FA8
39D2:  BCF    FA6.6
39D4:  BCF    FA6.7
39D6:  BSF    FA6.2
39D8:  MOVFF  FF2,00
39DC:  BCF    FF2.7
39DE:  MOVLW  55
39E0:  MOVWF  FA7
39E2:  MOVLW  AA
39E4:  MOVWF  FA7
39E6:  BSF    FA6.1
39E8:  BTFSC  FA6.1
39EA:  BRA    39E8
39EC:  BCF    FA6.2
39EE:  MOVF   00,W
39F0:  IORWF  FF2,F
....................    } 
39F2:  INCF   79,F
39F4:  MOVLB  0
39F6:  BRA    38BE
....................  
....................    //Guardamos en la EEPROM en el número de intervalos 
....................    write_eeprom(eeprom_num_intervalos, num_intervalos); 
39F8:  MOVLW  01
39FA:  MOVWF  FA9
39FC:  MOVFF  43,FA8
3A00:  BCF    FA6.6
3A02:  BCF    FA6.7
3A04:  BSF    FA6.2
3A06:  MOVFF  FF2,00
3A0A:  BCF    FF2.7
3A0C:  MOVLB  F
3A0E:  MOVLW  55
3A10:  MOVWF  FA7
3A12:  MOVLW  AA
3A14:  MOVWF  FA7
3A16:  BSF    FA6.1
3A18:  BTFSC  FA6.1
3A1A:  BRA    3A18
3A1C:  BCF    FA6.2
3A1E:  MOVF   00,W
3A20:  IORWF  FF2,F
.................... } 
3A22:  MOVLB  0
3A24:  GOTO   6796 (RETURN)
....................  
.................... //------------------------------------------------------------------------------------------------------------------------------------ 
....................  
.................... void inicializacion() 
.................... { 
....................    //NOTA: todos los pequeños retardos introducidos en esta rutina sirven para que el técnico 
....................    //no se sienta atosigado por los continuos mensajes que le aparecen solicitándole información. 
....................  
....................  
....................    //Variables para introducir los datos de fecha y hora 
....................    int weekday, dia, mes, anno, horas, minutos; 
....................  
....................    char c[2]; //Cadena para la conversión a int 
....................  
....................    //Comenzamos pidiendo la introducción de la fecha 
....................    //Es una lástima que en RS232 no se vean bien las tildes 
....................    e1: 
....................    printf("\rInicializacion del sistema\r"); 
*
191A:  CLRF   77
191C:  MOVF   77,W
191E:  CALL   0492
1922:  IORLW  00
1924:  BZ    1930
1926:  INCF   77,F
1928:  BTFSS  F9E.4
192A:  BRA    1928
192C:  MOVWF  FAD
192E:  BRA    191C
....................    printf("**************************\r"); 
1930:  CLRF   77
1932:  MOVF   77,W
1934:  CALL   04CA
1938:  IORLW  00
193A:  BZ    1946
193C:  INCF   77,F
193E:  BTFSS  F9E.4
1940:  BRA    193E
1942:  MOVWF  FAD
1944:  BRA    1932
....................    //Primero solicitamos el día de la semana 
....................    printf("Dia de la semana (1->Lunes, 2->Martes, ...): LUNES    "); 
1946:  CLRF   77
1948:  MOVF   77,W
194A:  CALL   0500
194E:  IORLW  00
1950:  BZ    195C
1952:  INCF   77,F
1954:  BTFSS  F9E.4
1956:  BRA    1954
1958:  MOVWF  FAD
195A:  BRA    1948
....................  
....................    //En principio se indica que es lunes 
....................    weekday = 0; 
195C:  CLRF   6F
....................  
....................    //Inicializamos el vector de caracteres a \0 por dos motivos según la posición: 
....................    //c[0] para que no se elija un día indeseado sin intervención del técnico y c[1], 
....................    //para marcar el fin de la cadena. 
....................    c[0]=c[1]='\0'; 
195E:  CLRF   76
1960:  MOVFF  76,75
....................  
....................  
....................    //Iteramos en el bucle hasta que no se pulse ENTER 
....................    while(c[0]!=13){ 
1964:  MOVF   75,W
1966:  SUBLW  0D
1968:  BTFSC  FD8.2
196A:  BRA    1A36
....................       //Guardamos el caracter leído 
....................       c[0]=getch(); 
196C:  BTFSS  F9E.5
196E:  BRA    196C
1970:  MOVFF  FAE,75
....................  
....................       //Además se asigna un valor numérico a la variable weekday para almacenarla en el reloj. 
....................       weekday=atoi(c)-1; 
1974:  CLRF   7B
1976:  MOVLW  75
1978:  MOVWF  7A
197A:  RCALL  128E
197C:  MOVLW  01
197E:  SUBWF  01,W
1980:  MOVWF  6F
....................  
....................       //Según el día introducido, imprimimos un resultado u otro por pantalla, borrando el 
....................       //anterior. Para ello, todos los días ocupan el tamaño del mayor (miércoles) gracias a espacios. 
....................       switch(weekday) 
....................       { 
1982:  MOVF   6F,W
1984:  ADDLW  F9
1986:  BC    1A34
1988:  ADDLW  07
198A:  GOTO   1EC4
....................          case 0: printf("\b\b\b\b\b\b\b\b\bLUNES    "); 
198E:  CLRF   77
1990:  MOVF   77,W
1992:  CALL   0552
1996:  IORLW  00
1998:  BZ    19A4
199A:  INCF   77,F
199C:  BTFSS  F9E.4
199E:  BRA    199C
19A0:  MOVWF  FAD
19A2:  BRA    1990
....................                  break; 
19A4:  BRA    1A34
....................          case 1: printf("\b\b\b\b\b\b\b\b\bMARTES   "); 
19A6:  CLRF   77
19A8:  MOVF   77,W
19AA:  CALL   0580
19AE:  IORLW  00
19B0:  BZ    19BC
19B2:  INCF   77,F
19B4:  BTFSS  F9E.4
19B6:  BRA    19B4
19B8:  MOVWF  FAD
19BA:  BRA    19A8
....................                  break; 
19BC:  BRA    1A34
....................          case 2: printf("\b\b\b\b\b\b\b\b\bMIERCOLES"); 
19BE:  CLRF   77
19C0:  MOVF   77,W
19C2:  CALL   05AE
19C6:  IORLW  00
19C8:  BZ    19D4
19CA:  INCF   77,F
19CC:  BTFSS  F9E.4
19CE:  BRA    19CC
19D0:  MOVWF  FAD
19D2:  BRA    19C0
....................                  break; 
19D4:  BRA    1A34
....................          case 3: printf("\b\b\b\b\b\b\b\b\bJUEVES   "); 
19D6:  CLRF   77
19D8:  MOVF   77,W
19DA:  CALL   05DC
19DE:  IORLW  00
19E0:  BZ    19EC
19E2:  INCF   77,F
19E4:  BTFSS  F9E.4
19E6:  BRA    19E4
19E8:  MOVWF  FAD
19EA:  BRA    19D8
....................                  break; 
19EC:  BRA    1A34
....................          case 4: printf("\b\b\b\b\b\b\b\b\bVIERNES  "); 
19EE:  CLRF   77
19F0:  MOVF   77,W
19F2:  CALL   060A
19F6:  IORLW  00
19F8:  BZ    1A04
19FA:  INCF   77,F
19FC:  BTFSS  F9E.4
19FE:  BRA    19FC
1A00:  MOVWF  FAD
1A02:  BRA    19F0
....................                  break; 
1A04:  BRA    1A34
....................          case 5: printf("\b\b\b\b\b\b\b\b\bSABADO   "); 
1A06:  CLRF   77
1A08:  MOVF   77,W
1A0A:  CALL   0638
1A0E:  IORLW  00
1A10:  BZ    1A1C
1A12:  INCF   77,F
1A14:  BTFSS  F9E.4
1A16:  BRA    1A14
1A18:  MOVWF  FAD
1A1A:  BRA    1A08
....................                  break; 
1A1C:  BRA    1A34
....................          case 6: printf("\b\b\b\b\b\b\b\b\bDOMINGO  "); 
1A1E:  CLRF   77
1A20:  MOVF   77,W
1A22:  CALL   0666
1A26:  IORLW  00
1A28:  BZ    1A34
1A2A:  INCF   77,F
1A2C:  BTFSS  F9E.4
1A2E:  BRA    1A2C
1A30:  MOVWF  FAD
1A32:  BRA    1A20
....................       } 
....................    } 
1A34:  BRA    1964
....................  
....................    //Pedimos la introducción de la fecha 
....................    printf("\rFECHA: "); 
1A36:  CLRF   77
1A38:  MOVF   77,W
1A3A:  CALL   0694
1A3E:  IORLW  00
1A40:  BZ    1A4C
1A42:  INCF   77,F
1A44:  BTFSS  F9E.4
1A46:  BRA    1A44
1A48:  MOVWF  FAD
1A4A:  BRA    1A38
....................  
....................    //Leemos el día del mes 
....................    dia = buscar_numero_rs232(); 
1A4C:  RCALL  1428
1A4E:  MOVFF  01,70
....................    //Si pulsamos "backspace", se resetea la inicialización 
....................    if(dia==NOCODE) 
1A52:  MOVF   70,W
1A54:  SUBLW  64
1A56:  BNZ   1A70
....................    { 
....................       printf("\rReseteando inicializacion...\r"); 
1A58:  CLRF   77
1A5A:  MOVF   77,W
1A5C:  CALL   06B8
1A60:  IORLW  00
1A62:  BZ    1A6E
1A64:  INCF   77,F
1A66:  BTFSS  F9E.4
1A68:  BRA    1A66
1A6A:  MOVWF  FAD
1A6C:  BRA    1A5A
....................       goto e1; 
1A6E:  BRA    191A
....................    } 
....................    //Si el día introducido no es válido, también reseteamos la inicialización 
....................    if(dia>31 || dia==0) 
1A70:  MOVF   70,W
1A72:  SUBLW  1F
1A74:  BNC   1A7A
1A76:  MOVF   70,F
1A78:  BNZ   1AA2
....................    { 
....................       printf("\rDia incorrecto. Reseteando inicializacion...\r"); 
1A7A:  CLRF   77
1A7C:  MOVF   77,W
1A7E:  CALL   06F2
1A82:  IORLW  00
1A84:  BZ    1A90
1A86:  INCF   77,F
1A88:  BTFSS  F9E.4
1A8A:  BRA    1A88
1A8C:  MOVWF  FAD
1A8E:  BRA    1A7C
....................       delay_ms(LCD_T_RETARDO); 
1A90:  MOVLW  02
1A92:  MOVWF  77
1A94:  MOVLW  FA
1A96:  MOVWF  x88
1A98:  CALL   10E6
1A9C:  DECFSZ 77,F
1A9E:  BRA    1A94
....................       goto e1; 
1AA0:  BRA    191A
....................    } 
....................  
....................    //Leemos el mes 
....................    printf("/"); 
1AA2:  CLRF   77
1AA4:  MOVF   77,W
1AA6:  CALL   073C
1AAA:  IORLW  00
1AAC:  BZ    1AB8
1AAE:  INCF   77,F
1AB0:  BTFSS  F9E.4
1AB2:  BRA    1AB0
1AB4:  MOVWF  FAD
1AB6:  BRA    1AA4
....................    mes = buscar_numero_rs232(); 
1AB8:  RCALL  1428
1ABA:  MOVFF  01,71
....................    //Si pulsamos "backspace", se resetea la inicialización 
....................    if(mes==NOCODE) 
1ABE:  MOVF   71,W
1AC0:  SUBLW  64
1AC2:  BNZ   1ADC
....................    { 
....................       printf("\rReseteando inicializacion...\r"); 
1AC4:  CLRF   77
1AC6:  MOVF   77,W
1AC8:  CALL   06B8
1ACC:  IORLW  00
1ACE:  BZ    1ADA
1AD0:  INCF   77,F
1AD2:  BTFSS  F9E.4
1AD4:  BRA    1AD2
1AD6:  MOVWF  FAD
1AD8:  BRA    1AC6
....................       goto e1; 
1ADA:  BRA    191A
....................    } 
....................    //Si el mes introducido no es válido, reseteamos la inicialización de igual modo 
....................    if(mes>12 || mes==0) 
1ADC:  MOVF   71,W
1ADE:  SUBLW  0C
1AE0:  BNC   1AE6
1AE2:  MOVF   71,F
1AE4:  BNZ   1B0E
....................    { 
....................       printf("\rMes incorrecto. Reseteando inicializacion...\r"); 
1AE6:  CLRF   77
1AE8:  MOVF   77,W
1AEA:  CALL   0758
1AEE:  IORLW  00
1AF0:  BZ    1AFC
1AF2:  INCF   77,F
1AF4:  BTFSS  F9E.4
1AF6:  BRA    1AF4
1AF8:  MOVWF  FAD
1AFA:  BRA    1AE8
....................       delay_ms(LCD_T_RETARDO); 
1AFC:  MOVLW  02
1AFE:  MOVWF  77
1B00:  MOVLW  FA
1B02:  MOVWF  x88
1B04:  CALL   10E6
1B08:  DECFSZ 77,F
1B0A:  BRA    1B00
....................       goto e1; 
1B0C:  BRA    191A
....................    } 
....................  
....................    //Si el día introducido no se encuentra en el mes seleccionado, mostramos un mensaje 
....................    //de error y reseteamos la operación 
....................    if((dia>29 && mes==2)||(dia==31 && (mes==4 || mes==6 || mes==9 || mes==11))) 
1B0E:  MOVF   70,W
1B10:  SUBLW  1D
1B12:  BC    1B1A
1B14:  MOVF   71,W
1B16:  SUBLW  02
1B18:  BZ    1B38
1B1A:  MOVF   70,W
1B1C:  SUBLW  1F
1B1E:  BNZ   1B60
1B20:  MOVF   71,W
1B22:  SUBLW  04
1B24:  BZ    1B38
1B26:  MOVF   71,W
1B28:  SUBLW  06
1B2A:  BZ    1B38
1B2C:  MOVF   71,W
1B2E:  SUBLW  09
1B30:  BZ    1B38
1B32:  MOVF   71,W
1B34:  SUBLW  0B
1B36:  BNZ   1B60
....................    { 
....................       printf("\rError en la fecha. Reseteando inicializacion...\r"); 
1B38:  CLRF   77
1B3A:  MOVF   77,W
1B3C:  CALL   07A2
1B40:  IORLW  00
1B42:  BZ    1B4E
1B44:  INCF   77,F
1B46:  BTFSS  F9E.4
1B48:  BRA    1B46
1B4A:  MOVWF  FAD
1B4C:  BRA    1B3A
....................       delay_ms(LCD_T_RETARDO); 
1B4E:  MOVLW  02
1B50:  MOVWF  77
1B52:  MOVLW  FA
1B54:  MOVWF  x88
1B56:  CALL   10E6
1B5A:  DECFSZ 77,F
1B5C:  BRA    1B52
....................       goto e1; 
1B5E:  BRA    191A
....................    } 
....................  
....................    //Leemos el año 
....................    printf("/"); 
1B60:  CLRF   77
1B62:  MOVF   77,W
1B64:  CALL   073C
1B68:  IORLW  00
1B6A:  BZ    1B76
1B6C:  INCF   77,F
1B6E:  BTFSS  F9E.4
1B70:  BRA    1B6E
1B72:  MOVWF  FAD
1B74:  BRA    1B62
....................    anno = buscar_numero_rs232(); 
1B76:  RCALL  1428
1B78:  MOVFF  01,72
....................    //Si pulsamos "backspace", se resetea la inicialización 
....................    if(anno==NOCODE) 
1B7C:  MOVF   72,W
1B7E:  SUBLW  64
1B80:  BNZ   1BAA
....................    { 
....................       printf("\rReseteando inicializacion...\r"); 
1B82:  CLRF   77
1B84:  MOVF   77,W
1B86:  CALL   06B8
1B8A:  IORLW  00
1B8C:  BZ    1B98
1B8E:  INCF   77,F
1B90:  BTFSS  F9E.4
1B92:  BRA    1B90
1B94:  MOVWF  FAD
1B96:  BRA    1B84
....................       delay_ms(LCD_T_RETARDO); 
1B98:  MOVLW  02
1B9A:  MOVWF  77
1B9C:  MOVLW  FA
1B9E:  MOVWF  x88
1BA0:  CALL   10E6
1BA4:  DECFSZ 77,F
1BA6:  BRA    1B9C
....................       goto e1; 
1BA8:  BRA    191A
....................    } 
....................    //Si el valor del año es incorrecto, reseteamos también la inicialización. 
....................    //Tampoco se permite un año menor que 2009 (año de fabricación del sistema de control) 
....................    if(anno>99 || anno<9) 
1BAA:  MOVF   72,W
1BAC:  SUBLW  63
1BAE:  BNC   1BB6
1BB0:  MOVF   72,W
1BB2:  SUBLW  08
1BB4:  BNC   1BDE
....................    { 
....................       printf("\rAnno incorrecto. Reseteando inicializacion...\r"); 
1BB6:  CLRF   77
1BB8:  MOVF   77,W
1BBA:  CALL   07EE
1BBE:  IORLW  00
1BC0:  BZ    1BCC
1BC2:  INCF   77,F
1BC4:  BTFSS  F9E.4
1BC6:  BRA    1BC4
1BC8:  MOVWF  FAD
1BCA:  BRA    1BB8
....................       delay_ms(LCD_T_RETARDO); 
1BCC:  MOVLW  02
1BCE:  MOVWF  77
1BD0:  MOVLW  FA
1BD2:  MOVWF  x88
1BD4:  CALL   10E6
1BD8:  DECFSZ 77,F
1BDA:  BRA    1BD0
....................       goto e1; 
1BDC:  BRA    191A
....................    } 
....................  
....................  
....................    //Si el año no es bisiesto y hemos seleccionado el 29 de febrero, 
....................    //mostramos un mensaje y reseteamos la operación. 
....................    if(anno%4!=0 && mes==2 && dia==29) 
1BDE:  MOVF   72,W
1BE0:  ANDLW  03
1BE2:  BZ    1C18
1BE4:  MOVF   71,W
1BE6:  SUBLW  02
1BE8:  BNZ   1C18
1BEA:  MOVF   70,W
1BEC:  SUBLW  1D
1BEE:  BNZ   1C18
....................    { 
....................       printf("\rEl anno no es bisiesto. Reseteando inicializacion...\r"); 
1BF0:  CLRF   77
1BF2:  MOVF   77,W
1BF4:  CALL   0838
1BF8:  IORLW  00
1BFA:  BZ    1C06
1BFC:  INCF   77,F
1BFE:  BTFSS  F9E.4
1C00:  BRA    1BFE
1C02:  MOVWF  FAD
1C04:  BRA    1BF2
....................       delay_ms(LCD_T_RETARDO); 
1C06:  MOVLW  02
1C08:  MOVWF  77
1C0A:  MOVLW  FA
1C0C:  MOVWF  x88
1C0E:  CALL   10E6
1C12:  DECFSZ 77,F
1C14:  BRA    1C0A
....................       goto e1; 
1C16:  BRA    191A
....................    } 
....................  
....................    //Introducimos un pequeño retardo para que el técnico vea los valores introducidos 
....................    delay_ms(LCD_T_RETARDO); 
1C18:  MOVLW  02
1C1A:  MOVWF  77
1C1C:  MOVLW  FA
1C1E:  MOVWF  x88
1C20:  CALL   10E6
1C24:  DECFSZ 77,F
1C26:  BRA    1C1C
....................  
....................    //Calculamos el año en el intervalo de 0 a 3 según sean bisiesto este año 
....................    //o los anteriores. 
....................    if(anno%4==0) 
1C28:  MOVF   72,W
1C2A:  ANDLW  03
1C2C:  BNZ   1C32
....................       anno_actual_0_to_3 = 0; 
1C2E:  CLRF   55
....................    else if((anno-1)%4==0) 
1C30:  BRA    1C5A
1C32:  MOVLW  01
1C34:  SUBWF  72,W
1C36:  ANDLW  03
1C38:  BNZ   1C40
....................       anno_actual_0_to_3 = 1; 
1C3A:  MOVLW  01
1C3C:  MOVWF  55
....................    else if((anno-2)%4==0) 
1C3E:  BRA    1C5A
1C40:  MOVLW  02
1C42:  SUBWF  72,W
1C44:  ANDLW  03
1C46:  BNZ   1C4E
....................       anno_actual_0_to_3 = 2; 
1C48:  MOVLW  02
1C4A:  MOVWF  55
....................    else if((anno-3)%4==0) 
1C4C:  BRA    1C5A
1C4E:  MOVLW  03
1C50:  SUBWF  72,W
1C52:  ANDLW  03
1C54:  BNZ   1C5A
....................       anno_actual_0_to_3 = 3; 
1C56:  MOVLW  03
1C58:  MOVWF  55
....................  
....................    e2: 
....................    //Se pide la introducción de la hora 
....................    printf("\rHORA: "); 
1C5A:  CLRF   77
1C5C:  MOVF   77,W
1C5E:  CALL   088A
1C62:  IORLW  00
1C64:  BZ    1C70
1C66:  INCF   77,F
1C68:  BTFSS  F9E.4
1C6A:  BRA    1C68
1C6C:  MOVWF  FAD
1C6E:  BRA    1C5C
....................  
....................    //Leemos la hora 
....................    horas = buscar_numero_rs232(); 
1C70:  CALL   1428
1C74:  MOVFF  01,73
....................    //Si se pulsa "backspace", se resetea todo el proceso 
....................    if(horas==NOCODE) 
1C78:  MOVF   73,W
1C7A:  SUBLW  64
1C7C:  BNZ   1CA6
....................    { 
....................       printf("\rReseteando la inicializacion...\r"); 
1C7E:  CLRF   77
1C80:  MOVF   77,W
1C82:  CALL   08AC
1C86:  IORLW  00
1C88:  BZ    1C94
1C8A:  INCF   77,F
1C8C:  BTFSS  F9E.4
1C8E:  BRA    1C8C
1C90:  MOVWF  FAD
1C92:  BRA    1C80
....................       delay_ms(LCD_T_RETARDO); 
1C94:  MOVLW  02
1C96:  MOVWF  77
1C98:  MOVLW  FA
1C9A:  MOVWF  x88
1C9C:  CALL   10E6
1CA0:  DECFSZ 77,F
1CA2:  BRA    1C98
....................       goto e1; 
1CA4:  BRA    191A
....................    } 
....................    //Si las horas son incorrectas, mostramos un mensaje de error por pantalla y 
....................    //reseteamos la introducción de la misma. 
....................    if(horas>23) 
1CA6:  MOVF   73,W
1CA8:  SUBLW  17
1CAA:  BC    1CD4
....................    { 
....................       printf("  Hora incorrecta!"); 
1CAC:  CLRF   77
1CAE:  MOVF   77,W
1CB0:  CALL   08E8
1CB4:  IORLW  00
1CB6:  BZ    1CC2
1CB8:  INCF   77,F
1CBA:  BTFSS  F9E.4
1CBC:  BRA    1CBA
1CBE:  MOVWF  FAD
1CC0:  BRA    1CAE
....................       delay_ms(LCD_T_RETARDO); 
1CC2:  MOVLW  02
1CC4:  MOVWF  77
1CC6:  MOVLW  FA
1CC8:  MOVWF  x88
1CCA:  CALL   10E6
1CCE:  DECFSZ 77,F
1CD0:  BRA    1CC6
....................       goto e2; 
1CD2:  BRA    1C5A
....................    } 
....................  
....................  
....................    //Leemos los minutos 
....................    printf(":"); 
1CD4:  CLRF   77
1CD6:  MOVF   77,W
1CD8:  CALL   0916
1CDC:  IORLW  00
1CDE:  BZ    1CEA
1CE0:  INCF   77,F
1CE2:  BTFSS  F9E.4
1CE4:  BRA    1CE2
1CE6:  MOVWF  FAD
1CE8:  BRA    1CD6
....................    minutos = buscar_numero_rs232(); 
1CEA:  CALL   1428
1CEE:  MOVFF  01,74
....................  
....................    //Si se pulsa "backspace", reseteamos la inicialización completa 
....................    if(minutos==NOCODE) 
1CF2:  MOVF   74,W
1CF4:  SUBLW  64
1CF6:  BNZ   1D20
....................    { 
....................       printf("\rReseteando la inicializacion...\r"); 
1CF8:  CLRF   77
1CFA:  MOVF   77,W
1CFC:  CALL   08AC
1D00:  IORLW  00
1D02:  BZ    1D0E
1D04:  INCF   77,F
1D06:  BTFSS  F9E.4
1D08:  BRA    1D06
1D0A:  MOVWF  FAD
1D0C:  BRA    1CFA
....................       delay_ms(LCD_T_RETARDO); 
1D0E:  MOVLW  02
1D10:  MOVWF  77
1D12:  MOVLW  FA
1D14:  MOVWF  x88
1D16:  CALL   10E6
1D1A:  DECFSZ 77,F
1D1C:  BRA    1D12
....................       goto e1; 
1D1E:  BRA    191A
....................    } 
....................    //Si los minutos no son correctos, mostramos un mensaje de error por pantalla y 
....................    //reseteamos la introducción de los minutos 
....................    if(minutos>59) 
1D20:  MOVF   74,W
1D22:  SUBLW  3B
1D24:  BC    1D4E
....................    { 
....................       printf("  Minutos incorrectos!"); 
1D26:  CLRF   77
1D28:  MOVF   77,W
1D2A:  CALL   0932
1D2E:  IORLW  00
1D30:  BZ    1D3C
1D32:  INCF   77,F
1D34:  BTFSS  F9E.4
1D36:  BRA    1D34
1D38:  MOVWF  FAD
1D3A:  BRA    1D28
....................       delay_ms(LCD_T_RETARDO); 
1D3C:  MOVLW  02
1D3E:  MOVWF  77
1D40:  MOVLW  FA
1D42:  MOVWF  x88
1D44:  CALL   10E6
1D48:  DECFSZ 77,F
1D4A:  BRA    1D40
....................       goto e2; 
1D4C:  BRA    1C5A
....................    } 
....................  
....................    //Introducimos un pequeño retardo para que el técnico pueda ver la hora introducida 
....................    delay_ms(LCD_T_RETARDO); 
1D4E:  MOVLW  02
1D50:  MOVWF  77
1D52:  MOVLW  FA
1D54:  MOVWF  x88
1D56:  CALL   10E6
1D5A:  DECFSZ 77,F
1D5C:  BRA    1D52
....................  
....................    //Mostramos un mensaje de guardado de configuración 
....................    printf("\rGuardando configuracion..."); 
1D5E:  CLRF   77
1D60:  MOVF   77,W
1D62:  CALL   0964
1D66:  IORLW  00
1D68:  BZ    1D74
1D6A:  INCF   77,F
1D6C:  BTFSS  F9E.4
1D6E:  BRA    1D6C
1D70:  MOVWF  FAD
1D72:  BRA    1D60
....................  
....................    //Almacenamos todo en la estructura que contiene la información del tiempo 
....................    tiempo.month   = mes; 
1D74:  MOVFF  71,49
....................    tiempo.day     = dia; 
1D78:  MOVFF  70,48
....................    tiempo.year    = anno_actual_0_to_3; 
1D7C:  MOVFF  55,4A
....................    tiempo.hours   = horas; 
1D80:  MOVFF  73,47
....................    tiempo.minutes = minutos; 
1D84:  MOVFF  74,46
....................    tiempo.seconds = 0x00; 
1D88:  CLRF   45
....................    tiempo.weekday = weekday; 
1D8A:  MOVFF  6F,4B
....................  
....................    //Fijamos el reloj a esa fecha y hora 
....................    PCF8583_set_datetime(&tiempo); 
1D8E:  CLRF   78
1D90:  MOVLW  45
1D92:  MOVWF  77
1D94:  GOTO   156C
....................  
....................    //Establecemos los parámetros iniciales del sistema para resetear la memoria 
....................    termostato = (float)20; 
1D98:  CLRF   22
1D9A:  CLRF   21
1D9C:  MOVLW  20
1D9E:  MOVWF  20
1DA0:  MOVLW  83
1DA2:  MOVWF  1F
....................    num_intervalos = 0; 
1DA4:  CLRF   43
....................    num_registros = 0; 
1DA6:  CLRF   53
....................    anno_actual = anno; 
1DA8:  MOVFF  72,54
....................  
....................    //Escribimos los datos en la EEPROM 
....................    write_eeprom(eeprom_termostato, (int)termostato); 
1DAC:  MOVFF  22,8A
1DB0:  MOVFF  21,89
1DB4:  MOVFF  20,88
1DB8:  MOVFF  1F,87
1DBC:  RCALL  16B2
1DBE:  MOVFF  01,77
1DC2:  CLRF   FA9
1DC4:  MOVFF  01,FA8
1DC8:  BCF    FA6.6
1DCA:  BCF    FA6.7
1DCC:  BSF    FA6.2
1DCE:  MOVFF  FF2,00
1DD2:  BCF    FF2.7
1DD4:  MOVLB  F
1DD6:  MOVLW  55
1DD8:  MOVWF  FA7
1DDA:  MOVLW  AA
1DDC:  MOVWF  FA7
1DDE:  BSF    FA6.1
1DE0:  BTFSC  FA6.1
1DE2:  BRA    1DE0
1DE4:  BCF    FA6.2
1DE6:  MOVF   00,W
1DE8:  IORWF  FF2,F
....................    write_eeprom(eeprom_num_intervalos, num_intervalos); 
1DEA:  MOVLW  01
1DEC:  MOVWF  FA9
1DEE:  MOVFF  43,FA8
1DF2:  BCF    FA6.6
1DF4:  BCF    FA6.7
1DF6:  BSF    FA6.2
1DF8:  MOVFF  FF2,00
1DFC:  BCF    FF2.7
1DFE:  MOVLW  55
1E00:  MOVWF  FA7
1E02:  MOVLW  AA
1E04:  MOVWF  FA7
1E06:  BSF    FA6.1
1E08:  BTFSC  FA6.1
1E0A:  BRA    1E08
1E0C:  BCF    FA6.2
1E0E:  MOVF   00,W
1E10:  IORWF  FF2,F
....................    write_eeprom(eeprom_num_registros, num_registros); 
1E12:  MOVLW  02
1E14:  MOVWF  FA9
1E16:  MOVFF  53,FA8
1E1A:  BCF    FA6.6
1E1C:  BCF    FA6.7
1E1E:  BSF    FA6.2
1E20:  MOVFF  FF2,00
1E24:  BCF    FF2.7
1E26:  MOVLW  55
1E28:  MOVWF  FA7
1E2A:  MOVLW  AA
1E2C:  MOVWF  FA7
1E2E:  BSF    FA6.1
1E30:  BTFSC  FA6.1
1E32:  BRA    1E30
1E34:  BCF    FA6.2
1E36:  MOVF   00,W
1E38:  IORWF  FF2,F
....................    write_eeprom(eeprom_anno_actual, anno_actual); 
1E3A:  MOVLW  03
1E3C:  MOVWF  FA9
1E3E:  MOVFF  54,FA8
1E42:  BCF    FA6.6
1E44:  BCF    FA6.7
1E46:  BSF    FA6.2
1E48:  MOVFF  FF2,00
1E4C:  BCF    FF2.7
1E4E:  MOVLW  55
1E50:  MOVWF  FA7
1E52:  MOVLW  AA
1E54:  MOVWF  FA7
1E56:  BSF    FA6.1
1E58:  BTFSC  FA6.1
1E5A:  BRA    1E58
1E5C:  BCF    FA6.2
1E5E:  MOVF   00,W
1E60:  IORWF  FF2,F
....................    write_eeprom(eeprom_anno_0_to_3, anno_actual_0_to_3); 
1E62:  MOVLW  04
1E64:  MOVWF  FA9
1E66:  MOVFF  55,FA8
1E6A:  BCF    FA6.6
1E6C:  BCF    FA6.7
1E6E:  BSF    FA6.2
1E70:  MOVFF  FF2,00
1E74:  BCF    FF2.7
1E76:  MOVLW  55
1E78:  MOVWF  FA7
1E7A:  MOVLW  AA
1E7C:  MOVWF  FA7
1E7E:  BSF    FA6.1
1E80:  BTFSC  FA6.1
1E82:  BRA    1E80
1E84:  BCF    FA6.2
1E86:  MOVF   00,W
1E88:  IORWF  FF2,F
....................  
....................    //Escribimos el valor del termostato en el sensor de temperatura. 
....................    //Ponemos como valor alto 127.5 grados, temperatura que no se va a alcanzar. 
....................    ds1820_establecer_TH_TL(127.5, termostato); 
1E8A:  CLRF   7A
1E8C:  CLRF   79
1E8E:  MOVLW  7F
1E90:  MOVWF  78
1E92:  MOVLW  85
1E94:  MOVWF  77
1E96:  MOVFF  22,7E
1E9A:  MOVFF  21,7D
1E9E:  MOVFF  20,7C
1EA2:  MOVFF  1F,7B
1EA6:  MOVLB  0
1EA8:  RCALL  184C
....................  
....................    //Mostramos un mensaje de inicio del sistema 
....................    printf("\rIniciando sistema...\r"); 
1EAA:  CLRF   77
1EAC:  MOVF   77,W
1EAE:  CALL   099A
1EB2:  IORLW  00
1EB4:  BZ    1EC0
1EB6:  INCF   77,F
1EB8:  BTFSS  F9E.4
1EBA:  BRA    1EB8
1EBC:  MOVWF  FAD
1EBE:  BRA    1EAC
.................... } 
1EC0:  GOTO   5B42 (RETURN)
....................  
.................... //------------------------------------------------------------------------------------------------------------------------------------ 
....................  
.................... void leer_programaciones(){ 
....................    programacion pr;  //Variable temporal para guardar la programación 
....................    int contador;    //Contador del bucle 
....................  
....................    //Se supone que antes ha sido recuperado el número de intervalos 
....................    //Recorremos todas las programaciones guardadas 
....................    for(contador=0; contador<num_intervalos; contador++) 
....................    { 
....................       //Leemos de memoria y vamos guardando los datos correspondientes 
....................       pr.horas_inicio   = read_eeprom(eeprom_programaciones + (contador)*5); 
....................       pr.minutos_inicio = read_eeprom(eeprom_programaciones + (contador)*5 + 1); 
....................       pr.horas_fin      = read_eeprom(eeprom_programaciones + (contador)*5 + 2); 
....................       pr.minutos_fin    = read_eeprom(eeprom_programaciones + (contador)*5 + 3); 
....................       pr.termostato     = read_eeprom(eeprom_programaciones + (contador)*5 + 4); 
....................  
....................       //Guardamos la programación en el vector correspondiente 
....................       programaciones[contador] = pr; 
....................  
....................    } 
.................... } 
....................  
.................... //------------------------------------------------------------------------------------------------------------------------------------ 
....................  
.................... void mostrar_temperatura() 
.................... { 
....................    //Leemos el tiempo y lo guardamos en la variable tiempo 
....................    PCF8583_read_datetime(&tiempo); 
*
5902:  CLRF   78
5904:  MOVLW  45
5906:  MOVWF  77
5908:  CALL   285C
....................    //Activamos las interrupciones, que se desactivan dentro del método 
....................    enable_interrupts(GLOBAL); 
590C:  MOVLW  C0
590E:  IORWF  FF2,F
....................  
....................    //Mostramos la temperatura registrada 
....................    lcd_send_byte(LCD_ORDEN, LCD_CLEAR); 
5910:  CLRF   x86
5912:  MOVLW  01
5914:  MOVWF  x87
5916:  CALL   1152
....................    printf(lcd_putc, "TEMP - %3.1f %cC\nHORA - ", temperatura, 223); 
591A:  CLRF   6F
591C:  MOVF   6F,W
591E:  CALL   09CC
5922:  INCF   6F,F
5924:  MOVWF  00
5926:  MOVWF  x81
5928:  CALL   11FE
592C:  MOVLW  07
592E:  SUBWF  6F,W
5930:  BNZ   591C
5932:  MOVLW  02
5934:  MOVWF  FE9
5936:  MOVFF  2A,77
593A:  MOVFF  29,76
593E:  MOVFF  28,75
5942:  MOVFF  27,74
5946:  MOVLW  01
5948:  MOVWF  78
594A:  CALL   334C
594E:  MOVLW  20
5950:  MOVWF  x81
5952:  CALL   11FE
5956:  MOVLW  DF
5958:  MOVWF  x81
595A:  CALL   11FE
595E:  MOVLW  0F
5960:  MOVWF  70
5962:  MOVF   70,W
5964:  CALL   09CC
5968:  INCF   70,F
596A:  MOVWF  00
596C:  MOVWF  x81
596E:  CALL   11FE
5972:  MOVLW  18
5974:  SUBWF  70,W
5976:  BNZ   5962
....................  
....................    //Mostramos la hora 
....................    //Comprobamos si los valores son menores que 10 para añadir un cero 
....................    //delante y que queden los valores alineados 
....................    if(tiempo.hours < 10) 
5978:  MOVF   47,W
597A:  SUBLW  09
597C:  BNC   5994
....................       printf(lcd_putc, "0"); 
597E:  CLRF   6F
5980:  MOVF   6F,W
5982:  CALL   0476
5986:  IORLW  00
5988:  BZ    5994
598A:  INCF   6F,F
598C:  MOVWF  x81
598E:  CALL   11FE
5992:  BRA    5980
....................    printf(lcd_putc, "%u:", tiempo.hours); 
5994:  MOVFF  47,6F
5998:  MOVLW  1B
599A:  MOVWF  70
599C:  RCALL  588A
599E:  MOVLW  3A
59A0:  MOVWF  x81
59A2:  CALL   11FE
....................    if(tiempo.minutes < 10) 
59A6:  MOVF   46,W
59A8:  SUBLW  09
59AA:  BNC   59C2
....................       printf(lcd_putc, "0"); 
59AC:  CLRF   6F
59AE:  MOVF   6F,W
59B0:  CALL   0476
59B4:  IORLW  00
59B6:  BZ    59C2
59B8:  INCF   6F,F
59BA:  MOVWF  x81
59BC:  CALL   11FE
59C0:  BRA    59AE
....................    printf(lcd_putc, "%u", tiempo.minutes); 
59C2:  MOVFF  46,6F
59C6:  MOVLW  1B
59C8:  MOVWF  70
59CA:  RCALL  588A
.................... } 
59CC:  GOTO   59E6 (RETURN)
....................  
.................... //------------------------------------------------------------------------------------------------------------------------------------ 
....................  
.................... void ordenar_programaciones() 
.................... { 
....................    //Variables temporales y contadores auxiliares 
....................    programacion *pr1; 
....................    programacion *pr2; 
....................    int contador1, contador2; 
....................    int h_inicio_1, min_inicio_1, h_inicio_2, min_inicio_2; 
....................  
....................    //Ambos punteros comienzan apuntando al principio de programaciones 
....................    pr1 = programaciones; 
*
3702:  CLRF   70
3704:  MOVLW  2F
3706:  MOVWF  6F
....................    pr2 = programaciones; 
3708:  CLRF   72
370A:  MOVWF  71
....................  
....................  
....................    //Algoritmo de la burbuja 
....................    for(contador1=0; contador1 < num_intervalos; contador1++) 
370C:  CLRF   73
370E:  MOVF   43,W
3710:  SUBWF  73,W
3712:  BTFSC  FD8.0
3714:  BRA    3836
....................    { 
....................       //Apuntamos a las dos últimas posiciones del vector 
....................       pr1 = programaciones+num_intervalos-2; 
3716:  MOVF   43,W
3718:  MULLW  05
371A:  MOVF   FF3,W
371C:  ADDLW  2F
371E:  MOVWF  7E
3720:  CLRF   7F
3722:  BTFSC  FD8.0
3724:  INCF   7F,F
3726:  MOVLW  0A
3728:  SUBWF  7E,W
372A:  MOVWF  6F
372C:  MOVLW  00
372E:  SUBWFB 7F,W
3730:  MOVWF  70
....................       pr2 = programaciones+num_intervalos-1; 
3732:  MOVF   43,W
3734:  MULLW  05
3736:  MOVF   FF3,W
3738:  ADDLW  2F
373A:  MOVWF  7E
373C:  CLRF   7F
373E:  BTFSC  FD8.0
3740:  INCF   7F,F
3742:  MOVLW  05
3744:  SUBWF  7E,W
3746:  MOVWF  71
3748:  MOVLW  00
374A:  SUBWFB 7F,W
374C:  MOVWF  72
....................  
....................       //Iteramos hasta llegar a la zona ordenada del vector 
....................       for(contador2=0; contador2 < num_intervalos-contador1-1; contador2++) 
374E:  CLRF   74
3750:  MOVF   73,W
3752:  SUBWF  43,W
3754:  ADDLW  FF
3756:  SUBWF  74,W
3758:  BC    3832
....................       { 
....................          //Tomamos para la comparación los instantes de inicio 
....................          h_inicio_1   = (*pr1).horas_inicio; 
375A:  MOVFF  6F,FE9
375E:  MOVFF  70,FEA
3762:  MOVFF  FEF,75
....................          min_inicio_1 = (*pr1).minutos_inicio; 
3766:  MOVLW  01
3768:  ADDWF  6F,W
376A:  MOVWF  FE9
376C:  MOVLW  00
376E:  ADDWFC 70,W
3770:  MOVWF  FEA
3772:  MOVFF  FEF,76
....................          h_inicio_2   = (*pr2).horas_inicio; 
3776:  MOVFF  71,FE9
377A:  MOVFF  72,FEA
377E:  MOVFF  FEF,77
....................          min_inicio_2 = (*pr2).minutos_inicio; 
3782:  MOVLW  01
3784:  ADDWF  71,W
3786:  MOVWF  FE9
3788:  MOVLW  00
378A:  ADDWFC 72,W
378C:  MOVWF  FEA
378E:  MOVFF  FEF,78
....................  
....................          //Si la hora de pr2 es menor que la de pr1, habrá que intercambiar los 
....................          //valores para mover la menor a una posición más baja 
....................          if(comprobar_hora(h_inicio_2, min_inicio_2, h_inicio_1, min_inicio_1)) 
3792:  MOVFF  77,81
3796:  MOVFF  78,82
379A:  MOVFF  75,83
379E:  MOVFF  76,84
37A2:  CALL   2A7C
37A6:  MOVF   01,F
37A8:  BZ    381E
....................          { 
....................             programacion temporal; 
....................             temporal = *pr1; 
37AA:  MOVFF  70,03
37AE:  MOVFF  6F,7E
37B2:  MOVFF  70,7F
37B6:  CLRF   FEA
37B8:  MOVLW  79
37BA:  MOVWF  FE9
37BC:  MOVFF  70,FE2
37C0:  MOVFF  6F,FE1
37C4:  MOVLW  05
37C6:  MOVWF  01
37C8:  MOVFF  FE6,FEE
37CC:  DECFSZ 01,F
37CE:  BRA    37C8
....................             *pr1 = *pr2; 
37D0:  MOVFF  6F,80
37D4:  MOVFF  70,81
37D8:  MOVFF  72,03
37DC:  MOVFF  71,82
37E0:  MOVFF  72,83
37E4:  MOVFF  70,FEA
37E8:  MOVFF  6F,FE9
37EC:  MOVFF  72,FE2
37F0:  MOVFF  71,FE1
37F4:  MOVLW  05
37F6:  MOVWF  01
37F8:  MOVFF  FE6,FEE
37FC:  DECFSZ 01,F
37FE:  BRA    37F8
....................             *pr2 = temporal; 
3800:  MOVFF  72,03
3804:  MOVFF  71,FE9
3808:  MOVFF  03,FEA
380C:  CLRF   FE2
380E:  MOVLW  79
3810:  MOVWF  FE1
3812:  MOVLW  05
3814:  MOVWF  01
3816:  MOVFF  FE6,FEE
381A:  DECFSZ 01,F
381C:  BRA    3816
....................          } 
....................  
....................          //Pasamos a la siguiente posición y repetimos el proceso 
....................          pr1--; 
381E:  MOVLW  FB
3820:  ADDWF  6F,F
3822:  BTFSS  FD8.0
3824:  DECF   70,F
....................          pr2--; 
3826:  MOVLW  FB
3828:  ADDWF  71,F
382A:  BTFSS  FD8.0
382C:  DECF   72,F
....................       } 
382E:  INCF   74,F
3830:  BRA    3750
....................  
....................    } 
3832:  INCF   73,F
3834:  BRA    370E
....................  
.................... } 
3836:  GOTO   6632 (RETURN)
....................  
.................... //------------------------------------------------------------------------------------------------------------------------------------ 
....................  
.................... void programar_proxima_alarma() 
.................... { 
....................    //Variables auxiliares 
....................    int hora, minutos; 
....................  
....................    //Recuperamos los datos de inicio de la alarma actual 
....................    prg=programaciones[posicion_alarmas]; 
*
2A3E:  MOVF   44,W
2A40:  MULLW  05
2A42:  MOVF   FF3,W
2A44:  CLRF   03
2A46:  ADDLW  2F
2A48:  MOVWF  01
2A4A:  MOVLW  00
2A4C:  ADDWFC 03,F
2A4E:  MOVFF  01,71
2A52:  MOVFF  03,72
2A56:  CLRF   FEA
2A58:  MOVLW  3E
2A5A:  MOVWF  FE9
2A5C:  MOVFF  03,FE2
2A60:  MOVFF  01,FE1
2A64:  MOVLW  05
2A66:  MOVWF  01
2A68:  MOVFF  FE6,FEE
2A6C:  DECFSZ 01,F
2A6E:  BRA    2A68
....................  
....................    //Establecemos la alarma a ese tiempo 
....................    hora_alarma = prg.horas_inicio; 
2A70:  MOVFF  3E,56
....................    minutos_alarma = prg.minutos_inicio; 
2A74:  MOVFF  3F,57
....................    alarma = TRUE; 
2A78:  BSF    1E.6
.................... } 
2A7A:  RETLW  00
....................  
.................... //------------------------------------------------------------------------------------------------------------------------------------ 
....................  
.................... void representar_registros() 
.................... { 
....................    //Contadores para los bucles 
....................    unsigned int contador, contador2; 
....................    //Caracter para la introducción de las opciones 
....................    char caracter; 
....................    //Lista de variables recuperadas 
....................    unsigned int dia, mes, anno, horas, minutos, temp_int, temp_dec, t_sistema, t_caldera, term; 
....................  
....................    float media_dia_mes[12];         //Tiempos medios en minutos que se enciende el sistema en cada mes 
....................    int dias_meses[12];              //Número de dias que tiene cada mes 
....................    float media_dia_caldera;         //Tiempo medio que se enciende la caldera cada día 
....................    float valor;                     //Tiempo medio en minutos que se enciende el sistema por día 
....................    float media_dia_mes_caldera[12]; //Tiempo medio que se enciende la caldera en cada mes 
....................  
....................    unsigned long valor_total;  //Tiempo total de encendido de la caldera 
....................    unsigned long valor_total_caldera; //Tiempo total de encendido del sistema 
....................  
....................    //Capacidad para 4 años de datos 
....................    //Vectores de almacenamiento de los datos anuales 
....................    float media_annos[4][12]; 
....................    float media_annos_caldera[4][12]; 
....................    //Número de años de los que se tienen datos 
....................    int num_annos; 
....................    //Años correspondientes 
....................    int annos[4]; 
....................  
....................    //Variables para almacenar valores provisionales 
....................    long tiempo_x_dia;         //Tiempo que se enciende cada día el sistema (minutos) 
....................    long tiempo_x_dia_caldera; //Tiempo que se enciende cada día la caldera (minutos) 
....................    int fecha[3];             //Día con el que estamos trabajando (día/mes/año) 
....................    long num_dias;             //Número de días que llevamos analizados 
....................  
....................    //dias_meses = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}; 
....................    dias_meses[0] = dias_meses[2] = dias_meses[4] = dias_meses[6] = dias_meses[7] = dias_meses[9] = dias_meses[11] = 31; 
*
3CFE:  MOVLW  1F
3D00:  MOVWF  xB7
3D02:  MOVFF  B7,B5
3D06:  MOVFF  B5,B3
3D0A:  MOVFF  B3,B2
3D0E:  MOVFF  B2,B0
3D12:  MOVFF  B0,AE
3D16:  MOVFF  AE,AC
....................    dias_meses[1] = 28; 
3D1A:  MOVLW  1C
3D1C:  MOVWF  xAD
....................    dias_meses[3] = dias_meses[5] = dias_meses[8] = dias_meses[10] = 30; 
3D1E:  MOVLW  1E
3D20:  MOVWF  xB6
3D22:  MOVFF  B6,B4
3D26:  MOVFF  B4,B1
3D2A:  MOVFF  B1,AF
....................  
....................    //Inicializamos los vectores a 0 
....................    for(contador=0; contador<12;contador++) 
3D2E:  CLRF   6F
3D30:  MOVF   6F,W
3D32:  SUBLW  0B
3D34:  BNC   3D54
....................    { 
....................       media_dia_mes[contador]=0; 
3D36:  MOVF   6F,W
3D38:  MULLW  04
3D3A:  MOVF   FF3,W
3D3C:  CLRF   03
3D3E:  ADDLW  7C
3D40:  MOVWF  FE9
3D42:  MOVLW  00
3D44:  ADDWFC 03,W
3D46:  MOVWF  FEA
3D48:  CLRF   FEF
3D4A:  CLRF   FEC
3D4C:  CLRF   FEC
3D4E:  CLRF   FEC
....................    } 
3D50:  INCF   6F,F
3D52:  BRA    3D30
....................  
....................    for(contador=0; contador<12;contador++) 
3D54:  CLRF   6F
3D56:  MOVF   6F,W
3D58:  SUBLW  0B
3D5A:  BNC   3D7A
....................    { 
....................       media_dia_mes_caldera[contador]=0; 
3D5C:  MOVF   6F,W
3D5E:  MULLW  04
3D60:  MOVF   FF3,W
3D62:  CLRF   03
3D64:  ADDLW  C0
3D66:  MOVWF  FE9
3D68:  MOVLW  00
3D6A:  ADDWFC 03,W
3D6C:  MOVWF  FEA
3D6E:  CLRF   FEF
3D70:  CLRF   FEC
3D72:  CLRF   FEC
3D74:  CLRF   FEC
....................    } 
3D76:  INCF   6F,F
3D78:  BRA    3D56
....................  
....................    for(contador=0; contador<4 ;contador++) 
3D7A:  CLRF   6F
3D7C:  MOVF   6F,W
3D7E:  SUBLW  03
3D80:  BNC   3DC4
....................    { 
....................       for(contador2=0; contador2<12 ;contador2++) 
3D82:  CLRF   70
3D84:  MOVF   70,W
3D86:  SUBLW  0B
3D88:  BNC   3DC0
....................       { 
....................          media_annos[contador][contador2]=0; 
3D8A:  MOVF   6F,W
3D8C:  MULLW  30
3D8E:  MOVF   FF3,W
3D90:  MOVLB  2
3D92:  CLRF   x83
3D94:  MOVWF  x82
3D96:  MOVF   70,W
3D98:  MULLW  04
3D9A:  MOVF   FF3,W
3D9C:  CLRF   03
3D9E:  ADDWF  x82,W
3DA0:  MOVWF  01
3DA2:  MOVF   x83,W
3DA4:  ADDWFC 03,F
3DA6:  MOVF   01,W
3DA8:  ADDLW  F4
3DAA:  MOVWF  FE9
3DAC:  MOVLW  00
3DAE:  ADDWFC 03,W
3DB0:  MOVWF  FEA
3DB2:  CLRF   FEF
3DB4:  CLRF   FEC
3DB6:  CLRF   FEC
3DB8:  CLRF   FEC
....................       } 
3DBA:  INCF   70,F
3DBC:  MOVLB  0
3DBE:  BRA    3D84
....................    } 
3DC0:  INCF   6F,F
3DC2:  BRA    3D7C
....................  
....................    for(contador=0; contador<4 ;contador++) 
3DC4:  CLRF   6F
3DC6:  MOVF   6F,W
3DC8:  SUBLW  03
3DCA:  BNC   3E0E
....................    { 
....................       for(contador2=0; contador2<12 ;contador2++) 
3DCC:  CLRF   70
3DCE:  MOVF   70,W
3DD0:  SUBLW  0B
3DD2:  BNC   3E0A
....................       { 
....................          media_annos_caldera[contador][contador2]=0; 
3DD4:  MOVF   6F,W
3DD6:  MULLW  30
3DD8:  MOVF   FF3,W
3DDA:  MOVLB  2
3DDC:  CLRF   x83
3DDE:  MOVWF  x82
3DE0:  MOVF   70,W
3DE2:  MULLW  04
3DE4:  MOVF   FF3,W
3DE6:  CLRF   03
3DE8:  ADDWF  x82,W
3DEA:  MOVWF  01
3DEC:  MOVF   x83,W
3DEE:  ADDWFC 03,F
3DF0:  MOVF   01,W
3DF2:  ADDLW  B4
3DF4:  MOVWF  FE9
3DF6:  MOVLW  01
3DF8:  ADDWFC 03,W
3DFA:  MOVWF  FEA
3DFC:  CLRF   FEF
3DFE:  CLRF   FEC
3E00:  CLRF   FEC
3E02:  CLRF   FEC
....................       } 
3E04:  INCF   70,F
3E06:  MOVLB  0
3E08:  BRA    3DCE
....................    } 
3E0A:  INCF   6F,F
3E0C:  BRA    3DC6
....................  
....................    //Iniciamos a cero las otras variables 
....................    fecha[0] = fecha[1] = fecha[2] = 0; 
3E0E:  MOVLB  2
3E10:  CLRF   x7F
3E12:  MOVFF  27F,27E
3E16:  MOVFF  27E,27D
....................    num_dias = 0; 
3E1A:  CLRF   x81
3E1C:  CLRF   x80
....................    num_annos = 0; 
3E1E:  CLRF   x74
....................  
....................    media_dia_caldera = 0; 
3E20:  MOVLB  0
3E22:  CLRF   xBB
3E24:  CLRF   xBA
3E26:  CLRF   xB9
3E28:  CLRF   xB8
....................    valor = 0; 
3E2A:  CLRF   xBF
3E2C:  CLRF   xBE
3E2E:  CLRF   xBD
3E30:  CLRF   xBC
....................    valor_total = 0; 
3E32:  CLRF   xF1
3E34:  CLRF   xF0
....................    valor_total_caldera = 0; 
3E36:  CLRF   xF3
3E38:  CLRF   xF2
....................  
....................    //Imprimimos el encabezamiento 
....................    printf("\rREGISTRO DE EVENTOS\r"); 
3E3A:  MOVLB  2
3E3C:  CLRF   x82
3E3E:  MOVF   x82,W
3E40:  MOVLB  0
3E42:  CALL   0A00
3E46:  IORLW  00
3E48:  BZ    3E58
3E4A:  MOVLB  2
3E4C:  INCF   x82,F
3E4E:  BTFSS  F9E.4
3E50:  BRA    3E4E
3E52:  MOVWF  FAD
3E54:  BRA    3E3E
3E56:  MOVLB  0
....................    printf("*******************\r"); 
3E58:  MOVLB  2
3E5A:  CLRF   x82
3E5C:  MOVF   x82,W
3E5E:  MOVLB  0
3E60:  CALL   0A30
3E64:  IORLW  00
3E66:  BZ    3E76
3E68:  MOVLB  2
3E6A:  INCF   x82,F
3E6C:  BTFSS  F9E.4
3E6E:  BRA    3E6C
3E70:  MOVWF  FAD
3E72:  BRA    3E5C
3E74:  MOVLB  0
....................    printf("Fecha           Temp.    Term.  Min.S.  Min.C.\r"); 
3E76:  MOVLB  2
3E78:  CLRF   x82
3E7A:  MOVF   x82,W
3E7C:  MOVLB  0
3E7E:  CALL   0A60
3E82:  IORLW  00
3E84:  BZ    3E94
3E86:  MOVLB  2
3E88:  INCF   x82,F
3E8A:  BTFSS  F9E.4
3E8C:  BRA    3E8A
3E8E:  MOVWF  FAD
3E90:  BRA    3E7A
3E92:  MOVLB  0
....................    printf("==============================================\r"); 
3E94:  MOVLB  2
3E96:  CLRF   x82
3E98:  MOVF   x82,W
3E9A:  MOVLB  0
3E9C:  CALL   0AAA
3EA0:  IORLW  00
3EA2:  BZ    3EB2
3EA4:  MOVLB  2
3EA6:  INCF   x82,F
3EA8:  BTFSS  F9E.4
3EAA:  BRA    3EA8
3EAC:  MOVWF  FAD
3EAE:  BRA    3E98
3EB0:  MOVLB  0
....................  
....................    //Recorremos todos los registros almacenados 
....................    for(contador=0; contador<num_registros; contador++) 
3EB2:  CLRF   6F
3EB4:  MOVF   53,W
3EB6:  SUBWF  6F,W
3EB8:  BTFSC  FD8.0
3EBA:  GOTO   4650
....................    { 
....................       //Comenzamos leyendo los datos de memoria 
....................       dia         =  read_eeprom(eeprom_registros + contador*10); 
3EBE:  MOVF   6F,W
3EC0:  MULLW  0A
3EC2:  MOVF   FF3,W
3EC4:  ADDLW  14
3EC6:  MOVLB  2
3EC8:  MOVFF  FF2,283
3ECC:  BCF    FF2.7
3ECE:  MOVWF  FA9
3ED0:  BCF    FA6.6
3ED2:  BCF    FA6.7
3ED4:  BSF    FA6.0
3ED6:  MOVF   FA8,W
3ED8:  BTFSC  x83.7
3EDA:  BSF    FF2.7
3EDC:  MOVWF  72
....................       mes         =  read_eeprom(eeprom_registros + contador*10 + 1); 
3EDE:  MOVF   6F,W
3EE0:  MULLW  0A
3EE2:  MOVF   FF3,W
3EE4:  ADDLW  14
3EE6:  ADDLW  01
3EE8:  MOVFF  FF2,284
3EEC:  BCF    FF2.7
3EEE:  MOVWF  FA9
3EF0:  BCF    FA6.6
3EF2:  BCF    FA6.7
3EF4:  BSF    FA6.0
3EF6:  MOVF   FA8,W
3EF8:  BTFSC  x84.7
3EFA:  BSF    FF2.7
3EFC:  MOVWF  73
....................       anno        =  read_eeprom(eeprom_registros + contador*10 + 2); 
3EFE:  MOVF   6F,W
3F00:  MULLW  0A
3F02:  MOVF   FF3,W
3F04:  ADDLW  14
3F06:  ADDLW  02
3F08:  MOVFF  FF2,284
3F0C:  BCF    FF2.7
3F0E:  MOVWF  FA9
3F10:  BCF    FA6.6
3F12:  BCF    FA6.7
3F14:  BSF    FA6.0
3F16:  MOVF   FA8,W
3F18:  BTFSC  x84.7
3F1A:  BSF    FF2.7
3F1C:  MOVWF  74
....................       horas       =  read_eeprom(eeprom_registros + contador*10 + 3); 
3F1E:  MOVF   6F,W
3F20:  MULLW  0A
3F22:  MOVF   FF3,W
3F24:  ADDLW  14
3F26:  ADDLW  03
3F28:  MOVFF  FF2,284
3F2C:  BCF    FF2.7
3F2E:  MOVWF  FA9
3F30:  BCF    FA6.6
3F32:  BCF    FA6.7
3F34:  BSF    FA6.0
3F36:  MOVF   FA8,W
3F38:  BTFSC  x84.7
3F3A:  BSF    FF2.7
3F3C:  MOVWF  75
....................       minutos     =  read_eeprom(eeprom_registros + contador*10 + 4); 
3F3E:  MOVF   6F,W
3F40:  MULLW  0A
3F42:  MOVF   FF3,W
3F44:  ADDLW  14
3F46:  ADDLW  04
3F48:  MOVFF  FF2,284
3F4C:  BCF    FF2.7
3F4E:  MOVWF  FA9
3F50:  BCF    FA6.6
3F52:  BCF    FA6.7
3F54:  BSF    FA6.0
3F56:  MOVF   FA8,W
3F58:  BTFSC  x84.7
3F5A:  BSF    FF2.7
3F5C:  MOVWF  76
....................       temp_int    =  read_eeprom(eeprom_registros + contador*10 + 5); 
3F5E:  MOVF   6F,W
3F60:  MULLW  0A
3F62:  MOVF   FF3,W
3F64:  ADDLW  14
3F66:  ADDLW  05
3F68:  MOVFF  FF2,284
3F6C:  BCF    FF2.7
3F6E:  MOVWF  FA9
3F70:  BCF    FA6.6
3F72:  BCF    FA6.7
3F74:  BSF    FA6.0
3F76:  MOVF   FA8,W
3F78:  BTFSC  x84.7
3F7A:  BSF    FF2.7
3F7C:  MOVWF  77
....................       temp_dec    =  read_eeprom(eeprom_registros + contador*10 + 6); 
3F7E:  MOVF   6F,W
3F80:  MULLW  0A
3F82:  MOVF   FF3,W
3F84:  ADDLW  14
3F86:  ADDLW  06
3F88:  MOVFF  FF2,284
3F8C:  BCF    FF2.7
3F8E:  MOVWF  FA9
3F90:  BCF    FA6.6
3F92:  BCF    FA6.7
3F94:  BSF    FA6.0
3F96:  MOVF   FA8,W
3F98:  BTFSC  x84.7
3F9A:  BSF    FF2.7
3F9C:  MOVWF  78
....................       t_sistema   =  read_eeprom(eeprom_registros + contador*10 + 7); 
3F9E:  MOVF   6F,W
3FA0:  MULLW  0A
3FA2:  MOVF   FF3,W
3FA4:  ADDLW  14
3FA6:  ADDLW  07
3FA8:  MOVFF  FF2,284
3FAC:  BCF    FF2.7
3FAE:  MOVWF  FA9
3FB0:  BCF    FA6.6
3FB2:  BCF    FA6.7
3FB4:  BSF    FA6.0
3FB6:  MOVF   FA8,W
3FB8:  BTFSC  x84.7
3FBA:  BSF    FF2.7
3FBC:  MOVWF  79
....................       t_caldera   =  read_eeprom(eeprom_registros + contador*10 + 8); 
3FBE:  MOVF   6F,W
3FC0:  MULLW  0A
3FC2:  MOVF   FF3,W
3FC4:  ADDLW  14
3FC6:  ADDLW  08
3FC8:  MOVFF  FF2,284
3FCC:  BCF    FF2.7
3FCE:  MOVWF  FA9
3FD0:  BCF    FA6.6
3FD2:  BCF    FA6.7
3FD4:  BSF    FA6.0
3FD6:  MOVF   FA8,W
3FD8:  BTFSC  x84.7
3FDA:  BSF    FF2.7
3FDC:  MOVWF  7A
....................       term        =  read_eeprom(eeprom_registros + contador*10 + 9); 
3FDE:  MOVF   6F,W
3FE0:  MULLW  0A
3FE2:  MOVF   FF3,W
3FE4:  ADDLW  14
3FE6:  ADDLW  09
3FE8:  MOVFF  FF2,284
3FEC:  BCF    FF2.7
3FEE:  MOVWF  FA9
3FF0:  BCF    FA6.6
3FF2:  BCF    FA6.7
3FF4:  BSF    FA6.0
3FF6:  MOVF   FA8,W
3FF8:  BTFSC  x84.7
3FFA:  BSF    FF2.7
3FFC:  MOVWF  7B
....................  
....................       //Si cambiamos de día debemos gestionar los datos del nuevo día y almacenar los del anterior 
....................       if(fecha[0]!=dia || fecha[1]!=mes || fecha[2]!=anno) 
3FFE:  MOVF   72,W
4000:  SUBWF  x7D,W
4002:  BNZ   4012
4004:  MOVF   73,W
4006:  SUBWF  x7E,W
4008:  BNZ   4012
400A:  MOVF   74,W
400C:  SUBWF  x7F,W
400E:  BTFSC  FD8.2
4010:  BRA    436E
....................       { 
....................          //Lógicamente, no tenemos en cuenta para la media los días en los que no se enciende: 
....................          //días de verano, calurosos, etc. Esta información puede visualizarse en la media 
....................          //por meses. 
....................          //Guardamos los datos del día anterior si el día no es el primero 
....................          if(fecha[0]!=0) 
4012:  MOVF   x7D,F
4014:  BZ    40EA
....................          { 
....................             //En la media de tiempo por día, acumulamos el tiempo que ha estado encendido el último día 
....................             valor = valor + (float)tiempo_x_dia; 
4016:  MOVFF  27A,289
401A:  MOVFF  279,288
401E:  MOVLB  0
4020:  CALL   24BE
4024:  BCF    FD8.1
4026:  MOVFF  BF,285
402A:  MOVFF  BE,284
402E:  MOVFF  BD,283
4032:  MOVFF  BC,282
4036:  MOVFF  03,289
403A:  MOVFF  02,288
403E:  MOVFF  01,287
4042:  MOVFF  00,286
4046:  CALL   2244
404A:  MOVFF  03,BF
404E:  MOVFF  02,BE
4052:  MOVFF  01,BD
4056:  MOVFF  00,BC
....................             //Guardamos también este valor en el registro del año 
....................             media_dia_mes[fecha[1]-1] = valor; 
405A:  MOVLW  01
405C:  MOVLB  2
405E:  SUBWF  x7E,W
4060:  MULLW  04
4062:  MOVF   FF3,W
4064:  CLRF   03
4066:  ADDLW  7C
4068:  MOVWF  FE9
406A:  MOVLW  00
406C:  ADDWFC 03,W
406E:  MOVWF  FEA
4070:  MOVFF  BC,FEF
4074:  MOVFF  BD,FEC
4078:  MOVFF  BE,FEC
407C:  MOVFF  BF,FEC
....................             //Realizamos la misma operación con la media de encendido de la caldera 
....................             media_dia_caldera = media_dia_caldera + (float)tiempo_x_dia_caldera; 
4080:  MOVFF  27C,289
4084:  MOVFF  27B,288
4088:  MOVLB  0
408A:  CALL   24BE
408E:  BCF    FD8.1
4090:  MOVFF  BB,285
4094:  MOVFF  BA,284
4098:  MOVFF  B9,283
409C:  MOVFF  B8,282
40A0:  MOVFF  03,289
40A4:  MOVFF  02,288
40A8:  MOVFF  01,287
40AC:  MOVFF  00,286
40B0:  CALL   2244
40B4:  MOVFF  03,BB
40B8:  MOVFF  02,BA
40BC:  MOVFF  01,B9
40C0:  MOVFF  00,B8
....................             media_dia_mes_caldera[fecha[1]-1] = media_dia_caldera; 
40C4:  MOVLW  01
40C6:  MOVLB  2
40C8:  SUBWF  x7E,W
40CA:  MULLW  04
40CC:  MOVF   FF3,W
40CE:  CLRF   03
40D0:  ADDLW  C0
40D2:  MOVWF  FE9
40D4:  MOVLW  00
40D6:  ADDWFC 03,W
40D8:  MOVWF  FEA
40DA:  MOVFF  B8,FEF
40DE:  MOVFF  B9,FEC
40E2:  MOVFF  BA,FEC
40E6:  MOVFF  BB,FEC
....................          } 
....................          //La sumatoria podría alcanzar un valor muy alto. El sistema no está preparado para estas eventualidades 
....................          //y debería ser reseteado cada cierto tiempo. Si el sistema va a utilizarse mucho (zonas muy frías o mal 
....................          //aisladas), el usuario debería informar al fabricante para aumentar la memoria de almacenamiento y el 
....................          //tamaño de las variables 
....................  
....................          //Si cambiamos de año, habrá que guardar los datos anuales 
....................          if(fecha[2]!=anno) 
40EA:  MOVF   74,W
40EC:  SUBWF  x7F,W
40EE:  BTFSC  FD8.2
40F0:  BRA    4354
....................          { 
....................             //Comprobamos que no nos encontrabamos en el año introducido por defecto 
....................             if(fecha[2]!=0) 
40F2:  MOVF   x7F,F
40F4:  BTFSC  FD8.2
40F6:  BRA    433E
....................             { 
....................                //En ese caso, guardamos los datos de todo el año 
....................                for(contador2=0; contador2<12; contador2++) 
40F8:  CLRF   70
40FA:  MOVF   70,W
40FC:  SUBLW  0B
40FE:  BTFSS  FD8.0
4100:  BRA    432A
....................                { 
....................                   media_dia_mes[contador2] = media_dia_mes[contador2]/(float)dias_meses[contador2]; 
4102:  MOVF   70,W
4104:  MULLW  04
4106:  MOVF   FF3,W
4108:  CLRF   03
410A:  ADDLW  7C
410C:  MOVWF  01
410E:  MOVLW  00
4110:  ADDWFC 03,F
4112:  MOVFF  01,282
4116:  MOVFF  03,283
411A:  MOVF   70,W
411C:  MULLW  04
411E:  MOVF   FF3,W
4120:  CLRF   03
4122:  ADDLW  7C
4124:  MOVWF  FE9
4126:  MOVLW  00
4128:  ADDWFC 03,W
412A:  MOVWF  FEA
412C:  MOVFF  FEF,284
4130:  MOVFF  FEC,285
4134:  MOVFF  FEC,286
4138:  MOVFF  FEC,287
413C:  CLRF   03
413E:  MOVF   70,W
4140:  ADDLW  AC
4142:  MOVWF  FE9
4144:  MOVLW  00
4146:  ADDWFC 03,W
4148:  MOVWF  FEA
414A:  MOVF   FEF,W
414C:  CLRF   x89
414E:  MOVWF  x88
4150:  MOVLB  0
4152:  CALL   24BE
4156:  MOVFF  287,28B
415A:  MOVFF  286,28A
415E:  MOVFF  285,289
4162:  MOVFF  284,288
4166:  MOVFF  03,28F
416A:  MOVFF  02,28E
416E:  MOVFF  01,28D
4172:  MOVFF  00,28C
4176:  CALL   1F8A
417A:  MOVFF  283,FEA
417E:  MOVFF  282,FE9
4182:  MOVFF  00,FEF
4186:  MOVFF  01,FEC
418A:  MOVFF  02,FEC
418E:  MOVFF  03,FEC
....................                   media_dia_mes_caldera[contador2] = media_dia_mes_caldera[contador2]/(float)dias_meses[contador2]; 
4192:  MOVF   70,W
4194:  MULLW  04
4196:  MOVF   FF3,W
4198:  CLRF   03
419A:  ADDLW  C0
419C:  MOVWF  01
419E:  MOVLW  00
41A0:  ADDWFC 03,F
41A2:  MOVFF  01,282
41A6:  MOVLB  2
41A8:  MOVFF  03,283
41AC:  MOVF   70,W
41AE:  MULLW  04
41B0:  MOVF   FF3,W
41B2:  CLRF   03
41B4:  ADDLW  C0
41B6:  MOVWF  FE9
41B8:  MOVLW  00
41BA:  ADDWFC 03,W
41BC:  MOVWF  FEA
41BE:  MOVFF  FEF,284
41C2:  MOVFF  FEC,285
41C6:  MOVFF  FEC,286
41CA:  MOVFF  FEC,287
41CE:  CLRF   03
41D0:  MOVF   70,W
41D2:  ADDLW  AC
41D4:  MOVWF  FE9
41D6:  MOVLW  00
41D8:  ADDWFC 03,W
41DA:  MOVWF  FEA
41DC:  MOVF   FEF,W
41DE:  CLRF   x89
41E0:  MOVWF  x88
41E2:  MOVLB  0
41E4:  CALL   24BE
41E8:  MOVFF  287,28B
41EC:  MOVFF  286,28A
41F0:  MOVFF  285,289
41F4:  MOVFF  284,288
41F8:  MOVFF  03,28F
41FC:  MOVFF  02,28E
4200:  MOVFF  01,28D
4204:  MOVFF  00,28C
4208:  CALL   1F8A
420C:  MOVFF  283,FEA
4210:  MOVFF  282,FE9
4214:  MOVFF  00,FEF
4218:  MOVFF  01,FEC
421C:  MOVFF  02,FEC
4220:  MOVFF  03,FEC
....................                   media_annos[num_annos][contador2] = media_dia_mes[contador2]; 
4224:  MOVLB  2
4226:  MOVF   x74,W
4228:  MULLW  30
422A:  MOVF   FF3,W
422C:  CLRF   x83
422E:  MOVWF  x82
4230:  MOVF   70,W
4232:  MULLW  04
4234:  MOVF   FF3,W
4236:  CLRF   03
4238:  ADDWF  x82,W
423A:  MOVWF  01
423C:  MOVF   x83,W
423E:  ADDWFC 03,F
4240:  MOVF   01,W
4242:  ADDLW  F4
4244:  MOVWF  01
4246:  MOVLW  00
4248:  ADDWFC 03,F
424A:  MOVFF  01,284
424E:  MOVFF  03,285
4252:  MOVF   70,W
4254:  MULLW  04
4256:  MOVF   FF3,W
4258:  CLRF   03
425A:  ADDLW  7C
425C:  MOVWF  FE9
425E:  MOVLW  00
4260:  ADDWFC 03,W
4262:  MOVWF  FEA
4264:  MOVFF  FEF,00
4268:  MOVFF  FEC,01
426C:  MOVFF  FEC,02
4270:  MOVFF  FEC,03
4274:  MOVFF  285,FEA
4278:  MOVFF  284,FE9
427C:  MOVFF  00,FEF
4280:  MOVFF  01,FEC
4284:  MOVFF  02,FEC
4288:  MOVFF  03,FEC
....................                   media_annos_caldera[num_annos][contador2] = media_dia_mes_caldera[contador2]; 
428C:  MOVF   x74,W
428E:  MULLW  30
4290:  MOVF   FF3,W
4292:  CLRF   x83
4294:  MOVWF  x82
4296:  MOVF   70,W
4298:  MULLW  04
429A:  MOVF   FF3,W
429C:  CLRF   03
429E:  ADDWF  x82,W
42A0:  MOVWF  01
42A2:  MOVF   x83,W
42A4:  ADDWFC 03,F
42A6:  MOVF   01,W
42A8:  ADDLW  B4
42AA:  MOVWF  01
42AC:  MOVLW  01
42AE:  ADDWFC 03,F
42B0:  MOVFF  01,284
42B4:  MOVFF  03,285
42B8:  MOVF   70,W
42BA:  MULLW  04
42BC:  MOVF   FF3,W
42BE:  CLRF   03
42C0:  ADDLW  C0
42C2:  MOVWF  FE9
42C4:  MOVLW  00
42C6:  ADDWFC 03,W
42C8:  MOVWF  FEA
42CA:  MOVFF  FEF,00
42CE:  MOVFF  FEC,01
42D2:  MOVFF  FEC,02
42D6:  MOVFF  FEC,03
42DA:  MOVFF  285,FEA
42DE:  MOVFF  284,FE9
42E2:  MOVFF  00,FEF
42E6:  MOVFF  01,FEC
42EA:  MOVFF  02,FEC
42EE:  MOVFF  03,FEC
....................                   //Inicializamos de nuevo los vectores que almacenan los datos del año actual 
....................                   media_dia_mes[contador2]=0; 
42F2:  MOVF   70,W
42F4:  MULLW  04
42F6:  MOVF   FF3,W
42F8:  CLRF   03
42FA:  ADDLW  7C
42FC:  MOVWF  FE9
42FE:  MOVLW  00
4300:  ADDWFC 03,W
4302:  MOVWF  FEA
4304:  CLRF   FEF
4306:  CLRF   FEC
4308:  CLRF   FEC
430A:  CLRF   FEC
....................                   media_dia_mes_caldera[contador2]=0; 
430C:  MOVF   70,W
430E:  MULLW  04
4310:  MOVF   FF3,W
4312:  CLRF   03
4314:  ADDLW  C0
4316:  MOVWF  FE9
4318:  MOVLW  00
431A:  ADDWFC 03,W
431C:  MOVWF  FEA
431E:  CLRF   FEF
4320:  CLRF   FEC
4322:  CLRF   FEC
4324:  CLRF   FEC
....................                } 
4326:  INCF   70,F
4328:  BRA    40FA
....................  
....................                //Guardamos el año del que se trata 
....................                annos[num_annos]=fecha[2]; 
432A:  CLRF   03
432C:  MOVF   x74,W
432E:  ADDLW  75
4330:  MOVWF  FE9
4332:  MOVLW  02
4334:  ADDWFC 03,W
4336:  MOVWF  FEA
4338:  MOVFF  27F,FEF
....................  
....................                //Aumentamos en 1 el número de años 
....................                num_annos++; 
433C:  INCF   x74,F
....................             } 
....................  
....................             //COMPROBAR BISIESTO 
....................             //En realidad, un año será bisiesto si es divisible por 4 y no lo es por 100, 
....................             //excepto si este último lo es por 400. Sin embargo, dado que trabajamos con las 
....................             //dos últimas cifras y que el próximo año divisible por 4 que no lo es por 100 
....................             //es el 2100, mejor nos limitaremos a la divisibilidad por 4. 
....................             //Dependiendo si el año es bisiesto o no, le damos a febrero 29 o 28 días. 
....................             if(anno%4 == 0) 
433E:  MOVF   74,W
4340:  ANDLW  03
4342:  BNZ   434C
....................                dias_meses[1] = 29; 
4344:  MOVLW  1D
4346:  MOVLB  0
4348:  MOVWF  xAD
....................             else 
434A:  BRA    4352
....................                dias_meses[1] = 28; 
434C:  MOVLW  1C
434E:  MOVLB  0
4350:  MOVWF  xAD
4352:  MOVLB  2
....................          } 
....................  
....................          //Modificamos la información del día 
....................          fecha[0] = dia; 
4354:  MOVFF  72,27D
....................          fecha[1] = mes; 
4358:  MOVFF  73,27E
....................          fecha[2] = anno; 
435C:  MOVFF  74,27F
....................  
....................          //Aumentamos en 1 el número de días 
....................          num_dias++; 
4360:  INCF   x80,F
4362:  BTFSC  FD8.2
4364:  INCF   x81,F
....................  
....................          //Reseteamos las variables acumulativas de tiempo por día 
....................          tiempo_x_dia = 0; 
4366:  CLRF   x7A
4368:  CLRF   x79
....................          tiempo_x_dia_caldera = 0; 
436A:  CLRF   x7C
436C:  CLRF   x7B
....................       } 
....................  
....................       //Le sumamos al tiempo de encendido de sistema y caldera el correspondiente de este registro 
....................       tiempo_x_dia = tiempo_x_dia + t_sistema; 
436E:  MOVF   79,W
4370:  ADDWF  x79,F
4372:  MOVLW  00
4374:  ADDWFC x7A,F
....................       tiempo_x_dia_caldera = tiempo_x_dia_caldera + t_caldera; 
4376:  MOVF   7A,W
4378:  ADDWF  x7B,F
437A:  MOVLW  00
437C:  ADDWFC x7C,F
....................       //También incrementamos los tiempos totales 
....................       valor_total = valor_total + t_sistema; 
437E:  MOVF   79,W
4380:  MOVLB  0
4382:  ADDWF  xF0,F
4384:  MOVLW  00
4386:  ADDWFC xF1,F
....................       valor_total_caldera = valor_total_caldera + t_caldera; 
4388:  MOVF   7A,W
438A:  ADDWF  xF2,F
438C:  MOVLW  00
438E:  ADDWFC xF3,F
....................  
....................       //Representamos todos los datos, teniendo en cuenta algunos requisitos representativos 
....................       //para que los datos queden alineados (número menores que 10, que 100, etc). 
....................       if(dia<10) 
4390:  MOVF   72,W
4392:  SUBLW  09
4394:  BNC   43B4
....................          printf(" "); 
4396:  MOVLB  2
4398:  CLRF   x82
439A:  MOVF   x82,W
439C:  MOVLB  0
439E:  CALL   0AF4
43A2:  IORLW  00
43A4:  BZ    43B4
43A6:  MOVLB  2
43A8:  INCF   x82,F
43AA:  BTFSS  F9E.4
43AC:  BRA    43AA
43AE:  MOVWF  FAD
43B0:  BRA    439A
43B2:  MOVLB  0
....................  
....................       printf("%u/", dia); 
43B4:  MOVFF  72,283
43B8:  MOVLW  1B
43BA:  MOVLB  2
43BC:  MOVWF  x84
43BE:  MOVLB  0
43C0:  CALL   3A28
43C4:  MOVLW  2F
43C6:  BTFSS  F9E.4
43C8:  BRA    43C6
43CA:  MOVWF  FAD
....................  
....................       if(mes<10) 
43CC:  MOVF   73,W
43CE:  SUBLW  09
43D0:  BNC   43F0
....................          printf("0"); 
43D2:  MOVLB  2
43D4:  CLRF   x82
43D6:  MOVF   x82,W
43D8:  MOVLB  0
43DA:  CALL   0476
43DE:  IORLW  00
43E0:  BZ    43F0
43E2:  MOVLB  2
43E4:  INCF   x82,F
43E6:  BTFSS  F9E.4
43E8:  BRA    43E6
43EA:  MOVWF  FAD
43EC:  BRA    43D6
43EE:  MOVLB  0
....................  
....................       printf("%u/", mes); 
43F0:  MOVFF  73,283
43F4:  MOVLW  1B
43F6:  MOVLB  2
43F8:  MOVWF  x84
43FA:  MOVLB  0
43FC:  CALL   3A28
4400:  MOVLW  2F
4402:  BTFSS  F9E.4
4404:  BRA    4402
4406:  MOVWF  FAD
....................  
....................       if(anno<10) 
4408:  MOVF   74,W
440A:  SUBLW  09
440C:  BNC   442C
....................          printf("0"); 
440E:  MOVLB  2
4410:  CLRF   x82
4412:  MOVF   x82,W
4414:  MOVLB  0
4416:  CALL   0476
441A:  IORLW  00
441C:  BZ    442C
441E:  MOVLB  2
4420:  INCF   x82,F
4422:  BTFSS  F9E.4
4424:  BRA    4422
4426:  MOVWF  FAD
4428:  BRA    4412
442A:  MOVLB  0
....................  
....................       printf("%u  ", anno); 
442C:  MOVFF  74,283
4430:  MOVLW  1B
4432:  MOVLB  2
4434:  MOVWF  x84
4436:  MOVLB  0
4438:  CALL   3A28
443C:  MOVLW  20
443E:  BTFSS  F9E.4
4440:  BRA    443E
4442:  MOVWF  FAD
4444:  MOVLW  20
4446:  BTFSS  F9E.4
4448:  BRA    4446
444A:  MOVWF  FAD
....................  
....................       if(horas<10) 
444C:  MOVF   75,W
444E:  SUBLW  09
4450:  BNC   4470
....................          printf("0"); 
4452:  MOVLB  2
4454:  CLRF   x82
4456:  MOVF   x82,W
4458:  MOVLB  0
445A:  CALL   0476
445E:  IORLW  00
4460:  BZ    4470
4462:  MOVLB  2
4464:  INCF   x82,F
4466:  BTFSS  F9E.4
4468:  BRA    4466
446A:  MOVWF  FAD
446C:  BRA    4456
446E:  MOVLB  0
....................  
....................       printf("%u:", horas); 
4470:  MOVFF  75,283
4474:  MOVLW  1B
4476:  MOVLB  2
4478:  MOVWF  x84
447A:  MOVLB  0
447C:  CALL   3A28
4480:  MOVLW  3A
4482:  BTFSS  F9E.4
4484:  BRA    4482
4486:  MOVWF  FAD
....................  
....................       if(minutos<10) 
4488:  MOVF   76,W
448A:  SUBLW  09
448C:  BNC   44AC
....................          printf("0"); 
448E:  MOVLB  2
4490:  CLRF   x82
4492:  MOVF   x82,W
4494:  MOVLB  0
4496:  CALL   0476
449A:  IORLW  00
449C:  BZ    44AC
449E:  MOVLB  2
44A0:  INCF   x82,F
44A2:  BTFSS  F9E.4
44A4:  BRA    44A2
44A6:  MOVWF  FAD
44A8:  BRA    4492
44AA:  MOVLB  0
....................  
....................       printf("%u ", minutos); 
44AC:  MOVFF  76,283
44B0:  MOVLW  1B
44B2:  MOVLB  2
44B4:  MOVWF  x84
44B6:  MOVLB  0
44B8:  CALL   3A28
44BC:  MOVLW  20
44BE:  BTFSS  F9E.4
44C0:  BRA    44BE
44C2:  MOVWF  FAD
....................  
....................       if(temp_int<10) 
44C4:  MOVF   77,W
44C6:  SUBLW  09
44C8:  BNC   44E8
....................          printf(" "); 
44CA:  MOVLB  2
44CC:  CLRF   x82
44CE:  MOVF   x82,W
44D0:  MOVLB  0
44D2:  CALL   0AF4
44D6:  IORLW  00
44D8:  BZ    44E8
44DA:  MOVLB  2
44DC:  INCF   x82,F
44DE:  BTFSS  F9E.4
44E0:  BRA    44DE
44E2:  MOVWF  FAD
44E4:  BRA    44CE
44E6:  MOVLB  0
....................  
....................       printf("%u.", temp_int); 
44E8:  MOVFF  77,283
44EC:  MOVLW  1B
44EE:  MOVLB  2
44F0:  MOVWF  x84
44F2:  MOVLB  0
44F4:  CALL   3A28
44F8:  MOVLW  2E
44FA:  BTFSS  F9E.4
44FC:  BRA    44FA
44FE:  MOVWF  FAD
....................  
....................       if(temp_dec<10) 
4500:  MOVF   78,W
4502:  SUBLW  09
4504:  BNC   4524
....................          printf("0"); 
4506:  MOVLB  2
4508:  CLRF   x82
450A:  MOVF   x82,W
450C:  MOVLB  0
450E:  CALL   0476
4512:  IORLW  00
4514:  BZ    4524
4516:  MOVLB  2
4518:  INCF   x82,F
451A:  BTFSS  F9E.4
451C:  BRA    451A
451E:  MOVWF  FAD
4520:  BRA    450A
4522:  MOVLB  0
....................  
....................       printf("%u%cC  %u%cC   ", temp_dec, 223, term, 223); 
4524:  MOVFF  78,283
4528:  MOVLW  1B
452A:  MOVLB  2
452C:  MOVWF  x84
452E:  MOVLB  0
4530:  CALL   3A28
4534:  MOVLW  DF
4536:  BTFSS  F9E.4
4538:  BRA    4536
453A:  MOVWF  FAD
453C:  MOVLW  43
453E:  BTFSS  F9E.4
4540:  BRA    453E
4542:  MOVWF  FAD
4544:  MOVLW  20
4546:  BTFSS  F9E.4
4548:  BRA    4546
454A:  MOVWF  FAD
454C:  MOVLW  20
454E:  BTFSS  F9E.4
4550:  BRA    454E
4552:  MOVWF  FAD
4554:  MOVFF  7B,283
4558:  MOVLW  1B
455A:  MOVLB  2
455C:  MOVWF  x84
455E:  MOVLB  0
4560:  CALL   3A28
4564:  MOVLW  DF
4566:  BTFSS  F9E.4
4568:  BRA    4566
456A:  MOVWF  FAD
456C:  MOVLW  43
456E:  BTFSS  F9E.4
4570:  BRA    456E
4572:  MOVWF  FAD
4574:  MOVLW  03
4576:  MOVLB  2
4578:  MOVWF  x82
457A:  MOVLW  20
457C:  BTFSS  F9E.4
457E:  BRA    457C
4580:  MOVWF  FAD
4582:  DECFSZ x82,F
4584:  BRA    457A
....................  
....................       if(t_sistema<100) 
4586:  MOVF   79,W
4588:  SUBLW  63
458A:  BNC   45A6
....................          printf(" "); 
458C:  CLRF   x82
458E:  MOVF   x82,W
4590:  MOVLB  0
4592:  CALL   0AF4
4596:  IORLW  00
4598:  BZ    45A8
459A:  MOVLB  2
459C:  INCF   x82,F
459E:  BTFSS  F9E.4
45A0:  BRA    459E
45A2:  MOVWF  FAD
45A4:  BRA    458E
45A6:  MOVLB  0
....................       if(t_sistema<10) 
45A8:  MOVF   79,W
45AA:  SUBLW  09
45AC:  BNC   45CC
....................          printf(" "); 
45AE:  MOVLB  2
45B0:  CLRF   x82
45B2:  MOVF   x82,W
45B4:  MOVLB  0
45B6:  CALL   0AF4
45BA:  IORLW  00
45BC:  BZ    45CC
45BE:  MOVLB  2
45C0:  INCF   x82,F
45C2:  BTFSS  F9E.4
45C4:  BRA    45C2
45C6:  MOVWF  FAD
45C8:  BRA    45B2
45CA:  MOVLB  0
....................  
....................       printf("%u     ", t_sistema); 
45CC:  MOVFF  79,283
45D0:  MOVLW  1B
45D2:  MOVLB  2
45D4:  MOVWF  x84
45D6:  MOVLB  0
45D8:  CALL   3A28
45DC:  MOVLW  05
45DE:  MOVLB  2
45E0:  MOVWF  x82
45E2:  MOVLW  20
45E4:  BTFSS  F9E.4
45E6:  BRA    45E4
45E8:  MOVWF  FAD
45EA:  DECFSZ x82,F
45EC:  BRA    45E2
....................  
....................       if(t_caldera<100) 
45EE:  MOVF   7A,W
45F0:  SUBLW  63
45F2:  BNC   460E
....................          printf(" "); 
45F4:  CLRF   x82
45F6:  MOVF   x82,W
45F8:  MOVLB  0
45FA:  CALL   0AF4
45FE:  IORLW  00
4600:  BZ    4610
4602:  MOVLB  2
4604:  INCF   x82,F
4606:  BTFSS  F9E.4
4608:  BRA    4606
460A:  MOVWF  FAD
460C:  BRA    45F6
460E:  MOVLB  0
....................       if(t_caldera<10) 
4610:  MOVF   7A,W
4612:  SUBLW  09
4614:  BNC   4634
....................          printf(" "); 
4616:  MOVLB  2
4618:  CLRF   x82
461A:  MOVF   x82,W
461C:  MOVLB  0
461E:  CALL   0AF4
4622:  IORLW  00
4624:  BZ    4634
4626:  MOVLB  2
4628:  INCF   x82,F
462A:  BTFSS  F9E.4
462C:  BRA    462A
462E:  MOVWF  FAD
4630:  BRA    461A
4632:  MOVLB  0
....................  
....................       printf("%u\r", t_caldera); 
4634:  MOVFF  7A,283
4638:  MOVLW  1B
463A:  MOVLB  2
463C:  MOVWF  x84
463E:  MOVLB  0
4640:  CALL   3A28
4644:  MOVLW  0D
4646:  BTFSS  F9E.4
4648:  BRA    4646
464A:  MOVWF  FAD
....................  
....................    } 
464C:  INCF   6F,F
464E:  BRA    3EB4
....................  
....................    //Debemos realizar la operación de guardado para el último día. El proceso es el mismo 
....................    //que hemos seguido arriba. 
....................    if(fecha[0]!=0) 
4650:  MOVLB  2
4652:  MOVF   x7D,F
4654:  BZ    472A
....................    { 
....................       valor = valor + (float)tiempo_x_dia; 
4656:  MOVFF  27A,289
465A:  MOVFF  279,288
465E:  MOVLB  0
4660:  CALL   24BE
4664:  BCF    FD8.1
4666:  MOVFF  BF,285
466A:  MOVFF  BE,284
466E:  MOVFF  BD,283
4672:  MOVFF  BC,282
4676:  MOVFF  03,289
467A:  MOVFF  02,288
467E:  MOVFF  01,287
4682:  MOVFF  00,286
4686:  CALL   2244
468A:  MOVFF  03,BF
468E:  MOVFF  02,BE
4692:  MOVFF  01,BD
4696:  MOVFF  00,BC
....................       media_dia_mes[fecha[1]-1] = valor; 
469A:  MOVLW  01
469C:  MOVLB  2
469E:  SUBWF  x7E,W
46A0:  MULLW  04
46A2:  MOVF   FF3,W
46A4:  CLRF   03
46A6:  ADDLW  7C
46A8:  MOVWF  FE9
46AA:  MOVLW  00
46AC:  ADDWFC 03,W
46AE:  MOVWF  FEA
46B0:  MOVFF  BC,FEF
46B4:  MOVFF  BD,FEC
46B8:  MOVFF  BE,FEC
46BC:  MOVFF  BF,FEC
....................       media_dia_caldera = media_dia_caldera + (float)tiempo_x_dia_caldera; 
46C0:  MOVFF  27C,289
46C4:  MOVFF  27B,288
46C8:  MOVLB  0
46CA:  CALL   24BE
46CE:  BCF    FD8.1
46D0:  MOVFF  BB,285
46D4:  MOVFF  BA,284
46D8:  MOVFF  B9,283
46DC:  MOVFF  B8,282
46E0:  MOVFF  03,289
46E4:  MOVFF  02,288
46E8:  MOVFF  01,287
46EC:  MOVFF  00,286
46F0:  CALL   2244
46F4:  MOVFF  03,BB
46F8:  MOVFF  02,BA
46FC:  MOVFF  01,B9
4700:  MOVFF  00,B8
....................       media_dia_mes_caldera[fecha[1]-1] = media_dia_caldera; 
4704:  MOVLW  01
4706:  MOVLB  2
4708:  SUBWF  x7E,W
470A:  MULLW  04
470C:  MOVF   FF3,W
470E:  CLRF   03
4710:  ADDLW  C0
4712:  MOVWF  FE9
4714:  MOVLW  00
4716:  ADDWFC 03,W
4718:  MOVWF  FEA
471A:  MOVFF  B8,FEF
471E:  MOVFF  B9,FEC
4722:  MOVFF  BA,FEC
4726:  MOVFF  BB,FEC
....................    } 
....................  
....................    //Comprobamos que no nos encontrabamos en el año introducido por defecto 
....................    if(fecha[2]!=0) 
472A:  MOVF   x7F,F
472C:  BTFSC  FD8.2
472E:  BRA    4942
....................    { 
....................       for(contador2=0; contador2<12; contador2++) 
4730:  CLRF   70
4732:  MOVF   70,W
4734:  SUBLW  0B
4736:  BTFSS  FD8.0
4738:  BRA    492E
....................       { 
....................          media_dia_mes[contador2] = media_dia_mes[contador2]/(float)dias_meses[contador2]; 
473A:  MOVF   70,W
473C:  MULLW  04
473E:  MOVF   FF3,W
4740:  CLRF   03
4742:  ADDLW  7C
4744:  MOVWF  01
4746:  MOVLW  00
4748:  ADDWFC 03,F
474A:  MOVFF  01,282
474E:  MOVFF  03,283
4752:  MOVF   70,W
4754:  MULLW  04
4756:  MOVF   FF3,W
4758:  CLRF   03
475A:  ADDLW  7C
475C:  MOVWF  FE9
475E:  MOVLW  00
4760:  ADDWFC 03,W
4762:  MOVWF  FEA
4764:  MOVFF  FEF,284
4768:  MOVFF  FEC,285
476C:  MOVFF  FEC,286
4770:  MOVFF  FEC,287
4774:  CLRF   03
4776:  MOVF   70,W
4778:  ADDLW  AC
477A:  MOVWF  FE9
477C:  MOVLW  00
477E:  ADDWFC 03,W
4780:  MOVWF  FEA
4782:  MOVF   FEF,W
4784:  CLRF   x89
4786:  MOVWF  x88
4788:  MOVLB  0
478A:  CALL   24BE
478E:  MOVFF  287,28B
4792:  MOVFF  286,28A
4796:  MOVFF  285,289
479A:  MOVFF  284,288
479E:  MOVFF  03,28F
47A2:  MOVFF  02,28E
47A6:  MOVFF  01,28D
47AA:  MOVFF  00,28C
47AE:  CALL   1F8A
47B2:  MOVFF  283,FEA
47B6:  MOVFF  282,FE9
47BA:  MOVFF  00,FEF
47BE:  MOVFF  01,FEC
47C2:  MOVFF  02,FEC
47C6:  MOVFF  03,FEC
....................          media_dia_mes_caldera[contador2] = media_dia_mes_caldera[contador2]/(float)dias_meses[contador2]; 
47CA:  MOVF   70,W
47CC:  MULLW  04
47CE:  MOVF   FF3,W
47D0:  CLRF   03
47D2:  ADDLW  C0
47D4:  MOVWF  01
47D6:  MOVLW  00
47D8:  ADDWFC 03,F
47DA:  MOVFF  01,282
47DE:  MOVLB  2
47E0:  MOVFF  03,283
47E4:  MOVF   70,W
47E6:  MULLW  04
47E8:  MOVF   FF3,W
47EA:  CLRF   03
47EC:  ADDLW  C0
47EE:  MOVWF  FE9
47F0:  MOVLW  00
47F2:  ADDWFC 03,W
47F4:  MOVWF  FEA
47F6:  MOVFF  FEF,284
47FA:  MOVFF  FEC,285
47FE:  MOVFF  FEC,286
4802:  MOVFF  FEC,287
4806:  CLRF   03
4808:  MOVF   70,W
480A:  ADDLW  AC
480C:  MOVWF  FE9
480E:  MOVLW  00
4810:  ADDWFC 03,W
4812:  MOVWF  FEA
4814:  MOVF   FEF,W
4816:  CLRF   x89
4818:  MOVWF  x88
481A:  MOVLB  0
481C:  CALL   24BE
4820:  MOVFF  287,28B
4824:  MOVFF  286,28A
4828:  MOVFF  285,289
482C:  MOVFF  284,288
4830:  MOVFF  03,28F
4834:  MOVFF  02,28E
4838:  MOVFF  01,28D
483C:  MOVFF  00,28C
4840:  CALL   1F8A
4844:  MOVFF  283,FEA
4848:  MOVFF  282,FE9
484C:  MOVFF  00,FEF
4850:  MOVFF  01,FEC
4854:  MOVFF  02,FEC
4858:  MOVFF  03,FEC
....................          media_annos[num_annos][contador2] = media_dia_mes[contador2]; 
485C:  MOVLB  2
485E:  MOVF   x74,W
4860:  MULLW  30
4862:  MOVF   FF3,W
4864:  CLRF   x83
4866:  MOVWF  x82
4868:  MOVF   70,W
486A:  MULLW  04
486C:  MOVF   FF3,W
486E:  CLRF   03
4870:  ADDWF  x82,W
4872:  MOVWF  01
4874:  MOVF   x83,W
4876:  ADDWFC 03,F
4878:  MOVF   01,W
487A:  ADDLW  F4
487C:  MOVWF  01
487E:  MOVLW  00
4880:  ADDWFC 03,F
4882:  MOVFF  01,284
4886:  MOVFF  03,285
488A:  MOVF   70,W
488C:  MULLW  04
488E:  MOVF   FF3,W
4890:  CLRF   03
4892:  ADDLW  7C
4894:  MOVWF  FE9
4896:  MOVLW  00
4898:  ADDWFC 03,W
489A:  MOVWF  FEA
489C:  MOVFF  FEF,00
48A0:  MOVFF  FEC,01
48A4:  MOVFF  FEC,02
48A8:  MOVFF  FEC,03
48AC:  MOVFF  285,FEA
48B0:  MOVFF  284,FE9
48B4:  MOVFF  00,FEF
48B8:  MOVFF  01,FEC
48BC:  MOVFF  02,FEC
48C0:  MOVFF  03,FEC
....................          media_annos_caldera[num_annos][contador2] = media_dia_mes_caldera[contador2]; 
48C4:  MOVF   x74,W
48C6:  MULLW  30
48C8:  MOVF   FF3,W
48CA:  CLRF   x83
48CC:  MOVWF  x82
48CE:  MOVF   70,W
48D0:  MULLW  04
48D2:  MOVF   FF3,W
48D4:  CLRF   03
48D6:  ADDWF  x82,W
48D8:  MOVWF  01
48DA:  MOVF   x83,W
48DC:  ADDWFC 03,F
48DE:  MOVF   01,W
48E0:  ADDLW  B4
48E2:  MOVWF  01
48E4:  MOVLW  01
48E6:  ADDWFC 03,F
48E8:  MOVFF  01,284
48EC:  MOVFF  03,285
48F0:  MOVF   70,W
48F2:  MULLW  04
48F4:  MOVF   FF3,W
48F6:  CLRF   03
48F8:  ADDLW  C0
48FA:  MOVWF  FE9
48FC:  MOVLW  00
48FE:  ADDWFC 03,W
4900:  MOVWF  FEA
4902:  MOVFF  FEF,00
4906:  MOVFF  FEC,01
490A:  MOVFF  FEC,02
490E:  MOVFF  FEC,03
4912:  MOVFF  285,FEA
4916:  MOVFF  284,FE9
491A:  MOVFF  00,FEF
491E:  MOVFF  01,FEC
4922:  MOVFF  02,FEC
4926:  MOVFF  03,FEC
....................       } 
492A:  INCF   70,F
492C:  BRA    4732
....................  
....................       annos[num_annos]=fecha[2]; 
492E:  CLRF   03
4930:  MOVF   x74,W
4932:  ADDLW  75
4934:  MOVWF  FE9
4936:  MOVLW  02
4938:  ADDWFC 03,W
493A:  MOVWF  FEA
493C:  MOVFF  27F,FEF
....................  
....................       num_annos++; 
4940:  INCF   x74,F
....................    } 
....................  
....................    //Calculamos la media como el cociente entre los valore de tiempo calculados y el número de 
....................    //días en los que se ha encendido la caldera 
....................    valor = valor/(float)num_dias; 
4942:  MOVFF  281,289
4946:  MOVFF  280,288
494A:  MOVLB  0
494C:  CALL   24BE
4950:  MOVFF  BF,28B
4954:  MOVFF  BE,28A
4958:  MOVFF  BD,289
495C:  MOVFF  BC,288
4960:  MOVFF  03,28F
4964:  MOVFF  02,28E
4968:  MOVFF  01,28D
496C:  MOVFF  00,28C
4970:  CALL   1F8A
4974:  MOVFF  03,BF
4978:  MOVFF  02,BE
497C:  MOVFF  01,BD
4980:  MOVFF  00,BC
....................    media_dia_caldera = media_dia_caldera/(float)num_dias; 
4984:  MOVFF  281,289
4988:  MOVFF  280,288
498C:  CALL   24BE
4990:  MOVFF  BB,28B
4994:  MOVFF  BA,28A
4998:  MOVFF  B9,289
499C:  MOVFF  B8,288
49A0:  MOVFF  03,28F
49A4:  MOVFF  02,28E
49A8:  MOVFF  01,28D
49AC:  MOVFF  00,28C
49B0:  CALL   1F8A
49B4:  MOVFF  03,BB
49B8:  MOVFF  02,BA
49BC:  MOVFF  01,B9
49C0:  MOVFF  00,B8
....................  
....................    repetir: 
....................    //Menú para mostrar los datos 
....................    printf("\r=============================================\r"); 
49C4:  MOVLB  2
49C6:  CLRF   x82
49C8:  MOVF   x82,W
49CA:  MOVLB  0
49CC:  CALL   0B10
49D0:  IORLW  00
49D2:  BZ    49E2
49D4:  MOVLB  2
49D6:  INCF   x82,F
49D8:  BTFSS  F9E.4
49DA:  BRA    49D8
49DC:  MOVWF  FAD
49DE:  BRA    49C8
49E0:  MOVLB  0
....................    printf("¿Que operacion desea realizar?\r"); 
49E2:  MOVLB  2
49E4:  CLRF   x82
49E6:  MOVF   x82,W
49E8:  MOVLB  0
49EA:  CALL   0B5A
49EE:  IORLW  00
49F0:  BZ    4A00
49F2:  MOVLB  2
49F4:  INCF   x82,F
49F6:  BTFSS  F9E.4
49F8:  BRA    49F6
49FA:  MOVWF  FAD
49FC:  BRA    49E6
49FE:  MOVLB  0
....................    printf("0. Salir\r"); 
4A00:  MOVLB  2
4A02:  CLRF   x82
4A04:  MOVF   x82,W
4A06:  MOVLB  0
4A08:  CALL   0B94
4A0C:  IORLW  00
4A0E:  BZ    4A1E
4A10:  MOVLB  2
4A12:  INCF   x82,F
4A14:  BTFSS  F9E.4
4A16:  BRA    4A14
4A18:  MOVWF  FAD
4A1A:  BRA    4A04
4A1C:  MOVLB  0
....................    printf("1. Extraer tiempos medios por dia\r"); 
4A1E:  MOVLB  2
4A20:  CLRF   x82
4A22:  MOVF   x82,W
4A24:  MOVLB  0
4A26:  CALL   0BB8
4A2A:  IORLW  00
4A2C:  BZ    4A3C
4A2E:  MOVLB  2
4A30:  INCF   x82,F
4A32:  BTFSS  F9E.4
4A34:  BRA    4A32
4A36:  MOVWF  FAD
4A38:  BRA    4A22
4A3A:  MOVLB  0
....................    printf("2. Extraer tiempos totales\r"); 
4A3C:  MOVLB  2
4A3E:  CLRF   x82
4A40:  MOVF   x82,W
4A42:  MOVLB  0
4A44:  CALL   0BF6
4A48:  IORLW  00
4A4A:  BZ    4A5A
4A4C:  MOVLB  2
4A4E:  INCF   x82,F
4A50:  BTFSS  F9E.4
4A52:  BRA    4A50
4A54:  MOVWF  FAD
4A56:  BRA    4A40
4A58:  MOVLB  0
....................    printf("3. Extraer datos mensuales\r"); 
4A5A:  MOVLB  2
4A5C:  CLRF   x82
4A5E:  MOVF   x82,W
4A60:  MOVLB  0
4A62:  CALL   0C2C
4A66:  IORLW  00
4A68:  BZ    4A78
4A6A:  MOVLB  2
4A6C:  INCF   x82,F
4A6E:  BTFSS  F9E.4
4A70:  BRA    4A6E
4A72:  MOVWF  FAD
4A74:  BRA    4A5E
4A76:  MOVLB  0
....................    printf("=============================================\r"); 
4A78:  MOVLB  2
4A7A:  CLRF   x82
4A7C:  MOVF   x82,W
4A7E:  MOVLB  0
4A80:  CALL   0C62
4A84:  IORLW  00
4A86:  BZ    4A96
4A88:  MOVLB  2
4A8A:  INCF   x82,F
4A8C:  BTFSS  F9E.4
4A8E:  BRA    4A8C
4A90:  MOVWF  FAD
4A92:  BRA    4A7C
4A94:  MOVLB  0
....................  
....................    //Esperamos la introducción de una de las opciones por parte del técnico. 
....................    //Cuando se pulse uno de los botones, asignamos a la variable caracter el valor correspondiente. 
....................    caracter='J'; 
4A96:  MOVLW  4A
4A98:  MOVWF  71
....................    while(caracter!='0' && caracter!='1' && caracter!='2' && caracter!='3'){ 
4A9A:  MOVF   71,W
4A9C:  SUBLW  30
4A9E:  BZ    4ABC
4AA0:  MOVF   71,W
4AA2:  SUBLW  31
4AA4:  BZ    4ABC
4AA6:  MOVF   71,W
4AA8:  SUBLW  32
4AAA:  BZ    4ABC
4AAC:  MOVF   71,W
4AAE:  SUBLW  33
4AB0:  BZ    4ABC
....................       caracter=getch(); 
4AB2:  BTFSS  F9E.5
4AB4:  BRA    4AB2
4AB6:  MOVFF  FAE,71
....................    } 
4ABA:  BRA    4A9A
....................  
....................    switch(caracter) 
....................    { 
4ABC:  MOVLW  30
4ABE:  SUBWF  71,W
4AC0:  ADDLW  FC
4AC2:  BTFSC  FD8.0
4AC4:  GOTO   57FE
4AC8:  ADDLW  04
4ACA:  GOTO   5802
....................       //En el caso 0, se sale del sistema 
....................       case '0': 
....................                //Se indica por pantalla la salida 
....................                printf("\rSaliendo...\r"); 
4ACE:  MOVLB  2
4AD0:  CLRF   x82
4AD2:  MOVF   x82,W
4AD4:  MOVLB  0
4AD6:  CALL   0CAC
4ADA:  IORLW  00
4ADC:  BZ    4AEC
4ADE:  MOVLB  2
4AE0:  INCF   x82,F
4AE2:  BTFSS  F9E.4
4AE4:  BRA    4AE2
4AE6:  MOVWF  FAD
4AE8:  BRA    4AD2
4AEA:  MOVLB  0
....................                break; 
4AEC:  GOTO   57FE
....................  
....................       //En el caso 1, se muestran los valores medios 
....................       case '1': 
....................                printf("\rT. medio encendido sistema por dia: %3.2f minutos\r\r", valor); 
4AF0:  MOVLB  2
4AF2:  CLRF   x82
4AF4:  MOVF   x82,W
4AF6:  MOVLB  0
4AF8:  CALL   0CD4
4AFC:  MOVLB  2
4AFE:  INCF   x82,F
4B00:  MOVWF  00
4B02:  MOVF   00,W
4B04:  BTFSS  F9E.4
4B06:  BRA    4B04
4B08:  MOVWF  FAD
4B0A:  MOVLW  25
4B0C:  SUBWF  x82,W
4B0E:  BNZ   4AF4
4B10:  MOVLW  02
4B12:  MOVWF  FE9
4B14:  MOVFF  BF,294
4B18:  MOVFF  BE,293
4B1C:  MOVFF  BD,292
4B20:  MOVFF  BC,291
4B24:  MOVWF  x95
4B26:  MOVLB  0
4B28:  CALL   3AAA
4B2C:  MOVLW  2A
4B2E:  MOVLB  2
4B30:  MOVWF  x83
4B32:  MOVF   x83,W
4B34:  MOVLB  0
4B36:  CALL   0CD4
4B3A:  MOVLB  2
4B3C:  INCF   x83,F
4B3E:  MOVWF  00
4B40:  MOVF   00,W
4B42:  BTFSS  F9E.4
4B44:  BRA    4B42
4B46:  MOVWF  FAD
4B48:  MOVLW  34
4B4A:  SUBWF  x83,W
4B4C:  BNZ   4B32
....................                printf("T. medio encendido caldera por dia: %3.2f minutos\r\r", media_dia_caldera); 
4B4E:  CLRF   x82
4B50:  MOVF   x82,W
4B52:  MOVLB  0
4B54:  CALL   0D24
4B58:  MOVLB  2
4B5A:  INCF   x82,F
4B5C:  MOVWF  00
4B5E:  MOVF   00,W
4B60:  BTFSS  F9E.4
4B62:  BRA    4B60
4B64:  MOVWF  FAD
4B66:  MOVLW  24
4B68:  SUBWF  x82,W
4B6A:  BNZ   4B50
4B6C:  MOVLW  02
4B6E:  MOVWF  FE9
4B70:  MOVFF  BB,294
4B74:  MOVFF  BA,293
4B78:  MOVFF  B9,292
4B7C:  MOVFF  B8,291
4B80:  MOVWF  x95
4B82:  MOVLB  0
4B84:  CALL   3AAA
4B88:  MOVLW  29
4B8A:  MOVLB  2
4B8C:  MOVWF  x83
4B8E:  MOVF   x83,W
4B90:  MOVLB  0
4B92:  CALL   0D24
4B96:  MOVLB  2
4B98:  INCF   x83,F
4B9A:  MOVWF  00
4B9C:  MOVF   00,W
4B9E:  BTFSS  F9E.4
4BA0:  BRA    4B9E
4BA2:  MOVWF  FAD
4BA4:  MOVLW  33
4BA6:  SUBWF  x83,W
4BA8:  BNZ   4B8E
....................                goto repetir; 
4BAA:  MOVLB  0
4BAC:  BRA    49C4
....................                break; 
4BAE:  GOTO   57FE
....................  
....................       //En el caso 2, se muestran los valores totales 
....................       case '2': 
....................                printf("\rT. total encendido sistema: %lu minutos\r\r", valor_total); 
4BB2:  MOVLB  2
4BB4:  CLRF   x82
4BB6:  MOVF   x82,W
4BB8:  MOVLB  0
4BBA:  CALL   0D72
4BBE:  MOVLB  2
4BC0:  INCF   x82,F
4BC2:  MOVWF  00
4BC4:  MOVF   00,W
4BC6:  BTFSS  F9E.4
4BC8:  BRA    4BC6
4BCA:  MOVWF  FAD
4BCC:  MOVLW  1D
4BCE:  SUBWF  x82,W
4BD0:  BNZ   4BB6
4BD2:  MOVLW  10
4BD4:  MOVWF  FE9
4BD6:  MOVFF  F1,284
4BDA:  MOVFF  F0,283
4BDE:  MOVLB  0
4BE0:  CALL   3C54
4BE4:  MOVLW  20
4BE6:  MOVLB  2
4BE8:  MOVWF  x83
4BEA:  MOVF   x83,W
4BEC:  MOVLB  0
4BEE:  CALL   0D72
4BF2:  MOVLB  2
4BF4:  INCF   x83,F
4BF6:  MOVWF  00
4BF8:  MOVF   00,W
4BFA:  BTFSS  F9E.4
4BFC:  BRA    4BFA
4BFE:  MOVWF  FAD
4C00:  MOVLW  2A
4C02:  SUBWF  x83,W
4C04:  BNZ   4BEA
....................                printf("T. total encendido caldera: %lu minutos\r\r", valor_total_caldera); 
4C06:  CLRF   x82
4C08:  MOVF   x82,W
4C0A:  MOVLB  0
4C0C:  CALL   0DB8
4C10:  MOVLB  2
4C12:  INCF   x82,F
4C14:  MOVWF  00
4C16:  MOVF   00,W
4C18:  BTFSS  F9E.4
4C1A:  BRA    4C18
4C1C:  MOVWF  FAD
4C1E:  MOVLW  1C
4C20:  SUBWF  x82,W
4C22:  BNZ   4C08
4C24:  MOVLW  10
4C26:  MOVWF  FE9
4C28:  MOVFF  F3,284
4C2C:  MOVFF  F2,283
4C30:  MOVLB  0
4C32:  CALL   3C54
4C36:  MOVLW  1F
4C38:  MOVLB  2
4C3A:  MOVWF  x83
4C3C:  MOVF   x83,W
4C3E:  MOVLB  0
4C40:  CALL   0DB8
4C44:  MOVLB  2
4C46:  INCF   x83,F
4C48:  MOVWF  00
4C4A:  MOVF   00,W
4C4C:  BTFSS  F9E.4
4C4E:  BRA    4C4C
4C50:  MOVWF  FAD
4C52:  MOVLW  29
4C54:  SUBWF  x83,W
4C56:  BNZ   4C3C
....................                goto repetir; 
4C58:  MOVLB  0
4C5A:  BRA    49C4
....................                break; 
4C5C:  GOTO   57FE
....................  
....................       //En el caso 3, se muestran todos los valores medios por meses y años 
....................       case '3': 
....................                //Se representan todos los años de los que se tiene registro 
....................                for(contador=0; contador<num_annos; contador++) 
4C60:  CLRF   6F
4C62:  MOVLB  2
4C64:  MOVF   x74,W
4C66:  SUBWF  6F,W
4C68:  BTFSC  FD8.0
4C6A:  GOTO   57F6
....................                { 
....................                   //Imprimimos el año en el que nos encontramos 
....................                   printf("\r20"); 
4C6E:  CLRF   x82
4C70:  MOVF   x82,W
4C72:  MOVLB  0
4C74:  CALL   0DFC
4C78:  IORLW  00
4C7A:  BZ    4C8A
4C7C:  MOVLB  2
4C7E:  INCF   x82,F
4C80:  BTFSS  F9E.4
4C82:  BRA    4C80
4C84:  MOVWF  FAD
4C86:  BRA    4C70
4C88:  MOVLB  0
....................                   if(annos[contador]<10) 
4C8A:  CLRF   03
4C8C:  MOVF   6F,W
4C8E:  ADDLW  75
4C90:  MOVWF  FE9
4C92:  MOVLW  02
4C94:  ADDWFC 03,W
4C96:  MOVWF  FEA
4C98:  MOVF   FEF,W
4C9A:  SUBLW  09
4C9C:  BNC   4CBC
....................                      printf("0"); 
4C9E:  MOVLB  2
4CA0:  CLRF   x82
4CA2:  MOVF   x82,W
4CA4:  MOVLB  0
4CA6:  CALL   0476
4CAA:  IORLW  00
4CAC:  BZ    4CBC
4CAE:  MOVLB  2
4CB0:  INCF   x82,F
4CB2:  BTFSS  F9E.4
4CB4:  BRA    4CB2
4CB6:  MOVWF  FAD
4CB8:  BRA    4CA2
4CBA:  MOVLB  0
....................                   printf("%u\r", annos[contador]); 
4CBC:  CLRF   03
4CBE:  MOVF   6F,W
4CC0:  ADDLW  75
4CC2:  MOVWF  FE9
4CC4:  MOVLW  02
4CC6:  ADDWFC 03,W
4CC8:  MOVWF  FEA
4CCA:  MOVFF  FEF,282
4CCE:  MOVFF  282,283
4CD2:  MOVLW  1B
4CD4:  MOVLB  2
4CD6:  MOVWF  x84
4CD8:  MOVLB  0
4CDA:  CALL   3A28
4CDE:  MOVLW  0D
4CE0:  BTFSS  F9E.4
4CE2:  BRA    4CE0
4CE4:  MOVWF  FAD
....................                   printf("-----------------------------------------------------\r"); 
4CE6:  MOVLB  2
4CE8:  CLRF   x82
4CEA:  MOVF   x82,W
4CEC:  MOVLB  0
4CEE:  CALL   0E1A
4CF2:  IORLW  00
4CF4:  BZ    4D04
4CF6:  MOVLB  2
4CF8:  INCF   x82,F
4CFA:  BTFSS  F9E.4
4CFC:  BRA    4CFA
4CFE:  MOVWF  FAD
4D00:  BRA    4CEA
4D02:  MOVLB  0
....................                   printf("           T. sistema (min/dia)  T. caldera (min/dia)\r"); 
4D04:  MOVLB  2
4D06:  CLRF   x82
4D08:  MOVF   x82,W
4D0A:  MOVLB  0
4D0C:  CALL   0E6C
4D10:  IORLW  00
4D12:  BZ    4D22
4D14:  MOVLB  2
4D16:  INCF   x82,F
4D18:  BTFSS  F9E.4
4D1A:  BRA    4D18
4D1C:  MOVWF  FAD
4D1E:  BRA    4D08
4D20:  MOVLB  0
....................                   printf("ENERO              %3.2f                %3.2f\r", media_annos[contador][0], media_annos_caldera[contador][0]); 
4D22:  MOVF   6F,W
4D24:  MULLW  30
4D26:  MOVF   FF3,W
4D28:  MOVLB  2
4D2A:  CLRF   x83
4D2C:  MOVWF  x82
4D2E:  MOVLW  F4
4D30:  ADDWF  x82,W
4D32:  MOVWF  FE9
4D34:  MOVLW  00
4D36:  ADDWFC x83,W
4D38:  MOVWF  FEA
4D3A:  MOVFF  FEF,284
4D3E:  MOVFF  FEC,285
4D42:  MOVFF  FEC,286
4D46:  MOVFF  FEC,287
4D4A:  MOVF   6F,W
4D4C:  MULLW  30
4D4E:  MOVF   FF3,W
4D50:  CLRF   x89
4D52:  MOVWF  x88
4D54:  MOVLW  B4
4D56:  ADDWF  x88,W
4D58:  MOVWF  FE9
4D5A:  MOVLW  01
4D5C:  ADDWFC x89,W
4D5E:  MOVWF  FEA
4D60:  MOVFF  FEF,28A
4D64:  MOVFF  FEC,28B
4D68:  MOVFF  FEC,28C
4D6C:  MOVFF  FEC,28D
4D70:  CLRF   x8E
4D72:  MOVF   x8E,W
4D74:  MOVLB  0
4D76:  CALL   0EBE
4D7A:  MOVLB  2
4D7C:  INCF   x8E,F
4D7E:  MOVWF  00
4D80:  MOVF   00,W
4D82:  BTFSS  F9E.4
4D84:  BRA    4D82
4D86:  MOVWF  FAD
4D88:  MOVLW  05
4D8A:  SUBWF  x8E,W
4D8C:  BNZ   4D72
4D8E:  MOVLW  0E
4D90:  MOVWF  x8F
4D92:  MOVLW  20
4D94:  BTFSS  F9E.4
4D96:  BRA    4D94
4D98:  MOVWF  FAD
4D9A:  DECFSZ x8F,F
4D9C:  BRA    4D92
4D9E:  MOVLW  02
4DA0:  MOVWF  FE9
4DA2:  MOVFF  287,294
4DA6:  MOVFF  286,293
4DAA:  MOVFF  285,292
4DAE:  MOVFF  284,291
4DB2:  MOVWF  x95
4DB4:  MOVLB  0
4DB6:  CALL   3AAA
4DBA:  MOVLW  10
4DBC:  MOVLB  2
4DBE:  MOVWF  x90
4DC0:  MOVLW  20
4DC2:  BTFSS  F9E.4
4DC4:  BRA    4DC2
4DC6:  MOVWF  FAD
4DC8:  DECFSZ x90,F
4DCA:  BRA    4DC0
4DCC:  MOVLW  02
4DCE:  MOVWF  FE9
4DD0:  MOVFF  28D,294
4DD4:  MOVFF  28C,293
4DD8:  MOVFF  28B,292
4DDC:  MOVFF  28A,291
4DE0:  MOVWF  x95
4DE2:  MOVLB  0
4DE4:  CALL   3AAA
4DE8:  MOVLW  0D
4DEA:  BTFSS  F9E.4
4DEC:  BRA    4DEA
4DEE:  MOVWF  FAD
....................                   printf("FEBRERO            %3.2f                %3.2f\r", media_annos[contador][1], media_annos_caldera[contador][1]); 
4DF0:  MOVF   6F,W
4DF2:  MULLW  30
4DF4:  MOVF   FF3,W
4DF6:  MOVLB  2
4DF8:  CLRF   x83
4DFA:  MOVWF  x82
4DFC:  MOVLW  04
4DFE:  ADDWF  x82,W
4E00:  MOVWF  01
4E02:  MOVLW  00
4E04:  ADDWFC x83,W
4E06:  MOVWF  03
4E08:  MOVF   01,W
4E0A:  ADDLW  F4
4E0C:  MOVWF  FE9
4E0E:  MOVLW  00
4E10:  ADDWFC 03,W
4E12:  MOVWF  FEA
4E14:  MOVFF  FEF,284
4E18:  MOVFF  FEC,285
4E1C:  MOVFF  FEC,286
4E20:  MOVFF  FEC,287
4E24:  MOVF   6F,W
4E26:  MULLW  30
4E28:  MOVF   FF3,W
4E2A:  CLRF   x89
4E2C:  MOVWF  x88
4E2E:  MOVLW  04
4E30:  ADDWF  x88,W
4E32:  MOVWF  01
4E34:  MOVLW  00
4E36:  ADDWFC x89,W
4E38:  MOVWF  03
4E3A:  MOVF   01,W
4E3C:  ADDLW  B4
4E3E:  MOVWF  FE9
4E40:  MOVLW  01
4E42:  ADDWFC 03,W
4E44:  MOVWF  FEA
4E46:  MOVFF  FEF,28A
4E4A:  MOVFF  FEC,28B
4E4E:  MOVFF  FEC,28C
4E52:  MOVFF  FEC,28D
4E56:  CLRF   x8E
4E58:  MOVF   x8E,W
4E5A:  MOVLB  0
4E5C:  CALL   0EEA
4E60:  MOVLB  2
4E62:  INCF   x8E,F
4E64:  MOVWF  00
4E66:  MOVF   00,W
4E68:  BTFSS  F9E.4
4E6A:  BRA    4E68
4E6C:  MOVWF  FAD
4E6E:  MOVLW  07
4E70:  SUBWF  x8E,W
4E72:  BNZ   4E58
4E74:  MOVLW  0C
4E76:  MOVWF  x8F
4E78:  MOVLW  20
4E7A:  BTFSS  F9E.4
4E7C:  BRA    4E7A
4E7E:  MOVWF  FAD
4E80:  DECFSZ x8F,F
4E82:  BRA    4E78
4E84:  MOVLW  02
4E86:  MOVWF  FE9
4E88:  MOVFF  287,294
4E8C:  MOVFF  286,293
4E90:  MOVFF  285,292
4E94:  MOVFF  284,291
4E98:  MOVWF  x95
4E9A:  MOVLB  0
4E9C:  CALL   3AAA
4EA0:  MOVLW  10
4EA2:  MOVLB  2
4EA4:  MOVWF  x90
4EA6:  MOVLW  20
4EA8:  BTFSS  F9E.4
4EAA:  BRA    4EA8
4EAC:  MOVWF  FAD
4EAE:  DECFSZ x90,F
4EB0:  BRA    4EA6
4EB2:  MOVLW  02
4EB4:  MOVWF  FE9
4EB6:  MOVFF  28D,294
4EBA:  MOVFF  28C,293
4EBE:  MOVFF  28B,292
4EC2:  MOVFF  28A,291
4EC6:  MOVWF  x95
4EC8:  MOVLB  0
4ECA:  CALL   3AAA
4ECE:  MOVLW  0D
4ED0:  BTFSS  F9E.4
4ED2:  BRA    4ED0
4ED4:  MOVWF  FAD
....................                   printf("MARZO              %3.2f                %3.2f\r", media_annos[contador][2], media_annos_caldera[contador][2]); 
4ED6:  MOVF   6F,W
4ED8:  MULLW  30
4EDA:  MOVF   FF3,W
4EDC:  MOVLB  2
4EDE:  CLRF   x83
4EE0:  MOVWF  x82
4EE2:  MOVLW  08
4EE4:  ADDWF  x82,W
4EE6:  MOVWF  01
4EE8:  MOVLW  00
4EEA:  ADDWFC x83,W
4EEC:  MOVWF  03
4EEE:  MOVF   01,W
4EF0:  ADDLW  F4
4EF2:  MOVWF  FE9
4EF4:  MOVLW  00
4EF6:  ADDWFC 03,W
4EF8:  MOVWF  FEA
4EFA:  MOVFF  FEF,284
4EFE:  MOVFF  FEC,285
4F02:  MOVFF  FEC,286
4F06:  MOVFF  FEC,287
4F0A:  MOVF   6F,W
4F0C:  MULLW  30
4F0E:  MOVF   FF3,W
4F10:  CLRF   x89
4F12:  MOVWF  x88
4F14:  MOVLW  08
4F16:  ADDWF  x88,W
4F18:  MOVWF  01
4F1A:  MOVLW  00
4F1C:  ADDWFC x89,W
4F1E:  MOVWF  03
4F20:  MOVF   01,W
4F22:  ADDLW  B4
4F24:  MOVWF  FE9
4F26:  MOVLW  01
4F28:  ADDWFC 03,W
4F2A:  MOVWF  FEA
4F2C:  MOVFF  FEF,28A
4F30:  MOVFF  FEC,28B
4F34:  MOVFF  FEC,28C
4F38:  MOVFF  FEC,28D
4F3C:  CLRF   x8E
4F3E:  MOVF   x8E,W
4F40:  MOVLB  0
4F42:  CALL   0F18
4F46:  MOVLB  2
4F48:  INCF   x8E,F
4F4A:  MOVWF  00
4F4C:  MOVF   00,W
4F4E:  BTFSS  F9E.4
4F50:  BRA    4F4E
4F52:  MOVWF  FAD
4F54:  MOVLW  05
4F56:  SUBWF  x8E,W
4F58:  BNZ   4F3E
4F5A:  MOVLW  0E
4F5C:  MOVWF  x8F
4F5E:  MOVLW  20
4F60:  BTFSS  F9E.4
4F62:  BRA    4F60
4F64:  MOVWF  FAD
4F66:  DECFSZ x8F,F
4F68:  BRA    4F5E
4F6A:  MOVLW  02
4F6C:  MOVWF  FE9
4F6E:  MOVFF  287,294
4F72:  MOVFF  286,293
4F76:  MOVFF  285,292
4F7A:  MOVFF  284,291
4F7E:  MOVWF  x95
4F80:  MOVLB  0
4F82:  CALL   3AAA
4F86:  MOVLW  10
4F88:  MOVLB  2
4F8A:  MOVWF  x90
4F8C:  MOVLW  20
4F8E:  BTFSS  F9E.4
4F90:  BRA    4F8E
4F92:  MOVWF  FAD
4F94:  DECFSZ x90,F
4F96:  BRA    4F8C
4F98:  MOVLW  02
4F9A:  MOVWF  FE9
4F9C:  MOVFF  28D,294
4FA0:  MOVFF  28C,293
4FA4:  MOVFF  28B,292
4FA8:  MOVFF  28A,291
4FAC:  MOVWF  x95
4FAE:  MOVLB  0
4FB0:  CALL   3AAA
4FB4:  MOVLW  0D
4FB6:  BTFSS  F9E.4
4FB8:  BRA    4FB6
4FBA:  MOVWF  FAD
....................                   printf("ABRIL              %3.2f                %3.2f\r", media_annos[contador][3], media_annos_caldera[contador][3]); 
4FBC:  MOVF   6F,W
4FBE:  MULLW  30
4FC0:  MOVF   FF3,W
4FC2:  MOVLB  2
4FC4:  CLRF   x83
4FC6:  MOVWF  x82
4FC8:  MOVLW  0C
4FCA:  ADDWF  x82,W
4FCC:  MOVWF  01
4FCE:  MOVLW  00
4FD0:  ADDWFC x83,W
4FD2:  MOVWF  03
4FD4:  MOVF   01,W
4FD6:  ADDLW  F4
4FD8:  MOVWF  FE9
4FDA:  MOVLW  00
4FDC:  ADDWFC 03,W
4FDE:  MOVWF  FEA
4FE0:  MOVFF  FEF,284
4FE4:  MOVFF  FEC,285
4FE8:  MOVFF  FEC,286
4FEC:  MOVFF  FEC,287
4FF0:  MOVF   6F,W
4FF2:  MULLW  30
4FF4:  MOVF   FF3,W
4FF6:  CLRF   x89
4FF8:  MOVWF  x88
4FFA:  MOVLW  0C
4FFC:  ADDWF  x88,W
4FFE:  MOVWF  01
5000:  MOVLW  00
5002:  ADDWFC x89,W
5004:  MOVWF  03
5006:  MOVF   01,W
5008:  ADDLW  B4
500A:  MOVWF  FE9
500C:  MOVLW  01
500E:  ADDWFC 03,W
5010:  MOVWF  FEA
5012:  MOVFF  FEF,28A
5016:  MOVFF  FEC,28B
501A:  MOVFF  FEC,28C
501E:  MOVFF  FEC,28D
5022:  CLRF   x8E
5024:  MOVF   x8E,W
5026:  MOVLB  0
5028:  CALL   0F44
502C:  MOVLB  2
502E:  INCF   x8E,F
5030:  MOVWF  00
5032:  MOVF   00,W
5034:  BTFSS  F9E.4
5036:  BRA    5034
5038:  MOVWF  FAD
503A:  MOVLW  05
503C:  SUBWF  x8E,W
503E:  BNZ   5024
5040:  MOVLW  0E
5042:  MOVWF  x8F
5044:  MOVLW  20
5046:  BTFSS  F9E.4
5048:  BRA    5046
504A:  MOVWF  FAD
504C:  DECFSZ x8F,F
504E:  BRA    5044
5050:  MOVLW  02
5052:  MOVWF  FE9
5054:  MOVFF  287,294
5058:  MOVFF  286,293
505C:  MOVFF  285,292
5060:  MOVFF  284,291
5064:  MOVWF  x95
5066:  MOVLB  0
5068:  CALL   3AAA
506C:  MOVLW  10
506E:  MOVLB  2
5070:  MOVWF  x90
5072:  MOVLW  20
5074:  BTFSS  F9E.4
5076:  BRA    5074
5078:  MOVWF  FAD
507A:  DECFSZ x90,F
507C:  BRA    5072
507E:  MOVLW  02
5080:  MOVWF  FE9
5082:  MOVFF  28D,294
5086:  MOVFF  28C,293
508A:  MOVFF  28B,292
508E:  MOVFF  28A,291
5092:  MOVWF  x95
5094:  MOVLB  0
5096:  CALL   3AAA
509A:  MOVLW  0D
509C:  BTFSS  F9E.4
509E:  BRA    509C
50A0:  MOVWF  FAD
....................                   printf("MAYO               %3.2f                %3.2f\r", media_annos[contador][4], media_annos_caldera[contador][4]); 
50A2:  MOVF   6F,W
50A4:  MULLW  30
50A6:  MOVF   FF3,W
50A8:  MOVLB  2
50AA:  CLRF   x83
50AC:  MOVWF  x82
50AE:  MOVLW  10
50B0:  ADDWF  x82,W
50B2:  MOVWF  01
50B4:  MOVLW  00
50B6:  ADDWFC x83,W
50B8:  MOVWF  03
50BA:  MOVF   01,W
50BC:  ADDLW  F4
50BE:  MOVWF  FE9
50C0:  MOVLW  00
50C2:  ADDWFC 03,W
50C4:  MOVWF  FEA
50C6:  MOVFF  FEF,284
50CA:  MOVFF  FEC,285
50CE:  MOVFF  FEC,286
50D2:  MOVFF  FEC,287
50D6:  MOVF   6F,W
50D8:  MULLW  30
50DA:  MOVF   FF3,W
50DC:  CLRF   x89
50DE:  MOVWF  x88
50E0:  MOVLW  10
50E2:  ADDWF  x88,W
50E4:  MOVWF  01
50E6:  MOVLW  00
50E8:  ADDWFC x89,W
50EA:  MOVWF  03
50EC:  MOVF   01,W
50EE:  ADDLW  B4
50F0:  MOVWF  FE9
50F2:  MOVLW  01
50F4:  ADDWFC 03,W
50F6:  MOVWF  FEA
50F8:  MOVFF  FEF,28A
50FC:  MOVFF  FEC,28B
5100:  MOVFF  FEC,28C
5104:  MOVFF  FEC,28D
5108:  CLRF   x8E
510A:  MOVF   x8E,W
510C:  MOVLB  0
510E:  CALL   0F70
5112:  MOVLB  2
5114:  INCF   x8E,F
5116:  MOVWF  00
5118:  MOVF   00,W
511A:  BTFSS  F9E.4
511C:  BRA    511A
511E:  MOVWF  FAD
5120:  MOVLW  04
5122:  SUBWF  x8E,W
5124:  BNZ   510A
5126:  MOVLW  0F
5128:  MOVWF  x8F
512A:  MOVLW  20
512C:  BTFSS  F9E.4
512E:  BRA    512C
5130:  MOVWF  FAD
5132:  DECFSZ x8F,F
5134:  BRA    512A
5136:  MOVLW  02
5138:  MOVWF  FE9
513A:  MOVFF  287,294
513E:  MOVFF  286,293
5142:  MOVFF  285,292
5146:  MOVFF  284,291
514A:  MOVWF  x95
514C:  MOVLB  0
514E:  CALL   3AAA
5152:  MOVLW  10
5154:  MOVLB  2
5156:  MOVWF  x90
5158:  MOVLW  20
515A:  BTFSS  F9E.4
515C:  BRA    515A
515E:  MOVWF  FAD
5160:  DECFSZ x90,F
5162:  BRA    5158
5164:  MOVLW  02
5166:  MOVWF  FE9
5168:  MOVFF  28D,294
516C:  MOVFF  28C,293
5170:  MOVFF  28B,292
5174:  MOVFF  28A,291
5178:  MOVWF  x95
517A:  MOVLB  0
517C:  CALL   3AAA
5180:  MOVLW  0D
5182:  BTFSS  F9E.4
5184:  BRA    5182
5186:  MOVWF  FAD
....................                   printf("JUNIO              %3.2f                %3.2f\r", media_annos[contador][5], media_annos_caldera[contador][5]); 
5188:  MOVF   6F,W
518A:  MULLW  30
518C:  MOVF   FF3,W
518E:  MOVLB  2
5190:  CLRF   x83
5192:  MOVWF  x82
5194:  MOVLW  14
5196:  ADDWF  x82,W
5198:  MOVWF  01
519A:  MOVLW  00
519C:  ADDWFC x83,W
519E:  MOVWF  03
51A0:  MOVF   01,W
51A2:  ADDLW  F4
51A4:  MOVWF  FE9
51A6:  MOVLW  00
51A8:  ADDWFC 03,W
51AA:  MOVWF  FEA
51AC:  MOVFF  FEF,284
51B0:  MOVFF  FEC,285
51B4:  MOVFF  FEC,286
51B8:  MOVFF  FEC,287
51BC:  MOVF   6F,W
51BE:  MULLW  30
51C0:  MOVF   FF3,W
51C2:  CLRF   x89
51C4:  MOVWF  x88
51C6:  MOVLW  14
51C8:  ADDWF  x88,W
51CA:  MOVWF  01
51CC:  MOVLW  00
51CE:  ADDWFC x89,W
51D0:  MOVWF  03
51D2:  MOVF   01,W
51D4:  ADDLW  B4
51D6:  MOVWF  FE9
51D8:  MOVLW  01
51DA:  ADDWFC 03,W
51DC:  MOVWF  FEA
51DE:  MOVFF  FEF,28A
51E2:  MOVFF  FEC,28B
51E6:  MOVFF  FEC,28C
51EA:  MOVFF  FEC,28D
51EE:  CLRF   x8E
51F0:  MOVF   x8E,W
51F2:  MOVLB  0
51F4:  CALL   0F9A
51F8:  MOVLB  2
51FA:  INCF   x8E,F
51FC:  MOVWF  00
51FE:  MOVF   00,W
5200:  BTFSS  F9E.4
5202:  BRA    5200
5204:  MOVWF  FAD
5206:  MOVLW  05
5208:  SUBWF  x8E,W
520A:  BNZ   51F0
520C:  MOVLW  0E
520E:  MOVWF  x8F
5210:  MOVLW  20
5212:  BTFSS  F9E.4
5214:  BRA    5212
5216:  MOVWF  FAD
5218:  DECFSZ x8F,F
521A:  BRA    5210
521C:  MOVLW  02
521E:  MOVWF  FE9
5220:  MOVFF  287,294
5224:  MOVFF  286,293
5228:  MOVFF  285,292
522C:  MOVFF  284,291
5230:  MOVWF  x95
5232:  MOVLB  0
5234:  CALL   3AAA
5238:  MOVLW  10
523A:  MOVLB  2
523C:  MOVWF  x90
523E:  MOVLW  20
5240:  BTFSS  F9E.4
5242:  BRA    5240
5244:  MOVWF  FAD
5246:  DECFSZ x90,F
5248:  BRA    523E
524A:  MOVLW  02
524C:  MOVWF  FE9
524E:  MOVFF  28D,294
5252:  MOVFF  28C,293
5256:  MOVFF  28B,292
525A:  MOVFF  28A,291
525E:  MOVWF  x95
5260:  MOVLB  0
5262:  CALL   3AAA
5266:  MOVLW  0D
5268:  BTFSS  F9E.4
526A:  BRA    5268
526C:  MOVWF  FAD
....................                   printf("JULIO              %3.2f                %3.2f\r", media_annos[contador][6], media_annos_caldera[contador][6]); 
526E:  MOVF   6F,W
5270:  MULLW  30
5272:  MOVF   FF3,W
5274:  MOVLB  2
5276:  CLRF   x83
5278:  MOVWF  x82
527A:  MOVLW  18
527C:  ADDWF  x82,W
527E:  MOVWF  01
5280:  MOVLW  00
5282:  ADDWFC x83,W
5284:  MOVWF  03
5286:  MOVF   01,W
5288:  ADDLW  F4
528A:  MOVWF  FE9
528C:  MOVLW  00
528E:  ADDWFC 03,W
5290:  MOVWF  FEA
5292:  MOVFF  FEF,284
5296:  MOVFF  FEC,285
529A:  MOVFF  FEC,286
529E:  MOVFF  FEC,287
52A2:  MOVF   6F,W
52A4:  MULLW  30
52A6:  MOVF   FF3,W
52A8:  CLRF   x89
52AA:  MOVWF  x88
52AC:  MOVLW  18
52AE:  ADDWF  x88,W
52B0:  MOVWF  01
52B2:  MOVLW  00
52B4:  ADDWFC x89,W
52B6:  MOVWF  03
52B8:  MOVF   01,W
52BA:  ADDLW  B4
52BC:  MOVWF  FE9
52BE:  MOVLW  01
52C0:  ADDWFC 03,W
52C2:  MOVWF  FEA
52C4:  MOVFF  FEF,28A
52C8:  MOVFF  FEC,28B
52CC:  MOVFF  FEC,28C
52D0:  MOVFF  FEC,28D
52D4:  CLRF   x8E
52D6:  MOVF   x8E,W
52D8:  MOVLB  0
52DA:  CALL   0FC6
52DE:  MOVLB  2
52E0:  INCF   x8E,F
52E2:  MOVWF  00
52E4:  MOVF   00,W
52E6:  BTFSS  F9E.4
52E8:  BRA    52E6
52EA:  MOVWF  FAD
52EC:  MOVLW  05
52EE:  SUBWF  x8E,W
52F0:  BNZ   52D6
52F2:  MOVLW  0E
52F4:  MOVWF  x8F
52F6:  MOVLW  20
52F8:  BTFSS  F9E.4
52FA:  BRA    52F8
52FC:  MOVWF  FAD
52FE:  DECFSZ x8F,F
5300:  BRA    52F6
5302:  MOVLW  02
5304:  MOVWF  FE9
5306:  MOVFF  287,294
530A:  MOVFF  286,293
530E:  MOVFF  285,292
5312:  MOVFF  284,291
5316:  MOVWF  x95
5318:  MOVLB  0
531A:  CALL   3AAA
531E:  MOVLW  10
5320:  MOVLB  2
5322:  MOVWF  x90
5324:  MOVLW  20
5326:  BTFSS  F9E.4
5328:  BRA    5326
532A:  MOVWF  FAD
532C:  DECFSZ x90,F
532E:  BRA    5324
5330:  MOVLW  02
5332:  MOVWF  FE9
5334:  MOVFF  28D,294
5338:  MOVFF  28C,293
533C:  MOVFF  28B,292
5340:  MOVFF  28A,291
5344:  MOVWF  x95
5346:  MOVLB  0
5348:  CALL   3AAA
534C:  MOVLW  0D
534E:  BTFSS  F9E.4
5350:  BRA    534E
5352:  MOVWF  FAD
....................                   printf("AGOSTO             %3.2f                %3.2f\r", media_annos[contador][7], media_annos_caldera[contador][7]); 
5354:  MOVF   6F,W
5356:  MULLW  30
5358:  MOVF   FF3,W
535A:  MOVLB  2
535C:  CLRF   x83
535E:  MOVWF  x82
5360:  MOVLW  1C
5362:  ADDWF  x82,W
5364:  MOVWF  01
5366:  MOVLW  00
5368:  ADDWFC x83,W
536A:  MOVWF  03
536C:  MOVF   01,W
536E:  ADDLW  F4
5370:  MOVWF  FE9
5372:  MOVLW  00
5374:  ADDWFC 03,W
5376:  MOVWF  FEA
5378:  MOVFF  FEF,284
537C:  MOVFF  FEC,285
5380:  MOVFF  FEC,286
5384:  MOVFF  FEC,287
5388:  MOVF   6F,W
538A:  MULLW  30
538C:  MOVF   FF3,W
538E:  CLRF   x89
5390:  MOVWF  x88
5392:  MOVLW  1C
5394:  ADDWF  x88,W
5396:  MOVWF  01
5398:  MOVLW  00
539A:  ADDWFC x89,W
539C:  MOVWF  03
539E:  MOVF   01,W
53A0:  ADDLW  B4
53A2:  MOVWF  FE9
53A4:  MOVLW  01
53A6:  ADDWFC 03,W
53A8:  MOVWF  FEA
53AA:  MOVFF  FEF,28A
53AE:  MOVFF  FEC,28B
53B2:  MOVFF  FEC,28C
53B6:  MOVFF  FEC,28D
53BA:  CLRF   x8E
53BC:  MOVF   x8E,W
53BE:  MOVLB  0
53C0:  CALL   0FF2
53C4:  MOVLB  2
53C6:  INCF   x8E,F
53C8:  MOVWF  00
53CA:  MOVF   00,W
53CC:  BTFSS  F9E.4
53CE:  BRA    53CC
53D0:  MOVWF  FAD
53D2:  MOVLW  06
53D4:  SUBWF  x8E,W
53D6:  BNZ   53BC
53D8:  MOVLW  0D
53DA:  MOVWF  x8F
53DC:  MOVLW  20
53DE:  BTFSS  F9E.4
53E0:  BRA    53DE
53E2:  MOVWF  FAD
53E4:  DECFSZ x8F,F
53E6:  BRA    53DC
53E8:  MOVLW  02
53EA:  MOVWF  FE9
53EC:  MOVFF  287,294
53F0:  MOVFF  286,293
53F4:  MOVFF  285,292
53F8:  MOVFF  284,291
53FC:  MOVWF  x95
53FE:  MOVLB  0
5400:  CALL   3AAA
5404:  MOVLW  10
5406:  MOVLB  2
5408:  MOVWF  x90
540A:  MOVLW  20
540C:  BTFSS  F9E.4
540E:  BRA    540C
5410:  MOVWF  FAD
5412:  DECFSZ x90,F
5414:  BRA    540A
5416:  MOVLW  02
5418:  MOVWF  FE9
541A:  MOVFF  28D,294
541E:  MOVFF  28C,293
5422:  MOVFF  28B,292
5426:  MOVFF  28A,291
542A:  MOVWF  x95
542C:  MOVLB  0
542E:  CALL   3AAA
5432:  MOVLW  0D
5434:  BTFSS  F9E.4
5436:  BRA    5434
5438:  MOVWF  FAD
....................                   printf("SEPTIEMBRE         %3.2f                %3.2f\r", media_annos[contador][8], media_annos_caldera[contador][8]); 
543A:  MOVF   6F,W
543C:  MULLW  30
543E:  MOVF   FF3,W
5440:  MOVLB  2
5442:  CLRF   x83
5444:  MOVWF  x82
5446:  MOVLW  20
5448:  ADDWF  x82,W
544A:  MOVWF  01
544C:  MOVLW  00
544E:  ADDWFC x83,W
5450:  MOVWF  03
5452:  MOVF   01,W
5454:  ADDLW  F4
5456:  MOVWF  FE9
5458:  MOVLW  00
545A:  ADDWFC 03,W
545C:  MOVWF  FEA
545E:  MOVFF  FEF,284
5462:  MOVFF  FEC,285
5466:  MOVFF  FEC,286
546A:  MOVFF  FEC,287
546E:  MOVF   6F,W
5470:  MULLW  30
5472:  MOVF   FF3,W
5474:  CLRF   x89
5476:  MOVWF  x88
5478:  MOVLW  20
547A:  ADDWF  x88,W
547C:  MOVWF  01
547E:  MOVLW  00
5480:  ADDWFC x89,W
5482:  MOVWF  03
5484:  MOVF   01,W
5486:  ADDLW  B4
5488:  MOVWF  FE9
548A:  MOVLW  01
548C:  ADDWFC 03,W
548E:  MOVWF  FEA
5490:  MOVFF  FEF,28A
5494:  MOVFF  FEC,28B
5498:  MOVFF  FEC,28C
549C:  MOVFF  FEC,28D
54A0:  CLRF   x8E
54A2:  MOVF   x8E,W
54A4:  MOVLB  0
54A6:  CALL   101E
54AA:  MOVLB  2
54AC:  INCF   x8E,F
54AE:  MOVWF  00
54B0:  MOVF   00,W
54B2:  BTFSS  F9E.4
54B4:  BRA    54B2
54B6:  MOVWF  FAD
54B8:  MOVLW  0A
54BA:  SUBWF  x8E,W
54BC:  BNZ   54A2
54BE:  MOVLW  09
54C0:  MOVWF  x8F
54C2:  MOVLW  20
54C4:  BTFSS  F9E.4
54C6:  BRA    54C4
54C8:  MOVWF  FAD
54CA:  DECFSZ x8F,F
54CC:  BRA    54C2
54CE:  MOVLW  02
54D0:  MOVWF  FE9
54D2:  MOVFF  287,294
54D6:  MOVFF  286,293
54DA:  MOVFF  285,292
54DE:  MOVFF  284,291
54E2:  MOVWF  x95
54E4:  MOVLB  0
54E6:  CALL   3AAA
54EA:  MOVLW  10
54EC:  MOVLB  2
54EE:  MOVWF  x90
54F0:  MOVLW  20
54F2:  BTFSS  F9E.4
54F4:  BRA    54F2
54F6:  MOVWF  FAD
54F8:  DECFSZ x90,F
54FA:  BRA    54F0
54FC:  MOVLW  02
54FE:  MOVWF  FE9
5500:  MOVFF  28D,294
5504:  MOVFF  28C,293
5508:  MOVFF  28B,292
550C:  MOVFF  28A,291
5510:  MOVWF  x95
5512:  MOVLB  0
5514:  CALL   3AAA
5518:  MOVLW  0D
551A:  BTFSS  F9E.4
551C:  BRA    551A
551E:  MOVWF  FAD
....................                   printf("OCTUBRE            %3.2f                %3.2f\r", media_annos[contador][9], media_annos_caldera[contador][9]); 
5520:  MOVF   6F,W
5522:  MULLW  30
5524:  MOVF   FF3,W
5526:  MOVLB  2
5528:  CLRF   x83
552A:  MOVWF  x82
552C:  MOVLW  24
552E:  ADDWF  x82,W
5530:  MOVWF  01
5532:  MOVLW  00
5534:  ADDWFC x83,W
5536:  MOVWF  03
5538:  MOVF   01,W
553A:  ADDLW  F4
553C:  MOVWF  FE9
553E:  MOVLW  00
5540:  ADDWFC 03,W
5542:  MOVWF  FEA
5544:  MOVFF  FEF,284
5548:  MOVFF  FEC,285
554C:  MOVFF  FEC,286
5550:  MOVFF  FEC,287
5554:  MOVF   6F,W
5556:  MULLW  30
5558:  MOVF   FF3,W
555A:  CLRF   x89
555C:  MOVWF  x88
555E:  MOVLW  24
5560:  ADDWF  x88,W
5562:  MOVWF  01
5564:  MOVLW  00
5566:  ADDWFC x89,W
5568:  MOVWF  03
556A:  MOVF   01,W
556C:  ADDLW  B4
556E:  MOVWF  FE9
5570:  MOVLW  01
5572:  ADDWFC 03,W
5574:  MOVWF  FEA
5576:  MOVFF  FEF,28A
557A:  MOVFF  FEC,28B
557E:  MOVFF  FEC,28C
5582:  MOVFF  FEC,28D
5586:  CLRF   x8E
5588:  MOVF   x8E,W
558A:  MOVLB  0
558C:  CALL   104E
5590:  MOVLB  2
5592:  INCF   x8E,F
5594:  MOVWF  00
5596:  MOVF   00,W
5598:  BTFSS  F9E.4
559A:  BRA    5598
559C:  MOVWF  FAD
559E:  MOVLW  07
55A0:  SUBWF  x8E,W
55A2:  BNZ   5588
55A4:  MOVLW  0C
55A6:  MOVWF  x8F
55A8:  MOVLW  20
55AA:  BTFSS  F9E.4
55AC:  BRA    55AA
55AE:  MOVWF  FAD
55B0:  DECFSZ x8F,F
55B2:  BRA    55A8
55B4:  MOVLW  02
55B6:  MOVWF  FE9
55B8:  MOVFF  287,294
55BC:  MOVFF  286,293
55C0:  MOVFF  285,292
55C4:  MOVFF  284,291
55C8:  MOVWF  x95
55CA:  MOVLB  0
55CC:  CALL   3AAA
55D0:  MOVLW  10
55D2:  MOVLB  2
55D4:  MOVWF  x90
55D6:  MOVLW  20
55D8:  BTFSS  F9E.4
55DA:  BRA    55D8
55DC:  MOVWF  FAD
55DE:  DECFSZ x90,F
55E0:  BRA    55D6
55E2:  MOVLW  02
55E4:  MOVWF  FE9
55E6:  MOVFF  28D,294
55EA:  MOVFF  28C,293
55EE:  MOVFF  28B,292
55F2:  MOVFF  28A,291
55F6:  MOVWF  x95
55F8:  MOVLB  0
55FA:  CALL   3AAA
55FE:  MOVLW  0D
5600:  BTFSS  F9E.4
5602:  BRA    5600
5604:  MOVWF  FAD
....................                   printf("NOVIEMBRE          %3.2f                %3.2f\r", media_annos[contador][10], media_annos_caldera[contador][10]); 
5606:  MOVF   6F,W
5608:  MULLW  30
560A:  MOVF   FF3,W
560C:  MOVLB  2
560E:  CLRF   x83
5610:  MOVWF  x82
5612:  MOVLW  28
5614:  ADDWF  x82,W
5616:  MOVWF  01
5618:  MOVLW  00
561A:  ADDWFC x83,W
561C:  MOVWF  03
561E:  MOVF   01,W
5620:  ADDLW  F4
5622:  MOVWF  FE9
5624:  MOVLW  00
5626:  ADDWFC 03,W
5628:  MOVWF  FEA
562A:  MOVFF  FEF,284
562E:  MOVFF  FEC,285
5632:  MOVFF  FEC,286
5636:  MOVFF  FEC,287
563A:  MOVF   6F,W
563C:  MULLW  30
563E:  MOVF   FF3,W
5640:  CLRF   x89
5642:  MOVWF  x88
5644:  MOVLW  28
5646:  ADDWF  x88,W
5648:  MOVWF  01
564A:  MOVLW  00
564C:  ADDWFC x89,W
564E:  MOVWF  03
5650:  MOVF   01,W
5652:  ADDLW  B4
5654:  MOVWF  FE9
5656:  MOVLW  01
5658:  ADDWFC 03,W
565A:  MOVWF  FEA
565C:  MOVFF  FEF,28A
5660:  MOVFF  FEC,28B
5664:  MOVFF  FEC,28C
5668:  MOVFF  FEC,28D
566C:  CLRF   x8E
566E:  MOVF   x8E,W
5670:  MOVLB  0
5672:  CALL   107C
5676:  MOVLB  2
5678:  INCF   x8E,F
567A:  MOVWF  00
567C:  MOVF   00,W
567E:  BTFSS  F9E.4
5680:  BRA    567E
5682:  MOVWF  FAD
5684:  MOVLW  09
5686:  SUBWF  x8E,W
5688:  BNZ   566E
568A:  MOVLW  0A
568C:  MOVWF  x8F
568E:  MOVLW  20
5690:  BTFSS  F9E.4
5692:  BRA    5690
5694:  MOVWF  FAD
5696:  DECFSZ x8F,F
5698:  BRA    568E
569A:  MOVLW  02
569C:  MOVWF  FE9
569E:  MOVFF  287,294
56A2:  MOVFF  286,293
56A6:  MOVFF  285,292
56AA:  MOVFF  284,291
56AE:  MOVWF  x95
56B0:  MOVLB  0
56B2:  CALL   3AAA
56B6:  MOVLW  10
56B8:  MOVLB  2
56BA:  MOVWF  x90
56BC:  MOVLW  20
56BE:  BTFSS  F9E.4
56C0:  BRA    56BE
56C2:  MOVWF  FAD
56C4:  DECFSZ x90,F
56C6:  BRA    56BC
56C8:  MOVLW  02
56CA:  MOVWF  FE9
56CC:  MOVFF  28D,294
56D0:  MOVFF  28C,293
56D4:  MOVFF  28B,292
56D8:  MOVFF  28A,291
56DC:  MOVWF  x95
56DE:  MOVLB  0
56E0:  CALL   3AAA
56E4:  MOVLW  0D
56E6:  BTFSS  F9E.4
56E8:  BRA    56E6
56EA:  MOVWF  FAD
....................                   printf("DICIEMBRE          %3.2f                %3.2f\r", media_annos[contador][11], media_annos_caldera[contador][11]); 
56EC:  MOVF   6F,W
56EE:  MULLW  30
56F0:  MOVF   FF3,W
56F2:  MOVLB  2
56F4:  CLRF   x83
56F6:  MOVWF  x82
56F8:  MOVLW  2C
56FA:  ADDWF  x82,W
56FC:  MOVWF  01
56FE:  MOVLW  00
5700:  ADDWFC x83,W
5702:  MOVWF  03
5704:  MOVF   01,W
5706:  ADDLW  F4
5708:  MOVWF  FE9
570A:  MOVLW  00
570C:  ADDWFC 03,W
570E:  MOVWF  FEA
5710:  MOVFF  FEF,284
5714:  MOVFF  FEC,285
5718:  MOVFF  FEC,286
571C:  MOVFF  FEC,287
5720:  MOVF   6F,W
5722:  MULLW  30
5724:  MOVF   FF3,W
5726:  CLRF   x89
5728:  MOVWF  x88
572A:  MOVLW  2C
572C:  ADDWF  x88,W
572E:  MOVWF  01
5730:  MOVLW  00
5732:  ADDWFC x89,W
5734:  MOVWF  03
5736:  MOVF   01,W
5738:  ADDLW  B4
573A:  MOVWF  FE9
573C:  MOVLW  01
573E:  ADDWFC 03,W
5740:  MOVWF  FEA
5742:  MOVFF  FEF,28A
5746:  MOVFF  FEC,28B
574A:  MOVFF  FEC,28C
574E:  MOVFF  FEC,28D
5752:  CLRF   x8E
5754:  MOVF   x8E,W
5756:  MOVLB  0
5758:  CALL   10AC
575C:  MOVLB  2
575E:  INCF   x8E,F
5760:  MOVWF  00
5762:  MOVF   00,W
5764:  BTFSS  F9E.4
5766:  BRA    5764
5768:  MOVWF  FAD
576A:  MOVLW  09
576C:  SUBWF  x8E,W
576E:  BNZ   5754
5770:  MOVLW  0A
5772:  MOVWF  x8F
5774:  MOVLW  20
5776:  BTFSS  F9E.4
5778:  BRA    5776
577A:  MOVWF  FAD
577C:  DECFSZ x8F,F
577E:  BRA    5774
5780:  MOVLW  02
5782:  MOVWF  FE9
5784:  MOVFF  287,294
5788:  MOVFF  286,293
578C:  MOVFF  285,292
5790:  MOVFF  284,291
5794:  MOVWF  x95
5796:  MOVLB  0
5798:  CALL   3AAA
579C:  MOVLW  10
579E:  MOVLB  2
57A0:  MOVWF  x90
57A2:  MOVLW  20
57A4:  BTFSS  F9E.4
57A6:  BRA    57A4
57A8:  MOVWF  FAD
57AA:  DECFSZ x90,F
57AC:  BRA    57A2
57AE:  MOVLW  02
57B0:  MOVWF  FE9
57B2:  MOVFF  28D,294
57B6:  MOVFF  28C,293
57BA:  MOVFF  28B,292
57BE:  MOVFF  28A,291
57C2:  MOVWF  x95
57C4:  MOVLB  0
57C6:  CALL   3AAA
57CA:  MOVLW  0D
57CC:  BTFSS  F9E.4
57CE:  BRA    57CC
57D0:  MOVWF  FAD
....................                   printf("-----------------------------------------------------\r"); 
57D2:  MOVLB  2
57D4:  CLRF   x82
57D6:  MOVF   x82,W
57D8:  MOVLB  0
57DA:  CALL   0E1A
57DE:  IORLW  00
57E0:  BZ    57F0
57E2:  MOVLB  2
57E4:  INCF   x82,F
57E6:  BTFSS  F9E.4
57E8:  BRA    57E6
57EA:  MOVWF  FAD
57EC:  BRA    57D6
57EE:  MOVLB  0
....................                } 
57F0:  INCF   6F,F
57F2:  GOTO   4C62
....................  
....................                goto repetir; 
57F6:  MOVLB  0
57F8:  GOTO   49C4
....................                break; 
57FC:  BRA    57FE
....................  
....................       //En los tres casos, vuelve a mostrarse el menú tras imprimir las estadísticas 
....................    } 
.................... } 
57FE:  GOTO   6796 (RETURN)
....................  
.................... //------------------------------------------------------------------------------------------------------------------------------------ 
....................  
.................... void seleccionar_alarma() 
.................... { 
....................    //Contador y variables auxiliares 
....................    int contador; 
....................    int hora, minutos, hora_p, min_p; 
....................  
....................    //Ponemos la posición en el vector de alarmas incialmente a 0 
....................    posicion_alarmas = 0; 
*
383A:  CLRF   44
....................  
....................    //Leemos el tiempo actual 
....................    PCF8583_read_datetime(&tiempo); 
383C:  CLRF   78
383E:  MOVLW  45
3840:  MOVWF  77
3842:  CALL   285C
....................    hora = tiempo.hours; 
3846:  MOVFF  47,70
....................    minutos = tiempo.minutes; 
384A:  MOVFF  46,71
....................  
....................    //Recorremos todas las programaciones 
....................    for(contador=0; contador<num_intervalos; contador++) 
384E:  CLRF   6F
3850:  MOVF   43,W
3852:  SUBWF  6F,W
3854:  BC    38B8
....................    { 
....................        hora_p = programaciones[contador].horas_inicio; 
3856:  MOVF   6F,W
3858:  MULLW  05
385A:  MOVF   FF3,W
385C:  CLRF   75
385E:  MOVWF  74
3860:  MOVLW  2F
3862:  ADDWF  74,W
3864:  MOVWF  FE9
3866:  MOVLW  00
3868:  ADDWFC 75,W
386A:  MOVWF  FEA
386C:  MOVFF  FEF,72
....................        min_p  = programaciones[contador].minutos_inicio; 
3870:  MOVF   6F,W
3872:  MULLW  05
3874:  MOVF   FF3,W
3876:  CLRF   75
3878:  MOVWF  74
387A:  MOVLW  01
387C:  ADDWF  74,W
387E:  MOVWF  01
3880:  MOVLW  00
3882:  ADDWFC 75,W
3884:  MOVWF  03
3886:  MOVF   01,W
3888:  ADDLW  2F
388A:  MOVWF  FE9
388C:  MOVLW  00
388E:  ADDWFC 03,W
3890:  MOVWF  FEA
3892:  MOVFF  FEF,73
....................  
....................        //Comprobamos las horas y tomamos la primera programación que tenga una 
....................        //hora mayor que la actual 
....................        if(!comprobar_hora(hora_p, min_p, hora, minutos)) 
3896:  MOVFF  72,81
389A:  MOVFF  73,82
389E:  MOVFF  70,83
38A2:  MOVFF  71,84
38A6:  CALL   2A7C
38AA:  MOVF   01,F
38AC:  BNZ   38B4
....................        { 
....................            //Guardamos la posición de esta programación y salimos 
....................            posicion_alarmas = contador; 
38AE:  MOVFF  6F,44
....................            break; 
38B2:  BRA    38B8
....................        } 
....................    } 
38B4:  INCF   6F,F
38B6:  BRA    3850
.................... } 
38B8:  GOTO   6636 (RETURN)

Configuration Fuses:
   Word  1: 0200   HS NOIESO NOFCMEN RESERVED
   Word  2: 181E   BROWNOUT NOWDT BORV25 PUT WDT4096
   Word  3: 8300   PBADEN CCP2C1 NOLPT1OSC MCLR RESERVED
   Word  4: 0081   STVREN NODEBUG NOLVP NOXINST RESERVED
   Word  5: C00F   NOPROTECT NOCPD NOCPB
   Word  6: E00F   NOWRT NOWRTD NOWRTC NOWRTB
   Word  7: 400F   NOEBTR NOEBTRB
