CCS PCM C Compiler, Version 4.023, 25097               27-feb-10 13:17

               Filename: E:\programming\sed\Proyecto 1\Material definitivo\Prototipo 3 (Pic gama media)\proyecto1.lst

               ROM used: 8106 words (99%)
                         Largest free fragment is 36
               RAM used: 75 (20%) at main() level
                         147 (40%) worst case
               Stack:    7 worst case (6 in main + 1 for interrupts)

*
0000:  MOVLW  18
0001:  MOVWF  0A
0002:  GOTO   245
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  MOVF   7B,W
0016:  MOVWF  27
0017:  BCF    03.7
0018:  BCF    03.5
0019:  BTFSS  0B.4
001A:  GOTO   01D
001B:  BTFSC  0B.1
001C:  GOTO   030
001D:  MOVF   22,W
001E:  MOVWF  04
001F:  MOVF   23,W
0020:  MOVWF  77
0021:  MOVF   24,W
0022:  MOVWF  78
0023:  MOVF   25,W
0024:  MOVWF  79
0025:  MOVF   26,W
0026:  MOVWF  7A
0027:  MOVF   27,W
0028:  MOVWF  7B
0029:  MOVF   20,W
002A:  MOVWF  0A
002B:  SWAPF  21,W
002C:  MOVWF  03
002D:  SWAPF  7F,F
002E:  SWAPF  7F,W
002F:  RETFIE
0030:  BCF    0A.3
0031:  BCF    0A.4
0032:  GOTO   19E
.................... //***************************************************************** 
.................... //***   PROYECTO 1: Control de un sistema de calefacción de una *** 
.................... //***   vivienda utilizando un microcontrolador PIC16F887       *** 
.................... //***************************************************************** 
.................... //Author: Julio Navarro Lara        2010 
....................  
.................... //En este caso está preparado para ajustarse a un pic de gama media 
....................  
....................  
....................  
.................... #include "16F887.H" 
.................... //////// Standard Header file for the PIC16F887 device //////////////// 
.................... #device PIC16F887 
.................... #list 
....................  
.................... #include "proyecto1.h" 
.................... //****************************************** 
.................... //Archivo de cabecera del Proyecto 1 
.................... //****************************************** 
.................... //Author: Julio Navarro Lara         2010 
....................  
.................... #bit sistema_encendido = 0xF08.2    //Pin que indica el encendido del sistema con un valor alto 
.................... #bit motor = 0xF08.1                //Pin que indica el encendido del motor de circulación del agua con un valor alto 
.................... #bit caldera_encendida = 0xF08.0    //Pin que indica el encendido de la caldera con un valor alto 
.................... #bit menos =    0xF07.1             //Pines para gestionar la entrada de los pulsadores 
.................... #bit mas   =    0xF07.0             //'' 
.................... #bit si    =    0xF07.2             //'' 
.................... #bit no    =    0xF07.5             //'' 
....................  
.................... //Parámetros de la pantalla LCD 
.................... #define LCD_ORDEN       0    //Código para enviar un orden 
.................... #define LCD_DATO        1    //Código para enviar un dato 
....................  
.................... #define LCD_CLEAR       0x01  //Orden para borrar la pantalla 
.................... #define LCD_NO_CURSOR   0x0C  //Orden para eliminar el cursor de la pantalla 
.................... #define LCD_CURSOR      0x0E  //Orden para visualizar el cursor en la pantalla 
.................... #define LCD_PARPADEAR   0x0D  //Orden para que parpadee el cursor 
....................  
.................... //Parámetros del conversor AD 
.................... #define termostato_caldera   3   //Entrada AD que se refiere a la temperatura de referencia de la caldera 
.................... #define temperatura_caldera  2   //Entrada AD que se refiere a la temperatura del agua en la caldera 
.................... #define histeresis_caldera   5   //Diferencia de histéresis para el agua de la caldera 
.................... //Para probar en el PROTEUS, poner una histeresis de 10 ºC (los potenciómetros simulados no tienen más sensibilidad) 
.................... #define t_max_caldera        100  //Temperatura máxima a la que puede regularse la caldera 
.................... #define t_min_caldera        0  //Temperatura mínima a la que puede regularse la caldera 
.................... #define AD_num_valores       255 //Número de valores de escala del conversor (sensibilidad de los potenciómetros) 
....................  
.................... //Parámetros de control de temperatura 
.................... //Datos suministrados por el aparato de aire acondicionado (con bomba de calor) de mi casa 
.................... #define temp_max          32  //Temperatura máxima de regulación del termostato 
.................... #define temp_min          16  //Temperatura mínima de regulación del termostato 
....................  
.................... //Direcciones para la EEPROM 
.................... #define eeprom_termostato        0x0000  //Valor del termostato 
.................... #define eeprom_num_registros     0x0001  //Número de registros de desconexión de los que se disponen 
.................... #define eeprom_anno_actual       0x0003  //Año en el que nos encontramos 
.................... #define eeprom_anno_0_to_3       0x0004  //Año en el que nos encontramos medido de 0 a 3 (llamado 1_to_3 por razones "históricas") 
.................... #define eeprom_programacion      0x0008  //Posición a partir de la cual se almacenan la programación de la alarma 
.................... #define eeprom_registros         0x0010  //Posición a partir de la cual se almacenan los registros 
....................  
.................... #fuses HS, BROWNOUT, PUT, NOWDT 
.................... //El watchdog-timer salta cada 16.384 segundos, aproximadamente 
.................... #use delay(clock=8000000, restart_wdt) 
*
01A3:  MOVLW  AC
01A4:  MOVWF  04
01A5:  BCF    03.7
01A6:  MOVF   00,W
01A7:  BTFSC  03.2
01A8:  GOTO   1BA
01A9:  MOVLW  02
01AA:  MOVWF  78
01AB:  MOVLW  BF
01AC:  MOVWF  77
01AD:  CLRWDT
01AE:  DECFSZ 77,F
01AF:  GOTO   1AD
01B0:  DECFSZ 78,F
01B1:  GOTO   1AB
01B2:  MOVLW  96
01B3:  MOVWF  77
01B4:  DECFSZ 77,F
01B5:  GOTO   1B4
01B6:  GOTO   1B7
01B7:  CLRWDT
01B8:  DECFSZ 00,F
01B9:  GOTO   1A9
01BA:  RETLW  00
*
01CB:  MOVLW  08
01CC:  BSF    03.5
01CD:  SUBWF  2D,F
01CE:  BTFSS  03.0
01CF:  GOTO   1DC
01D0:  MOVLW  AD
01D1:  MOVWF  04
01D2:  BCF    03.7
01D3:  BCF    03.0
01D4:  RRF    00,F
01D5:  MOVF   00,W
01D6:  BTFSC  03.2
01D7:  GOTO   1DC
01D8:  GOTO   1DA
01D9:  CLRWDT
01DA:  DECFSZ 00,F
01DB:  GOTO   1D9
01DC:  BCF    03.5
01DD:  RETLW  00
.................... #use rs232(baud=4800, xmit=PIN_C6,rcv=PIN_C7,RESTART_WDT) 
.................... #use i2c(master, sda=PIN_C4, scl=PIN_C3, NOFORCE_SW) 
*
038C:  BCF    14.7
038D:  BCF    0C.3
038E:  BSF    03.5
038F:  MOVF   31,W
0390:  BCF    03.5
0391:  MOVWF  13
0392:  MOVLW  02
0393:  BTFSC  14.7
0394:  GOTO   39C
0395:  BTFSS  0C.3
0396:  GOTO   395
0397:  MOVLW  00
0398:  BSF    03.5
0399:  BTFSC  11.6
039A:  MOVLW  01
039B:  BCF    03.5
039C:  MOVWF  78
039D:  RETLW  00
*
07EB:  BSF    03.5
07EC:  BSF    11.3
07ED:  BTFSC  11.3
07EE:  GOTO   7ED
07EF:  BTFSC  77.0
07F0:  BCF    11.5
07F1:  BTFSS  77.0
07F2:  BSF    11.5
07F3:  BSF    11.4
07F4:  BTFSC  11.4
07F5:  GOTO   7F4
07F6:  BCF    03.5
07F7:  MOVF   13,W
07F8:  MOVWF  78
07F9:  RETLW  00
*
1A7C:  BCF    03.5
1A7D:  BCF    03.6
1A7E:  MOVWF  28
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(int *)==1 
.................... #define ptrdiff_t int 
.................... #else 
.................... #define ptrdiff_t long 
.................... #endif 
....................  
.................... #define size_t int 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: float atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... float atof(char * s); 
....................  
.................... /* Standard template: float atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... float atoe(char * s); 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int32 atoi32(char *s); 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, int8 base, char * s); 
....................  
.................... /* Standard template: signed long  atol(char * s) 
....................  * converts the initial portion of the string s to a signed long 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: float strtol(char * s,char *endptr) 
....................  * converts the initial portion of the string s to a float 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... float strtod(char *s,char *endptr); 
....................  
.................... /* Standard template: long strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr,signed int base); 
....................  
.................... /* Standard template: long strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... long strtoul(char *s,char *endptr,signed int base); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... long rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer,signed int denom); 
.................... ldiv_t ldiv(signed long numer,signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(int *)==1 
.................... #define ptrdiff_t int 
.................... #else 
.................... #define ptrdiff_t long 
.................... #endif 
....................  
.................... #define size_t int 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(int *)==1 
.................... #define ptrdiff_t int 
.................... #else 
.................... #define ptrdiff_t long 
.................... #endif 
....................  
.................... #define size_t int 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* compiler ignored the name 'strcpy()'; perhaps, it's reserved? 
....................    Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1*/ 
....................  
.................... char *strcopy(char *s1, char *s2) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; *s2 != 0; s++, s2++) { 
....................      *s = *s2; 
....................   } 
....................   *s = *s2; 
....................   return(s1); 
.................... } 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   int n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,int c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, int c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... int *strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, int c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... int *strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
1A7F:  CLRF   29
1A80:  CLRF   2A
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(int errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... int *strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer,signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer,signed long denom) 
.................... { 
....................    ldiv_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... float atof(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int sign = 0; 
....................    char c; 
....................    int ptr = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
....................  
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int sign = 0; 
....................    int expsign = 0; 
....................    char c; 
....................    int ptr = 0; 
....................    int i; 
....................    float exp = 1.0; 
....................    int expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
0266:  CLRF   7D
....................    sign = 0; 
0267:  CLRF   76
....................    base = 10; 
0268:  MOVLW  0A
0269:  MOVWF  7C
....................    result = 0; 
026A:  CLRF   75
....................  
....................    if (!s) 
026B:  MOVF   73,W
026C:  IORWF  74,W
026D:  BTFSS  03.2
026E:  GOTO   272
....................       return 0; 
026F:  MOVLW  00
0270:  MOVWF  78
0271:  GOTO   34A
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
0272:  MOVF   7D,W
0273:  INCF   7D,F
0274:  ADDWF  73,W
0275:  MOVWF  04
0276:  BCF    03.7
0277:  BTFSC  74.0
0278:  BSF    03.7
0279:  MOVF   00,W
027A:  MOVWF  7E
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
027B:  MOVF   7E,W
027C:  SUBLW  2D
027D:  BTFSS  03.2
027E:  GOTO   28B
....................    { 
....................       sign = 1;         // Set the sign to negative 
027F:  MOVLW  01
0280:  MOVWF  76
....................       c = s[index++]; 
0281:  MOVF   7D,W
0282:  INCF   7D,F
0283:  ADDWF  73,W
0284:  MOVWF  04
0285:  BCF    03.7
0286:  BTFSC  74.0
0287:  BSF    03.7
0288:  MOVF   00,W
0289:  MOVWF  7E
....................    } 
....................    else if (c == '+') 
028A:  GOTO   298
028B:  MOVF   7E,W
028C:  SUBLW  2B
028D:  BTFSS  03.2
028E:  GOTO   298
....................    { 
....................       c = s[index++]; 
028F:  MOVF   7D,W
0290:  INCF   7D,F
0291:  ADDWF  73,W
0292:  MOVWF  04
0293:  BCF    03.7
0294:  BTFSC  74.0
0295:  BSF    03.7
0296:  MOVF   00,W
0297:  MOVWF  7E
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
0298:  MOVF   7E,W
0299:  SUBLW  2F
029A:  BTFSC  03.0
029B:  GOTO   340
029C:  MOVF   7E,W
029D:  SUBLW  39
029E:  BTFSS  03.0
029F:  GOTO   340
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
02A0:  MOVF   7E,W
02A1:  SUBLW  30
02A2:  BTFSS  03.2
02A3:  GOTO   2C4
02A4:  MOVF   7D,W
02A5:  ADDWF  73,W
02A6:  MOVWF  04
02A7:  BCF    03.7
02A8:  BTFSC  74.0
02A9:  BSF    03.7
02AA:  MOVF   00,W
02AB:  SUBLW  78
02AC:  BTFSC  03.2
02AD:  GOTO   2B8
02AE:  MOVF   7D,W
02AF:  ADDWF  73,W
02B0:  MOVWF  04
02B1:  BCF    03.7
02B2:  BTFSC  74.0
02B3:  BSF    03.7
02B4:  MOVF   00,W
02B5:  SUBLW  58
02B6:  BTFSS  03.2
02B7:  GOTO   2C4
....................       { 
....................          base = 16; 
02B8:  MOVLW  10
02B9:  MOVWF  7C
....................          index++; 
02BA:  INCF   7D,F
....................          c = s[index++]; 
02BB:  MOVF   7D,W
02BC:  INCF   7D,F
02BD:  ADDWF  73,W
02BE:  MOVWF  04
02BF:  BCF    03.7
02C0:  BTFSC  74.0
02C1:  BSF    03.7
02C2:  MOVF   00,W
02C3:  MOVWF  7E
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
02C4:  MOVF   7C,W
02C5:  SUBLW  0A
02C6:  BTFSS  03.2
02C7:  GOTO   2EA
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
02C8:  MOVF   7E,W
02C9:  SUBLW  2F
02CA:  BTFSC  03.0
02CB:  GOTO   2E9
02CC:  MOVF   7E,W
02CD:  SUBLW  39
02CE:  BTFSS  03.0
02CF:  GOTO   2E9
....................             result = 10*result + (c - '0'); 
02D0:  MOVLW  0A
02D1:  BSF    03.5
02D2:  MOVWF  20
02D3:  MOVF   75,W
02D4:  MOVWF  21
02D5:  BCF    03.5
02D6:  GOTO   23D
02D7:  MOVF   78,W
02D8:  BSF    03.5
02D9:  MOVWF  20
02DA:  MOVLW  30
02DB:  SUBWF  7E,W
02DC:  ADDWF  20,W
02DD:  MOVWF  75
....................             c = s[index++]; 
02DE:  MOVF   7D,W
02DF:  INCF   7D,F
02E0:  ADDWF  73,W
02E1:  MOVWF  04
02E2:  BCF    03.7
02E3:  BTFSC  74.0
02E4:  BSF    03.7
02E5:  MOVF   00,W
02E6:  MOVWF  7E
....................          } 
02E7:  BCF    03.5
02E8:  GOTO   2C8
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
02E9:  GOTO   340
02EA:  MOVF   7C,W
02EB:  SUBLW  10
02EC:  BTFSS  03.2
02ED:  GOTO   340
....................       { 
....................          c = toupper(c); 
02EE:  MOVF   7E,W
02EF:  SUBLW  60
02F0:  BTFSC  03.0
02F1:  GOTO   2F9
02F2:  MOVF   7E,W
02F3:  SUBLW  7A
02F4:  BTFSS  03.0
02F5:  GOTO   2F9
02F6:  MOVF   7E,W
02F7:  ANDLW  DF
02F8:  GOTO   2FA
02F9:  MOVF   7E,W
02FA:  MOVWF  7E
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
02FB:  MOVF   7E,W
02FC:  SUBLW  2F
02FD:  BTFSC  03.0
02FE:  GOTO   303
02FF:  MOVF   7E,W
0300:  SUBLW  39
0301:  BTFSC  03.0
0302:  GOTO   30B
0303:  MOVF   7E,W
0304:  SUBLW  40
0305:  BTFSC  03.0
0306:  GOTO   340
0307:  MOVF   7E,W
0308:  SUBLW  46
0309:  BTFSS  03.0
030A:  GOTO   340
....................             if (c >= '0' && c <= '9') 
030B:  MOVF   7E,W
030C:  SUBLW  2F
030D:  BTFSC  03.0
030E:  GOTO   31E
030F:  MOVF   7E,W
0310:  SUBLW  39
0311:  BTFSS  03.0
0312:  GOTO   31E
....................                result = (result << 4) + (c - '0'); 
0313:  SWAPF  75,W
0314:  BSF    03.5
0315:  MOVWF  20
0316:  MOVLW  F0
0317:  ANDWF  20,F
0318:  MOVLW  30
0319:  SUBWF  7E,W
031A:  ADDWF  20,W
031B:  MOVWF  75
....................             else 
031C:  GOTO   328
031D:  BCF    03.5
....................                result = (result << 4) + (c - 'A' + 10); 
031E:  SWAPF  75,W
031F:  BSF    03.5
0320:  MOVWF  20
0321:  MOVLW  F0
0322:  ANDWF  20,F
0323:  MOVLW  41
0324:  SUBWF  7E,W
0325:  ADDLW  0A
0326:  ADDWF  20,W
0327:  MOVWF  75
....................  
....................             c = s[index++]; 
0328:  MOVF   7D,W
0329:  INCF   7D,F
032A:  ADDWF  73,W
032B:  MOVWF  04
032C:  BCF    03.7
032D:  BTFSC  74.0
032E:  BSF    03.7
032F:  MOVF   00,W
0330:  MOVWF  7E
....................             c = toupper(c); 
0331:  MOVF   7E,W
0332:  SUBLW  60
0333:  BTFSC  03.0
0334:  GOTO   33C
0335:  MOVF   7E,W
0336:  SUBLW  7A
0337:  BTFSS  03.0
0338:  GOTO   33C
0339:  MOVF   7E,W
033A:  ANDLW  DF
033B:  GOTO   33D
033C:  MOVF   7E,W
033D:  MOVWF  7E
....................          } 
033E:  BCF    03.5
033F:  GOTO   2FB
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
0340:  DECFSZ 76,W
0341:  GOTO   348
0342:  MOVF   7C,W
0343:  SUBLW  0A
0344:  BTFSS  03.2
0345:  GOTO   348
....................        result = -result; 
0346:  COMF   75,F
0347:  INCF   75,F
....................  
....................    return(result); 
0348:  MOVF   75,W
0349:  MOVWF  78
.................... } 
034A:  RETLW  00
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... char * itoa(signed int32 num, int8 base, char *s) 
.................... { 
....................      int32 temp=1; 
....................      int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... float strtod(char *s,char *endptr) { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int sign = 0, point = 0; 
....................    char c; 
....................    int ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c=s[ptr++]; 
....................  
....................  
....................    while((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 0) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          point = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 1) { 
....................          pow10 = pow10*10; 
....................          result += (c - '0')/pow10; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '+') { 
....................          c = s[ptr++]; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................          *((char *)endptr)=s+ptr; 
....................       } 
....................       else 
....................          *((char *)endptr)=s; 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... long strtoul(char *s,char *endptr,signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-') 
....................    { 
....................       if (endptr) 
....................       { 
....................         *((char *)endptr)=s; 
....................       } 
....................       return 0; 
....................    } 
....................  
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    { 
....................       if (endptr) 
....................       { 
....................         *((char *)endptr)=s; 
....................       } 
....................       return 0; 
....................    } 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................       if (endptr) 
....................       { 
....................         *((char *)endptr)=s; 
....................       } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................         *((char *)endptr)=sc; 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr,signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    { 
....................       if (endptr) 
....................       { 
....................         *((char *)endptr)=s; 
....................       } 
....................       return 0; 
....................    } 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................       if (endptr) 
....................       { 
....................         *((char *)endptr)=s; 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................         *((char *)endptr)=sc; 
....................    return x; 
.................... } 
....................  
.................... signed int system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... long rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned long)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... typedef signed int (*_Cmpfun)(char * p1,char * p2); 
....................  
.................... void qsort(char * qdata, int qitems, int qsize, _Cmpfun cmp) { 
....................    int m,j,i,l; 
....................    short done; 
....................    BYTE t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=TRUE; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = FALSE; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include "PCF8583.c" 
.................... // Funciones para el RTC I2c: PCF8583 
.................... // Este código no procede de CCS (no está totalmente verificado) 
.................... // Inluye funciones de conversión BCD-Binario 
.................... // y de lectura/escritura a través de I2C. 
....................  
.................... //Vamos a eliminar todos los casos en los que se habiliten las interrupciones globales 
.................... //Estas sentencias nos impedían utilizar estos métodos en las interrupciones 
....................  
.................... #ifndef PCF8583_SDA 
.................... #define PCF8583_SDA  PIN_C4 
.................... #define PCF8583_SCL  PIN_C3 
.................... #endif 
....................  
.................... //#use i2c(master, sda=PCF8583_SDA, scl=PCF8583_SCL, NOFORCE_SW) 
....................  
.................... #ifndef PCF8583_WRITE_ADDRESS 
.................... #define PCF8583_WRITE_ADDRESS 0xA0 
.................... #define PCF8583_READ_ADDRESS  0xA1 
.................... #endif 
....................  
.................... // Register addresses 
.................... #define PCF8583_CTRL_STATUS_REG    0x00 
.................... #define PCF8583_100S_REG           0x01 
.................... #define PCF8583_SECONDS_REG        0x02 
....................  
.................... // Use the first NVRAM address for the year byte. 
.................... #define PCF8583_YEAR_REG           0x10 
....................  
....................  
.................... // Commands for the Control/Status register. 
.................... #define PCF8583_START_COUNTING     0x00 
.................... #define PCF8583_STOP_COUNTING      0x80 
....................  
....................  
.................... // This structure defines the user's date and time data. 
.................... // The values are stored as unsigned integers.  The user 
.................... // should declare a structure of this type in the application 
.................... // program. Then the address of the structure should be 
.................... // passed to the PCF8583 read/write functions in this 
.................... // driver, whenever you want to talk to the chip. 
.................... typedef struct 
.................... { 
.................... int8 seconds;    // 0 to 59 
.................... int8 minutes;    // 0 to 59 
.................... int8 hours;      // 0 to 23  (24-hour time) 
.................... int8 day;        // 1 to 31 
.................... int8 month;      // 1 to 12 
.................... int8 year;       // 00 to 99 
.................... int8 weekday;    // 0 = Sunday, 1 = Monday, etc. 
.................... }date_time_t; 
....................  
....................  
.................... //---------------------------------------------- 
.................... void PCF8583_write_byte(int8 address, int8 data) 
.................... { 
.................... disable_interrupts(GLOBAL); 
*
039E:  BCF    0B.6
039F:  BCF    0B.7
03A0:  BTFSC  0B.7
03A1:  GOTO   39F
.................... i2c_start(); 
03A2:  BSF    03.5
03A3:  BSF    11.0
03A4:  BTFSC  11.0
03A5:  GOTO   3A4
.................... i2c_write(PCF8583_WRITE_ADDRESS); 
03A6:  MOVLW  A0
03A7:  MOVWF  31
03A8:  BCF    03.5
03A9:  CALL   38C
.................... i2c_write(address); 
03AA:  MOVF   7D,W
03AB:  BSF    03.5
03AC:  MOVWF  31
03AD:  BCF    03.5
03AE:  CALL   38C
.................... i2c_write(data); 
03AF:  MOVF   7E,W
03B0:  BSF    03.5
03B1:  MOVWF  31
03B2:  BCF    03.5
03B3:  CALL   38C
.................... i2c_stop(); 
03B4:  BSF    03.5
03B5:  BSF    11.2
03B6:  BTFSC  11.2
03B7:  GOTO   3B6
.................... } 
03B8:  BCF    03.5
03B9:  RETLW  00
....................  
.................... //---------------------------------------------- 
.................... int8 PCF8583_read_byte(int8 address) 
.................... { 
.................... int8 retval; 
....................  
.................... disable_interrupts(GLOBAL); 
*
0D5C:  BCF    0B.6
0D5D:  BCF    0B.7
0D5E:  BTFSC  0B.7
0D5F:  GOTO   55D
.................... i2c_start(); 
0D60:  BSF    03.5
0D61:  BSF    11.0
0D62:  BTFSC  11.0
0D63:  GOTO   562
.................... i2c_write(PCF8583_WRITE_ADDRESS); 
0D64:  MOVLW  A0
0D65:  MOVWF  31
0D66:  BCF    0A.3
0D67:  BCF    03.5
0D68:  CALL   38C
0D69:  BSF    0A.3
.................... i2c_write(address); 
0D6A:  MOVF   74,W
0D6B:  BSF    03.5
0D6C:  MOVWF  31
0D6D:  BCF    0A.3
0D6E:  BCF    03.5
0D6F:  CALL   38C
0D70:  BSF    0A.3
.................... i2c_start(); 
0D71:  BSF    03.5
0D72:  BSF    11.1
0D73:  BTFSC  11.1
0D74:  GOTO   573
.................... i2c_write(PCF8583_READ_ADDRESS); 
0D75:  MOVLW  A1
0D76:  MOVWF  31
0D77:  BCF    0A.3
0D78:  BCF    03.5
0D79:  CALL   38C
0D7A:  BSF    0A.3
.................... retval = i2c_read(0); 
0D7B:  CLRF   77
0D7C:  BCF    0A.3
0D7D:  CALL   7EB
0D7E:  BSF    0A.3
0D7F:  MOVF   78,W
0D80:  MOVWF  75
.................... i2c_stop(); 
0D81:  BSF    03.5
0D82:  BSF    11.2
0D83:  BTFSC  11.2
0D84:  GOTO   583
....................  
.................... return(retval); 
0D85:  MOVF   75,W
0D86:  MOVWF  78
.................... } 
....................  
....................  
.................... void PCF8583_init(void) 
.................... { 
.................... PCF8583_write_byte(PCF8583_CTRL_STATUS_REG, 
....................                               PCF8583_START_COUNTING); 
.................... } 
....................  
.................... //---------------------------------------------- 
.................... // This function converts an 8 bit binary value 
.................... // to an 8 bit BCD value. 
.................... // The input range must be from 0 to 99. 
....................  
.................... int8 bin2bcd(int8 value) 
.................... { 
.................... char retval; 
....................  
.................... retval = 0; 
*
037B:  CLRF   7E
....................  
.................... while(1) 
....................   { 
....................    // Get the tens digit by doing multiple subtraction 
....................    // of 10 from the binary value. 
....................    if(value >= 10) 
037C:  MOVF   7D,W
037D:  SUBLW  09
037E:  BTFSC  03.0
037F:  GOTO   385
....................      { 
....................       value -= 10; 
0380:  MOVLW  0A
0381:  SUBWF  7D,F
....................       retval += 0x10; 
0382:  MOVLW  10
0383:  ADDWF  7E,F
....................      } 
....................    else // Get the ones digit by adding the remainder. 
0384:  GOTO   388
....................      { 
....................       retval += value; 
0385:  MOVF   7D,W
0386:  ADDWF  7E,F
....................       break; 
0387:  GOTO   389
....................      } 
....................    } 
0388:  GOTO   37C
....................  
.................... return(retval); 
0389:  MOVF   7E,W
038A:  MOVWF  78
.................... } 
038B:  RETLW  00
....................  
.................... //---------------------------------------------- 
.................... // This function converts an 8 bit BCD value to 
.................... // an 8 bit binary value. 
.................... // The input range must be from 00 to 99. 
....................  
.................... char bcd2bin(char bcd_value) 
.................... { 
.................... char temp; 
....................  
.................... temp = bcd_value; 
*
0C82:  MOVF   7C,W
0C83:  MOVWF  7D
....................  
.................... // Shifting the upper digit right by 1 is 
.................... // the same as multiplying it by 8. 
.................... temp >>= 1; 
0C84:  BCF    03.0
0C85:  RRF    7D,F
....................  
.................... // Isolate the bits for the upper digit. 
.................... temp &= 0x78; 
0C86:  MOVLW  78
0C87:  ANDWF  7D,F
....................  
.................... // Now return: (Tens * 8) + (Tens * 2) + Ones 
.................... return(temp + (temp >> 2) + (bcd_value & 0x0f)); 
0C88:  RRF    7D,W
0C89:  MOVWF  77
0C8A:  RRF    77,F
0C8B:  MOVLW  3F
0C8C:  ANDWF  77,F
0C8D:  MOVF   77,W
0C8E:  ADDWF  7D,W
0C8F:  MOVWF  7E
0C90:  MOVF   7C,W
0C91:  ANDLW  0F
0C92:  ADDWF  7E,W
0C93:  MOVWF  78
....................  
.................... } 
0C94:  RETLW  00
....................  
.................... //---------------------------------------------- 
.................... void PCF8583_set_datetime(date_time_t *dt) 
.................... { 
.................... int8 bcd_sec; 
.................... int8 bcd_min; 
.................... int8 bcd_hrs; 
.................... int8 bcd_day; 
.................... int8 bcd_mon; 
....................  
.................... // Convert the input date/time into BCD values 
.................... // that are formatted for the PCF8583 registers. 
.................... bcd_sec = bin2bcd(dt->seconds); 
*
06EA:  MOVF   70,W
06EB:  MOVWF  04
06EC:  BCF    03.7
06ED:  BTFSC  71.0
06EE:  BSF    03.7
06EF:  MOVF   00,W
06F0:  MOVWF  7C
06F1:  MOVWF  7D
06F2:  CALL   37B
06F3:  MOVF   78,W
06F4:  MOVWF  72
.................... bcd_min = bin2bcd(dt->minutes); 
06F5:  MOVLW  01
06F6:  ADDWF  70,W
06F7:  MOVWF  04
06F8:  BCF    03.7
06F9:  BTFSC  71.0
06FA:  BSF    03.7
06FB:  MOVF   00,W
06FC:  MOVWF  7C
06FD:  MOVWF  7D
06FE:  CALL   37B
06FF:  MOVF   78,W
0700:  MOVWF  73
.................... bcd_hrs = bin2bcd(dt->hours); 
0701:  MOVLW  02
0702:  ADDWF  70,W
0703:  MOVWF  04
0704:  BCF    03.7
0705:  BTFSC  71.0
0706:  BSF    03.7
0707:  MOVF   00,W
0708:  MOVWF  7C
0709:  MOVWF  7D
070A:  CALL   37B
070B:  MOVF   78,W
070C:  MOVWF  74
.................... bcd_day = bin2bcd(dt->day) | (dt->year << 6); 
070D:  MOVLW  03
070E:  ADDWF  70,W
070F:  MOVWF  04
0710:  BCF    03.7
0711:  BTFSC  71.0
0712:  BSF    03.7
0713:  MOVF   00,W
0714:  MOVWF  7C
0715:  MOVWF  7D
0716:  CALL   37B
0717:  MOVLW  05
0718:  ADDWF  70,W
0719:  MOVWF  04
071A:  BCF    03.7
071B:  BTFSC  71.0
071C:  BSF    03.7
071D:  SWAPF  00,W
071E:  MOVWF  77
071F:  RLF    77,F
0720:  RLF    77,F
0721:  MOVLW  C0
0722:  ANDWF  77,F
0723:  MOVF   77,W
0724:  IORWF  78,W
0725:  MOVWF  75
.................... bcd_mon = bin2bcd(dt->month) | (dt->weekday << 5); 
0726:  MOVLW  04
0727:  ADDWF  70,W
0728:  MOVWF  04
0729:  BCF    03.7
072A:  BTFSC  71.0
072B:  BSF    03.7
072C:  MOVF   00,W
072D:  MOVWF  7C
072E:  MOVWF  7D
072F:  CALL   37B
0730:  MOVLW  06
0731:  ADDWF  70,W
0732:  MOVWF  04
0733:  BCF    03.7
0734:  BTFSC  71.0
0735:  BSF    03.7
0736:  SWAPF  00,W
0737:  MOVWF  77
0738:  RLF    77,F
0739:  MOVLW  E0
073A:  ANDWF  77,F
073B:  MOVF   77,W
073C:  IORWF  78,W
073D:  MOVWF  76
....................  
.................... // Stop the RTC from counting, before we write to 
.................... // the date and time registers. 
.................... PCF8583_write_byte(PCF8583_CTRL_STATUS_REG, 
....................                               PCF8583_STOP_COUNTING); 
073E:  CLRF   7D
073F:  MOVLW  80
0740:  MOVWF  7E
0741:  CALL   39E
....................  
.................... // Write to the date and time registers.  Disable interrupts 
.................... // so they can't disrupt the i2c operations. 
.................... disable_interrupts(GLOBAL); 
0742:  BCF    0B.6
0743:  BCF    0B.7
0744:  BTFSC  0B.7
0745:  GOTO   743
.................... i2c_start(); 
0746:  BSF    03.5
0747:  BSF    11.0
0748:  BTFSC  11.0
0749:  GOTO   748
.................... i2c_write(PCF8583_WRITE_ADDRESS); 
074A:  MOVLW  A0
074B:  MOVWF  31
074C:  BCF    03.5
074D:  CALL   38C
.................... i2c_write(PCF8583_100S_REG);   // Start at 100's reg. 
074E:  MOVLW  01
074F:  BSF    03.5
0750:  MOVWF  31
0751:  BCF    03.5
0752:  CALL   38C
.................... i2c_write(0x00);               // Set 100's reg = 0 
0753:  BSF    03.5
0754:  CLRF   31
0755:  BCF    03.5
0756:  CALL   38C
.................... i2c_write(bcd_sec); 
0757:  MOVF   72,W
0758:  BSF    03.5
0759:  MOVWF  31
075A:  BCF    03.5
075B:  CALL   38C
.................... i2c_write(bcd_min); 
075C:  MOVF   73,W
075D:  BSF    03.5
075E:  MOVWF  31
075F:  BCF    03.5
0760:  CALL   38C
.................... i2c_write(bcd_hrs); 
0761:  MOVF   74,W
0762:  BSF    03.5
0763:  MOVWF  31
0764:  BCF    03.5
0765:  CALL   38C
.................... i2c_write(bcd_day); 
0766:  MOVF   75,W
0767:  BSF    03.5
0768:  MOVWF  31
0769:  BCF    03.5
076A:  CALL   38C
.................... i2c_write(bcd_mon); 
076B:  MOVF   76,W
076C:  BSF    03.5
076D:  MOVWF  31
076E:  BCF    03.5
076F:  CALL   38C
.................... i2c_stop(); 
0770:  BSF    03.5
0771:  BSF    11.2
0772:  BTFSC  11.2
0773:  GOTO   772
....................  
.................... // Write the year byte to the first NVRAM location. 
.................... // Leave it in binary format. 
.................... PCF8583_write_byte(PCF8583_YEAR_REG, dt->year); 
0774:  MOVLW  05
0775:  ADDWF  70,W
0776:  MOVWF  04
0777:  BCF    03.7
0778:  BTFSC  71.0
0779:  BSF    03.7
077A:  MOVF   00,W
077B:  MOVWF  7C
077C:  MOVLW  10
077D:  MOVWF  7D
077E:  MOVF   7C,W
077F:  MOVWF  7E
0780:  BCF    03.5
0781:  CALL   39E
....................  
.................... // Now allow the PCF8583 to start counting again. 
.................... PCF8583_write_byte(PCF8583_CTRL_STATUS_REG, 
....................                               PCF8583_START_COUNTING); 
0782:  CLRF   7D
0783:  CLRF   7E
0784:  CALL   39E
.................... } 
....................  
.................... //---------------------------------------------- 
.................... // Read the Date and Time from the hardware registers 
.................... // in the PCF8583.   We don't have to disable counting 
.................... // during read operations, because according to the data 
.................... // sheet, if any of the lower registers (1 to 7) is read, 
.................... // all of them are loaded into "capture" registers. 
.................... // All further reading within that cycle is done from 
.................... // those registers. 
....................  
.................... void PCF8583_read_datetime(date_time_t *dt) 
.................... { 
.................... int8 year_bits; 
.................... int8 year; 
....................  
.................... int8 bcd_sec; 
.................... int8 bcd_min; 
.................... int8 bcd_hrs; 
.................... int8 bcd_day; 
.................... int8 bcd_mon; 
....................  
.................... // Disable interrupts so the i2c process is not disrupted. 
.................... disable_interrupts(GLOBAL); 
*
0C95:  BCF    0B.6
0C96:  BCF    0B.7
0C97:  BTFSC  0B.7
0C98:  GOTO   496
....................  
.................... // Read the date/time registers inside the PCF8583. 
.................... i2c_start(); 
0C99:  BSF    03.5
0C9A:  BSF    11.0
0C9B:  BTFSC  11.0
0C9C:  GOTO   49B
.................... i2c_write(PCF8583_WRITE_ADDRESS); 
0C9D:  MOVLW  A0
0C9E:  MOVWF  31
0C9F:  BCF    0A.3
0CA0:  BCF    03.5
0CA1:  CALL   38C
0CA2:  BSF    0A.3
.................... i2c_write(PCF8583_SECONDS_REG);   // Start at seconds reg. 
0CA3:  MOVLW  02
0CA4:  BSF    03.5
0CA5:  MOVWF  31
0CA6:  BCF    0A.3
0CA7:  BCF    03.5
0CA8:  CALL   38C
0CA9:  BSF    0A.3
.................... i2c_start(); 
0CAA:  BSF    03.5
0CAB:  BSF    11.1
0CAC:  BTFSC  11.1
0CAD:  GOTO   4AC
.................... i2c_write(PCF8583_READ_ADDRESS); 
0CAE:  MOVLW  A1
0CAF:  MOVWF  31
0CB0:  BCF    0A.3
0CB1:  BCF    03.5
0CB2:  CALL   38C
0CB3:  BSF    0A.3
....................  
.................... bcd_sec = i2c_read(); 
0CB4:  MOVLW  01
0CB5:  MOVWF  77
0CB6:  BCF    0A.3
0CB7:  CALL   7EB
0CB8:  BSF    0A.3
0CB9:  MOVF   78,W
0CBA:  MOVWF  6F
.................... bcd_min = i2c_read(); 
0CBB:  MOVLW  01
0CBC:  MOVWF  77
0CBD:  BCF    0A.3
0CBE:  CALL   7EB
0CBF:  BSF    0A.3
0CC0:  MOVF   78,W
0CC1:  MOVWF  70
.................... bcd_hrs = i2c_read(); 
0CC2:  MOVLW  01
0CC3:  MOVWF  77
0CC4:  BCF    0A.3
0CC5:  CALL   7EB
0CC6:  BSF    0A.3
0CC7:  MOVF   78,W
0CC8:  MOVWF  71
.................... bcd_day = i2c_read(); 
0CC9:  MOVLW  01
0CCA:  MOVWF  77
0CCB:  BCF    0A.3
0CCC:  CALL   7EB
0CCD:  BSF    0A.3
0CCE:  MOVF   78,W
0CCF:  MOVWF  72
.................... bcd_mon = i2c_read(0); 
0CD0:  CLRF   77
0CD1:  BCF    0A.3
0CD2:  CALL   7EB
0CD3:  BSF    0A.3
0CD4:  MOVF   78,W
0CD5:  MOVWF  73
.................... i2c_stop(); 
0CD6:  BSF    03.5
0CD7:  BSF    11.2
0CD8:  BTFSC  11.2
0CD9:  GOTO   4D8
....................  
....................  
.................... // Convert the date/time values from BCD to 
.................... // unsigned 8-bit integers.  Unpack the bits 
.................... // in the PCF8583 registers where required. 
.................... dt->seconds = bcd2bin(bcd_sec); 
0CDA:  BCF    03.5
0CDB:  MOVF   6B,W
0CDC:  MOVWF  78
0CDD:  MOVF   6C,W
0CDE:  MOVWF  7A
0CDF:  MOVF   6B,W
0CE0:  MOVWF  74
0CE1:  MOVF   6C,W
0CE2:  MOVWF  75
0CE3:  MOVF   6F,W
0CE4:  MOVWF  7C
0CE5:  CALL   482
0CE6:  MOVF   74,W
0CE7:  MOVWF  04
0CE8:  BCF    03.7
0CE9:  BTFSC  75.0
0CEA:  BSF    03.7
0CEB:  MOVF   78,W
0CEC:  MOVWF  00
.................... dt->minutes = bcd2bin(bcd_min); 
0CED:  MOVLW  01
0CEE:  ADDWF  6B,W
0CEF:  MOVWF  78
0CF0:  MOVF   6C,W
0CF1:  MOVWF  7A
0CF2:  BTFSC  03.0
0CF3:  INCF   7A,F
0CF4:  MOVF   78,W
0CF5:  MOVWF  74
0CF6:  MOVF   7A,W
0CF7:  MOVWF  75
0CF8:  MOVF   70,W
0CF9:  MOVWF  7C
0CFA:  CALL   482
0CFB:  MOVF   74,W
0CFC:  MOVWF  04
0CFD:  BCF    03.7
0CFE:  BTFSC  75.0
0CFF:  BSF    03.7
0D00:  MOVF   78,W
0D01:  MOVWF  00
.................... dt->hours   = bcd2bin(bcd_hrs & 0x3F); 
0D02:  MOVLW  02
0D03:  ADDWF  6B,W
0D04:  MOVWF  78
0D05:  MOVF   6C,W
0D06:  MOVWF  7A
0D07:  BTFSC  03.0
0D08:  INCF   7A,F
0D09:  MOVF   78,W
0D0A:  MOVWF  74
0D0B:  MOVF   7A,W
0D0C:  MOVWF  75
0D0D:  MOVF   71,W
0D0E:  ANDLW  3F
0D0F:  MOVWF  76
0D10:  MOVWF  7C
0D11:  CALL   482
0D12:  MOVF   74,W
0D13:  MOVWF  04
0D14:  BCF    03.7
0D15:  BTFSC  75.0
0D16:  BSF    03.7
0D17:  MOVF   78,W
0D18:  MOVWF  00
.................... dt->day     = bcd2bin(bcd_day & 0x3F); 
0D19:  MOVLW  03
0D1A:  ADDWF  6B,W
0D1B:  MOVWF  78
0D1C:  MOVF   6C,W
0D1D:  MOVWF  7A
0D1E:  BTFSC  03.0
0D1F:  INCF   7A,F
0D20:  MOVF   78,W
0D21:  MOVWF  74
0D22:  MOVF   7A,W
0D23:  MOVWF  75
0D24:  MOVF   72,W
0D25:  ANDLW  3F
0D26:  MOVWF  76
0D27:  MOVWF  7C
0D28:  CALL   482
0D29:  MOVF   74,W
0D2A:  MOVWF  04
0D2B:  BCF    03.7
0D2C:  BTFSC  75.0
0D2D:  BSF    03.7
0D2E:  MOVF   78,W
0D2F:  MOVWF  00
.................... dt->month   = bcd2bin(bcd_mon & 0x1F); 
0D30:  MOVLW  04
0D31:  ADDWF  6B,W
0D32:  MOVWF  78
0D33:  MOVF   6C,W
0D34:  MOVWF  7A
0D35:  BTFSC  03.0
0D36:  INCF   7A,F
0D37:  MOVF   78,W
0D38:  MOVWF  74
0D39:  MOVF   7A,W
0D3A:  MOVWF  75
0D3B:  MOVF   73,W
0D3C:  ANDLW  1F
0D3D:  MOVWF  76
0D3E:  MOVWF  7C
0D3F:  CALL   482
0D40:  MOVF   74,W
0D41:  MOVWF  04
0D42:  BCF    03.7
0D43:  BTFSC  75.0
0D44:  BSF    03.7
0D45:  MOVF   78,W
0D46:  MOVWF  00
.................... dt->weekday = bcd_mon >> 5; 
0D47:  MOVLW  06
0D48:  ADDWF  6B,W
0D49:  MOVWF  04
0D4A:  BCF    03.7
0D4B:  BTFSC  6C.0
0D4C:  BSF    03.7
0D4D:  SWAPF  73,W
0D4E:  MOVWF  77
0D4F:  RRF    77,F
0D50:  MOVLW  07
0D51:  ANDWF  77,F
0D52:  MOVF   77,W
0D53:  MOVWF  00
.................... year_bits   = bcd_day >> 6; 
0D54:  SWAPF  72,W
0D55:  MOVWF  6D
0D56:  RRF    6D,F
0D57:  RRF    6D,F
0D58:  MOVLW  03
0D59:  ANDWF  6D,F
....................  
.................... // Read the year byte from NVRAM. 
.................... // This is an added feature of this driver. 
.................... year = PCF8583_read_byte(PCF8583_YEAR_REG); 
0D5A:  MOVLW  10
0D5B:  MOVWF  74
*
0D87:  MOVF   78,W
0D88:  BCF    03.5
0D89:  MOVWF  6E
....................  
.................... // Check if the two "year bits" were incremented by 
.................... // the PCF8583.  If so, increment the 8-bit year 
.................... // byte (read from NVRAM) by the same amount. 
.................... while(year_bits != (year & 3)) 
....................       year++; 
0D8A:  MOVF   6E,W
0D8B:  ANDLW  03
0D8C:  SUBWF  6D,W
0D8D:  BTFSC  03.2
0D8E:  GOTO   591
0D8F:  INCF   6E,F
0D90:  GOTO   58A
....................  
.................... dt->year = year; 
0D91:  MOVLW  05
0D92:  ADDWF  6B,W
0D93:  MOVWF  04
0D94:  BCF    03.7
0D95:  BTFSC  6C.0
0D96:  BSF    03.7
0D97:  MOVF   6E,W
0D98:  MOVWF  00
....................  
.................... // Now update the year byte in the NVRAM 
.................... // inside the PCF8583. 
.................... PCF8583_write_byte(PCF8583_YEAR_REG, year); 
0D99:  MOVLW  10
0D9A:  MOVWF  7D
0D9B:  MOVF   6E,W
0D9C:  MOVWF  7E
0D9D:  BCF    0A.3
0D9E:  CALL   39E
0D9F:  BSF    0A.3
....................  
.................... } 
0DA0:  RETLW  00
....................  
....................  
.................... #include "LCDeasy.c" 
.................... ////----------------------------------------------------------------------------//// 
.................... //    Funciones para la gestion del display LCD de la EasyPIC3 
.................... //   con el compilador de CCS. 
.................... //   Es una adaptación del archivo LCD.c de CCS para las prácticas de la 
.................... //   asignatura, y por tanto no distribuible a usuarios no autorizados. 
.................... //------------------------------------------------------------------------------//// 
....................  
.................... //  lcd_init()   Inicializa el LCD: debe ser llamada antes que las otras funciones. 
.................... // 
.................... //  lcd_putc(c)  Visualiza c en la siguiente posición del display. 
.................... //               Caracteres especiales de control: 
.................... //                      \f  Borrar display 
.................... //                      \n  Saltar a la segunda linea 
.................... //                      \b  Retroceder una posición. 
.................... // 
.................... //  lcd_gotoxy(x,y) Selecciona la nueva posicion de escritura en el display. 
.................... //                  (la esquina superior izquierda es 1,1) 
.................... // 
.................... //  lcd_getc(x,y)   Devuelve el caracter de la posicion x,y del display. 
.................... //         (esta función no va en la EASYPIC3, pues R/W=0) 
.................... // 
.................... //  lcd_send_byte(rs,byte)   escribe byte en el registro de datos(con rs=1) o de 
.................... //            instrucciones (con rs=0). 
.................... //------------------------------------------------------------------------------// 
.................... // Conexion del LCD con el PIC: 
.................... //     RB0 -- 
.................... //     RB1 -- 
.................... //     RB2  rs 
.................... //     RB3  Enable 
.................... //     RB4  D4 
.................... //     RB5  D5 
.................... //     RB6  D6 
.................... //     RB7  D7 
.................... // 
.................... // Los pines D0-D3 del LCD no se usan 
.................... // El pin RB0 del PIC no se usa 
.................... // El pin RB1 no está conectado en la tarjeta, 
.................... // podría ser para r/w 
....................  
.................... // Un-comment the following define to use port B 
.................... #define use_portb_lcd TRUE       //LINEA DES-COMENTADA---------------- 
....................  
....................  
.................... struct lcd_pin_map {                 // This structure is overlayed 
....................            int unused : 2 ;   //MODIFICADA PARA EASYPIC-------------------- 
....................       //BOOLEAN rw;      //MODIFICADA PARA EASYPIC-------------------- 
....................       BOOLEAN rs;           // on to an I/O port to gain 
....................            BOOLEAN ENABLE;            // access to the LCD pins. 
....................                                // The bits are allocated from 
....................                               // low order up.  ENABLE will 
....................            int     data : 4;            // be pin B3------------------------- 
....................         } lcd; 
....................  
....................  
.................... #if defined(__PCH__) 
.................... #if defined use_portb_lcd 
....................    #byte lcd = 0xF81                   // This puts the entire structure 
.................... #else 
....................    #byte lcd = 0xF83                   // This puts the entire structure 
.................... #endif 
.................... #else 
.................... #if defined use_portb_lcd 
....................    #byte lcd = 6                  // on to port B (at address 6) 
.................... #else 
....................    #byte lcd = 8                 // on to port D (at address 8) 
.................... #endif 
.................... #endif 
....................  
.................... #if defined use_portb_lcd 
....................    #define set_tris_lcd(x) set_tris_b(x) 
.................... #else 
....................    #define set_tris_lcd(x) set_tris_d(x) 
.................... #endif 
....................  
....................  
.................... #define lcd_type 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #define lcd_line_two 0x40    // LCD RAM address for the second line 
....................  
....................  
.................... BYTE const LCD_INIT_STRING[4] = {0x24 | (lcd_type << 2), 0xF, 1, 6}; 
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................  
....................  
....................                              // The following are used for setting 
....................                              // the I/O port direction register. 
....................  
.................... struct lcd_pin_map const LCD_WRITE = {3,0,0,0}; // For write mode all pins are out 
.................... struct lcd_pin_map const LCD_READ = {3,0,0,15}; // For read mode data pins are in 
....................  
....................  
....................  
.................... BYTE lcd_read_byte() { 
....................       BYTE low,high; 
....................       set_tris_lcd(LCD_READ); 
....................       //////lcd.rw = 1; 
....................       delay_cycles(1); 
....................       lcd.enable = 1; 
....................       delay_cycles(1); 
....................       high = lcd.data; 
....................       lcd.enable = 0; 
....................       delay_cycles(1); 
....................       lcd.enable = 1; 
....................       delay_us(1); 
....................       low = lcd.data; 
....................       lcd.enable = 0; 
....................       set_tris_lcd(LCD_WRITE); 
....................       return( (high<<4) | low); 
.................... } 
....................  
....................  
.................... void lcd_send_nibble( BYTE n ) { 
....................       lcd.data = n; 
*
01BB:  BSF    03.5
01BC:  SWAPF  24,W
01BD:  ANDLW  F0
01BE:  MOVWF  77
01BF:  MOVLW  0F
01C0:  BCF    03.5
01C1:  ANDWF  06,W
01C2:  IORWF  77,W
01C3:  MOVWF  06
....................       delay_cycles(1); 
01C4:  NOP
....................       lcd.enable = 1; 
01C5:  BSF    06.3
....................       delay_us(2); 
01C6:  CLRWDT
01C7:  GOTO   1C8
01C8:  NOP
....................       lcd.enable = 0; 
01C9:  BCF    06.3
.................... } 
01CA:  RETLW  00
....................  
....................  
.................... void lcd_send_byte( BYTE address, BYTE n ) { 
....................  
....................       lcd.rs = 0; 
*
01DE:  BCF    06.2
....................       delay_us(3000); 
01DF:  CLRWDT
01E0:  MOVLW  02
01E1:  BSF    03.5
01E2:  MOVWF  2C
01E3:  BCF    03.5
01E4:  CALL   1A3
01E5:  MOVLW  09
01E6:  BSF    03.5
01E7:  MOVWF  23
01E8:  MOVLW  6D
01E9:  MOVWF  2D
01EA:  BCF    03.5
01EB:  CALL   1CB
01EC:  BSF    03.5
01ED:  DECFSZ 23,F
01EE:  GOTO   1E8
.................... //      while ( bit_test(lcd_read_byte(),7) ) ; 
....................       lcd.rs = address; 
01EF:  BTFSC  21.0
01F0:  GOTO   1F4
01F1:  BCF    03.5
01F2:  BCF    06.2
01F3:  BSF    03.5
01F4:  BTFSS  21.0
01F5:  GOTO   1F9
01F6:  BCF    03.5
01F7:  BSF    06.2
01F8:  BSF    03.5
....................       delay_cycles(1); 
01F9:  NOP
....................       //////////lcd.rw = 0; 
....................       delay_cycles(1); 
01FA:  NOP
....................       lcd.enable = 0; 
01FB:  BCF    03.5
01FC:  BCF    06.3
....................       lcd_send_nibble(n >> 4); 
01FD:  BSF    03.5
01FE:  SWAPF  22,W
01FF:  MOVWF  23
0200:  MOVLW  0F
0201:  ANDWF  23,F
0202:  MOVF   23,W
0203:  MOVWF  24
0204:  BCF    03.5
0205:  CALL   1BB
....................       lcd_send_nibble(n & 0xf); 
0206:  BSF    03.5
0207:  MOVF   22,W
0208:  ANDLW  0F
0209:  MOVWF  23
020A:  MOVWF  24
020B:  BCF    03.5
020C:  CALL   1BB
.................... } 
020D:  RETLW  00
....................  
....................  
.................... void lcd_init() { 
....................     BYTE i; 
....................     set_tris_lcd(LCD_WRITE); 
020E:  MOVLW  03
020F:  BSF    03.5
0210:  MOVWF  06
....................     lcd.rs = 0; 
0211:  BCF    03.5
0212:  BCF    06.2
....................     /////lcd.rw = 0; 
....................     lcd.enable = 0; 
0213:  BCF    06.3
....................     delay_ms(50); 
0214:  MOVLW  32
0215:  BSF    03.5
0216:  MOVWF  2C
0217:  BCF    03.5
0218:  CALL   1A3
....................     //for(i=1;i<=3;++i) { 
....................     //   lcd_send_nibble(3); 
....................     //  delay_ms(5); 
....................     //} 
....................     lcd_send_nibble(2); 
0219:  MOVLW  02
021A:  BSF    03.5
021B:  MOVWF  24
021C:  BCF    03.5
021D:  CALL   1BB
....................     delay_ms(5); 
021E:  MOVLW  05
021F:  BSF    03.5
0220:  MOVWF  2C
0221:  BCF    03.5
0222:  CALL   1A3
....................     for(i=0;i<=3;++i) 
0223:  CLRF   68
0224:  MOVF   68,W
0225:  SUBLW  03
0226:  BTFSS  03.0
0227:  GOTO   23A
....................        { lcd_send_byte(0,LCD_INIT_STRING[i]); 
0228:  MOVF   68,W
0229:  CALL   033
022A:  MOVWF  69
022B:  BSF    03.5
022C:  CLRF   21
022D:  BCF    03.5
022E:  MOVF   69,W
022F:  BSF    03.5
0230:  MOVWF  22
0231:  BCF    03.5
0232:  CALL   1DE
....................         delay_ms(5); } 
0233:  MOVLW  05
0234:  BSF    03.5
0235:  MOVWF  2C
0236:  BCF    03.5
0237:  CALL   1A3
0238:  INCF   68,F
0239:  GOTO   224
.................... } 
023A:  BSF    0A.3
023B:  BSF    0A.4
023C:  GOTO   2AE (RETURN)
....................  
....................  
.................... void lcd_gotoxy( BYTE x, BYTE y) { 
....................    BYTE address; 
....................  
....................    if(y!=1) 
*
0F60:  DECFSZ 7D,W
0F61:  GOTO   763
0F62:  GOTO   766
....................      address=lcd_line_two; 
0F63:  MOVLW  40
0F64:  MOVWF  7E
....................    else 
0F65:  GOTO   767
....................      address=0; 
0F66:  CLRF   7E
....................    address+=x-1; 
0F67:  MOVLW  01
0F68:  SUBWF  7C,W
0F69:  ADDWF  7E,F
....................    lcd_send_byte(0,0x80|address); 
0F6A:  MOVF   7E,W
0F6B:  IORLW  80
0F6C:  BSF    03.5
0F6D:  MOVWF  20
0F6E:  CLRF   21
0F6F:  MOVF   20,W
0F70:  MOVWF  22
0F71:  BCF    0A.3
0F72:  BCF    03.5
0F73:  CALL   1DE
0F74:  BSF    0A.3
.................... } 
0F75:  RETLW  00
....................  
.................... void lcd_putc( char c) { 
....................    switch (c) { 
0F76:  MOVF   76,W
0F77:  XORLW  0C
0F78:  BTFSC  03.2
0F79:  GOTO   781
0F7A:  XORLW  06
0F7B:  BTFSC  03.2
0F7C:  GOTO   791
0F7D:  XORLW  02
0F7E:  BTFSC  03.2
0F7F:  GOTO   797
0F80:  GOTO   7A0
....................      case '\f'   : lcd_send_byte(0,1); 
0F81:  BSF    03.5
0F82:  CLRF   21
0F83:  MOVLW  01
0F84:  MOVWF  22
0F85:  BCF    0A.3
0F86:  BCF    03.5
0F87:  CALL   1DE
0F88:  BSF    0A.3
....................                    delay_ms(2); 
0F89:  MOVLW  02
0F8A:  BSF    03.5
0F8B:  MOVWF  2C
0F8C:  BCF    0A.3
0F8D:  BCF    03.5
0F8E:  CALL   1A3
0F8F:  BSF    0A.3
....................                                            break; 
0F90:  GOTO   7AA
....................      case '\n'   : lcd_gotoxy(1,2);        break; 
0F91:  MOVLW  01
0F92:  MOVWF  7C
0F93:  MOVLW  02
0F94:  MOVWF  7D
0F95:  CALL   760
0F96:  GOTO   7AA
....................      case '\b'   : lcd_send_byte(0,0x10);  break; 
0F97:  BSF    03.5
0F98:  CLRF   21
0F99:  MOVLW  10
0F9A:  MOVWF  22
0F9B:  BCF    0A.3
0F9C:  BCF    03.5
0F9D:  CALL   1DE
0F9E:  BSF    0A.3
0F9F:  GOTO   7AA
....................      default     : lcd_send_byte(1,c);     break; 
0FA0:  MOVLW  01
0FA1:  BSF    03.5
0FA2:  MOVWF  21
0FA3:  MOVF   76,W
0FA4:  MOVWF  22
0FA5:  BCF    0A.3
0FA6:  BCF    03.5
0FA7:  CALL   1DE
0FA8:  BSF    0A.3
0FA9:  GOTO   7AA
....................    } 
.................... } 
0FAA:  RETLW  00
....................  
.................... #include "1wire.c" 
.................... /***********************1Wire Class***********************/ 
.................... /*Funciones básicas para comunicación con un solo sensor 1wire */ 
.................... /*********************************************************/ 
.................... /*-------1-wire definitions-------*/ 
....................  
.................... #define ONE_WIRE_PIN PIN_A5 //modificar de acuerdo con la tarjeta 
....................  
....................  
.................... /************onewire_reset*************************************************/ 
.................... void onewire_reset()  // OK if just using a single permanently connected device 
.................... { 
....................  output_low(ONE_WIRE_PIN); 
*
03F7:  BSF    03.5
03F8:  BCF    05.5
03F9:  BCF    03.5
03FA:  BCF    05.5
....................  delay_us( 500 ); // pull 1-wire low for reset pulse 
03FB:  CLRWDT
03FC:  MOVLW  02
03FD:  BSF    03.5
03FE:  MOVWF  2C
03FF:  MOVLW  F7
0400:  MOVWF  2D
0401:  BCF    03.5
0402:  CALL   1CB
0403:  BSF    03.5
0404:  DECFSZ 2C,F
0405:  GOTO   3FF
....................  output_float(ONE_WIRE_PIN); // float 1-wire high 
0406:  BSF    05.5
....................  delay_us( 500 ); // wait-out remaining initialisation window. 
0407:  CLRWDT
0408:  MOVLW  02
0409:  MOVWF  2C
040A:  MOVLW  F7
040B:  MOVWF  2D
040C:  BCF    03.5
040D:  CALL   1CB
040E:  BSF    03.5
040F:  DECFSZ 2C,F
0410:  GOTO   40A
....................  output_float(ONE_WIRE_PIN); 
0411:  BSF    05.5
.................... } 
0412:  BCF    03.5
0413:  RETLW  00
....................  
.................... /*********************** onewire_write() ********************************/ 
.................... /*Esta función escribe un byte en el sensor.*/ 
.................... /* */ 
.................... /*Parametros: byte - el byte a escribir en el 1wire */ 
....................  
.................... void onewire_write(int data) 
.................... { 
....................  int count; 
....................  
....................  for (count=0; count<8; ++count) 
0414:  BSF    03.5
0415:  CLRF   2E
0416:  MOVF   2E,W
0417:  SUBLW  07
0418:  BTFSS  03.0
0419:  GOTO   439
....................  { 
....................   output_low(ONE_WIRE_PIN); 
041A:  BCF    05.5
041B:  BCF    03.5
041C:  BCF    05.5
....................   delay_us( 2 ); // pull 1-wire low to initiate write time-slot. 
041D:  CLRWDT
041E:  GOTO   41F
041F:  NOP
....................   output_bit(ONE_WIRE_PIN, shift_right(&data,1,0)); // set output bit on 1-wire 
0420:  BCF    03.0
0421:  BSF    03.5
0422:  RRF    2D,F
0423:  BTFSC  03.0
0424:  GOTO   429
0425:  BCF    03.5
0426:  BCF    05.5
0427:  GOTO   42B
0428:  BSF    03.5
0429:  BCF    03.5
042A:  BSF    05.5
042B:  BSF    03.5
042C:  BCF    05.5
....................   delay_us( 60 ); // wait until end of write slot. 
042D:  CLRWDT
042E:  MOVLW  27
042F:  MOVWF  77
0430:  DECFSZ 77,F
0431:  GOTO   430
0432:  NOP
....................   output_float(ONE_WIRE_PIN); // set 1-wire high again, 
0433:  BSF    05.5
....................   delay_us( 2 ); // for more than 1us minimum. 
0434:  CLRWDT
0435:  GOTO   436
0436:  NOP
....................  } 
0437:  INCF   2E,F
0438:  GOTO   416
.................... } 
0439:  BCF    03.5
043A:  RETLW  00
....................  
.................... /*********************** read1wire() *********************************/ 
.................... /*Esta función lee un dato de 8 bits del sensor.*/ 
.................... /*Devuelve: dato de 8-bit (1-byte)*/ 
....................  
.................... int onewire_read() 
.................... { 
....................  int count, data; 
....................  
....................  for (count=0; count<8; ++count) 
*
07C4:  CLRF   71
07C5:  MOVF   71,W
07C6:  SUBLW  07
07C7:  BTFSS  03.0
07C8:  GOTO   7E8
....................  { 
....................   output_low(ONE_WIRE_PIN); 
07C9:  BSF    03.5
07CA:  BCF    05.5
07CB:  BCF    03.5
07CC:  BCF    05.5
....................   delay_us( 2 ); // pull 1-wire low to initiate read time-slot. 
07CD:  CLRWDT
07CE:  GOTO   7CF
07CF:  NOP
....................   output_float(ONE_WIRE_PIN); // now let 1-wire float high, 
07D0:  BSF    03.5
07D1:  BSF    05.5
....................   delay_us( 8 ); // let device state stabilise, 
07D2:  CLRWDT
07D3:  MOVLW  04
07D4:  MOVWF  77
07D5:  DECFSZ 77,F
07D6:  GOTO   7D5
07D7:  GOTO   7D8
....................   shift_right(&data,1,input(ONE_WIRE_PIN)); // and load result. 
07D8:  BSF    05.5
07D9:  BCF    03.5
07DA:  BTFSC  05.5
07DB:  GOTO   7DE
07DC:  BCF    03.0
07DD:  GOTO   7DF
07DE:  BSF    03.0
07DF:  RRF    72,F
....................   delay_us( 120 ); // wait until end of read slot. 
07E0:  CLRWDT
07E1:  MOVLW  4F
07E2:  MOVWF  77
07E3:  DECFSZ 77,F
07E4:  GOTO   7E3
07E5:  NOP
....................  } 
07E6:  INCF   71,F
07E7:  GOTO   7C5
....................  
....................  return( data ); 
07E8:  MOVF   72,W
07E9:  MOVWF  78
.................... } 
07EA:  RETLW  00
....................  
.................... /////////////////////////////////////////////////////////////////// 
....................  
....................  
....................  
.................... #include "ds1820.c" 
....................  
.................... /***************************************************/ 
.................... /*Driver básico del termómetro/termostato ds1820.c */ 
.................... // 
.................... //Realiza una secuencia completa de incialización, conversión 
.................... //de temperatura, y lectura del (único) sensor de temperatura 
.................... //con alimentación externa (no parásita). 
.................... // 
.................... /***************************************************/ 
....................  
.................... float ds1820_read() 
.................... { 
....................  int8 busy=0, temp1, temp2; 
*
08F3:  CLRF   68
....................  signed int16 temp3; 
....................  float result; 
....................  
....................  onewire_reset();     // Cada acceso al sensor debe iniciarse con reset 
08F4:  BCF    0A.3
08F5:  CALL   3F7
08F6:  BSF    0A.3
....................  onewire_write(0xCC); //Instrucción SKIP ROM (selecciona todos los dispositivos del 1wire) 
08F7:  MOVLW  CC
08F8:  BSF    03.5
08F9:  MOVWF  2D
08FA:  BCF    0A.3
08FB:  BCF    03.5
08FC:  CALL   414
08FD:  BSF    0A.3
....................  onewire_write(0x44); //Orden de inicio de conversión de temperatura 
08FE:  MOVLW  44
08FF:  BSF    03.5
0900:  MOVWF  2D
0901:  BCF    0A.3
0902:  BCF    03.5
0903:  CALL   414
0904:  BSF    0A.3
....................  
....................  while (busy == 0)    //el sensor mantiene la linea a 0 mientras realiza la conversión 
....................   busy = onewire_read(); //y la deja a 1 al completarla 
0905:  MOVF   68,F
0906:  BTFSS  03.2
0907:  GOTO   10E
0908:  BCF    0A.3
0909:  CALL   7C4
090A:  BSF    0A.3
090B:  MOVF   78,W
090C:  MOVWF  68
090D:  GOTO   105
....................  
....................  onewire_reset(); 
090E:  BCF    0A.3
090F:  CALL   3F7
0910:  BSF    0A.3
....................  onewire_write(0xCC); 
0911:  MOVLW  CC
0912:  BSF    03.5
0913:  MOVWF  2D
0914:  BCF    0A.3
0915:  BCF    03.5
0916:  CALL   414
0917:  BSF    0A.3
....................  onewire_write(0xBE); //Envío de la orden READ SCRATCHPAD (lectura de la memoria temporal) 
0918:  MOVLW  BE
0919:  BSF    03.5
091A:  MOVWF  2D
091B:  BCF    0A.3
091C:  BCF    03.5
091D:  CALL   414
091E:  BSF    0A.3
....................  temp1 = onewire_read(); //lectura del LSB de la temperatura 
091F:  BCF    0A.3
0920:  CALL   7C4
0921:  BSF    0A.3
0922:  MOVF   78,W
0923:  MOVWF  69
....................  temp2 = onewire_read(); //lectura del MSB de la temperatura 
0924:  BCF    0A.3
0925:  CALL   7C4
0926:  BSF    0A.3
0927:  MOVF   78,W
0928:  MOVWF  6A
....................  
....................  temp3 = make16(temp2, temp1); // 
0929:  MOVF   6A,W
092A:  MOVWF  6C
092B:  MOVF   69,W
092C:  MOVWF  6B
....................  result = (float) temp3 / 2.0;   //Calculation for DS18S20 with 0.5 deg C resolution 
092D:  MOVF   6C,W
092E:  MOVWF  72
092F:  MOVF   6B,W
0930:  MOVWF  71
0931:  GOTO   000
0932:  MOVF   77,W
0933:  MOVWF  71
0934:  MOVF   78,W
0935:  MOVWF  72
0936:  MOVF   79,W
0937:  MOVWF  73
0938:  MOVF   7A,W
0939:  MOVWF  74
093A:  BSF    03.5
093B:  MOVWF  2A
093C:  MOVF   79,W
093D:  MOVWF  29
093E:  MOVF   78,W
093F:  MOVWF  28
0940:  MOVF   77,W
0941:  MOVWF  27
0942:  CLRF   2E
0943:  CLRF   2D
0944:  CLRF   2C
0945:  MOVLW  80
0946:  MOVWF  2B
0947:  BCF    03.5
0948:  CALL   027
0949:  MOVF   7A,W
094A:  MOVWF  70
094B:  MOVF   79,W
094C:  MOVWF  6F
094D:  MOVF   78,W
094E:  MOVWF  6E
094F:  MOVF   77,W
0950:  MOVWF  6D
.................... // result = (float) temp3 / 16.0;  //Calculation for DS18B20 with 0.1 deg C resolution 
....................  
....................  delay_ms(200); 
0951:  MOVLW  C8
0952:  BSF    03.5
0953:  MOVWF  2C
0954:  BCF    0A.3
0955:  BCF    03.5
0956:  CALL   1A3
0957:  BSF    0A.3
....................  return(result); 
0958:  MOVF   6D,W
0959:  MOVWF  77
095A:  MOVF   6E,W
095B:  MOVWF  78
095C:  MOVF   6F,W
095D:  MOVWF  79
095E:  MOVF   70,W
095F:  MOVWF  7A
.................... } 
0960:  RETLW  00
....................  
.................... //Establece la temperatura máxima y mínima para el termostato 
.................... void ds1820_establecer_TH_TL(float th, float tl){ 
....................    float th2, tl2; 
....................    onewire_reset(); 
*
04D3:  CALL   3F7
....................    onewire_write(0xCC); //Accedemos a todos los dispositivos 
04D4:  MOVLW  CC
04D5:  BSF    03.5
04D6:  MOVWF  2D
04D7:  BCF    03.5
04D8:  CALL   414
....................    onewire_write(0x4E); //Envío de la orden Write Scratchpad (escritura en la memoria principal) 
04D9:  MOVLW  4E
04DA:  BSF    03.5
04DB:  MOVWF  2D
04DC:  BCF    03.5
04DD:  CALL   414
....................    th2=2*th; 
04DE:  BSF    03.5
04DF:  CLRF   38
04E0:  CLRF   37
04E1:  CLRF   36
04E2:  MOVLW  80
04E3:  MOVWF  35
04E4:  MOVF   73,W
04E5:  MOVWF  3C
04E6:  MOVF   72,W
04E7:  MOVWF  3B
04E8:  MOVF   71,W
04E9:  MOVWF  3A
04EA:  MOVF   70,W
04EB:  MOVWF  39
04EC:  BCF    03.5
04ED:  CALL   43B
04EE:  MOVF   7A,W
04EF:  BSF    03.5
04F0:  MOVWF  27
04F1:  MOVF   79,W
04F2:  MOVWF  26
04F3:  MOVF   78,W
04F4:  MOVWF  25
04F5:  MOVF   77,W
04F6:  MOVWF  24
....................    tl2=2*tl; 
04F7:  CLRF   38
04F8:  CLRF   37
04F9:  CLRF   36
04FA:  MOVLW  80
04FB:  MOVWF  35
04FC:  MOVF   23,W
04FD:  MOVWF  3C
04FE:  MOVF   22,W
04FF:  MOVWF  3B
0500:  MOVF   21,W
0501:  MOVWF  3A
0502:  MOVF   20,W
0503:  MOVWF  39
0504:  BCF    03.5
0505:  CALL   43B
0506:  MOVF   7A,W
0507:  BSF    03.5
0508:  MOVWF  2B
0509:  MOVF   79,W
050A:  MOVWF  2A
050B:  MOVF   78,W
050C:  MOVWF  29
050D:  MOVF   77,W
050E:  MOVWF  28
....................    onewire_write((int8)th2); 
050F:  MOVF   27,W
0510:  MOVWF  2F
0511:  MOVF   26,W
0512:  MOVWF  2E
0513:  MOVF   25,W
0514:  MOVWF  2D
0515:  MOVF   24,W
0516:  MOVWF  2C
0517:  BCF    03.5
0518:  CALL   4B2
0519:  MOVF   78,W
051A:  MOVWF  74
051B:  BSF    03.5
051C:  MOVWF  2D
051D:  BCF    03.5
051E:  CALL   414
....................    onewire_write((int8)tl2); 
051F:  BSF    03.5
0520:  MOVF   2B,W
0521:  MOVWF  2F
0522:  MOVF   2A,W
0523:  MOVWF  2E
0524:  MOVF   29,W
0525:  MOVWF  2D
0526:  MOVF   28,W
0527:  MOVWF  2C
0528:  BCF    03.5
0529:  CALL   4B2
052A:  MOVF   78,W
052B:  MOVWF  74
052C:  BSF    03.5
052D:  MOVWF  2D
052E:  BCF    03.5
052F:  CALL   414
....................  
....................    //Copiamos los valores en la ROM 
....................    onewire_reset(); 
0530:  CALL   3F7
....................    onewire_write(0xCC); 
0531:  MOVLW  CC
0532:  BSF    03.5
0533:  MOVWF  2D
0534:  BCF    03.5
0535:  CALL   414
....................    onewire_write(0x48); 
0536:  MOVLW  48
0537:  BSF    03.5
0538:  MOVWF  2D
0539:  BCF    03.5
053A:  CALL   414
....................  
....................    //Dejamos un poco de tiempo para que se escriba en la EEPROM 
....................    //El tiempo ha sido calculado a partir de la simulación en Proteus 
....................    delay_us(10600); 
053B:  CLRWDT
053C:  MOVLW  0A
053D:  BSF    03.5
053E:  MOVWF  2C
053F:  BCF    03.5
0540:  CALL   1A3
0541:  MOVLW  0D
0542:  MOVWF  74
0543:  MOVLW  2C
0544:  BSF    03.5
0545:  MOVWF  2D
0546:  BCF    03.5
0547:  CALL   1CB
0548:  DECFSZ 74,F
0549:  GOTO   543
....................  
.................... } 
054A:  RETLW  00
....................  
.................... //Intenta buscar la alarma del único sensor conectado por si ha saltado 
.................... //el termostato. Si lo ha hecho, devuelve TRUE, y en caso contrario, FALSE. 
.................... int1 ds1820_termostato(){ 
....................    int busy=0; 
*
0961:  CLRF   68
....................    int1 bit1, bit2; 
....................  
....................    //Primero forzamos la conversión de la temperatura 
....................    onewire_reset(); 
0962:  BCF    0A.3
0963:  CALL   3F7
0964:  BSF    0A.3
....................    onewire_write(0xCC); 
0965:  MOVLW  CC
0966:  BSF    03.5
0967:  MOVWF  2D
0968:  BCF    0A.3
0969:  BCF    03.5
096A:  CALL   414
096B:  BSF    0A.3
....................    onewire_write(0x44); 
096C:  MOVLW  44
096D:  BSF    03.5
096E:  MOVWF  2D
096F:  BCF    0A.3
0970:  BCF    03.5
0971:  CALL   414
0972:  BSF    0A.3
....................  
....................    while(busy == 0) 
....................       busy = onewire_read(); 
0973:  MOVF   68,F
0974:  BTFSS  03.2
0975:  GOTO   17C
0976:  BCF    0A.3
0977:  CALL   7C4
0978:  BSF    0A.3
0979:  MOVF   78,W
097A:  MOVWF  68
097B:  GOTO   173
....................  
....................    onewire_reset(); 
097C:  BCF    0A.3
097D:  CALL   3F7
097E:  BSF    0A.3
....................    onewire_write(0xEC); //Buscamos la alarma de algún dispositivo (función ALARM SEARCH) 
097F:  MOVLW  EC
0980:  BSF    03.5
0981:  MOVWF  2D
0982:  BCF    0A.3
0983:  BCF    03.5
0984:  CALL   414
0985:  BSF    0A.3
....................  
....................    //Leemos dos bits consecutivos. Si el dispositivo tiene el flag de alarma activado, escribirá 
....................    //en la línea el bit más bajo de su dirección ROM y, después, su complemento. Si no, no hará 
....................    //nada. Por eso, si ambos bits leídos son diferentes, la alarma estará activada, mientras que 
....................    //si son iguales, no lo estarán. No es necesario continuar leyendo toda la dirección del dispositivo. 
....................    output_low(ONE_WIRE_PIN); 
0986:  BSF    03.5
0987:  BCF    05.5
0988:  BCF    03.5
0989:  BCF    05.5
....................    delay_us( 2 ); 
098A:  CLRWDT
098B:  GOTO   18C
098C:  NOP
....................    output_float(ONE_WIRE_PIN); 
098D:  BSF    03.5
098E:  BSF    05.5
....................    delay_us( 8 ); 
098F:  CLRWDT
0990:  MOVLW  04
0991:  MOVWF  77
0992:  DECFSZ 77,F
0993:  GOTO   192
0994:  GOTO   195
....................    bit1 = input(ONE_WIRE_PIN); //Leemos el bit menos significativo de la dirección ROM 
0995:  BSF    05.5
0996:  BCF    03.5
0997:  BCF    69.0
0998:  BTFSC  05.5
0999:  BSF    69.0
....................    delay_us( 120 ); 
099A:  CLRWDT
099B:  MOVLW  4F
099C:  MOVWF  77
099D:  DECFSZ 77,F
099E:  GOTO   19D
099F:  NOP
....................  
....................    output_low(ONE_WIRE_PIN); 
09A0:  BSF    03.5
09A1:  BCF    05.5
09A2:  BCF    03.5
09A3:  BCF    05.5
....................    delay_us( 2 ); 
09A4:  CLRWDT
09A5:  GOTO   1A6
09A6:  NOP
....................    output_float(ONE_WIRE_PIN); 
09A7:  BSF    03.5
09A8:  BSF    05.5
....................    delay_us( 8 ); 
09A9:  CLRWDT
09AA:  MOVLW  04
09AB:  MOVWF  77
09AC:  DECFSZ 77,F
09AD:  GOTO   1AC
09AE:  GOTO   1AF
....................    bit2 = input(ONE_WIRE_PIN); //Leemos su complemento (si la alarma está activada) 
09AF:  BSF    05.5
09B0:  BCF    03.5
09B1:  BCF    69.1
09B2:  BTFSC  05.5
09B3:  BSF    69.1
....................    delay_us( 120 ); 
09B4:  CLRWDT
09B5:  MOVLW  4F
09B6:  MOVWF  77
09B7:  DECFSZ 77,F
09B8:  GOTO   1B7
09B9:  NOP
....................  
....................    if(bit1 != bit2) 
09BA:  CLRF   77
09BB:  BTFSC  69.1
09BC:  BSF    77.0
09BD:  MOVF   69,W
09BE:  XORWF  77,W
09BF:  ANDLW  01
09C0:  BTFSC  03.2
09C1:  GOTO   1C6
....................       return TRUE; 
09C2:  MOVLW  01
09C3:  MOVWF  78
09C4:  GOTO   1C9
....................    else 
09C5:  GOTO   1C9
....................       return FALSE; 
09C6:  MOVLW  00
09C7:  MOVWF  78
09C8:  GOTO   1C9
.................... } 
09C9:  RETLW  00
....................  
....................  
.................... #include "eeprom.c" 
.................... //****************************************************** 
.................... //Programa para escritura y lectura de la memoria EEPROM 
.................... //****************************************************** 
.................... //Author: Julio Navarro Lara 
....................  
....................  
.................... //Definimos las palabras de control, que constan de tres partes 
.................... //   - Los bits más altos de direccionamiento del dispositivo (fijos): 1010 
.................... //   - Los bits de dirección configurables A2A1A0: 111 (en este caso) 
.................... //   - El bit R/W', 1 para lectura y 0 para escritura 
.................... //NOTA: No es necesario definir las características de la comunicación I2C porque se supone 
.................... //que ya han sido especificadas en el código principal. 
.................... #define CONTROL_W 0b10101110 
.................... #define CONTROL_R 0b10101111 
....................  
.................... void graba_ee(long int dir, int tam, int *wdata) 
.................... { 
....................    boolean ack; 
....................    int i; 
....................    //Escribimos la palabra de control 
....................    do{ 
....................       i2c_start(); 
*
03BA:  BSF    03.5
03BB:  BSF    11.0
03BC:  BTFSC  11.0
03BD:  GOTO   3BC
....................       ack=i2c_write(CONTROL_W); 
03BE:  MOVLW  AE
03BF:  MOVWF  31
03C0:  BCF    03.5
03C1:  CALL   38C
03C2:  MOVF   78,W
03C3:  BTFSC  78.0
03C4:  GOTO   3C7
03C5:  BCF    75.0
03C6:  GOTO   3C8
03C7:  BSF    75.0
....................    }while(ack); //Esperamos a que el dispositivo responda 
03C8:  BTFSC  75.0
03C9:  GOTO   3BA
....................    //Cuando está listo, devuelve un ACK como 0 
....................    //Mandamos la dirección en la que se quiere escribir 
....................    i2c_write(dir>>8); 
03CA:  MOVF   71,W
03CB:  MOVWF  7C
03CC:  CLRF   7D
03CD:  MOVF   71,W
03CE:  BSF    03.5
03CF:  MOVWF  31
03D0:  BCF    03.5
03D1:  CALL   38C
....................    i2c_write(dir & 255); 
03D2:  MOVF   70,W
03D3:  MOVWF  7C
03D4:  CLRF   7D
03D5:  MOVF   70,W
03D6:  BSF    03.5
03D7:  MOVWF  31
03D8:  BCF    03.5
03D9:  CALL   38C
....................  
....................    //Escribimos los datos contenidos en wdata 
....................    for(i=0;i<tam;i++){ 
03DA:  CLRF   76
03DB:  MOVF   72,W
03DC:  SUBWF  76,W
03DD:  BTFSC  03.0
03DE:  GOTO   3F1
....................       i2c_write(*wdata); 
03DF:  MOVF   74,W
03E0:  MOVWF  7A
03E1:  MOVF   73,W
03E2:  MOVWF  04
03E3:  BCF    03.7
03E4:  BTFSC  74.0
03E5:  BSF    03.7
03E6:  MOVF   00,W
03E7:  MOVWF  7C
03E8:  BSF    03.5
03E9:  MOVWF  31
03EA:  BCF    03.5
03EB:  CALL   38C
....................       wdata++; 
03EC:  INCF   73,F
03ED:  BTFSC  03.2
03EE:  INCF   74,F
....................    } 
03EF:  INCF   76,F
03F0:  GOTO   3DB
....................  
....................    //Finalizamos la comunicación 
....................    i2c_stop(); 
03F1:  BSF    03.5
03F2:  BSF    11.2
03F3:  BTFSC  11.2
03F4:  GOTO   3F3
.................... } 
03F5:  BCF    03.5
03F6:  RETLW  00
....................  
.................... void lee_ee(long int dir, int tam, int8 *rdata) 
.................... { 
....................    boolean ack; 
....................    int i; 
....................    //Comenzamos escribiendo la dirección que queremos consultar 
....................    //al igual que ya hicimos con el método de escritura 
....................    do{ 
....................       i2c_start(); 
*
13C1:  BSF    11.0
13C2:  BTFSC  11.0
13C3:  GOTO   3C2
....................       ack=i2c_write(CONTROL_W); 
13C4:  MOVLW  AE
13C5:  MOVWF  31
13C6:  BCF    0A.4
13C7:  BCF    03.5
13C8:  CALL   38C
13C9:  BSF    0A.4
13CA:  MOVF   78,W
13CB:  BTFSC  78.0
13CC:  GOTO   3D1
13CD:  BSF    03.5
13CE:  BCF    2D.0
13CF:  GOTO   3D3
13D0:  BCF    03.5
13D1:  BSF    03.5
13D2:  BSF    2D.0
....................    }while(ack); //Esperamos a que el dispositivo responda 
13D3:  BTFSC  2D.0
13D4:  GOTO   3C1
....................    i2c_write(dir>>8); 
13D5:  MOVF   29,W
13D6:  MOVWF  2F
13D7:  CLRF   30
13D8:  MOVF   29,W
13D9:  MOVWF  31
13DA:  BCF    0A.4
13DB:  BCF    03.5
13DC:  CALL   38C
13DD:  BSF    0A.4
....................    i2c_write(dir & 255); 
13DE:  BSF    03.5
13DF:  MOVF   28,W
13E0:  MOVWF  2F
13E1:  CLRF   30
13E2:  MOVF   28,W
13E3:  MOVWF  31
13E4:  BCF    0A.4
13E5:  BCF    03.5
13E6:  CALL   38C
13E7:  BSF    0A.4
....................  
....................    //Reiniciamos la comunicación para leer los datos 
....................    i2c_start(); 
13E8:  BSF    03.5
13E9:  BSF    11.1
13EA:  BTFSC  11.1
13EB:  GOTO   3EA
....................    //Escribimos palabra de control de escritura 
....................    i2c_write(CONTROL_R); 
13EC:  MOVLW  AF
13ED:  MOVWF  31
13EE:  BCF    0A.4
13EF:  BCF    03.5
13F0:  CALL   38C
13F1:  BSF    0A.4
....................  
....................    //Leemos hasta que completemos el bus 
....................    for(i=0; i<tam-1; i++){ 
13F2:  BSF    03.5
13F3:  CLRF   2E
13F4:  MOVLW  01
13F5:  SUBWF  2A,W
13F6:  SUBWF  2E,W
13F7:  BTFSC  03.0
13F8:  GOTO   40E
....................       //Se responde en cada caso con ACK 
....................       //(la función i2c_read tiene su argumento al revés: 1 corresponde a 
....................       //ACK y 0 a NACK, cuando en la línea un valor bajo es ACK y uno alto, NACK) 
....................       *rdata=i2c_read(1); 
13F9:  MOVF   2C,W
13FA:  MOVWF  7A
13FB:  MOVF   2B,W
13FC:  MOVWF  04
13FD:  BCF    03.7
13FE:  BTFSC  2C.0
13FF:  BSF    03.7
1400:  MOVLW  01
1401:  MOVWF  77
1402:  BCF    0A.4
1403:  BCF    03.5
1404:  CALL   7EB
1405:  BSF    0A.4
1406:  MOVF   78,W
1407:  MOVWF  00
....................       rdata++; 
1408:  BSF    03.5
1409:  INCF   2B,F
140A:  BTFSC  03.2
140B:  INCF   2C,F
....................    } 
140C:  INCF   2E,F
140D:  GOTO   3F4
....................    //Debemos terminar la lectura con un NACK 
....................    *rdata=i2c_read(0); 
140E:  MOVF   2C,W
140F:  MOVWF  7A
1410:  MOVF   2B,W
1411:  MOVWF  04
1412:  BCF    03.7
1413:  BTFSC  2C.0
1414:  BSF    03.7
1415:  CLRF   77
1416:  BCF    0A.4
1417:  BCF    03.5
1418:  CALL   7EB
1419:  BSF    0A.4
141A:  MOVF   78,W
141B:  MOVWF  00
....................    i2c_stop(); 
141C:  BSF    03.5
141D:  BSF    11.2
141E:  BTFSC  11.2
141F:  GOTO   41E
.................... } 
....................  
....................  
....................  
.................... #use fast_io(A) 
.................... #use fast_io(B) 
.................... #use fast_io(C) 
.................... #use fast_io(D) 
....................  
.................... int1 temperatura_caldera_superada; //Control de la histéresis en la caldera 
.................... int1 temp_habitacion_superada;  //Control de la histéresis del ambiente 
.................... int1 encendido_por_alarma; //Indica si la última vez que se encendió fue en respuesta o no a una alarma 
.................... int1 toca_encender; //Indica si la próxima alarma es de encendido o de apagado 
.................... float termostato; //Temperatura límite de la vivienda 
.................... float termostato_provisional; //Valor de termostato provisional para cuando saltan las alarmas 
.................... float temperatura; //Temperatura de la vivienda 
.................... float histeresis_vivienda = 0.5; //Intervalo de histéresis de la vivienda 
*
1A81:  MOVLW  7E
1A82:  MOVWF  3C
1A83:  CLRF   3D
1A84:  CLRF   3E
1A85:  CLRF   3F
....................  
.................... //Estructura de un intervalo de programación 
.................... typedef struct 
.................... { 
....................    unsigned int horas_inicio;    //Hora a la que se inicia el encendido 
....................    unsigned int minutos_inicio;  // 
....................    unsigned int horas_fin;       //Hora a la que se apaga el sistema 
....................    unsigned int minutos_fin;     // 
....................    unsigned int termostato;      //Termostato vigente en ese intervalo 
.................... }programacion; 
....................  
.................... //Única programación horaria posible 
.................... //La información se distribuye en grupos de 5: hora_inicio, minutos_inicio, 
.................... //hora_fin, minutos_fin y termostato. 
.................... programacion prg; 
....................  
.................... //Vector para guardar datos en memoria 
.................... int data[8]; 
....................  
.................... //Estructura para leer el tiempo del reloj 
.................... date_time_t tiempo; 
....................  
.................... //Registro de la hora en la que se enciende el sistema 
.................... int hora_encendido; 
.................... int minutos_encendido; 
....................  
.................... //Registro de la hora en la que se enciende la caldera 
.................... //Se supone que el encendido de la caldera se realiza en intervalos cortos, 
.................... //que se alcanza la temperatura deseada relativamente rápido. 
.................... int hora_caldera; 
.................... int minutos_caldera; 
.................... int segundos_caldera; 
.................... //Tiempo total de encendido de la caldera en cada intervalo de encendido del sistema 
.................... long t_total_caldera; 
....................  
.................... //Variables para el registro en memoria 
.................... unsigned long num_registros;  //Número de registros de fechas almacenados 
.................... int anno_actual;             //Año en el que estamos (de 0 a 99) 
.................... int anno_actual_0_to_3;      //Año en el que estamos (de 0 a 3) 
....................  
.................... //Flag para activar las interrupciones de interfaz con el teclado y alarma 
.................... int1 lcd_int; 
.................... int1 alarma_int; 
....................  
.................... //Variables para gestionar las alarmas por software 
.................... int hora_alarma; 
.................... int minutos_alarma; 
.................... int1 alarma; 
....................  
....................  
.................... //Listado de métodos utilizados ordenados por orden alfabético 
.................... //************************************************************ 
.................... //Mostramos aquí una breve explicación de cada uno. El interior de los métodos está 
.................... //descrito después del método main. 
....................  
.................... //apagar_caldera() -> Apaga la caldera, almacenando el tiempo que ha estado encendida. 
.................... void apagar_caldera(); 
.................... //apagar_sistema() -> Realiza todas las operaciones necesarias para el apagado 
.................... //del sistema, como el almacenamiento de los datos necesarios en memoria. 
.................... void apagar_sistema(); 
.................... //buscar_numero(int led_unidades, int min, int max, int valor_inicial) -> Busca un número introducido con los 
.................... //botones + y - y se va mostrando el valor en la posición led_unidades del display (siempre en la fila 2). El 
.................... //rango de variación del valor está limitado por el intervalo [min,max]. Valor_inicial es el valor con el que 
.................... //se muestra la variable al principio. Si se pulsa SI, se aprueba el valor que aparece. 
.................... int buscar_numero(int led_unidades, int min, int max, int valor_inicial); 
.................... //buscar_numero_rs232() -> Registra la introducción de un número de dos cifras mediante la interfaz RS232 y 
.................... //lo devuelve. Además, si se pulsa el "backspace" durante el proceso, devuelve el código correspondiente a NO 
.................... int buscar_numero_rs232(); 
.................... //comp_caldera() -> Devuelve TRUE si debemos apagar la caldera. Esta función tiene en cuenta 
.................... //cierta histéresis para evitar ciclos continuos de apagado-encendido. 
.................... int comp_caldera(); 
.................... //comprobar_temperatura() -> Devuelve TRUE si la temperatura de la habitación es menor 
.................... //que la indicada en el termostato, y FALSE en caso contrario. 
.................... int comprobar_temperatura(); 
.................... //diferencia_tiempo_sec(int hora1, int min1, int sec1, int hora2, int min2, int sec2) -> 
.................... //Calcula la diferencia de tiempo en segundos entre hora1:min1:sec1 y hora2:min2:sec2 
.................... //Si hora1:min1:sec1 es mayor que hora2:min2:sec2, los considera en días consecutivos 
.................... long diferencia_tiempo_sec(int hora1,int min1, int sec1, int hora2, int min2, int sec2); 
.................... //encender_caldera() -> Enciende la caldera, almacenando el tiempo de encendido en 
.................... //las variables correspondientes. 
.................... void encender_caldera(); 
.................... //encender_sistema() -> Realiza todas las operaciones necesarias para el encendido 
.................... //del sistema, como registro del tiempo de inicio. 
.................... void encender_sistema(); 
.................... //inicializacion() -> Gestiona la inicialización del sistema por parte del técnico. 
.................... void inicializacion(); 
.................... //mostrar_temperatura() -> Muestra en la pantalla LCD la temperatura actual y la hora. 
.................... void mostrar_temperatura(); 
.................... //representar_registros() -> Representa la información de los registros en el puerto RS232 
.................... //Nunca guardamos la información de los registros para no saturar la memoria y 
.................... //aprovechamos la representación de los datos para calcular medias y demás y así 
.................... //no tener que realizar un segundo barrido de lectura en memoria. 
.................... void representar_registros(); 
....................  
.................... //-------------------------------------------------------------------------------- 
....................  
.................... //Gestión de interrupciones de activación de la interfaz de usuario 
.................... #INT_EXT 
.................... void activacion_led(){ 
....................    //Se activa el flag correspondiente 
....................    lcd_int = TRUE; 
*
019E:  BSF    2F.4
.................... } 
....................  
.................... //*********************************************************** 
.................... //Método main 
.................... //*********************************************************** 
019F:  BCF    0B.1
01A0:  BCF    0A.3
01A1:  BCF    0A.4
01A2:  GOTO   01D
.................... void main() 
.................... { 
*
1A45:  CLRF   04
1A46:  BCF    03.7
1A47:  MOVLW  1F
1A48:  ANDWF  03,F
1A49:  BSF    03.5
1A4A:  BSF    03.6
1A4B:  BSF    07.3
1A4C:  MOVLW  A0
1A4D:  BCF    03.6
1A4E:  MOVWF  19
1A4F:  MOVLW  01
1A50:  MOVWF  1A
1A51:  MOVLW  A6
1A52:  MOVWF  18
1A53:  MOVLW  90
1A54:  BCF    03.5
1A55:  MOVWF  18
1A56:  BSF    28.3
1A57:  MOVF   28,W
1A58:  BSF    03.5
1A59:  MOVWF  07
1A5A:  BCF    03.5
1A5B:  BSF    28.4
1A5C:  MOVF   28,W
1A5D:  BSF    03.5
1A5E:  MOVWF  07
1A5F:  MOVLW  13
1A60:  MOVWF  13
1A61:  MOVLW  28
1A62:  BCF    03.5
1A63:  MOVWF  14
1A64:  BSF    03.5
1A65:  BSF    14.7
1A66:  BCF    14.6
1A67:  BSF    03.6
1A68:  MOVF   09,W
1A69:  ANDLW  C0
1A6A:  MOVWF  09
1A6B:  BCF    03.6
1A6C:  BCF    1F.4
1A6D:  BCF    1F.5
1A6E:  MOVLW  00
1A6F:  BSF    03.6
1A70:  MOVWF  08
1A71:  MOVLW  07
1A72:  BCF    03.5
1A73:  MOVWF  07
1A74:  MOVLW  FF
1A75:  MOVWF  08
1A76:  CLRF   09
1A77:  BSF    03.5
1A78:  BCF    03.6
1A79:  CLRF   17
1A7A:  BSF    03.6
1A7B:  CLRF   05
....................    //Variable auxiliar 
....................    int aux; 
....................     
....................    //Configuramos el perro guardián 
....................    setup_wdt(WDT_18MS | WDT_TIMES_1024); 
*
1A86:  MOVLW  0B
1A87:  BSF    03.6
1A88:  MOVWF  05
1A89:  CLRF   77
1A8A:  MOVLW  07
1A8B:  BCF    03.6
1A8C:  CLRF   01
1A8D:  MOVLW  81
1A8E:  MOVWF  04
1A8F:  BCF    03.7
1A90:  MOVF   00,W
1A91:  ANDLW  F0
1A92:  IORLW  07
1A93:  MOVWF  00
1A94:  CLRWDT
1A95:  MOVF   00,W
1A96:  ANDLW  F7
1A97:  BTFSC  77.3
1A98:  ANDLW  F0
1A99:  IORWF  77,W
1A9A:  MOVWF  00
....................  
....................    //Inicializamos salidas 
....................    //Comenzamos con todo apagado (sistema, motor y caldera) 
....................    sistema_encendido = FALSE; 
1A9B:  BSF    03.6
1A9C:  BCF    08.2
....................    motor = FALSE; 
1A9D:  BCF    08.1
....................    caldera_encendida = FALSE; 
1A9E:  BCF    08.0
....................    encendido_por_alarma = FALSE; 
1A9F:  BCF    03.6
1AA0:  BCF    2F.2
....................    t_total_caldera = 0; //El tiempo total de encendido de la caldera también lo ponemos a 0 
1AA1:  CLRF   5A
1AA2:  CLRF   59
....................  
....................    //Establecemos el estado de los puertos como entradas o salidas 
....................    set_tris_b(0x03); 
1AA3:  MOVLW  03
1AA4:  BSF    03.5
1AA5:  MOVWF  06
....................    set_tris_d(0x00); 
1AA6:  MOVLW  00
1AA7:  MOVWF  08
....................    set_tris_c(0xE7); 
1AA8:  MOVLW  E7
1AA9:  MOVWF  07
....................  
....................    //Inicializamos la pantalla lcd 
....................    lcd_init(); 
1AAA:  BCF    0A.4
1AAB:  BCF    0A.3
1AAC:  BCF    03.5
1AAD:  GOTO   20E
1AAE:  BSF    0A.4
1AAF:  BSF    0A.3
....................  
....................    //No mostramos mensaje de inicio para ahorrar memoria 
....................  
....................    //----------------------------------------------------------- 
....................    //Rutina de inicialización del sistema por parte del técnico 
....................    //----------------------------------------------------------- 
....................    inicializacion(); 
1AB0:  BCF    0A.4
1AB1:  BCF    0A.3
1AB2:  GOTO   54B
1AB3:  BSF    0A.4
1AB4:  BSF    0A.3
....................  
....................    //Propiedades de conversión analógico digital 
....................    //Caracterizamos los puertos A0 a A3 como entradas analógicas 
....................    setup_adc_ports(sAN2 | sAN3); 
1AB5:  BSF    03.5
1AB6:  BSF    03.6
1AB7:  MOVF   09,W
1AB8:  ANDLW  C0
1AB9:  MOVWF  09
1ABA:  BCF    03.6
1ABB:  BCF    1F.4
1ABC:  BCF    1F.5
1ABD:  MOVLW  00
1ABE:  IORLW  0C
1ABF:  BSF    03.6
1AC0:  MOVWF  08
....................    //Definimos el reloj de conversión 
....................    setup_adc(adc_clock_div_32); 
1AC1:  BCF    03.5
1AC2:  BCF    03.6
1AC3:  BCF    1F.6
1AC4:  BSF    1F.7
1AC5:  BSF    03.5
1AC6:  BCF    1F.7
1AC7:  BCF    03.5
1AC8:  BSF    1F.0
....................  
....................    //Leemos la temperatura 
....................    temperatura = ds1820_read(); 
1AC9:  BCF    0A.4
1ACA:  CALL   0F3
1ACB:  BSF    0A.4
1ACC:  MOVF   7A,W
1ACD:  MOVWF  3B
1ACE:  MOVF   79,W
1ACF:  MOVWF  3A
1AD0:  MOVF   78,W
1AD1:  MOVWF  39
1AD2:  MOVF   77,W
1AD3:  MOVWF  38
....................    if(!ds1820_termostato()) 
1AD4:  BCF    0A.4
1AD5:  CALL   161
1AD6:  BSF    0A.4
1AD7:  MOVF   78,F
1AD8:  BTFSS  03.2
1AD9:  GOTO   323
....................    { 
....................       //Si supera el valor del termostato, lo indicamos con el flag 
....................       temp_habitacion_superada = TRUE; 
1ADA:  BSF    2F.1
....................       //Tendremos que establecer un nuevo termostato teniendo en cuenta la histéresis de la temperatura 
....................       termostato = termostato - histeresis_vivienda; 
1ADB:  BSF    03.1
1ADC:  MOVF   33,W
1ADD:  BSF    03.5
1ADE:  MOVWF  2A
1ADF:  BCF    03.5
1AE0:  MOVF   32,W
1AE1:  BSF    03.5
1AE2:  MOVWF  29
1AE3:  BCF    03.5
1AE4:  MOVF   31,W
1AE5:  BSF    03.5
1AE6:  MOVWF  28
1AE7:  BCF    03.5
1AE8:  MOVF   30,W
1AE9:  BSF    03.5
1AEA:  MOVWF  27
1AEB:  BCF    03.5
1AEC:  MOVF   3F,W
1AED:  BSF    03.5
1AEE:  MOVWF  2E
1AEF:  BCF    03.5
1AF0:  MOVF   3E,W
1AF1:  BSF    03.5
1AF2:  MOVWF  2D
1AF3:  BCF    03.5
1AF4:  MOVF   3D,W
1AF5:  BSF    03.5
1AF6:  MOVWF  2C
1AF7:  BCF    03.5
1AF8:  MOVF   3C,W
1AF9:  BSF    03.5
1AFA:  MOVWF  2B
1AFB:  BCF    0A.4
1AFC:  BCF    03.5
1AFD:  CALL   1CA
1AFE:  BSF    0A.4
1AFF:  MOVF   7A,W
1B00:  MOVWF  33
1B01:  MOVF   79,W
1B02:  MOVWF  32
1B03:  MOVF   78,W
1B04:  MOVWF  31
1B05:  MOVF   77,W
1B06:  MOVWF  30
....................       //Guardamos el dato en el sensor 
....................       //La TH la configuramos con un valor muy alto (127.5ºC) 
....................       ds1820_establecer_TH_TL(127.5, termostato); 
1B07:  CLRF   73
1B08:  CLRF   72
1B09:  MOVLW  7F
1B0A:  MOVWF  71
1B0B:  MOVLW  85
1B0C:  MOVWF  70
1B0D:  MOVF   33,W
1B0E:  BSF    03.5
1B0F:  MOVWF  23
1B10:  BCF    03.5
1B11:  MOVF   32,W
1B12:  BSF    03.5
1B13:  MOVWF  22
1B14:  BCF    03.5
1B15:  MOVF   31,W
1B16:  BSF    03.5
1B17:  MOVWF  21
1B18:  BCF    03.5
1B19:  MOVF   30,W
1B1A:  BSF    03.5
1B1B:  MOVWF  20
1B1C:  BCF    0A.4
1B1D:  BCF    0A.3
1B1E:  BCF    03.5
1B1F:  CALL   4D3
1B20:  BSF    0A.4
1B21:  BSF    0A.3
....................    }else 
1B22:  GOTO   324
....................       //Si no se supera, se indica también 
....................       temp_habitacion_superada = FALSE; 
1B23:  BCF    2F.1
....................  
....................  
....................    //Asumimos que en principio la temperatura de la caldera no ha sido superada 
....................    temperatura_caldera_superada = FALSE; 
1B24:  BCF    2F.0
....................    if(comp_caldera()) 
1B25:  BCF    0A.4
1B26:  CALL   370
1B27:  BSF    0A.4
1B28:  MOVF   78,F
1B29:  BTFSS  03.2
....................       //Si la temperatura del agua en la caldera supera el termostato, activamos el flag 
....................       temperatura_caldera_superada = TRUE; 
1B2A:  BSF    2F.0
....................  
....................    //Desactivamos los flag de las interrupciones 
....................    alarma_int = lcd_int = FALSE; 
1B2B:  BCF    2F.4
1B2C:  BCF    2F.5
....................  
....................    //Activamos las interrupciones del puerto B1 
....................    enable_interrupts(INT_EXT); 
1B2D:  BSF    0B.4
....................    enable_interrupts(GLOBAL); 
1B2E:  MOVLW  C0
1B2F:  IORWF  0B,F
....................  
....................    //Repetimos la siguiente rutina hasta que se desconecte el micro 
....................    while(1){ 
....................       inicio: 
....................       //Inhabilitamos el perro guardián para que no interfiera con las gestión de interrupciones y 
....................       //con la medida de la temperatura 
....................       setup_wdt(WDT_OFF); 
1B30:  BSF    03.6
1B31:  CLRF   05
1B32:  CLRF   77
1B33:  MOVLW  07
1B34:  BCF    03.6
1B35:  CLRF   01
1B36:  MOVLW  81
1B37:  MOVWF  04
1B38:  BCF    03.7
1B39:  MOVF   00,W
1B3A:  ANDLW  F0
1B3B:  IORLW  07
1B3C:  MOVWF  00
1B3D:  CLRWDT
1B3E:  MOVF   00,W
1B3F:  ANDLW  F7
1B40:  BTFSC  77.3
1B41:  ANDLW  F0
1B42:  IORWF  77,W
1B43:  MOVWF  00
....................  
....................       //Si la interrupción de alarma se activa, gestionamos el proceso. En realidad no se trata de una 
....................       //interrupción propiamente dicha, pues se activa por software según lo que apunto en el comentario 
....................       //correspondiente a la activación (al final del main). 
....................       if(alarma_int) 
1B44:  BTFSS  2F.5
1B45:  GOTO   418
....................       { 
....................  
....................          //Desactivamos interrupciones 
....................          disable_interrupts(GLOBAL); 
1B46:  BCF    0B.6
1B47:  BCF    0B.7
1B48:  BTFSC  0B.7
1B49:  GOTO   347
....................  
....................          if(toca_encender) 
1B4A:  BTFSS  2F.3
1B4B:  GOTO   3D5
....................          { 
....................             if(!sistema_encendido) 
1B4C:  BSF    03.6
1B4D:  BTFSC  08.2
1B4E:  GOTO   3C5
....................             { 
....................                //Ejecutamos esto si se trata de una alarma de encendido y el sistema 
....................                //está apagado. 
....................                //Actualizamos el termostato, guardando el valor que había ya (teniendo 
....................                //en cuenta la histéresis) 
....................                if(temp_habitacion_superada) 
1B4F:  BCF    03.6
1B50:  BTFSS  2F.1
1B51:  GOTO   37F
....................                   termostato_provisional = termostato + histeresis_vivienda; 
1B52:  BCF    03.1
1B53:  MOVF   33,W
1B54:  BSF    03.5
1B55:  MOVWF  2A
1B56:  BCF    03.5
1B57:  MOVF   32,W
1B58:  BSF    03.5
1B59:  MOVWF  29
1B5A:  BCF    03.5
1B5B:  MOVF   31,W
1B5C:  BSF    03.5
1B5D:  MOVWF  28
1B5E:  BCF    03.5
1B5F:  MOVF   30,W
1B60:  BSF    03.5
1B61:  MOVWF  27
1B62:  BCF    03.5
1B63:  MOVF   3F,W
1B64:  BSF    03.5
1B65:  MOVWF  2E
1B66:  BCF    03.5
1B67:  MOVF   3E,W
1B68:  BSF    03.5
1B69:  MOVWF  2D
1B6A:  BCF    03.5
1B6B:  MOVF   3D,W
1B6C:  BSF    03.5
1B6D:  MOVWF  2C
1B6E:  BCF    03.5
1B6F:  MOVF   3C,W
1B70:  BSF    03.5
1B71:  MOVWF  2B
1B72:  BCF    0A.4
1B73:  BCF    03.5
1B74:  CALL   1CA
1B75:  BSF    0A.4
1B76:  MOVF   7A,W
1B77:  MOVWF  37
1B78:  MOVF   79,W
1B79:  MOVWF  36
1B7A:  MOVF   78,W
1B7B:  MOVWF  35
1B7C:  MOVF   77,W
1B7D:  MOVWF  34
....................                else 
1B7E:  GOTO   387
....................                   termostato_provisional = termostato; 
1B7F:  MOVF   33,W
1B80:  MOVWF  37
1B81:  MOVF   32,W
1B82:  MOVWF  36
1B83:  MOVF   31,W
1B84:  MOVWF  35
1B85:  MOVF   30,W
1B86:  MOVWF  34
....................                termostato = prg.termostato; 
1B87:  BSF    03.5
1B88:  CLRF   28
1B89:  BCF    03.5
1B8A:  MOVF   44,W
1B8B:  BSF    03.5
1B8C:  MOVWF  27
1B8D:  BCF    0A.4
1B8E:  BCF    03.5
1B8F:  CALL   310
1B90:  BSF    0A.4
1B91:  MOVF   7A,W
1B92:  MOVWF  33
1B93:  MOVF   79,W
1B94:  MOVWF  32
1B95:  MOVF   78,W
1B96:  MOVWF  31
1B97:  MOVF   77,W
1B98:  MOVWF  30
....................                //Grabamos el termostato en el sensor como valor TL 
....................                ds1820_establecer_TH_TL(127.5, termostato); 
1B99:  CLRF   73
1B9A:  CLRF   72
1B9B:  MOVLW  7F
1B9C:  MOVWF  71
1B9D:  MOVLW  85
1B9E:  MOVWF  70
1B9F:  MOVF   33,W
1BA0:  BSF    03.5
1BA1:  MOVWF  23
1BA2:  BCF    03.5
1BA3:  MOVF   32,W
1BA4:  BSF    03.5
1BA5:  MOVWF  22
1BA6:  BCF    03.5
1BA7:  MOVF   31,W
1BA8:  BSF    03.5
1BA9:  MOVWF  21
1BAA:  BCF    03.5
1BAB:  MOVF   30,W
1BAC:  BSF    03.5
1BAD:  MOVWF  20
1BAE:  BCF    0A.4
1BAF:  BCF    0A.3
1BB0:  BCF    03.5
1BB1:  CALL   4D3
1BB2:  BSF    0A.4
1BB3:  BSF    0A.3
....................  
....................                //Si la temperatura no está superada, desactivamos el flag por si acaso 
....................                //lo estaba con el otro valor de termostato. 
....................                if(ds1820_termostato()) 
1BB4:  BCF    0A.4
1BB5:  CALL   161
1BB6:  BSF    0A.4
1BB7:  MOVF   78,F
1BB8:  BTFSS  03.2
....................                   temp_habitacion_superada = FALSE; 
1BB9:  BCF    2F.1
....................  
....................                //Determinamos la próxima alarma como de apagado 
....................                toca_encender = FALSE; 
1BBA:  BCF    2F.3
....................  
....................                //Activamos el flag de sistema encendido por alarma 
....................                encendido_por_alarma = TRUE; 
1BBB:  BSF    2F.2
....................                //No mostramos mensaje para ahorrar memoria 
....................                //Encendemos el sistema 
....................                encender_sistema(); 
1BBC:  BCF    0A.4
1BBD:  CALL   5A1
1BBE:  BSF    0A.4
....................  
....................                //Recogemos el tiempo en el que debe de saltar la alarma de apagado. 
....................                 
....................                hora_alarma = prg.horas_fin; 
1BBF:  MOVF   42,W
1BC0:  MOVWF  5F
....................                minutos_alarma = prg.minutos_fin; 
1BC1:  MOVF   43,W
1BC2:  MOVWF  60
....................  
....................  
....................             }else 
1BC3:  GOTO   3D4
1BC4:  BSF    03.6
....................             { 
....................                //Si se trata de una alarma de encendido y el sistema está encendido 
....................                delay_ms(250); //Retraso para evitar solapamiento de alarmas 
1BC5:  MOVLW  FA
1BC6:  BSF    03.5
1BC7:  BCF    03.6
1BC8:  MOVWF  2C
1BC9:  BCF    0A.4
1BCA:  BCF    0A.3
1BCB:  BCF    03.5
1BCC:  CALL   1A3
1BCD:  BSF    0A.4
1BCE:  BSF    0A.3
....................  
....................                //Programamos la próxima alarma de encendido 
....................                hora_alarma = prg.horas_inicio; 
1BCF:  MOVF   40,W
1BD0:  MOVWF  5F
....................                minutos_alarma = prg.minutos_inicio; 
1BD1:  MOVF   41,W
1BD2:  MOVWF  60
....................  
....................                //Determinamos que la siguiente es de encendido 
....................                toca_encender = TRUE; 
1BD3:  BSF    2F.3
....................             } 
....................          }else 
1BD4:  GOTO   414
....................          { 
....................             //Si se trata de una alarma de apagado 
....................  
....................             delay_ms(250); //Retraso para evitar el solapamiento de alarmas 
1BD5:  MOVLW  FA
1BD6:  BSF    03.5
1BD7:  MOVWF  2C
1BD8:  BCF    0A.4
1BD9:  BCF    0A.3
1BDA:  BCF    03.5
1BDB:  CALL   1A3
1BDC:  BSF    0A.4
1BDD:  BSF    0A.3
....................  
....................             if(sistema_encendido && encendido_por_alarma) 
1BDE:  BSF    03.6
1BDF:  BTFSS  08.2
1BE0:  GOTO   40E
1BE1:  BCF    03.6
1BE2:  BTFSC  2F.2
1BE3:  GOTO   3E6
1BE4:  BSF    03.6
1BE5:  GOTO   40E
....................             { 
....................                //Si el sistema está encendido y se trata de un encendido por alarma: 
....................                //Restauramos el valor del termostato que había antes de la alarma 
....................                termostato=termostato_provisional; 
1BE6:  MOVF   37,W
1BE7:  MOVWF  33
1BE8:  MOVF   36,W
1BE9:  MOVWF  32
1BEA:  MOVF   35,W
1BEB:  MOVWF  31
1BEC:  MOVF   34,W
1BED:  MOVWF  30
....................                //Grabamos la información en el sensor 
....................                ds1820_establecer_TH_TL(127.5, termostato); 
1BEE:  CLRF   73
1BEF:  CLRF   72
1BF0:  MOVLW  7F
1BF1:  MOVWF  71
1BF2:  MOVLW  85
1BF3:  MOVWF  70
1BF4:  MOVF   33,W
1BF5:  BSF    03.5
1BF6:  MOVWF  23
1BF7:  BCF    03.5
1BF8:  MOVF   32,W
1BF9:  BSF    03.5
1BFA:  MOVWF  22
1BFB:  BCF    03.5
1BFC:  MOVF   31,W
1BFD:  BSF    03.5
1BFE:  MOVWF  21
1BFF:  BCF    03.5
1C00:  MOVF   30,W
1C01:  BSF    03.5
1C02:  MOVWF  20
1C03:  BCF    0A.4
1C04:  BCF    0A.3
1C05:  BCF    03.5
1C06:  CALL   4D3
1C07:  BSF    0A.4
1C08:  BSF    0A.3
....................                //Determinamos que la próxima vez que se encienda no sea por alarma 
....................                encendido_por_alarma = FALSE; 
1C09:  BCF    2F.2
....................                //No mostramos mensaje para ahorrar memoria 
....................                //Apagamos el sistema 
....................                apagar_sistema(); 
1C0A:  BCF    0A.4
1C0B:  CALL   672
1C0C:  BSF    0A.4
1C0D:  BSF    03.6
....................             } 
....................  
....................             //Reestablecemos la hora de la alarma 
....................             hora_alarma = prg.horas_inicio; 
1C0E:  BCF    03.6
1C0F:  MOVF   40,W
1C10:  MOVWF  5F
....................             minutos_alarma = prg.minutos_inicio; 
1C11:  MOVF   41,W
1C12:  MOVWF  60
....................  
....................             //Y activamos que, efectivamente, se trata de una alarma de encendido 
....................             toca_encender = TRUE; 
1C13:  BSF    2F.3
....................          } 
....................  
....................          //Activamos de nuevo la alarma 
....................          alarma = TRUE; 
1C14:  BSF    2F.6
....................  
....................          //Desactivamos el flag de interrupción 
....................          alarma_int = FALSE; 
1C15:  BCF    2F.5
....................  
....................          //Activamos de nuevo las interrupciones 
....................          enable_interrupts(GLOBAL); 
1C16:  MOVLW  C0
1C17:  IORWF  0B,F
....................       } 
....................  
....................  
....................       //Si se activa la interrupción de interfaz con el usuario, se gestiona el proceso 
....................       if(lcd_int) 
1C18:  BTFSS  2F.4
1C19:  GOTO   713
....................       { 
....................          //Contadores y valores auxiliares 
....................          int valor, input; 
....................          //Variable para almacenar el nuevo valor del termostato 
....................          float term; 
....................  
....................          //Desactivamos interrupciones 
....................          disable_interrupts(GLOBAL); 
1C1A:  BCF    0B.6
1C1B:  BCF    0B.7
1C1C:  BTFSC  0B.7
1C1D:  GOTO   41B
....................  
....................          //Mostramos un mensaje al usuario para que elija su opción 
....................          lcd_send_byte(LCD_ORDEN,LCD_CLEAR); 
1C1E:  BSF    03.5
1C1F:  CLRF   21
1C20:  MOVLW  01
1C21:  MOVWF  22
1C22:  BCF    0A.4
1C23:  BCF    0A.3
1C24:  BCF    03.5
1C25:  CALL   1DE
1C26:  BSF    0A.4
1C27:  BSF    0A.3
....................          lcd_gotoxy(8,2); 
1C28:  MOVLW  08
1C29:  MOVWF  7C
1C2A:  MOVLW  02
1C2B:  MOVWF  7D
1C2C:  BCF    0A.4
1C2D:  CALL   760
1C2E:  BSF    0A.4
....................          lcd_putc("1"); 
1C2F:  CLRF   68
1C30:  MOVF   68,W
1C31:  BCF    0A.4
1C32:  BCF    0A.3
1C33:  CALL   03B
1C34:  BSF    0A.4
1C35:  BSF    0A.3
1C36:  IORLW  00
1C37:  BTFSC  03.2
1C38:  GOTO   43F
1C39:  INCF   68,F
1C3A:  MOVWF  76
1C3B:  BCF    0A.4
1C3C:  CALL   776
1C3D:  BSF    0A.4
1C3E:  GOTO   430
....................          lcd_gotoxy(8,2); 
1C3F:  MOVLW  08
1C40:  MOVWF  7C
1C41:  MOVLW  02
1C42:  MOVWF  7D
1C43:  BCF    0A.4
1C44:  CALL   760
1C45:  BSF    0A.4
....................          lcd_send_byte(LCD_ORDEN,LCD_CURSOR); //Activamos el parpadeo del cursor 
1C46:  BSF    03.5
1C47:  CLRF   21
1C48:  MOVLW  0E
1C49:  MOVWF  22
1C4A:  BCF    0A.4
1C4B:  BCF    0A.3
1C4C:  BCF    03.5
1C4D:  CALL   1DE
1C4E:  BSF    0A.4
1C4F:  BSF    0A.3
....................  
....................          input = 1; 
1C50:  MOVLW  01
1C51:  MOVWF  63
....................          //Mientras que no se pulse SI o NO, esperamos a que el usuario introduzca un número con los cursores 
....................          while(1) 
....................          { 
....................             if(!mas) 
1C52:  BSF    03.6
1C53:  BTFSC  07.0
1C54:  GOTO   474
....................             { 
....................                //Si se pulsa el botón de +, se aumenta el valor de input 
....................                input++; 
1C55:  BCF    03.6
1C56:  INCF   63,F
....................                //Si llegamos al límite de las opciones, reseteamos 
....................                if(input>4) 
1C57:  MOVF   63,W
1C58:  SUBLW  04
1C59:  BTFSC  03.0
1C5A:  GOTO   45D
....................                   input = 1; 
1C5B:  MOVLW  01
1C5C:  MOVWF  63
....................                //Se muestra por pantalla 
....................                printf(lcd_putc,"%i",input); 
1C5D:  MOVF   63,W
1C5E:  MOVWF  6D
1C5F:  MOVLW  1F
1C60:  MOVWF  6E
1C61:  BCF    0A.3
1C62:  CALL   000
1C63:  BSF    0A.3
....................                //Regresamos el cursor a su posición 
....................                lcd_gotoxy(8,2); 
1C64:  MOVLW  08
1C65:  MOVWF  7C
1C66:  MOVLW  02
1C67:  MOVWF  7D
1C68:  BCF    0A.4
1C69:  CALL   760
1C6A:  BSF    0A.4
....................                //Esperamos a que se levante la tecla 
....................                while(!mas){} 
1C6B:  BSF    03.6
1C6C:  BTFSC  07.0
1C6D:  GOTO   471
1C6E:  BCF    03.6
1C6F:  GOTO   46B
1C70:  BSF    03.6
....................                continue; 
1C71:  BCF    03.6
1C72:  GOTO   452
1C73:  BSF    03.6
....................             } 
....................             if(!menos) 
1C74:  BTFSC  07.1
1C75:  GOTO   492
....................             { 
....................                //Si se pulsa el botón de -, se decrementa el valor de input 
....................                input--; 
1C76:  BCF    03.6
1C77:  DECFSZ 63,F
....................                //Si llegamos al límite de las opciones, reseteamos 
....................                if(input<1) 
1C78:  GOTO   47B
....................                   input = 4; 
1C79:  MOVLW  04
1C7A:  MOVWF  63
....................                //Se muestra por pantalla 
....................                printf(lcd_putc,"%i",input); 
1C7B:  MOVF   63,W
1C7C:  MOVWF  6D
1C7D:  MOVLW  1F
1C7E:  MOVWF  6E
1C7F:  BCF    0A.3
1C80:  CALL   000
1C81:  BSF    0A.3
....................                //Regresamos el cursor a su posición 
....................                lcd_gotoxy(8,2); 
1C82:  MOVLW  08
1C83:  MOVWF  7C
1C84:  MOVLW  02
1C85:  MOVWF  7D
1C86:  BCF    0A.4
1C87:  CALL   760
1C88:  BSF    0A.4
....................                //Esperamos a que se levante la tecla 
....................                while(!menos){} 
1C89:  BSF    03.6
1C8A:  BTFSC  07.1
1C8B:  GOTO   48F
1C8C:  BCF    03.6
1C8D:  GOTO   489
1C8E:  BSF    03.6
....................                continue; 
1C8F:  BCF    03.6
1C90:  GOTO   452
1C91:  BSF    03.6
....................             } 
....................             if(!si) 
1C92:  BTFSC  07.2
1C93:  GOTO   497
....................             { 
....................                //Si se pulsa Si, nos quedamos con el valor seleccionado 
....................                //Esperamos a que se suelte la tecla 
....................                while(!si){} 
1C94:  BTFSS  07.2
1C95:  GOTO   494
....................                break; 
1C96:  GOTO   4A2
....................             } 
....................             if(!no) 
1C97:  BTFSC  07.5
1C98:  GOTO   49F
....................             { 
....................                //Si se pulsa No, salimos 
....................                //Esperamos... 
....................                while(!no){} 
1C99:  BTFSS  07.5
1C9A:  GOTO   499
....................                //No se muestra mensaje de finalización para ahorrar memoria 
....................                lcd_int = FALSE; //Desactivamos el flag de interrupción 
1C9B:  BCF    03.6
1C9C:  BCF    2F.4
....................                goto inicio; 
1C9D:  GOTO   330
1C9E:  BSF    03.6
....................             } 
....................          } 
1C9F:  BCF    03.6
1CA0:  GOTO   452
1CA1:  BSF    03.6
....................  
....................          //Se elige la opción pertinente 
....................          switch(input) 
....................          { 
1CA2:  MOVLW  01
1CA3:  BCF    03.6
1CA4:  SUBWF  63,W
1CA5:  ADDLW  FC
1CA6:  BTFSC  03.0
1CA7:  GOTO   710
1CA8:  ADDLW  04
1CA9:  GOTO   7D9
....................             //Si es 1, entramos en la opción de apagado y encendido manual del sistema 
....................             case 1: 
....................                      //Si el sistema está apagado, lo encendemos 
....................                      if(!sistema_encendido) 
1CAA:  BSF    03.6
1CAB:  BTFSC  08.2
1CAC:  GOTO   4B3
....................                      { 
....................                         encender_sistema(); 
1CAD:  BCF    0A.4
1CAE:  BCF    03.6
1CAF:  CALL   5A1
1CB0:  BSF    0A.4
....................                      }else 
1CB1:  GOTO   4E1
1CB2:  BSF    03.6
....................                      //Si está encendido, lo apagamos 
....................                      { 
....................                         apagar_sistema(); 
1CB3:  BCF    0A.4
1CB4:  BCF    03.6
1CB5:  CALL   672
1CB6:  BSF    0A.4
....................                         //Si el motor estaba en marcha, debemos apagarlo 
....................                         if(motor) 
1CB7:  BSF    03.6
1CB8:  BTFSC  08.1
....................                            motor = FALSE; 
1CB9:  BCF    08.1
....................  
....................                         //Si estaba encendido por alguna alarma debemos indicarlo 
....................                         if(encendido_por_alarma) 
1CBA:  BCF    03.6
1CBB:  BTFSS  2F.2
1CBC:  GOTO   4E1
....................                         { 
....................                            //Recuperamos el valor del termostato 
....................                            termostato=termostato_provisional; 
1CBD:  MOVF   37,W
1CBE:  MOVWF  33
1CBF:  MOVF   36,W
1CC0:  MOVWF  32
1CC1:  MOVF   35,W
1CC2:  MOVWF  31
1CC3:  MOVF   34,W
1CC4:  MOVWF  30
....................                            //Almacenamos el valor en el sensor 
....................                            ds1820_establecer_TH_TL(127.5, termostato); 
1CC5:  CLRF   73
1CC6:  CLRF   72
1CC7:  MOVLW  7F
1CC8:  MOVWF  71
1CC9:  MOVLW  85
1CCA:  MOVWF  70
1CCB:  MOVF   33,W
1CCC:  BSF    03.5
1CCD:  MOVWF  23
1CCE:  BCF    03.5
1CCF:  MOVF   32,W
1CD0:  BSF    03.5
1CD1:  MOVWF  22
1CD2:  BCF    03.5
1CD3:  MOVF   31,W
1CD4:  BSF    03.5
1CD5:  MOVWF  21
1CD6:  BCF    03.5
1CD7:  MOVF   30,W
1CD8:  BSF    03.5
1CD9:  MOVWF  20
1CDA:  BCF    0A.4
1CDB:  BCF    0A.3
1CDC:  BCF    03.5
1CDD:  CALL   4D3
1CDE:  BSF    0A.4
1CDF:  BSF    0A.3
....................  
....................                            encendido_por_alarma = FALSE; 
1CE0:  BCF    2F.2
....................                         } 
....................                      } 
....................                      break; 
1CE1:  GOTO   710
....................  
....................  
....................             //Si es 2, entramos en la opción de configuración del termostato 
....................             case 2: 
....................  
....................                      //No ponemos encabezado por falta de memoria 
....................                       
....................                      //Para considerar el valor del termostato hay que tener en cuenta el valor de la histéresis. 
....................                      //Extraemos la parte entera del termostato para así poder trabajar con la función buscar_numero(). 
....................                      //Tampoco es una limitación trabajar con valores enteros del termostato, pues nuestro cuerpo no notará 
....................                      //demasiado la diferencia. 
....................                      if(temp_habitacion_superada) 
1CE2:  BTFSS  2F.1
1CE3:  GOTO   546
....................                      { 
....................                         valor = (int)(termostato+histeresis_vivienda); 
1CE4:  BCF    03.1
1CE5:  MOVF   33,W
1CE6:  BSF    03.5
1CE7:  MOVWF  2A
1CE8:  BCF    03.5
1CE9:  MOVF   32,W
1CEA:  BSF    03.5
1CEB:  MOVWF  29
1CEC:  BCF    03.5
1CED:  MOVF   31,W
1CEE:  BSF    03.5
1CEF:  MOVWF  28
1CF0:  BCF    03.5
1CF1:  MOVF   30,W
1CF2:  BSF    03.5
1CF3:  MOVWF  27
1CF4:  BCF    03.5
1CF5:  MOVF   3F,W
1CF6:  BSF    03.5
1CF7:  MOVWF  2E
1CF8:  BCF    03.5
1CF9:  MOVF   3E,W
1CFA:  BSF    03.5
1CFB:  MOVWF  2D
1CFC:  BCF    03.5
1CFD:  MOVF   3D,W
1CFE:  BSF    03.5
1CFF:  MOVWF  2C
1D00:  BCF    03.5
1D01:  MOVF   3C,W
1D02:  BSF    03.5
1D03:  MOVWF  2B
1D04:  BCF    0A.4
1D05:  BCF    03.5
1D06:  CALL   1CA
1D07:  BSF    0A.4
1D08:  MOVF   7A,W
1D09:  BSF    03.5
1D0A:  MOVWF  2F
1D0B:  MOVF   79,W
1D0C:  MOVWF  2E
1D0D:  MOVF   78,W
1D0E:  MOVWF  2D
1D0F:  MOVF   77,W
1D10:  MOVWF  2C
1D11:  BCF    0A.4
1D12:  BCF    0A.3
1D13:  BCF    03.5
1D14:  CALL   4B2
1D15:  BSF    0A.4
1D16:  BSF    0A.3
1D17:  MOVF   78,W
1D18:  MOVWF  62
....................                         term = termostato+histeresis_vivienda; 
1D19:  BCF    03.1
1D1A:  MOVF   33,W
1D1B:  BSF    03.5
1D1C:  MOVWF  2A
1D1D:  BCF    03.5
1D1E:  MOVF   32,W
1D1F:  BSF    03.5
1D20:  MOVWF  29
1D21:  BCF    03.5
1D22:  MOVF   31,W
1D23:  BSF    03.5
1D24:  MOVWF  28
1D25:  BCF    03.5
1D26:  MOVF   30,W
1D27:  BSF    03.5
1D28:  MOVWF  27
1D29:  BCF    03.5
1D2A:  MOVF   3F,W
1D2B:  BSF    03.5
1D2C:  MOVWF  2E
1D2D:  BCF    03.5
1D2E:  MOVF   3E,W
1D2F:  BSF    03.5
1D30:  MOVWF  2D
1D31:  BCF    03.5
1D32:  MOVF   3D,W
1D33:  BSF    03.5
1D34:  MOVWF  2C
1D35:  BCF    03.5
1D36:  MOVF   3C,W
1D37:  BSF    03.5
1D38:  MOVWF  2B
1D39:  BCF    0A.4
1D3A:  BCF    03.5
1D3B:  CALL   1CA
1D3C:  BSF    0A.4
1D3D:  MOVF   7A,W
1D3E:  MOVWF  67
1D3F:  MOVF   79,W
1D40:  MOVWF  66
1D41:  MOVF   78,W
1D42:  MOVWF  65
1D43:  MOVF   77,W
1D44:  MOVWF  64
....................                      } 
....................                      else 
1D45:  GOTO   565
....................                      { 
....................                         valor = (int)termostato; 
1D46:  MOVF   33,W
1D47:  BSF    03.5
1D48:  MOVWF  2F
1D49:  BCF    03.5
1D4A:  MOVF   32,W
1D4B:  BSF    03.5
1D4C:  MOVWF  2E
1D4D:  BCF    03.5
1D4E:  MOVF   31,W
1D4F:  BSF    03.5
1D50:  MOVWF  2D
1D51:  BCF    03.5
1D52:  MOVF   30,W
1D53:  BSF    03.5
1D54:  MOVWF  2C
1D55:  BCF    0A.4
1D56:  BCF    0A.3
1D57:  BCF    03.5
1D58:  CALL   4B2
1D59:  BSF    0A.4
1D5A:  BSF    0A.3
1D5B:  MOVF   78,W
1D5C:  MOVWF  62
....................                         term = termostato; 
1D5D:  MOVF   33,W
1D5E:  MOVWF  67
1D5F:  MOVF   32,W
1D60:  MOVWF  66
1D61:  MOVF   31,W
1D62:  MOVWF  65
1D63:  MOVF   30,W
1D64:  MOVWF  64
....................                      } 
....................  
....................                      //Pedimos la introducción de nuevo valor 
....................                      lcd_send_byte(LCD_ORDEN, LCD_CLEAR); 
1D65:  BSF    03.5
1D66:  CLRF   21
1D67:  MOVLW  01
1D68:  MOVWF  22
1D69:  BCF    0A.4
1D6A:  BCF    0A.3
1D6B:  BCF    03.5
1D6C:  CALL   1DE
1D6D:  BSF    0A.4
1D6E:  BSF    0A.3
....................                      printf(lcd_putc, "Term:\n       %cC",223); 
1D6F:  CLRF   68
1D70:  MOVF   68,W
1D71:  BCF    0A.4
1D72:  BCF    0A.3
1D73:  CALL   041
1D74:  BSF    0A.4
1D75:  BSF    0A.3
1D76:  INCF   68,F
1D77:  MOVWF  77
1D78:  MOVWF  76
1D79:  BCF    0A.4
1D7A:  CALL   776
1D7B:  BSF    0A.4
1D7C:  MOVLW  06
1D7D:  SUBWF  68,W
1D7E:  BTFSS  03.2
1D7F:  GOTO   570
1D80:  MOVLW  07
1D81:  MOVWF  69
1D82:  MOVLW  20
1D83:  MOVWF  76
1D84:  BCF    0A.4
1D85:  CALL   776
1D86:  BSF    0A.4
1D87:  DECFSZ 69,F
1D88:  GOTO   582
1D89:  MOVLW  DF
1D8A:  MOVWF  76
1D8B:  BCF    0A.4
1D8C:  CALL   776
1D8D:  BSF    0A.4
1D8E:  MOVLW  43
1D8F:  MOVWF  76
1D90:  BCF    0A.4
1D91:  CALL   776
1D92:  BSF    0A.4
....................  
....................                      //Recogemos el número de dos cifras introducido por el teclado 
....................                      term=(float)buscar_numero(6, temp_min, temp_max, valor); 
1D93:  MOVLW  06
1D94:  MOVWF  68
1D95:  MOVLW  10
1D96:  MOVWF  69
1D97:  MOVLW  20
1D98:  MOVWF  6A
1D99:  MOVF   62,W
1D9A:  MOVWF  6B
1D9B:  BCF    0A.3
1D9C:  CALL   081
1D9D:  BSF    0A.3
1D9E:  BSF    03.5
1D9F:  CLRF   28
1DA0:  MOVF   78,W
1DA1:  MOVWF  27
1DA2:  BCF    0A.4
1DA3:  BCF    03.5
1DA4:  CALL   310
1DA5:  BSF    0A.4
1DA6:  MOVF   7A,W
1DA7:  MOVWF  67
1DA8:  MOVF   79,W
1DA9:  MOVWF  66
1DAA:  MOVF   78,W
1DAB:  MOVWF  65
1DAC:  MOVF   77,W
1DAD:  MOVWF  64
....................  
....................                      //Aquí, a diferencia que con el teclado matricial, no es necesario comprobar los límites de temperatura después 
....................  
....................                      //Leemos la temperatura 
....................                      temperatura = ds1820_read(); 
1DAE:  BCF    0A.4
1DAF:  CALL   0F3
1DB0:  BSF    0A.4
1DB1:  MOVF   7A,W
1DB2:  MOVWF  3B
1DB3:  MOVF   79,W
1DB4:  MOVWF  3A
1DB5:  MOVF   78,W
1DB6:  MOVWF  39
1DB7:  MOVF   77,W
1DB8:  MOVWF  38
....................                      if(temperatura >= term) 
1DB9:  MOVF   67,W
1DBA:  MOVWF  73
1DBB:  MOVF   66,W
1DBC:  MOVWF  72
1DBD:  MOVF   65,W
1DBE:  MOVWF  71
1DBF:  MOVF   64,W
1DC0:  MOVWF  70
1DC1:  MOVF   3B,W
1DC2:  BSF    03.5
1DC3:  MOVWF  23
1DC4:  BCF    03.5
1DC5:  MOVF   3A,W
1DC6:  BSF    03.5
1DC7:  MOVWF  22
1DC8:  BCF    03.5
1DC9:  MOVF   39,W
1DCA:  BSF    03.5
1DCB:  MOVWF  21
1DCC:  BCF    03.5
1DCD:  MOVF   38,W
1DCE:  BSF    03.5
1DCF:  MOVWF  20
1DD0:  BCF    0A.4
1DD1:  BCF    03.5
1DD2:  CALL   32F
1DD3:  BSF    0A.4
1DD4:  BTFSC  03.0
1DD5:  GOTO   5D8
1DD6:  BTFSS  03.2
1DD7:  GOTO   606
....................                      { 
....................                         //Si supera el valor del termostato, lo indicamos con el flag 
....................                         temp_habitacion_superada = TRUE; 
1DD8:  BSF    2F.1
....................                         //Guardamos el termostato nuevo teniendo en cuenta la histeresis de la vivienda 
....................                         termostato = term - histeresis_vivienda; 
1DD9:  BSF    03.1
1DDA:  MOVF   67,W
1DDB:  BSF    03.5
1DDC:  MOVWF  2A
1DDD:  BCF    03.5
1DDE:  MOVF   66,W
1DDF:  BSF    03.5
1DE0:  MOVWF  29
1DE1:  BCF    03.5
1DE2:  MOVF   65,W
1DE3:  BSF    03.5
1DE4:  MOVWF  28
1DE5:  BCF    03.5
1DE6:  MOVF   64,W
1DE7:  BSF    03.5
1DE8:  MOVWF  27
1DE9:  BCF    03.5
1DEA:  MOVF   3F,W
1DEB:  BSF    03.5
1DEC:  MOVWF  2E
1DED:  BCF    03.5
1DEE:  MOVF   3E,W
1DEF:  BSF    03.5
1DF0:  MOVWF  2D
1DF1:  BCF    03.5
1DF2:  MOVF   3D,W
1DF3:  BSF    03.5
1DF4:  MOVWF  2C
1DF5:  BCF    03.5
1DF6:  MOVF   3C,W
1DF7:  BSF    03.5
1DF8:  MOVWF  2B
1DF9:  BCF    0A.4
1DFA:  BCF    03.5
1DFB:  CALL   1CA
1DFC:  BSF    0A.4
1DFD:  MOVF   7A,W
1DFE:  MOVWF  33
1DFF:  MOVF   79,W
1E00:  MOVWF  32
1E01:  MOVF   78,W
1E02:  MOVWF  31
1E03:  MOVF   77,W
1E04:  MOVWF  30
....................                      }else 
1E05:  GOTO   60F
....................                      { 
....................                         //Si no se supera, se indica también 
....................                         temp_habitacion_superada = FALSE; 
1E06:  BCF    2F.1
....................                         //Se guarda el valor tal cual 
....................                         termostato = term; 
1E07:  MOVF   67,W
1E08:  MOVWF  33
1E09:  MOVF   66,W
1E0A:  MOVWF  32
1E0B:  MOVF   65,W
1E0C:  MOVWF  31
1E0D:  MOVF   64,W
1E0E:  MOVWF  30
....................                      } 
....................  
....................                      //Escribimos en el sensor el nuevo valor del termostato 
....................                      ds1820_establecer_TH_TL(127.5, termostato); 
1E0F:  CLRF   73
1E10:  CLRF   72
1E11:  MOVLW  7F
1E12:  MOVWF  71
1E13:  MOVLW  85
1E14:  MOVWF  70
1E15:  MOVF   33,W
1E16:  BSF    03.5
1E17:  MOVWF  23
1E18:  BCF    03.5
1E19:  MOVF   32,W
1E1A:  BSF    03.5
1E1B:  MOVWF  22
1E1C:  BCF    03.5
1E1D:  MOVF   31,W
1E1E:  BSF    03.5
1E1F:  MOVWF  21
1E20:  BCF    03.5
1E21:  MOVF   30,W
1E22:  BSF    03.5
1E23:  MOVWF  20
1E24:  BCF    0A.4
1E25:  BCF    0A.3
1E26:  BCF    03.5
1E27:  CALL   4D3
1E28:  BSF    0A.4
1E29:  BSF    0A.3
....................  
....................                      //Guardamos el nuevo valor del termostato en memoria 
....................                      graba_ee(eeprom_termostato, 1, &valor); 
1E2A:  CLRF   71
1E2B:  CLRF   70
1E2C:  MOVLW  01
1E2D:  MOVWF  72
1E2E:  CLRF   74
1E2F:  MOVLW  62
1E30:  MOVWF  73
1E31:  BCF    0A.4
1E32:  BCF    0A.3
1E33:  CALL   3BA
1E34:  BSF    0A.4
1E35:  BSF    0A.3
....................  
....................                      break; 
1E36:  GOTO   710
....................  
....................  
....................             //Si es 3, entramos en la opción de configuración de las alarmas 
....................             case 3: 
....................  
....................                      //No se muestra encabezamiento por falta de memoria 
....................  
....................                      //Se pide la introducción de los valores para la alarma 
....................                      //Se muestra el intervalo a configurar 
....................                      lcd_send_byte(LCD_ORDEN, LCD_CLEAR); 
1E37:  BSF    03.5
1E38:  CLRF   21
1E39:  MOVLW  01
1E3A:  MOVWF  22
1E3B:  BCF    0A.4
1E3C:  BCF    0A.3
1E3D:  BCF    03.5
1E3E:  CALL   1DE
1E3F:  BSF    0A.4
1E40:  BSF    0A.3
....................                      printf(lcd_putc, "HORAS\n   :      :"); 
1E41:  CLRF   68
1E42:  MOVF   68,W
1E43:  BCF    0A.4
1E44:  BCF    0A.3
1E45:  CALL   04F
1E46:  BSF    0A.4
1E47:  BSF    0A.3
1E48:  INCF   68,F
1E49:  MOVWF  77
1E4A:  MOVWF  76
1E4B:  BCF    0A.4
1E4C:  CALL   776
1E4D:  BSF    0A.4
1E4E:  MOVLW  06
1E4F:  SUBWF  68,W
1E50:  BTFSS  03.2
1E51:  GOTO   642
1E52:  MOVLW  03
1E53:  MOVWF  69
1E54:  MOVLW  20
1E55:  MOVWF  76
1E56:  BCF    0A.4
1E57:  CALL   776
1E58:  BSF    0A.4
1E59:  DECFSZ 69,F
1E5A:  GOTO   654
1E5B:  MOVLW  3A
1E5C:  MOVWF  76
1E5D:  BCF    0A.4
1E5E:  CALL   776
1E5F:  BSF    0A.4
1E60:  MOVLW  06
1E61:  MOVWF  6A
1E62:  MOVLW  20
1E63:  MOVWF  76
1E64:  BCF    0A.4
1E65:  CALL   776
1E66:  BSF    0A.4
1E67:  DECFSZ 6A,F
1E68:  GOTO   662
1E69:  MOVLW  3A
1E6A:  MOVWF  76
1E6B:  BCF    0A.4
1E6C:  CALL   776
1E6D:  BSF    0A.4
....................  
....................                      //Se pide al usuario el valor de hora de inicio de la alarma 
....................                      prg.horas_inicio = buscar_numero(2, 0, 23, 0); 
1E6E:  MOVLW  02
1E6F:  MOVWF  68
1E70:  CLRF   69
1E71:  MOVLW  17
1E72:  MOVWF  6A
1E73:  CLRF   6B
1E74:  BCF    0A.3
1E75:  CALL   081
1E76:  BSF    0A.3
1E77:  MOVF   78,W
1E78:  MOVWF  40
....................  
....................                      //Se pide al usuario el valor de los minutos de inicio 
....................                      prg.minutos_inicio = buscar_numero(5, 0, 59, 0); 
1E79:  MOVLW  05
1E7A:  MOVWF  68
1E7B:  CLRF   69
1E7C:  MOVLW  3B
1E7D:  MOVWF  6A
1E7E:  CLRF   6B
1E7F:  BCF    0A.3
1E80:  CALL   081
1E81:  BSF    0A.3
1E82:  MOVF   78,W
1E83:  MOVWF  41
....................  
....................                      //Al contrario que ocurría en el Proyecto 1 que contaba con teclado matricial, 
....................                      //en este caso comprobamos que la hora final sea posterior a la inicial en el momento. 
....................                      //Para ello debemos establecer el límite inferior de la hora de fin correctamente. 
....................                       
....................                      valor = prg.horas_inicio; 
1E84:  MOVF   40,W
1E85:  MOVWF  62
....................                      //Si los minutos son 59, tendremos que irnos a la siguiente hora 
....................                      if(prg.minutos_inicio==59) 
1E86:  MOVF   41,W
1E87:  SUBLW  3B
1E88:  BTFSS  03.2
1E89:  GOTO   68C
....................                         valor += 1; 
1E8A:  MOVLW  01
1E8B:  ADDWF  62,F
....................                          
....................                      prg.horas_fin = buscar_numero(9, valor, 23, valor); 
1E8C:  MOVLW  09
1E8D:  MOVWF  68
1E8E:  MOVF   62,W
1E8F:  MOVWF  69
1E90:  MOVLW  17
1E91:  MOVWF  6A
1E92:  MOVF   62,W
1E93:  MOVWF  6B
1E94:  BCF    0A.3
1E95:  CALL   081
1E96:  BSF    0A.3
1E97:  MOVF   78,W
1E98:  MOVWF  42
....................  
....................                      //Si las horas de inicio y fin son las mismas, habrá que limitar que los minutos de finalización 
....................                      //tengan un valor mayor 
....................                      if(prg.horas_inicio == prg.horas_fin) 
1E99:  MOVF   42,W
1E9A:  SUBWF  40,W
1E9B:  BTFSS  03.2
1E9C:  GOTO   6A1
....................                         valor = prg.minutos_inicio+1; 
1E9D:  MOVLW  01
1E9E:  ADDWF  41,W
1E9F:  MOVWF  62
....................                      else 
1EA0:  GOTO   6A2
....................                         valor = 0; 
1EA1:  CLRF   62
....................                          
....................                      prg.minutos_fin = buscar_numero(12, valor, 59, valor);  
1EA2:  MOVLW  0C
1EA3:  MOVWF  68
1EA4:  MOVF   62,W
1EA5:  MOVWF  69
1EA6:  MOVLW  3B
1EA7:  MOVWF  6A
1EA8:  MOVF   62,W
1EA9:  MOVWF  6B
1EAA:  BCF    0A.3
1EAB:  CALL   081
1EAC:  BSF    0A.3
1EAD:  MOVF   78,W
1EAE:  MOVWF  43
....................  
....................                      //El usuario debe ahora introducir el valor del temostato para ese periodo de encendido 
....................                      lcd_send_byte(LCD_ORDEN, LCD_CLEAR); 
1EAF:  BSF    03.5
1EB0:  CLRF   21
1EB1:  MOVLW  01
1EB2:  MOVWF  22
1EB3:  BCF    0A.4
1EB4:  BCF    0A.3
1EB5:  BCF    03.5
1EB6:  CALL   1DE
1EB7:  BSF    0A.4
1EB8:  BSF    0A.3
....................                      printf(lcd_putc, "Term.\n      %cC", 223); 
1EB9:  CLRF   68
1EBA:  MOVF   68,W
1EBB:  BCF    0A.4
1EBC:  BCF    0A.3
1EBD:  CALL   05C
1EBE:  BSF    0A.4
1EBF:  BSF    0A.3
1EC0:  INCF   68,F
1EC1:  MOVWF  77
1EC2:  MOVWF  76
1EC3:  BCF    0A.4
1EC4:  CALL   776
1EC5:  BSF    0A.4
1EC6:  MOVLW  06
1EC7:  SUBWF  68,W
1EC8:  BTFSS  03.2
1EC9:  GOTO   6BA
1ECA:  MOVLW  06
1ECB:  MOVWF  69
1ECC:  MOVLW  20
1ECD:  MOVWF  76
1ECE:  BCF    0A.4
1ECF:  CALL   776
1ED0:  BSF    0A.4
1ED1:  DECFSZ 69,F
1ED2:  GOTO   6CC
1ED3:  MOVLW  DF
1ED4:  MOVWF  76
1ED5:  BCF    0A.4
1ED6:  CALL   776
1ED7:  BSF    0A.4
1ED8:  MOVLW  43
1ED9:  MOVWF  76
1EDA:  BCF    0A.4
1EDB:  CALL   776
1EDC:  BSF    0A.4
....................  
....................                      //Recogemos el número introducido por el usuario 
....................                      prg.termostato = buscar_numero(4, temp_min, temp_max, 20);  
1EDD:  MOVLW  04
1EDE:  MOVWF  68
1EDF:  MOVLW  10
1EE0:  MOVWF  69
1EE1:  MOVLW  20
1EE2:  MOVWF  6A
1EE3:  MOVLW  14
1EE4:  MOVWF  6B
1EE5:  BCF    0A.3
1EE6:  CALL   081
1EE7:  BSF    0A.3
1EE8:  MOVF   78,W
1EE9:  MOVWF  44
....................  
....................                      //Habilitamos la alarma 
....................                      alarma=TRUE; 
1EEA:  BSF    2F.6
....................  
....................                      //Programamos la alarma para que salte el reloj en el momento indicado 
....................                      hora_alarma = prg.horas_inicio; 
1EEB:  MOVF   40,W
1EEC:  MOVWF  5F
....................                      minutos_alarma = prg.minutos_inicio; 
1EED:  MOVF   41,W
1EEE:  MOVWF  60
....................                      alarma = TRUE; 
1EEF:  BSF    2F.6
....................  
....................                      //Indicamos que se trata de una alarma de encendido 
....................                      toca_encender = TRUE; 
1EF0:  BSF    2F.3
....................  
....................                      //Guardamos la programación introducida 
....................                      data[0] = prg.horas_inicio; 
1EF1:  MOVF   40,W
1EF2:  MOVWF  45
....................                      data[1] = prg.minutos_inicio; 
1EF3:  MOVF   41,W
1EF4:  MOVWF  46
....................                      data[2] = prg.horas_fin; 
1EF5:  MOVF   42,W
1EF6:  MOVWF  47
....................                      data[3] = prg.minutos_fin; 
1EF7:  MOVF   43,W
1EF8:  MOVWF  48
....................                      data[4] = prg.termostato; 
1EF9:  MOVF   44,W
1EFA:  MOVWF  49
....................  
....................                      graba_ee(eeprom_programacion, 5, data); 
1EFB:  CLRF   71
1EFC:  MOVLW  08
1EFD:  MOVWF  70
1EFE:  MOVLW  05
1EFF:  MOVWF  72
1F00:  CLRF   74
1F01:  MOVLW  45
1F02:  MOVWF  73
1F03:  BCF    0A.4
1F04:  BCF    0A.3
1F05:  CALL   3BA
1F06:  BSF    0A.4
1F07:  BSF    0A.3
....................  
....................                      break; 
1F08:  GOTO   710
....................                       
....................             //Si es 4, entramos en el modo de revisión y obtención de datos históricos 
....................             case 4: 
....................  
....................                      //En este caso no se pide la introducción de la clave para acortar la longitud del programa 
....................                      //Entramos en el modo revisión 
....................  
....................                      //Dejamos la pantalla lcd fija 
....................                      set_tris_d(0xFF); 
1F09:  MOVLW  FF
1F0A:  BSF    03.5
1F0B:  MOVWF  08
....................  
....................                      //Representamos el contenido de los registros y activamos la interfaz RS-232 
....................                      representar_registros(); 
1F0C:  BCF    0A.3
1F0D:  BCF    03.5
1F0E:  GOTO   30D
1F0F:  BSF    0A.3
....................  
....................                      break; 
....................          } 
....................  
....................          //Se desactiva el flag de indicación de la interrupción 
....................          lcd_int = FALSE; 
1F10:  BCF    2F.4
....................  
....................          //Volvemos a activar las interrupciones 
....................          enable_interrupts(GLOBAL); 
1F11:  MOVLW  C0
1F12:  IORWF  0B,F
....................       } 
....................  
....................       //Comenzamos el bloque de comprobación de parámetros y activación de los procesos necesarios. 
....................  
....................       //Comparamos primero la temperatura del agua en la caldera. Esta comprobación se 
....................       //realiza siempre, independientemente de que el sistema esté o no encendido. 
....................       if(!comp_caldera()) 
1F13:  BCF    0A.4
1F14:  CALL   370
1F15:  BSF    0A.4
1F16:  MOVF   78,F
1F17:  BTFSS  03.2
1F18:  GOTO   725
....................       { 
....................          //Entramos aquí si la temperatura de la caldera es menor que la necesaria 
....................          if(temperatura_caldera_superada) 
1F19:  BTFSC  2F.0
....................            //Si el flag estaba activado, lo desactivamos 
....................            temperatura_caldera_superada = FALSE; 
1F1A:  BCF    2F.0
....................          if(!caldera_encendida) 
1F1B:  BSF    03.6
1F1C:  BTFSC  08.0
1F1D:  GOTO   723
....................             //Si no estaba encendida, la encendemos 
....................             encender_caldera(); 
1F1E:  BCF    0A.4
1F1F:  BCF    03.6
1F20:  GOTO   7E3
1F21:  BSF    0A.4
1F22:  BSF    03.6
....................       } 
....................       else 
1F23:  GOTO   72F
1F24:  BCF    03.6
....................       { 
....................          //Si la temperatura de la caldera es mayor que la necesaria, apagamos la caldera si está encendida 
....................          //y activamos el flag correspondiente 
....................          if(!temperatura_caldera_superada) 
1F25:  BTFSS  2F.0
....................             temperatura_caldera_superada = TRUE; 
1F26:  BSF    2F.0
....................          if(caldera_encendida) 
1F27:  BSF    03.6
1F28:  BTFSS  08.0
1F29:  GOTO   72F
....................             apagar_caldera(); 
1F2A:  BCF    0A.3
1F2B:  BCF    03.6
1F2C:  GOTO   7B1
1F2D:  BSF    0A.3
1F2E:  BSF    03.6
....................       } 
....................  
....................       //Comprobamos la temperatura y almacenamos el resultado en una variable 
....................       aux = comprobar_temperatura(); 
1F2F:  BCF    03.6
1F30:  GOTO   13B
1F31:  MOVF   78,W
1F32:  MOVWF  61
....................  
....................       //Comprobamos que el sistema no lleve encendido más de 4 horas, ya que en ese caso hay riesgo de avería 
....................       //(en realidad esta limitación deriva de un problema propio de representación en memoria). 
....................       //Ya leimos el tiempo en comprobar_temperatura(), así que no necesitamos leerlo de nuevo. 
....................       if(sistema_encendido && (diferencia_tiempo_sec(hora_encendido, minutos_encendido, 0, tiempo.hours, tiempo.minutes,0))/60>240) 
1F33:  BSF    03.6
1F34:  BTFSS  08.2
1F35:  GOTO   78E
1F36:  BCF    03.6
1F37:  MOVF   54,W
1F38:  MOVWF  6B
1F39:  MOVF   55,W
1F3A:  MOVWF  6C
1F3B:  CLRF   6D
1F3C:  MOVF   4F,W
1F3D:  MOVWF  6E
1F3E:  MOVF   4E,W
1F3F:  MOVWF  6F
1F40:  CLRF   70
1F41:  BCF    0A.4
1F42:  CALL   5D0
1F43:  BSF    0A.4
1F44:  MOVF   79,W
1F45:  MOVWF  69
1F46:  MOVF   78,W
1F47:  MOVWF  68
1F48:  MOVF   69,W
1F49:  MOVWF  6E
1F4A:  MOVF   68,W
1F4B:  MOVWF  6D
1F4C:  CLRF   70
1F4D:  MOVLW  3C
1F4E:  MOVWF  6F
1F4F:  BCF    0A.4
1F50:  CALL   64D
1F51:  BSF    0A.4
1F52:  MOVF   79,W
1F53:  MOVWF  6A
1F54:  MOVF   78,W
1F55:  MOVWF  69
1F56:  MOVF   6A,F
1F57:  BTFSS  03.2
1F58:  GOTO   75F
1F59:  MOVF   69,W
1F5A:  SUBLW  F0
1F5B:  BTFSS  03.0
1F5C:  GOTO   75F
1F5D:  BSF    03.6
1F5E:  GOTO   78E
....................       { 
....................          //Si la diferencia de tiempo es mayor que 4 horas, apagamos el motor y el sistema 
....................          apagar_sistema(); 
1F5F:  BCF    0A.4
1F60:  CALL   672
1F61:  BSF    0A.4
....................  
....................          if(motor) 
1F62:  BSF    03.6
1F63:  BTFSC  08.1
....................            motor = FALSE; 
1F64:  BCF    08.1
....................  
....................          //Si estaba encendido por alguna alarma, recuperamos el termostato anterior. 
....................          if(encendido_por_alarma) 
1F65:  BCF    03.6
1F66:  BTFSS  2F.2
1F67:  GOTO   78C
....................          { 
....................             termostato = termostato_provisional; 
1F68:  MOVF   37,W
1F69:  MOVWF  33
1F6A:  MOVF   36,W
1F6B:  MOVWF  32
1F6C:  MOVF   35,W
1F6D:  MOVWF  31
1F6E:  MOVF   34,W
1F6F:  MOVWF  30
....................             //Almacenamos el valor en el sensor 
....................             ds1820_establecer_TH_TL(127.5, termostato); 
1F70:  CLRF   73
1F71:  CLRF   72
1F72:  MOVLW  7F
1F73:  MOVWF  71
1F74:  MOVLW  85
1F75:  MOVWF  70
1F76:  MOVF   33,W
1F77:  BSF    03.5
1F78:  MOVWF  23
1F79:  BCF    03.5
1F7A:  MOVF   32,W
1F7B:  BSF    03.5
1F7C:  MOVWF  22
1F7D:  BCF    03.5
1F7E:  MOVF   31,W
1F7F:  BSF    03.5
1F80:  MOVWF  21
1F81:  BCF    03.5
1F82:  MOVF   30,W
1F83:  BSF    03.5
1F84:  MOVWF  20
1F85:  BCF    0A.4
1F86:  BCF    0A.3
1F87:  BCF    03.5
1F88:  CALL   4D3
1F89:  BSF    0A.4
1F8A:  BSF    0A.3
....................             encendido_por_alarma = FALSE; 
1F8B:  BCF    2F.2
....................          } 
....................  
....................          goto inicio; 
1F8C:  GOTO   330
1F8D:  BSF    03.6
....................  
....................       } 
....................  
....................       //Comprobamos ahora la temperatura de la vivienda. Esto se realiza sólo si el sistema está encendido 
....................       if(aux && sistema_encendido && temperatura_caldera_superada) 
1F8E:  BCF    03.6
1F8F:  MOVF   61,F
1F90:  BTFSC  03.2
1F91:  GOTO   79F
1F92:  BSF    03.6
1F93:  BTFSC  08.2
1F94:  GOTO   797
1F95:  BCF    03.6
1F96:  GOTO   79F
1F97:  BCF    03.6
1F98:  BTFSS  2F.0
1F99:  GOTO   79F
....................       { 
....................          //Si la temperatura es menor que la necesaria, el sistema está encendido y la temperatura del 
....................          //agua en la caldera es la adecuada, encendemos el motor de circulación del agua 
....................          if(!motor) 
1F9A:  BSF    03.6
1F9B:  BTFSS  08.1
....................             motor = TRUE; 
1F9C:  BSF    08.1
....................  
....................       } 
....................       else if(motor) 
1F9D:  GOTO   7A2
1F9E:  BCF    03.6
1F9F:  BSF    03.6
1FA0:  BTFSC  08.1
....................          //Si no se cumplen las condiciones, apagamos el motor si está encendido 
....................          motor = FALSE; 
1FA1:  BCF    08.1
....................  
....................       //Comprobamos si ha saltado la alarma. Esta comprobación la hacemos por software en lugar de por 
....................       //interrupciones porque he tenido muchos problemas con las interrupciones de reloj en la placa 
....................       //que cogí el día de las pruebas, problemas relacionados con el borrado del flag de alarma del 
....................       //reloj. Ante esto, por tanto, aplico la solución gordiana de hacerlo por software para asegurar 
....................       //que funcione en la defensa. Puede verse un ejemplo de aplicación de las interrupciones de reloj 
....................       //en el modelo de PROTEUS del proyecto final. 
....................       //Para detectar si la alarma ha saltado vemos si la diferencia de tiempo entre ambas horas es igual. 
....................       //Esto no nos dará ningún problema en el tiempo de respuesta de la alarma (que se pase al minuto siguiente) 
....................       //ya que el WDT despierta al PIC varias veces por minuto. 
....................       if(alarma && (diferencia_tiempo_sec(hora_alarma, minutos_alarma, 0, tiempo.hours, tiempo.minutes, 0)<59)) 
1FA2:  BCF    03.6
1FA3:  BTFSS  2F.6
1FA4:  GOTO   7BE
1FA5:  MOVF   5F,W
1FA6:  MOVWF  6B
1FA7:  MOVF   60,W
1FA8:  MOVWF  6C
1FA9:  CLRF   6D
1FAA:  MOVF   4F,W
1FAB:  MOVWF  6E
1FAC:  MOVF   4E,W
1FAD:  MOVWF  6F
1FAE:  CLRF   70
1FAF:  BCF    0A.4
1FB0:  CALL   5D0
1FB1:  BSF    0A.4
1FB2:  MOVF   79,W
1FB3:  MOVWF  69
1FB4:  MOVF   78,W
1FB5:  MOVWF  68
1FB6:  MOVF   69,F
1FB7:  BTFSS  03.2
1FB8:  GOTO   7BE
1FB9:  MOVF   68,W
1FBA:  SUBLW  3A
1FBB:  BTFSS  03.0
1FBC:  GOTO   7BE
....................       { 
....................          alarma_int=TRUE; 
1FBD:  BSF    2F.5
....................       } 
....................  
....................       //Activamos el perro guardián 
....................       setup_wdt(WDT_ON); 
1FBE:  MOVLW  01
1FBF:  BSF    03.6
1FC0:  MOVWF  05
1FC1:  CLRF   77
1FC2:  MOVLW  07
1FC3:  BCF    03.6
1FC4:  CLRF   01
1FC5:  MOVLW  81
1FC6:  MOVWF  04
1FC7:  BCF    03.7
1FC8:  MOVF   00,W
1FC9:  ANDLW  F0
1FCA:  IORLW  07
1FCB:  MOVWF  00
1FCC:  CLRWDT
1FCD:  MOVF   00,W
1FCE:  ANDLW  F7
1FCF:  BTFSC  77.3
1FD0:  ANDLW  F0
1FD1:  IORWF  77,W
1FD2:  MOVWF  00
....................  
....................       //Ponemos a "dormir" al microcontrolador para que el gasto de energía sea menor 
....................       //Esto lo hacemos sólo si no se han levantado los flags de interrupción en estos segundos, 
....................       //ya que esto provocaría que se aplazase la gestión de la interrupción hasta que saltase el 
....................       //perro guardián. 
....................       if(!alarma_int && !lcd_int) 
1FD3:  BTFSC  2F.5
1FD4:  GOTO   7D7
1FD5:  BTFSS  2F.4
....................          sleep(); 
1FD6:  SLEEP
....................  
....................    } 
1FD7:  GOTO   330
....................  
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 
.................... //*************************************************************************** 
.................... //    Descripción de los métodos utilizados ordenados en orden alfabético 
.................... //*************************************************************************** 
.................... //Puede verse una explicación general de la función de cada método al principio del programa 
....................  
.................... void apagar_caldera() 
.................... { 
1FD8:  SLEEP
....................    int hora, minutos, segundos; //Variables para el tiempo 
....................  
....................    //Leemos el tiempo 
....................    PCF8583_read_datetime(&tiempo); 
*
17B1:  CLRF   6C
17B2:  MOVLW  4D
17B3:  MOVWF  6B
17B4:  BCF    0A.4
17B5:  BSF    0A.3
17B6:  CALL   495
17B7:  BSF    0A.4
17B8:  BCF    0A.3
....................  
....................    //Copiamos en las variables 
....................    hora = tiempo.hours; 
17B9:  MOVF   4F,W
17BA:  MOVWF  68
....................    minutos = tiempo.minutes; 
17BB:  MOVF   4E,W
17BC:  MOVWF  69
....................    segundos = tiempo.seconds; 
17BD:  MOVF   4D,W
17BE:  MOVWF  6A
....................  
....................    //Sumamos al tiempo total de encendido de la caldera el tiempo que ha estado encendida esta vez 
....................    t_total_caldera = t_total_caldera + diferencia_tiempo_sec(hora_caldera, minutos_caldera, segundos_caldera, hora, minutos, segundos); 
17BF:  MOVF   56,W
17C0:  MOVWF  6B
17C1:  MOVF   57,W
17C2:  MOVWF  6C
17C3:  MOVF   58,W
17C4:  MOVWF  6D
17C5:  MOVF   68,W
17C6:  MOVWF  6E
17C7:  MOVF   69,W
17C8:  MOVWF  6F
17C9:  MOVF   6A,W
17CA:  MOVWF  70
17CB:  BCF    0A.4
17CC:  BSF    0A.3
17CD:  CALL   5D0
17CE:  BSF    0A.4
17CF:  BCF    0A.3
17D0:  MOVF   78,W
17D1:  ADDWF  59,F
17D2:  MOVF   79,W
17D3:  BTFSC  03.0
17D4:  INCFSZ 79,W
17D5:  ADDWF  5A,F
....................  
....................    //Apagamos la caldera 
....................    caldera_encendida = FALSE; 
17D6:  BSF    03.6
17D7:  BCF    08.0
.................... } 
17D8:  BCF    03.6
17D9:  BSF    0A.3
17DA:  BSF    0A.4
17DB:  GOTO   72D (RETURN)
....................  
.................... //------------------------------------------------------------------------------------------------------------------------------------ 
....................  
.................... void apagar_sistema() 
.................... { 
....................    long minutos_trans;  //Minutos transcurridos desde el encendido del sistema 
....................    int temp; //Temperatura del hogar en ese momento (parte entera y decimal) 
....................  
....................  
....................    //Si llegamos al límite de la memoria, se resetea el indicador 
....................    //Por utilizar la memoria del PIC sólo contamos con 26 registros de fecha 
....................    if(num_registros > 26) 
*
0E72:  MOVF   5C,F
0E73:  BTFSS  03.2
0E74:  GOTO   679
0E75:  MOVF   5B,W
0E76:  SUBLW  1A
0E77:  BTFSC  03.0
0E78:  GOTO   67B
....................       num_registros = 0; 
0E79:  CLRF   5C
0E7A:  CLRF   5B
....................  
....................    //Leemos el tiempo actual 
....................    PCF8583_read_datetime(&tiempo); 
0E7B:  CLRF   6C
0E7C:  MOVLW  4D
0E7D:  MOVWF  6B
0E7E:  CALL   495
....................  
....................    //Calculamos los minutos transcurridos desde el encendido como una diferencia de tiempos 
....................    minutos_trans = (diferencia_tiempo_sec(hora_encendido, minutos_encendido,0, tiempo.hours, tiempo.minutes,0)/60); 
0E7F:  MOVF   54,W
0E80:  MOVWF  6B
0E81:  MOVF   55,W
0E82:  MOVWF  6C
0E83:  CLRF   6D
0E84:  MOVF   4F,W
0E85:  MOVWF  6E
0E86:  MOVF   4E,W
0E87:  MOVWF  6F
0E88:  CLRF   70
0E89:  CALL   5D0
0E8A:  MOVF   79,W
0E8B:  MOVWF  6C
0E8C:  MOVF   78,W
0E8D:  MOVWF  6B
0E8E:  MOVF   79,W
0E8F:  MOVWF  6E
0E90:  MOVF   78,W
0E91:  MOVWF  6D
0E92:  CLRF   70
0E93:  MOVLW  3C
0E94:  MOVWF  6F
0E95:  CALL   64D
0E96:  MOVF   79,W
0E97:  MOVWF  69
0E98:  MOVF   78,W
0E99:  MOVWF  68
....................  
....................    //Calculamos el valor de la última temperatura cosignada en función de la histéresis 
....................    if(temp_habitacion_superada) 
0E9A:  BTFSS  2F.1
0E9B:  GOTO   6C4
....................       temp = (unsigned int)(termostato+histeresis_caldera); 
0E9C:  BCF    03.1
0E9D:  MOVF   33,W
0E9E:  BSF    03.5
0E9F:  MOVWF  2A
0EA0:  BCF    03.5
0EA1:  MOVF   32,W
0EA2:  BSF    03.5
0EA3:  MOVWF  29
0EA4:  BCF    03.5
0EA5:  MOVF   31,W
0EA6:  BSF    03.5
0EA7:  MOVWF  28
0EA8:  BCF    03.5
0EA9:  MOVF   30,W
0EAA:  BSF    03.5
0EAB:  MOVWF  27
0EAC:  CLRF   2E
0EAD:  CLRF   2D
0EAE:  MOVLW  20
0EAF:  MOVWF  2C
0EB0:  MOVLW  81
0EB1:  MOVWF  2B
0EB2:  BCF    03.5
0EB3:  CALL   1CA
0EB4:  MOVF   7A,W
0EB5:  BSF    03.5
0EB6:  MOVWF  2F
0EB7:  MOVF   79,W
0EB8:  MOVWF  2E
0EB9:  MOVF   78,W
0EBA:  MOVWF  2D
0EBB:  MOVF   77,W
0EBC:  MOVWF  2C
0EBD:  BCF    0A.3
0EBE:  BCF    03.5
0EBF:  CALL   4B2
0EC0:  BSF    0A.3
0EC1:  MOVF   78,W
0EC2:  MOVWF  6A
....................    else 
0EC3:  GOTO   6D9
....................       temp = (unsigned int)termostato; 
0EC4:  MOVF   33,W
0EC5:  BSF    03.5
0EC6:  MOVWF  2F
0EC7:  BCF    03.5
0EC8:  MOVF   32,W
0EC9:  BSF    03.5
0ECA:  MOVWF  2E
0ECB:  BCF    03.5
0ECC:  MOVF   31,W
0ECD:  BSF    03.5
0ECE:  MOVWF  2D
0ECF:  BCF    03.5
0ED0:  MOVF   30,W
0ED1:  BSF    03.5
0ED2:  MOVWF  2C
0ED3:  BCF    0A.3
0ED4:  BCF    03.5
0ED5:  CALL   4B2
0ED6:  BSF    0A.3
0ED7:  MOVF   78,W
0ED8:  MOVWF  6A
....................  
....................    //Si la caldera estaba encendida, sumamos el último intervalo de encendido al tiempo total 
....................    if(caldera_encendida) 
0ED9:  BSF    03.6
0EDA:  BTFSS  08.0
0EDB:  GOTO   6F1
....................       t_total_caldera = t_total_caldera + diferencia_tiempo_sec(hora_caldera, minutos_caldera, segundos_caldera, tiempo.hours, tiempo.minutes, tiempo.seconds); 
0EDC:  BCF    03.6
0EDD:  MOVF   56,W
0EDE:  MOVWF  6B
0EDF:  MOVF   57,W
0EE0:  MOVWF  6C
0EE1:  MOVF   58,W
0EE2:  MOVWF  6D
0EE3:  MOVF   4F,W
0EE4:  MOVWF  6E
0EE5:  MOVF   4E,W
0EE6:  MOVWF  6F
0EE7:  MOVF   4D,W
0EE8:  MOVWF  70
0EE9:  CALL   5D0
0EEA:  MOVF   78,W
0EEB:  ADDWF  59,F
0EEC:  MOVF   79,W
0EED:  BTFSC  03.0
0EEE:  INCFSZ 79,W
0EEF:  ADDWF  5A,F
0EF0:  BSF    03.6
....................  
....................    //Calculamos el año en el que nos encontramos 
....................    if(anno_actual_0_to_3 != tiempo.year) 
0EF1:  BCF    03.6
0EF2:  MOVF   52,W
0EF3:  SUBWF  5E,W
0EF4:  BTFSC  03.2
0EF5:  GOTO   707
....................    { 
....................       //Si el año que teníamos almacenado no es igual que el que marca el reloj, 
....................       //debemos de actualizar las variables correspondientes. 
....................       //Suponemos que al menos se conecta el sistema una vez al año 
....................       anno_actual++; 
0EF6:  INCF   5D,F
....................       anno_actual_0_to_3++; 
0EF7:  INCF   5E,F
....................  
....................       //Guardamos los valores en memoria 
....................       data[0] = anno_actual; 
0EF8:  MOVF   5D,W
0EF9:  MOVWF  45
....................       data[1] = anno_actual_0_to_3; 
0EFA:  MOVF   5E,W
0EFB:  MOVWF  46
....................        
....................       graba_ee(eeprom_anno_actual, 2, data); 
0EFC:  CLRF   71
0EFD:  MOVLW  03
0EFE:  MOVWF  70
0EFF:  MOVLW  02
0F00:  MOVWF  72
0F01:  CLRF   74
0F02:  MOVLW  45
0F03:  MOVWF  73
0F04:  BCF    0A.3
0F05:  CALL   3BA
0F06:  BSF    0A.3
....................    } 
....................  
....................  
....................    //Almacenamos todos los datos requeridos 
....................    data[0] = tiempo.day; 
0F07:  MOVF   50,W
0F08:  MOVWF  45
....................    data[1] = tiempo.month; 
0F09:  MOVF   51,W
0F0A:  MOVWF  46
....................    data[2] = anno_actual; 
0F0B:  MOVF   5D,W
0F0C:  MOVWF  47
....................    data[3] = tiempo.hours; 
0F0D:  MOVF   4F,W
0F0E:  MOVWF  48
....................    data[4] = tiempo.minutes; 
0F0F:  MOVF   4E,W
0F10:  MOVWF  49
....................    data[5] = temp; 
0F11:  MOVF   6A,W
0F12:  MOVWF  4A
....................    data[6] = (unsigned int)minutos_trans; 
0F13:  MOVF   68,W
0F14:  MOVWF  4B
....................    data[7] = (unsigned int)(t_total_caldera/60); 
0F15:  MOVF   5A,W
0F16:  MOVWF  6E
0F17:  MOVF   59,W
0F18:  MOVWF  6D
0F19:  CLRF   70
0F1A:  MOVLW  3C
0F1B:  MOVWF  6F
0F1C:  CALL   64D
0F1D:  MOVF   78,W
0F1E:  MOVWF  4C
....................    graba_ee(eeprom_registros + (num_registros)*8 , 8, data);    
0F1F:  RLF    5B,W
0F20:  MOVWF  79
0F21:  RLF    5C,W
0F22:  MOVWF  7A
0F23:  RLF    79,F
0F24:  RLF    7A,F
0F25:  RLF    79,F
0F26:  RLF    7A,F
0F27:  MOVLW  F8
0F28:  ANDWF  79,F
0F29:  MOVF   79,W
0F2A:  ADDLW  10
0F2B:  MOVWF  6B
0F2C:  MOVF   7A,W
0F2D:  MOVWF  6C
0F2E:  BTFSC  03.0
0F2F:  INCF   6C,F
0F30:  MOVF   6C,W
0F31:  MOVWF  71
0F32:  MOVF   6B,W
0F33:  MOVWF  70
0F34:  MOVLW  08
0F35:  MOVWF  72
0F36:  CLRF   74
0F37:  MOVLW  45
0F38:  MOVWF  73
0F39:  BCF    0A.3
0F3A:  CALL   3BA
0F3B:  BSF    0A.3
....................  
....................    //Aumentamos en uno el número de registros 
....................    num_registros++; 
0F3C:  INCF   5B,F
0F3D:  BTFSC  03.2
0F3E:  INCF   5C,F
....................  
....................    //Guardamos el número de registros en memoria descomponiendo en dos el número 
....................    data[0] = (int)(num_registros/256); 
0F3F:  MOVF   5C,W
0F40:  CLRF   7A
0F41:  MOVWF  45
....................    data[1] = (int)(num_registros - data[0]*256); 
0F42:  MOVF   45,W
0F43:  MOVWF  7A
0F44:  MOVLW  00
0F45:  SUBWF  5B,W
0F46:  MOVWF  77
0F47:  MOVF   45,W
0F48:  BTFSS  03.0
0F49:  INCFSZ 45,W
0F4A:  GOTO   74D
0F4B:  MOVF   5C,W
0F4C:  GOTO   74E
0F4D:  SUBWF  5C,W
0F4E:  MOVWF  7A
0F4F:  MOVF   77,W
0F50:  MOVWF  46
....................  
....................    graba_ee(eeprom_num_registros, 2, data); 
0F51:  CLRF   71
0F52:  MOVLW  01
0F53:  MOVWF  70
0F54:  MOVLW  02
0F55:  MOVWF  72
0F56:  CLRF   74
0F57:  MOVLW  45
0F58:  MOVWF  73
0F59:  BCF    0A.3
0F5A:  CALL   3BA
0F5B:  BSF    0A.3
....................  
....................    //Finalmente, apagamos el sistema 
....................    sistema_encendido = FALSE; 
0F5C:  BSF    03.6
0F5D:  BCF    08.2
.................... } 
0F5E:  BCF    03.6
0F5F:  RETLW  00
....................  
.................... //------------------------------------------------------------------------------------------------------------------------------------ 
....................  
.................... int buscar_numero(int led_unidades, int min, int max, int valor_inicial){ 
....................    signed int input; 
....................  
....................    //Iniciamos al valor indicado 
....................    input = valor_inicial; 
*
1081:  MOVF   6B,W
1082:  MOVWF  6C
....................  
....................    //Activamos el cursor de la pantalla 
....................    lcd_send_byte(LCD_ORDEN, LCD_CURSOR); 
1083:  BSF    03.5
1084:  CLRF   21
1085:  MOVLW  0E
1086:  MOVWF  22
1087:  BCF    0A.4
1088:  BCF    03.5
1089:  CALL   1DE
108A:  BSF    0A.4
....................  
....................    //Se muestra por pantalla 
....................    lcd_gotoxy(led_unidades,2); 
108B:  MOVF   68,W
108C:  MOVWF  7C
108D:  MOVLW  02
108E:  MOVWF  7D
108F:  BCF    0A.4
1090:  BSF    0A.3
1091:  CALL   760
1092:  BSF    0A.4
1093:  BCF    0A.3
....................    //Si el número es menor que 10, le añadimos antes un 0 
....................    if(input<10) 
1094:  BTFSC  6C.7
1095:  GOTO   09A
1096:  MOVF   6C,W
1097:  SUBLW  09
1098:  BTFSS  03.0
1099:  GOTO   0A1
....................       printf(lcd_putc, "0"); 
109A:  MOVLW  30
109B:  MOVWF  76
109C:  BCF    0A.4
109D:  BSF    0A.3
109E:  CALL   776
109F:  BSF    0A.4
10A0:  BCF    0A.3
....................    printf(lcd_putc,"%i",input); 
10A1:  MOVF   6C,W
10A2:  MOVWF  6D
10A3:  MOVLW  1F
10A4:  MOVWF  6E
10A5:  CALL   000
....................    //Regresamos el cursor a su posición 
....................    lcd_gotoxy(led_unidades,2); 
10A6:  MOVF   68,W
10A7:  MOVWF  7C
10A8:  MOVLW  02
10A9:  MOVWF  7D
10AA:  BCF    0A.4
10AB:  BSF    0A.3
10AC:  CALL   760
10AD:  BSF    0A.4
10AE:  BCF    0A.3
....................  
....................    while(1) 
....................    { 
....................       if(!mas) 
10AF:  BSF    03.6
10B0:  BTFSC  07.0
10B1:  GOTO   0E0
....................       { 
....................          //Si se pulsa el botón de +, se aumenta el valor de input 
....................          input++; 
10B2:  BCF    03.6
10B3:  INCF   6C,F
....................          //Si llegamos al límite de los valores, reseteamos 
....................          if(input>max) 
10B4:  BTFSC  6C.7
10B5:  GOTO   0BC
10B6:  MOVF   6C,W
10B7:  SUBWF  6A,W
10B8:  BTFSC  03.0
10B9:  GOTO   0BC
....................             input = min; 
10BA:  MOVF   69,W
10BB:  MOVWF  6C
....................          //Si es un número menor que 10, añadimos un 0 antes 
....................          if(input<10) 
10BC:  BTFSC  6C.7
10BD:  GOTO   0C2
10BE:  MOVF   6C,W
10BF:  SUBLW  09
10C0:  BTFSS  03.0
10C1:  GOTO   0C9
....................             printf(lcd_putc,"0"); 
10C2:  MOVLW  30
10C3:  MOVWF  76
10C4:  BCF    0A.4
10C5:  BSF    0A.3
10C6:  CALL   776
10C7:  BSF    0A.4
10C8:  BCF    0A.3
....................          //Se muestra por pantalla 
....................          printf(lcd_putc,"%i",input); 
10C9:  MOVF   6C,W
10CA:  MOVWF  6D
10CB:  MOVLW  1F
10CC:  MOVWF  6E
10CD:  CALL   000
....................          //Regresamos el cursor a su posición 
....................          lcd_gotoxy(led_unidades,2); 
10CE:  MOVF   68,W
10CF:  MOVWF  7C
10D0:  MOVLW  02
10D1:  MOVWF  7D
10D2:  BCF    0A.4
10D3:  BSF    0A.3
10D4:  CALL   760
10D5:  BSF    0A.4
10D6:  BCF    0A.3
....................          //Esperamos a que se levante la tecla 
....................          while(!mas){} 
10D7:  BSF    03.6
10D8:  BTFSC  07.0
10D9:  GOTO   0DD
10DA:  BCF    03.6
10DB:  GOTO   0D7
10DC:  BSF    03.6
....................          continue; 
10DD:  BCF    03.6
10DE:  GOTO   0AF
10DF:  BSF    03.6
....................       } 
....................       if(!menos) 
10E0:  BTFSC  07.1
10E1:  GOTO   110
....................       { 
....................          //Si se pulsa el botón de -, se decrementa el valor de input 
....................          input--; 
10E2:  BCF    03.6
10E3:  DECF   6C,F
....................          //Si llegamos al límite de las opciones, reseteamos 
....................          if(input<min) 
10E4:  BTFSC  6C.7
10E5:  GOTO   0EA
10E6:  MOVF   69,W
10E7:  SUBWF  6C,W
10E8:  BTFSC  03.0
10E9:  GOTO   0EC
....................             input = max; 
10EA:  MOVF   6A,W
10EB:  MOVWF  6C
....................          //Si es un número menor que 10, añadimos un 0 antes 
....................          if(input<10) 
10EC:  BTFSC  6C.7
10ED:  GOTO   0F2
10EE:  MOVF   6C,W
10EF:  SUBLW  09
10F0:  BTFSS  03.0
10F1:  GOTO   0F9
....................             printf(lcd_putc,"0"); 
10F2:  MOVLW  30
10F3:  MOVWF  76
10F4:  BCF    0A.4
10F5:  BSF    0A.3
10F6:  CALL   776
10F7:  BSF    0A.4
10F8:  BCF    0A.3
....................          //Se muestra por pantalla 
....................          printf(lcd_putc,"%i",input); 
10F9:  MOVF   6C,W
10FA:  MOVWF  6D
10FB:  MOVLW  1F
10FC:  MOVWF  6E
10FD:  CALL   000
....................          //Regresamos el cursor a su posición 
....................          lcd_gotoxy(led_unidades,2); 
10FE:  MOVF   68,W
10FF:  MOVWF  7C
1100:  MOVLW  02
1101:  MOVWF  7D
1102:  BCF    0A.4
1103:  BSF    0A.3
1104:  CALL   760
1105:  BSF    0A.4
1106:  BCF    0A.3
....................          //Esperamos a que se levante la tecla 
....................          while(!menos){} 
1107:  BSF    03.6
1108:  BTFSC  07.1
1109:  GOTO   10D
110A:  BCF    03.6
110B:  GOTO   107
110C:  BSF    03.6
....................          continue; 
110D:  BCF    03.6
110E:  GOTO   0AF
110F:  BSF    03.6
....................       } 
....................       if(!si) 
1110:  BTFSC  07.2
1111:  GOTO   115
....................       { 
....................          //Esperamos a que se suelte la tecla 
....................          while(!si){} 
1112:  BTFSS  07.2
1113:  GOTO   112
....................          break; 
1114:  GOTO   118
....................       }       
....................    } 
1115:  BCF    03.6
1116:  GOTO   0AF
1117:  BSF    03.6
....................  
....................    //Inhabilitamos el cursor de nuevo 
....................    lcd_send_byte(LCD_ORDEN, LCD_NO_CURSOR); 
1118:  BSF    03.5
1119:  BCF    03.6
111A:  CLRF   21
111B:  MOVLW  0C
111C:  MOVWF  22
111D:  BCF    0A.4
111E:  BCF    03.5
111F:  CALL   1DE
1120:  BSF    0A.4
....................  
....................    //Devolvemos el valor correspondiente 
....................    return input; 
1121:  MOVF   6C,W
1122:  MOVWF  78
.................... } 
1123:  RETLW  00
....................  
.................... //------------------------------------------------------------------------------------------------------------------------------------ 
....................  
.................... int buscar_numero_rs232(){ 
....................    char c[3]; //Cadena que contendrá los números en caracteres 
....................  
....................    //Iniciamos los caracteres a valores nulos que no se correspondan con números 
....................    //Además, esto nos servirá para que c[2] marque el fin de la cadena a la hora de aplicar 
....................    //el método atoi(). 
....................    c[0]=c[1]=c[2]='\0'; 
*
034B:  CLRF   72
034C:  MOVF   72,W
034D:  MOVWF  71
034E:  MOVWF  70
....................  
....................    //Leemos la primera cifra del número 
....................    while(!isdigit(c[0])) 
....................       c[0]=getch(); 
034F:  MOVF   70,W
0350:  SUBLW  2F
0351:  BTFSC  03.0
0352:  GOTO   357
0353:  MOVF   70,W
0354:  SUBLW  39
0355:  BTFSC  03.0
0356:  GOTO   35D
0357:  CLRWDT
0358:  BTFSS  0C.5
0359:  GOTO   357
035A:  MOVF   1A,W
035B:  MOVWF  70
035C:  GOTO   34F
....................    //Imprimimos la primera cifra 
....................    printf("%c", c[0]); 
035D:  MOVF   70,W
035E:  CLRWDT
035F:  BTFSS  0C.4
0360:  GOTO   35E
0361:  MOVWF  19
....................  
....................    //Leemos la segunda cifra del número, procediendo de la misma manera 
....................    while(!isdigit(c[1])) 
....................       c[1]=getch(); 
0362:  MOVF   71,W
0363:  SUBLW  2F
0364:  BTFSC  03.0
0365:  GOTO   36A
0366:  MOVF   71,W
0367:  SUBLW  39
0368:  BTFSC  03.0
0369:  GOTO   370
036A:  CLRWDT
036B:  BTFSS  0C.5
036C:  GOTO   36A
036D:  MOVF   1A,W
036E:  MOVWF  71
036F:  GOTO   362
....................    printf("%c", c[1]); 
0370:  MOVF   71,W
0371:  CLRWDT
0372:  BTFSS  0C.4
0373:  GOTO   371
0374:  MOVWF  19
....................  
....................    //Transformamos a entero la cadena y la devolvemos 
....................    return atoi(c); 
0375:  CLRF   74
0376:  MOVLW  70
0377:  MOVWF  73
0378:  CALL   266
0379:  MOVF   78,W
....................  
.................... } 
037A:  RETLW  00
....................  
.................... //------------------------------------------------------------------------------------------------------------------------------------ 
....................  
.................... int comp_caldera() 
.................... { 
....................    //Suponemos una variación de la temperatura del agua en la caldera de t_max_calderaºC 
....................    //a t_min_calderaºC, con una precisión que depende del potenciómetro. 
....................  
....................    //Variables para registrar el termostato y la temperatura de la caldera 
....................    float termo, temp; 
....................  
....................    //Establecemos como entrada analógica a analizar la del termostato 
....................    set_adc_channel(termostato_caldera); 
*
0B70:  MOVLW  0C
0B71:  MOVWF  78
0B72:  MOVF   1F,W
0B73:  ANDLW  C3
0B74:  IORWF  78,W
0B75:  MOVWF  1F
....................    delay_us(10);  //Retraso para posibilitar la lectura 
0B76:  CLRWDT
0B77:  MOVLW  06
0B78:  MOVWF  77
0B79:  DECFSZ 77,F
0B7A:  GOTO   379
....................    //Transformamos el valor analógico leído en la escala utilizada por el termostato 
....................    termo = t_min_caldera + ((t_max_caldera-t_min_caldera)*(float)read_adc())/AD_num_valores; 
0B7B:  BSF    1F.1
0B7C:  BTFSC  1F.1
0B7D:  GOTO   37C
0B7E:  MOVF   1E,W
0B7F:  BSF    03.5
0B80:  CLRF   28
0B81:  MOVWF  27
0B82:  BCF    03.5
0B83:  CALL   310
0B84:  BSF    03.5
0B85:  CLRF   38
0B86:  CLRF   37
0B87:  MOVLW  48
0B88:  MOVWF  36
0B89:  MOVLW  85
0B8A:  MOVWF  35
0B8B:  MOVF   7A,W
0B8C:  MOVWF  3C
0B8D:  MOVF   79,W
0B8E:  MOVWF  3B
0B8F:  MOVF   78,W
0B90:  MOVWF  3A
0B91:  MOVF   77,W
0B92:  MOVWF  39
0B93:  BCF    0A.3
0B94:  BCF    03.5
0B95:  CALL   43B
0B96:  BSF    0A.3
0B97:  MOVF   77,W
0B98:  MOVWF  70
0B99:  MOVF   78,W
0B9A:  MOVWF  71
0B9B:  MOVF   79,W
0B9C:  MOVWF  72
0B9D:  MOVF   7A,W
0B9E:  MOVWF  73
0B9F:  BSF    03.5
0BA0:  MOVWF  2A
0BA1:  MOVF   79,W
0BA2:  MOVWF  29
0BA3:  MOVF   78,W
0BA4:  MOVWF  28
0BA5:  MOVF   77,W
0BA6:  MOVWF  27
0BA7:  CLRF   2E
0BA8:  CLRF   2D
0BA9:  MOVLW  7F
0BAA:  MOVWF  2C
0BAB:  MOVLW  86
0BAC:  MOVWF  2B
0BAD:  BCF    03.5
0BAE:  CALL   027
0BAF:  BCF    03.1
0BB0:  BSF    03.5
0BB1:  CLRF   2A
0BB2:  CLRF   29
0BB3:  CLRF   28
0BB4:  CLRF   27
0BB5:  MOVF   7A,W
0BB6:  MOVWF  2E
0BB7:  MOVF   79,W
0BB8:  MOVWF  2D
0BB9:  MOVF   78,W
0BBA:  MOVWF  2C
0BBB:  MOVF   77,W
0BBC:  MOVWF  2B
0BBD:  BCF    03.5
0BBE:  CALL   1CA
0BBF:  MOVF   7A,W
0BC0:  MOVWF  6B
0BC1:  MOVF   79,W
0BC2:  MOVWF  6A
0BC3:  MOVF   78,W
0BC4:  MOVWF  69
0BC5:  MOVF   77,W
0BC6:  MOVWF  68
....................  
....................    //Establecemos como entrada analógica a analizar la de la temperatura del agua 
....................    set_adc_channel(temperatura_caldera); 
0BC7:  MOVLW  08
0BC8:  MOVWF  78
0BC9:  MOVF   1F,W
0BCA:  ANDLW  C3
0BCB:  IORWF  78,W
0BCC:  MOVWF  1F
....................    delay_us(10); //Retraso para posibilitar la lectura 
0BCD:  CLRWDT
0BCE:  MOVLW  06
0BCF:  MOVWF  77
0BD0:  DECFSZ 77,F
0BD1:  GOTO   3D0
....................    //Transformamos el valor analógico leído a la escala utlizada en la temperatura 
....................    temp = t_min_caldera + ((t_max_caldera-t_min_caldera)*(float)read_adc())/AD_num_valores; 
0BD2:  BSF    1F.1
0BD3:  BTFSC  1F.1
0BD4:  GOTO   3D3
0BD5:  MOVF   1E,W
0BD6:  BSF    03.5
0BD7:  CLRF   28
0BD8:  MOVWF  27
0BD9:  BCF    03.5
0BDA:  CALL   310
0BDB:  BSF    03.5
0BDC:  CLRF   38
0BDD:  CLRF   37
0BDE:  MOVLW  48
0BDF:  MOVWF  36
0BE0:  MOVLW  85
0BE1:  MOVWF  35
0BE2:  MOVF   7A,W
0BE3:  MOVWF  3C
0BE4:  MOVF   79,W
0BE5:  MOVWF  3B
0BE6:  MOVF   78,W
0BE7:  MOVWF  3A
0BE8:  MOVF   77,W
0BE9:  MOVWF  39
0BEA:  BCF    0A.3
0BEB:  BCF    03.5
0BEC:  CALL   43B
0BED:  BSF    0A.3
0BEE:  MOVF   77,W
0BEF:  MOVWF  70
0BF0:  MOVF   78,W
0BF1:  MOVWF  71
0BF2:  MOVF   79,W
0BF3:  MOVWF  72
0BF4:  MOVF   7A,W
0BF5:  MOVWF  73
0BF6:  BSF    03.5
0BF7:  MOVWF  2A
0BF8:  MOVF   79,W
0BF9:  MOVWF  29
0BFA:  MOVF   78,W
0BFB:  MOVWF  28
0BFC:  MOVF   77,W
0BFD:  MOVWF  27
0BFE:  CLRF   2E
0BFF:  CLRF   2D
0C00:  MOVLW  7F
0C01:  MOVWF  2C
0C02:  MOVLW  86
0C03:  MOVWF  2B
0C04:  BCF    03.5
0C05:  CALL   027
0C06:  BCF    03.1
0C07:  BSF    03.5
0C08:  CLRF   2A
0C09:  CLRF   29
0C0A:  CLRF   28
0C0B:  CLRF   27
0C0C:  MOVF   7A,W
0C0D:  MOVWF  2E
0C0E:  MOVF   79,W
0C0F:  MOVWF  2D
0C10:  MOVF   78,W
0C11:  MOVWF  2C
0C12:  MOVF   77,W
0C13:  MOVWF  2B
0C14:  BCF    03.5
0C15:  CALL   1CA
0C16:  MOVF   7A,W
0C17:  MOVWF  6F
0C18:  MOVF   79,W
0C19:  MOVWF  6E
0C1A:  MOVF   78,W
0C1B:  MOVWF  6D
0C1C:  MOVF   77,W
0C1D:  MOVWF  6C
....................  
....................    //Comparamos ambas temperaturas teniendo en cuenta la histéresis de la caldera 
....................    if(temperatura_caldera_superada) 
0C1E:  BTFSS  2F.0
0C1F:  GOTO   45D
....................    { 
....................       if(temp >= termo-histeresis_caldera) 
0C20:  BSF    03.1
0C21:  MOVF   6B,W
0C22:  BSF    03.5
0C23:  MOVWF  2A
0C24:  BCF    03.5
0C25:  MOVF   6A,W
0C26:  BSF    03.5
0C27:  MOVWF  29
0C28:  BCF    03.5
0C29:  MOVF   69,W
0C2A:  BSF    03.5
0C2B:  MOVWF  28
0C2C:  BCF    03.5
0C2D:  MOVF   68,W
0C2E:  BSF    03.5
0C2F:  MOVWF  27
0C30:  CLRF   2E
0C31:  CLRF   2D
0C32:  MOVLW  20
0C33:  MOVWF  2C
0C34:  MOVLW  81
0C35:  MOVWF  2B
0C36:  BCF    03.5
0C37:  CALL   1CA
0C38:  MOVF   7A,W
0C39:  MOVWF  73
0C3A:  MOVF   79,W
0C3B:  MOVWF  72
0C3C:  MOVF   78,W
0C3D:  MOVWF  71
0C3E:  MOVF   77,W
0C3F:  MOVWF  70
0C40:  MOVF   6F,W
0C41:  BSF    03.5
0C42:  MOVWF  23
0C43:  BCF    03.5
0C44:  MOVF   6E,W
0C45:  BSF    03.5
0C46:  MOVWF  22
0C47:  BCF    03.5
0C48:  MOVF   6D,W
0C49:  BSF    03.5
0C4A:  MOVWF  21
0C4B:  BCF    03.5
0C4C:  MOVF   6C,W
0C4D:  BSF    03.5
0C4E:  MOVWF  20
0C4F:  BCF    03.5
0C50:  CALL   32F
0C51:  BTFSC  03.0
0C52:  GOTO   455
0C53:  BTFSS  03.2
0C54:  GOTO   459
....................          return TRUE; 
0C55:  MOVLW  01
0C56:  MOVWF  78
0C57:  GOTO   481
....................       else 
0C58:  GOTO   45C
....................          return FALSE; 
0C59:  MOVLW  00
0C5A:  MOVWF  78
0C5B:  GOTO   481
....................    }else 
0C5C:  GOTO   481
....................    { 
....................       if(temp >= termo) 
0C5D:  MOVF   6B,W
0C5E:  MOVWF  73
0C5F:  MOVF   6A,W
0C60:  MOVWF  72
0C61:  MOVF   69,W
0C62:  MOVWF  71
0C63:  MOVF   68,W
0C64:  MOVWF  70
0C65:  MOVF   6F,W
0C66:  BSF    03.5
0C67:  MOVWF  23
0C68:  BCF    03.5
0C69:  MOVF   6E,W
0C6A:  BSF    03.5
0C6B:  MOVWF  22
0C6C:  BCF    03.5
0C6D:  MOVF   6D,W
0C6E:  BSF    03.5
0C6F:  MOVWF  21
0C70:  BCF    03.5
0C71:  MOVF   6C,W
0C72:  BSF    03.5
0C73:  MOVWF  20
0C74:  BCF    03.5
0C75:  CALL   32F
0C76:  BTFSC  03.0
0C77:  GOTO   47A
0C78:  BTFSS  03.2
0C79:  GOTO   47E
....................          return TRUE; 
0C7A:  MOVLW  01
0C7B:  MOVWF  78
0C7C:  GOTO   481
....................       else 
0C7D:  GOTO   481
....................          return FALSE; 
0C7E:  MOVLW  00
0C7F:  MOVWF  78
0C80:  GOTO   481
....................    } 
.................... } 
0C81:  RETLW  00
....................  
.................... //------------------------------------------------------------------------------------------------------------------------------------ 
....................  
.................... int1 comprobar_temperatura() 
.................... { 
....................    //Leemos la temperatura 
....................    temperatura = ds1820_read(); 
*
193B:  BCF    0A.4
193C:  CALL   0F3
193D:  BSF    0A.4
193E:  MOVF   7A,W
193F:  MOVWF  3B
1940:  MOVF   79,W
1941:  MOVWF  3A
1942:  MOVF   78,W
1943:  MOVWF  39
1944:  MOVF   77,W
1945:  MOVWF  38
....................  
....................    //Mostramos la información en la pantalla lcd 
....................    mostrar_temperatura(); 
....................  
....................    if(ds1820_termostato()) 
*
19A1:  BCF    0A.4
19A2:  CALL   161
19A3:  BSF    0A.4
19A4:  MOVF   78,F
19A5:  BTFSC  03.2
19A6:  GOTO   1F5
....................    { 
....................       //Si la temperatura es menor que la del termostato, devolvemos TRUE 
....................       if(temp_habitacion_superada) 
19A7:  BTFSS  2F.1
19A8:  GOTO   1F1
....................       { 
....................          //Si la temperatura antes era mayor, indicamos el cambio en el flag 
....................          temp_habitacion_superada = FALSE; 
19A9:  BCF    2F.1
....................          //Tenemos en cuenta la histéresis para el nuevo valor del termostato 
....................          termostato = termostato + histeresis_vivienda; 
19AA:  BCF    03.1
19AB:  MOVF   33,W
19AC:  BSF    03.5
19AD:  MOVWF  2A
19AE:  BCF    03.5
19AF:  MOVF   32,W
19B0:  BSF    03.5
19B1:  MOVWF  29
19B2:  BCF    03.5
19B3:  MOVF   31,W
19B4:  BSF    03.5
19B5:  MOVWF  28
19B6:  BCF    03.5
19B7:  MOVF   30,W
19B8:  BSF    03.5
19B9:  MOVWF  27
19BA:  BCF    03.5
19BB:  MOVF   3F,W
19BC:  BSF    03.5
19BD:  MOVWF  2E
19BE:  BCF    03.5
19BF:  MOVF   3E,W
19C0:  BSF    03.5
19C1:  MOVWF  2D
19C2:  BCF    03.5
19C3:  MOVF   3D,W
19C4:  BSF    03.5
19C5:  MOVWF  2C
19C6:  BCF    03.5
19C7:  MOVF   3C,W
19C8:  BSF    03.5
19C9:  MOVWF  2B
19CA:  BCF    0A.4
19CB:  BCF    03.5
19CC:  CALL   1CA
19CD:  BSF    0A.4
19CE:  MOVF   7A,W
19CF:  MOVWF  33
19D0:  MOVF   79,W
19D1:  MOVWF  32
19D2:  MOVF   78,W
19D3:  MOVWF  31
19D4:  MOVF   77,W
19D5:  MOVWF  30
....................          //Guardamos la información también en el sensor de temperatura 
....................          //Ponemos como TH una temperatura muy grande (127.5ºC) 
....................          ds1820_establecer_TH_TL(127.5, termostato); 
19D6:  CLRF   73
19D7:  CLRF   72
19D8:  MOVLW  7F
19D9:  MOVWF  71
19DA:  MOVLW  85
19DB:  MOVWF  70
19DC:  MOVF   33,W
19DD:  BSF    03.5
19DE:  MOVWF  23
19DF:  BCF    03.5
19E0:  MOVF   32,W
19E1:  BSF    03.5
19E2:  MOVWF  22
19E3:  BCF    03.5
19E4:  MOVF   31,W
19E5:  BSF    03.5
19E6:  MOVWF  21
19E7:  BCF    03.5
19E8:  MOVF   30,W
19E9:  BSF    03.5
19EA:  MOVWF  20
19EB:  BCF    0A.4
19EC:  BCF    0A.3
19ED:  BCF    03.5
19EE:  CALL   4D3
19EF:  BSF    0A.4
19F0:  BSF    0A.3
....................       } 
....................       return TRUE; 
19F1:  MOVLW  01
19F2:  MOVWF  78
19F3:  GOTO   242
....................    } 
....................    else 
19F4:  GOTO   242
....................    { 
....................       //Si la temperatura es mayor que la del termostato, devolvemos FALSE 
....................       if(!temp_habitacion_superada) 
19F5:  BTFSC  2F.1
19F6:  GOTO   23F
....................       { 
....................          //Si antes era menor, cambiamos el flag 
....................          temp_habitacion_superada = TRUE; 
19F7:  BSF    2F.1
....................          //Guardamos el nuevo valor del termostato teniendo en cuenta la histéresis 
....................          termostato = termostato - histeresis_vivienda; 
19F8:  BSF    03.1
19F9:  MOVF   33,W
19FA:  BSF    03.5
19FB:  MOVWF  2A
19FC:  BCF    03.5
19FD:  MOVF   32,W
19FE:  BSF    03.5
19FF:  MOVWF  29
1A00:  BCF    03.5
1A01:  MOVF   31,W
1A02:  BSF    03.5
1A03:  MOVWF  28
1A04:  BCF    03.5
1A05:  MOVF   30,W
1A06:  BSF    03.5
1A07:  MOVWF  27
1A08:  BCF    03.5
1A09:  MOVF   3F,W
1A0A:  BSF    03.5
1A0B:  MOVWF  2E
1A0C:  BCF    03.5
1A0D:  MOVF   3E,W
1A0E:  BSF    03.5
1A0F:  MOVWF  2D
1A10:  BCF    03.5
1A11:  MOVF   3D,W
1A12:  BSF    03.5
1A13:  MOVWF  2C
1A14:  BCF    03.5
1A15:  MOVF   3C,W
1A16:  BSF    03.5
1A17:  MOVWF  2B
1A18:  BCF    0A.4
1A19:  BCF    03.5
1A1A:  CALL   1CA
1A1B:  BSF    0A.4
1A1C:  MOVF   7A,W
1A1D:  MOVWF  33
1A1E:  MOVF   79,W
1A1F:  MOVWF  32
1A20:  MOVF   78,W
1A21:  MOVWF  31
1A22:  MOVF   77,W
1A23:  MOVWF  30
....................          //Guardamos la información también en el sensor de temperatura 
....................          //Ponemos como TH una temperatura muy grande (127.5ºC) 
....................          ds1820_establecer_TH_TL(127.5, termostato); 
1A24:  CLRF   73
1A25:  CLRF   72
1A26:  MOVLW  7F
1A27:  MOVWF  71
1A28:  MOVLW  85
1A29:  MOVWF  70
1A2A:  MOVF   33,W
1A2B:  BSF    03.5
1A2C:  MOVWF  23
1A2D:  BCF    03.5
1A2E:  MOVF   32,W
1A2F:  BSF    03.5
1A30:  MOVWF  22
1A31:  BCF    03.5
1A32:  MOVF   31,W
1A33:  BSF    03.5
1A34:  MOVWF  21
1A35:  BCF    03.5
1A36:  MOVF   30,W
1A37:  BSF    03.5
1A38:  MOVWF  20
1A39:  BCF    0A.4
1A3A:  BCF    0A.3
1A3B:  BCF    03.5
1A3C:  CALL   4D3
1A3D:  BSF    0A.4
1A3E:  BSF    0A.3
....................       } 
....................       return FALSE; 
1A3F:  MOVLW  00
1A40:  MOVWF  78
1A41:  GOTO   242
....................    } 
.................... } 
1A42:  BSF    0A.3
1A43:  BSF    0A.4
1A44:  GOTO   731 (RETURN)
....................  
.................... //------------------------------------------------------------------------------------------------------------------------------------ 
....................  
.................... long diferencia_tiempo_sec(int hora1, int min1, int sec1, int hora2, int min2, int sec2) 
.................... { 
....................    unsigned long dif; 
....................    unsigned long dif2; 
....................     
....................    //Si la hora y los minutos son iguales, devolvemos simplemente la diferencia en segundos 
....................    if(hora1==hora2 && min1==min2) 
*
0DD0:  MOVF   6E,W
0DD1:  SUBWF  6B,W
0DD2:  BTFSS  03.2
0DD3:  GOTO   5E1
0DD4:  MOVF   6F,W
0DD5:  SUBWF  6C,W
0DD6:  BTFSS  03.2
0DD7:  GOTO   5E1
....................       dif = abs(sec2-sec1); 
0DD8:  MOVF   6D,W
0DD9:  SUBWF  70,W
0DDA:  BSF    03.5
0DDB:  MOVWF  20
0DDC:  CLRF   72
0DDD:  MOVF   20,W
0DDE:  MOVWF  71
....................    else 
0DDF:  GOTO   647
0DE0:  BCF    03.5
....................    { 
....................       //Si no habrá que tener en cuenta también la diferencia entre horas y minutos 
....................       dif2 = ((long)hora2*60 + (long)min2) - ((long)hora1*60 + (long)min1); 
0DE1:  BSF    03.5
0DE2:  CLRF   21
0DE3:  BCF    03.5
0DE4:  MOVF   6E,W
0DE5:  BSF    03.5
0DE6:  MOVWF  20
0DE7:  MOVF   21,W
0DE8:  MOVWF  28
0DE9:  MOVF   20,W
0DEA:  MOVWF  27
0DEB:  CLRF   2A
0DEC:  MOVLW  3C
0DED:  MOVWF  29
0DEE:  BCF    03.5
0DEF:  CALL   5B9
0DF0:  MOVF   79,W
0DF1:  BSF    03.5
0DF2:  MOVWF  22
0DF3:  MOVF   78,W
0DF4:  MOVWF  21
0DF5:  CLRF   7A
0DF6:  BCF    03.5
0DF7:  MOVF   6F,W
0DF8:  BSF    03.5
0DF9:  ADDWF  21,W
0DFA:  MOVWF  23
0DFB:  MOVF   22,W
0DFC:  MOVWF  24
0DFD:  MOVF   7A,W
0DFE:  BTFSC  03.0
0DFF:  INCFSZ 7A,W
0E00:  ADDWF  24,F
0E01:  CLRF   26
0E02:  BCF    03.5
0E03:  MOVF   6B,W
0E04:  BSF    03.5
0E05:  MOVWF  25
0E06:  MOVF   26,W
0E07:  MOVWF  28
0E08:  MOVF   25,W
0E09:  MOVWF  27
0E0A:  CLRF   2A
0E0B:  MOVLW  3C
0E0C:  MOVWF  29
0E0D:  BCF    03.5
0E0E:  CALL   5B9
0E0F:  MOVF   79,W
0E10:  BSF    03.5
0E11:  MOVWF  27
0E12:  MOVF   78,W
0E13:  MOVWF  26
0E14:  CLRF   7A
0E15:  BCF    03.5
0E16:  MOVF   6C,W
0E17:  BSF    03.5
0E18:  ADDWF  26,W
0E19:  MOVWF  78
0E1A:  MOVF   27,W
0E1B:  BTFSC  03.0
0E1C:  INCFSZ 27,W
0E1D:  ADDWF  7A,F
0E1E:  MOVF   78,W
0E1F:  SUBWF  23,W
0E20:  MOVWF  73
0E21:  MOVF   24,W
0E22:  MOVWF  74
0E23:  MOVF   7A,W
0E24:  BTFSS  03.0
0E25:  INCFSZ 7A,W
0E26:  SUBWF  74,F
....................       //No hacemos la diferencia en segundos directamente porque el long no da de sí 
....................       dif = dif2*60 + sec2 - sec1; 
0E27:  MOVF   74,W
0E28:  MOVWF  28
0E29:  MOVF   73,W
0E2A:  MOVWF  27
0E2B:  CLRF   2A
0E2C:  MOVLW  3C
0E2D:  MOVWF  29
0E2E:  BCF    03.5
0E2F:  CALL   5B9
0E30:  MOVF   79,W
0E31:  BSF    03.5
0E32:  MOVWF  21
0E33:  MOVF   78,W
0E34:  MOVWF  20
0E35:  MOVF   70,W
0E36:  ADDWF  20,W
0E37:  MOVWF  22
0E38:  MOVF   21,W
0E39:  MOVWF  23
0E3A:  BTFSC  03.0
0E3B:  INCF   23,F
0E3C:  BCF    03.5
0E3D:  MOVF   6D,W
0E3E:  BSF    03.5
0E3F:  SUBWF  22,W
0E40:  MOVWF  71
0E41:  MOVF   23,W
0E42:  MOVWF  72
0E43:  MOVLW  00
0E44:  BTFSS  03.0
0E45:  MOVLW  01
0E46:  SUBWF  72,F
....................    }    
....................  
....................    //Devolvemos el resultado 
....................    return dif; 
0E47:  MOVF   71,W
0E48:  MOVWF  78
0E49:  MOVF   72,W
0E4A:  MOVWF  79
.................... } 
0E4B:  BCF    03.5
0E4C:  RETLW  00
....................  
.................... //------------------------------------------------------------------------------------------------------------------------------------ 
....................  
.................... void encender_caldera() 
.................... { 
....................    //Leemos el tiempo actual 
....................    PCF8583_read_datetime(&tiempo); 
*
0FE3:  CLRF   6C
0FE4:  MOVLW  4D
0FE5:  MOVWF  6B
0FE6:  CALL   495
....................  
....................    //Guardamos los datos en las variables correspondientes 
....................    hora_caldera = tiempo.hours; 
0FE7:  MOVF   4F,W
0FE8:  MOVWF  56
....................    minutos_caldera = tiempo.minutes; 
0FE9:  MOVF   4E,W
0FEA:  MOVWF  57
....................    segundos_caldera = tiempo.seconds; 
0FEB:  MOVF   4D,W
0FEC:  MOVWF  58
....................  
....................    //Encendemos la caldera 
....................    caldera_encendida = TRUE; 
0FED:  BSF    03.6
0FEE:  BSF    08.0
.................... } 
0FEF:  BCF    03.6
0FF0:  BSF    0A.3
0FF1:  BSF    0A.4
0FF2:  GOTO   721 (RETURN)
....................  
.................... //------------------------------------------------------------------------------------------------------------------------------------ 
....................  
.................... void encender_sistema() 
.................... { 
....................    //Leemos el tiempo actual 
....................    PCF8583_read_datetime(&tiempo); 
*
0DA1:  CLRF   6C
0DA2:  MOVLW  4D
0DA3:  MOVWF  6B
0DA4:  CALL   495
....................  
....................    //Registramos la hora y minutos en los que se enciende el sistema 
....................    hora_encendido    = tiempo.hours; 
0DA5:  MOVF   4F,W
0DA6:  MOVWF  54
....................    minutos_encendido = tiempo.minutes; 
0DA7:  MOVF   4E,W
0DA8:  MOVWF  55
....................  
....................    //Inicializamos a 0 el tiempo total que está encendida la caldera 
....................    t_total_caldera = 0; 
0DA9:  CLRF   5A
0DAA:  CLRF   59
....................  
....................    //Si la caldera está encendida, inicializamos el instante de encendido a 
....................    //éste. 
....................    if(caldera_encendida) 
0DAB:  BSF    03.6
0DAC:  BTFSS  08.0
0DAD:  GOTO   5B6
....................    { 
....................       hora_caldera = tiempo.hours; 
0DAE:  BCF    03.6
0DAF:  MOVF   4F,W
0DB0:  MOVWF  56
....................       minutos_caldera = tiempo.minutes; 
0DB1:  MOVF   4E,W
0DB2:  MOVWF  57
....................       segundos_caldera = tiempo.seconds; 
0DB3:  MOVF   4D,W
0DB4:  MOVWF  58
0DB5:  BSF    03.6
....................    } 
....................  
....................    //Encendemos el sistema 
....................    sistema_encendido = TRUE; 
0DB6:  BSF    08.2
.................... } 
0DB7:  BCF    03.6
0DB8:  RETLW  00
....................  
.................... //------------------------------------------------------------------------------------------------------------------------------------ 
....................  
.................... void inicializacion() 
.................... { 
....................    //NOTA: todos los pequeños retardos introducidos en esta rutina sirven para que el técnico 
....................    //no se sienta atosigado por los continuos mensajes que le aparecen solicitándole información. 
....................  
....................  
....................    //Variables para introducir los datos de fecha y hora 
....................    int weekday, dia, mes, anno, horas, minutos; 
....................  
....................    char c[2]; //Cadena para la conversión a int 
....................  
....................    //Comenzamos pidiendo la introducción de la fecha 
....................    //Es una lástima que en RS232 no se vean bien las tildes 
....................    e1: 
....................    printf("\rInicializacion\r"); 
*
054B:  CLRF   70
054C:  MOVF   70,W
054D:  CALL   06A
054E:  INCF   70,F
054F:  MOVWF  77
0550:  CLRWDT
0551:  BTFSS  0C.4
0552:  GOTO   550
0553:  MOVWF  19
0554:  MOVLW  10
0555:  SUBWF  70,W
0556:  BTFSS  03.2
0557:  GOTO   54C
....................    printf("\r"); 
0558:  MOVLW  0D
0559:  CLRWDT
055A:  BTFSS  0C.4
055B:  GOTO   559
055C:  MOVWF  19
....................    //Primero solicitamos el día de la semana 
....................    printf("LUN"); 
055D:  MOVLW  4C
055E:  CLRWDT
055F:  BTFSS  0C.4
0560:  GOTO   55E
0561:  MOVWF  19
0562:  MOVLW  55
0563:  CLRWDT
0564:  BTFSS  0C.4
0565:  GOTO   563
0566:  MOVWF  19
0567:  MOVLW  4E
0568:  CLRWDT
0569:  BTFSS  0C.4
056A:  GOTO   568
056B:  MOVWF  19
....................  
....................    //En principio se indica que es lunes 
....................    weekday = 0; 
056C:  CLRF   68
....................  
....................    //Inicializamos el vector de caracteres a \0 por dos motivos según la posición: 
....................    //c[0] para que no se elija un día indeseado sin intervención del técnico y c[1], 
....................    //para marcar el fin de la cadena. 
....................    c[0]=c[1]='\0'; 
056D:  CLRF   6F
056E:  MOVF   6F,W
056F:  MOVWF  6E
....................  
....................  
....................    //Iteramos en el bucle hasta que no se pulse ENTER 
....................    while(c[0]!=13){ 
0570:  MOVF   6E,W
0571:  SUBLW  0D
0572:  BTFSC  03.2
0573:  GOTO   635
....................       //Guardamos el caracter leído 
....................       c[0]=getch(); 
0574:  CLRWDT
0575:  BTFSS  0C.5
0576:  GOTO   574
0577:  MOVF   1A,W
0578:  MOVWF  6E
....................  
....................       //Además se asigna un valor numérico a la variable weekday para almacenarla en el reloj. 
....................       weekday=atoi(c)-1; 
0579:  CLRF   74
057A:  MOVLW  6E
057B:  MOVWF  73
057C:  CALL   266
057D:  MOVLW  01
057E:  SUBWF  78,W
057F:  MOVWF  68
....................  
....................       //Según el día introducido, imprimimos un resultado u otro por pantalla, borrando el 
....................       //anterior. 
....................       switch(weekday) 
....................       { 
0580:  MOVF   68,W
0581:  ADDLW  F9
0582:  BTFSC  03.0
0583:  GOTO   634
0584:  ADDLW  07
0585:  GOTO   7B9
....................          case 0: printf("\b\b\bLUN"); 
0586:  MOVLW  03
0587:  MOVWF  70
0588:  MOVLW  08
0589:  CLRWDT
058A:  BTFSS  0C.4
058B:  GOTO   589
058C:  MOVWF  19
058D:  DECFSZ 70,F
058E:  GOTO   588
058F:  MOVLW  4C
0590:  CLRWDT
0591:  BTFSS  0C.4
0592:  GOTO   590
0593:  MOVWF  19
0594:  MOVLW  55
0595:  CLRWDT
0596:  BTFSS  0C.4
0597:  GOTO   595
0598:  MOVWF  19
0599:  MOVLW  4E
059A:  CLRWDT
059B:  BTFSS  0C.4
059C:  GOTO   59A
059D:  MOVWF  19
....................                  break; 
059E:  GOTO   634
....................          case 1: printf("\b\b\bMAR"); 
059F:  MOVLW  03
05A0:  MOVWF  70
05A1:  MOVLW  08
05A2:  CLRWDT
05A3:  BTFSS  0C.4
05A4:  GOTO   5A2
05A5:  MOVWF  19
05A6:  DECFSZ 70,F
05A7:  GOTO   5A1
05A8:  MOVLW  4D
05A9:  CLRWDT
05AA:  BTFSS  0C.4
05AB:  GOTO   5A9
05AC:  MOVWF  19
05AD:  MOVLW  41
05AE:  CLRWDT
05AF:  BTFSS  0C.4
05B0:  GOTO   5AE
05B1:  MOVWF  19
05B2:  MOVLW  52
05B3:  CLRWDT
05B4:  BTFSS  0C.4
05B5:  GOTO   5B3
05B6:  MOVWF  19
....................                  break; 
05B7:  GOTO   634
....................          case 2: printf("\b\b\bMIE"); 
05B8:  MOVLW  03
05B9:  MOVWF  70
05BA:  MOVLW  08
05BB:  CLRWDT
05BC:  BTFSS  0C.4
05BD:  GOTO   5BB
05BE:  MOVWF  19
05BF:  DECFSZ 70,F
05C0:  GOTO   5BA
05C1:  MOVLW  4D
05C2:  CLRWDT
05C3:  BTFSS  0C.4
05C4:  GOTO   5C2
05C5:  MOVWF  19
05C6:  MOVLW  49
05C7:  CLRWDT
05C8:  BTFSS  0C.4
05C9:  GOTO   5C7
05CA:  MOVWF  19
05CB:  MOVLW  45
05CC:  CLRWDT
05CD:  BTFSS  0C.4
05CE:  GOTO   5CC
05CF:  MOVWF  19
....................                  break; 
05D0:  GOTO   634
....................          case 3: printf("\b\b\bJUE"); 
05D1:  MOVLW  03
05D2:  MOVWF  70
05D3:  MOVLW  08
05D4:  CLRWDT
05D5:  BTFSS  0C.4
05D6:  GOTO   5D4
05D7:  MOVWF  19
05D8:  DECFSZ 70,F
05D9:  GOTO   5D3
05DA:  MOVLW  4A
05DB:  CLRWDT
05DC:  BTFSS  0C.4
05DD:  GOTO   5DB
05DE:  MOVWF  19
05DF:  MOVLW  55
05E0:  CLRWDT
05E1:  BTFSS  0C.4
05E2:  GOTO   5E0
05E3:  MOVWF  19
05E4:  MOVLW  45
05E5:  CLRWDT
05E6:  BTFSS  0C.4
05E7:  GOTO   5E5
05E8:  MOVWF  19
....................                  break; 
05E9:  GOTO   634
....................          case 4: printf("\b\b\bVIE"); 
05EA:  MOVLW  03
05EB:  MOVWF  70
05EC:  MOVLW  08
05ED:  CLRWDT
05EE:  BTFSS  0C.4
05EF:  GOTO   5ED
05F0:  MOVWF  19
05F1:  DECFSZ 70,F
05F2:  GOTO   5EC
05F3:  MOVLW  56
05F4:  CLRWDT
05F5:  BTFSS  0C.4
05F6:  GOTO   5F4
05F7:  MOVWF  19
05F8:  MOVLW  49
05F9:  CLRWDT
05FA:  BTFSS  0C.4
05FB:  GOTO   5F9
05FC:  MOVWF  19
05FD:  MOVLW  45
05FE:  CLRWDT
05FF:  BTFSS  0C.4
0600:  GOTO   5FE
0601:  MOVWF  19
....................                  break; 
0602:  GOTO   634
....................          case 5: printf("\b\b\bSAB"); 
0603:  MOVLW  03
0604:  MOVWF  70
0605:  MOVLW  08
0606:  CLRWDT
0607:  BTFSS  0C.4
0608:  GOTO   606
0609:  MOVWF  19
060A:  DECFSZ 70,F
060B:  GOTO   605
060C:  MOVLW  53
060D:  CLRWDT
060E:  BTFSS  0C.4
060F:  GOTO   60D
0610:  MOVWF  19
0611:  MOVLW  41
0612:  CLRWDT
0613:  BTFSS  0C.4
0614:  GOTO   612
0615:  MOVWF  19
0616:  MOVLW  42
0617:  CLRWDT
0618:  BTFSS  0C.4
0619:  GOTO   617
061A:  MOVWF  19
....................                  break; 
061B:  GOTO   634
....................          case 6: printf("\b\b\bDOM"); 
061C:  MOVLW  03
061D:  MOVWF  70
061E:  MOVLW  08
061F:  CLRWDT
0620:  BTFSS  0C.4
0621:  GOTO   61F
0622:  MOVWF  19
0623:  DECFSZ 70,F
0624:  GOTO   61E
0625:  MOVLW  44
0626:  CLRWDT
0627:  BTFSS  0C.4
0628:  GOTO   626
0629:  MOVWF  19
062A:  MOVLW  4F
062B:  CLRWDT
062C:  BTFSS  0C.4
062D:  GOTO   62B
062E:  MOVWF  19
062F:  MOVLW  4D
0630:  CLRWDT
0631:  BTFSS  0C.4
0632:  GOTO   630
0633:  MOVWF  19
....................       } 
....................    } 
0634:  GOTO   570
....................  
....................    //Pedimos la introducción de la fecha 
....................    printf(" "); 
0635:  MOVLW  20
0636:  CLRWDT
0637:  BTFSS  0C.4
0638:  GOTO   636
0639:  MOVWF  19
....................  
....................    //Leemos el día del mes 
....................    dia = buscar_numero_rs232(); 
063A:  CALL   34B
063B:  MOVF   78,W
063C:  MOVWF  69
....................    //Si pulsamos "backspace" o el día es incorrecto, se resetea la inicialización 
....................    if(dia>31 || dia==0) 
063D:  MOVF   69,W
063E:  SUBLW  1F
063F:  BTFSS  03.0
0640:  GOTO   644
0641:  MOVF   69,F
0642:  BTFSS  03.2
0643:  GOTO   645
....................    { 
....................       goto e1; 
0644:  GOTO   54B
....................    } 
....................  
....................    //Leemos el mes 
....................    printf("/"); 
0645:  MOVLW  2F
0646:  CLRWDT
0647:  BTFSS  0C.4
0648:  GOTO   646
0649:  MOVWF  19
....................    mes = buscar_numero_rs232(); 
064A:  CALL   34B
064B:  MOVF   78,W
064C:  MOVWF  6A
....................    //Si pulsamos "backspace", el mes es incorrecto o el día no se encuentra en el mes seleccionado, 
....................    //se resetea la inicialización 
....................    if(mes>12 || mes==0 || (dia>29 && mes==2) || (dia==31 && (mes==4 || mes==6 || mes==9 || mes==11))) 
064D:  MOVF   6A,W
064E:  SUBLW  0C
064F:  BTFSS  03.0
0650:  GOTO   670
0651:  MOVF   6A,F
0652:  BTFSC  03.2
0653:  GOTO   670
0654:  MOVF   69,W
0655:  SUBLW  1D
0656:  BTFSC  03.0
0657:  GOTO   65C
0658:  MOVF   6A,W
0659:  SUBLW  02
065A:  BTFSC  03.2
065B:  GOTO   670
065C:  MOVF   69,W
065D:  SUBLW  1F
065E:  BTFSS  03.2
065F:  GOTO   671
0660:  MOVF   6A,W
0661:  SUBLW  04
0662:  BTFSC  03.2
0663:  GOTO   670
0664:  MOVF   6A,W
0665:  SUBLW  06
0666:  BTFSC  03.2
0667:  GOTO   670
0668:  MOVF   6A,W
0669:  SUBLW  09
066A:  BTFSC  03.2
066B:  GOTO   670
066C:  MOVF   6A,W
066D:  SUBLW  0B
066E:  BTFSS  03.2
066F:  GOTO   671
....................    { 
....................       goto e1; 
0670:  GOTO   54B
....................    } 
....................  
....................    //Leemos el año 
....................    printf("/"); 
0671:  MOVLW  2F
0672:  CLRWDT
0673:  BTFSS  0C.4
0674:  GOTO   672
0675:  MOVWF  19
....................    anno = buscar_numero_rs232(); 
0676:  CALL   34B
0677:  MOVF   78,W
0678:  MOVWF  6B
....................    //Si pulsamos "backspace" o el valor del año es incorrecto, se resetea la inicialización 
....................    //Tampoco se permite un año menor que 2009 (año de fabricación del sistema de control). 
....................    //También salta si el año no es bisiesto y hemos seleccionado el 29 de febrero. 
....................    if(anno>99 || anno<9 || (anno%4!=0 && mes==2 && dia==29)) 
0679:  MOVF   6B,W
067A:  SUBLW  63
067B:  BTFSS  03.0
067C:  GOTO   68D
067D:  MOVF   6B,W
067E:  SUBLW  08
067F:  BTFSC  03.0
0680:  GOTO   68D
0681:  MOVF   6B,W
0682:  ANDLW  03
0683:  BTFSC  03.2
0684:  GOTO   68E
0685:  MOVF   6A,W
0686:  SUBLW  02
0687:  BTFSS  03.2
0688:  GOTO   68E
0689:  MOVF   69,W
068A:  SUBLW  1D
068B:  BTFSS  03.2
068C:  GOTO   68E
....................    { 
....................       goto e1; 
068D:  GOTO   54B
....................    } 
....................  
....................    //Calculamos el año en el intervalo de 0 a 3 según sean bisiesto este año 
....................    //o los anteriores. 
....................    if(anno%4==0) 
068E:  MOVF   6B,W
068F:  ANDLW  03
0690:  BTFSS  03.2
0691:  GOTO   694
....................       anno_actual_0_to_3 = 0; 
0692:  CLRF   5E
....................    else if((anno-1)%4==0) 
0693:  GOTO   6AB
0694:  MOVLW  01
0695:  SUBWF  6B,W
0696:  ANDLW  03
0697:  BTFSS  03.2
0698:  GOTO   69C
....................       anno_actual_0_to_3 = 1; 
0699:  MOVLW  01
069A:  MOVWF  5E
....................    else if((anno-2)%4==0) 
069B:  GOTO   6AB
069C:  MOVLW  02
069D:  SUBWF  6B,W
069E:  ANDLW  03
069F:  BTFSS  03.2
06A0:  GOTO   6A4
....................       anno_actual_0_to_3 = 2; 
06A1:  MOVLW  02
06A2:  MOVWF  5E
....................    else if((anno-3)%4==0) 
06A3:  GOTO   6AB
06A4:  MOVLW  03
06A5:  SUBWF  6B,W
06A6:  ANDLW  03
06A7:  BTFSS  03.2
06A8:  GOTO   6AB
....................       anno_actual_0_to_3 = 3; 
06A9:  MOVLW  03
06AA:  MOVWF  5E
....................  
....................    //Se pide la introducción de la hora 
....................    printf(" "); 
06AB:  MOVLW  20
06AC:  CLRWDT
06AD:  BTFSS  0C.4
06AE:  GOTO   6AC
06AF:  MOVWF  19
....................  
....................    //Leemos la hora 
....................    horas = buscar_numero_rs232(); 
06B0:  CALL   34B
06B1:  MOVF   78,W
06B2:  MOVWF  6C
....................    //Si se pulsa "backspace" o la hora es incorrecta, se resetea todo el proceso 
....................    if(horas>23) 
06B3:  MOVF   6C,W
06B4:  SUBLW  17
06B5:  BTFSC  03.0
06B6:  GOTO   6B8
....................    { 
....................       goto e1; 
06B7:  GOTO   54B
....................    } 
....................  
....................    //Leemos los minutos 
....................    printf(":"); 
06B8:  MOVLW  3A
06B9:  CLRWDT
06BA:  BTFSS  0C.4
06BB:  GOTO   6B9
06BC:  MOVWF  19
....................    minutos = buscar_numero_rs232(); 
06BD:  CALL   34B
06BE:  MOVF   78,W
06BF:  MOVWF  6D
....................  
....................    //Si se pulsa "backspace" o los minutos son incorrectos, reseteamos la inicialización completa 
....................    if(minutos>59) 
06C0:  MOVF   6D,W
06C1:  SUBLW  3B
06C2:  BTFSC  03.0
06C3:  GOTO   6C5
....................    { 
....................       goto e1; 
06C4:  GOTO   54B
....................    } 
....................  
....................    //Mostramos un mensaje de guardado de configuración 
....................    printf("\rGuardando..."); 
06C5:  CLRF   70
06C6:  MOVF   70,W
06C7:  CALL   07F
06C8:  INCF   70,F
06C9:  MOVWF  77
06CA:  CLRWDT
06CB:  BTFSS  0C.4
06CC:  GOTO   6CA
06CD:  MOVWF  19
06CE:  MOVLW  0A
06CF:  SUBWF  70,W
06D0:  BTFSS  03.2
06D1:  GOTO   6C6
06D2:  MOVLW  03
06D3:  MOVWF  71
06D4:  MOVLW  2E
06D5:  CLRWDT
06D6:  BTFSS  0C.4
06D7:  GOTO   6D5
06D8:  MOVWF  19
06D9:  DECFSZ 71,F
06DA:  GOTO   6D4
....................  
....................    //Almacenamos todo en la estructura que contiene la información del tiempo 
....................    tiempo.month   = mes; 
06DB:  MOVF   6A,W
06DC:  MOVWF  51
....................    tiempo.day     = dia; 
06DD:  MOVF   69,W
06DE:  MOVWF  50
....................    tiempo.year    = anno_actual_0_to_3; 
06DF:  MOVF   5E,W
06E0:  MOVWF  52
....................    tiempo.hours   = horas; 
06E1:  MOVF   6C,W
06E2:  MOVWF  4F
....................    tiempo.minutes = minutos; 
06E3:  MOVF   6D,W
06E4:  MOVWF  4E
....................    tiempo.weekday = weekday; 
06E5:  MOVF   68,W
06E6:  MOVWF  53
....................  
....................    //Fijamos el reloj a esa fecha y hora 
....................    PCF8583_set_datetime(&tiempo); 
06E7:  CLRF   71
06E8:  MOVLW  4D
06E9:  MOVWF  70
....................  
....................    //Establecemos los parámetros iniciales del sistema para resetear la memoria 
....................    termostato = (float)20; 
*
0785:  CLRF   33
0786:  CLRF   32
0787:  MOVLW  20
0788:  MOVWF  31
0789:  MOVLW  83
078A:  MOVWF  30
....................    num_registros = 0; 
078B:  CLRF   5C
078C:  CLRF   5B
....................    anno_actual = anno; 
078D:  MOVF   6B,W
078E:  MOVWF  5D
....................  
....................    //Escribimos los datos en la EEPROM 
....................    data[0] = 20; 
078F:  MOVLW  14
0790:  MOVWF  45
....................    data[1] = 0; 
0791:  CLRF   46
....................    data[2] = 0; 
0792:  CLRF   47
....................    data[3] = anno; 
0793:  MOVF   6B,W
0794:  MOVWF  48
....................    data[4] = anno_actual_0_to_3; 
0795:  MOVF   5E,W
0796:  MOVWF  49
....................    graba_ee(eeprom_termostato, 5, data);    
0797:  CLRF   71
0798:  CLRF   70
0799:  MOVLW  05
079A:  MOVWF  72
079B:  CLRF   74
079C:  MOVLW  45
079D:  MOVWF  73
079E:  CALL   3BA
....................  
....................    //Escribimos el valor del termostato en el sensor de temperatura. 
....................    //Ponemos como valor alto 127.5 grados, temperatura que no se va a alcanzar. 
....................    ds1820_establecer_TH_TL(127.5, termostato); 
079F:  CLRF   73
07A0:  CLRF   72
07A1:  MOVLW  7F
07A2:  MOVWF  71
07A3:  MOVLW  85
07A4:  MOVWF  70
07A5:  MOVF   33,W
07A6:  BSF    03.5
07A7:  MOVWF  23
07A8:  BCF    03.5
07A9:  MOVF   32,W
07AA:  BSF    03.5
07AB:  MOVWF  22
07AC:  BCF    03.5
07AD:  MOVF   31,W
07AE:  BSF    03.5
07AF:  MOVWF  21
07B0:  BCF    03.5
07B1:  MOVF   30,W
07B2:  BSF    03.5
07B3:  MOVWF  20
07B4:  BCF    03.5
07B5:  CALL   4D3
.................... } 
07B6:  BSF    0A.3
07B7:  BSF    0A.4
07B8:  GOTO   2B3 (RETURN)
....................  
.................... //------------------------------------------------------------------------------------------------------------------------------------ 
....................  
.................... void mostrar_temperatura() 
.................... { 
....................    //Leemos el tiempo y lo guardamos en la variable tiempo 
....................    PCF8583_read_datetime(&tiempo); 
*
1946:  CLRF   6C
1947:  MOVLW  4D
1948:  MOVWF  6B
1949:  BCF    0A.4
194A:  CALL   495
194B:  BSF    0A.4
....................    //Activamos las interrupciones, que se desactivan dentro del método 
....................    enable_interrupts(GLOBAL); 
194C:  MOVLW  C0
194D:  IORWF  0B,F
....................  
....................    //Mostramos la temperatura registrada 
....................    lcd_send_byte(LCD_ORDEN, LCD_CLEAR); 
194E:  BSF    03.5
194F:  CLRF   21
1950:  MOVLW  01
1951:  MOVWF  22
1952:  BCF    0A.4
1953:  BCF    0A.3
1954:  BCF    03.5
1955:  CALL   1DE
1956:  BSF    0A.4
1957:  BSF    0A.3
....................    printf(lcd_putc, "TEMP-%3.1f %cC\nHORA-%u:%u", temperatura, 223,tiempo.hours, tiempo.minutes); 
1958:  CLRF   68
1959:  MOVF   68,W
195A:  BCF    0A.4
195B:  BCF    0A.3
195C:  CALL   08E
195D:  BSF    0A.4
195E:  BSF    0A.3
195F:  INCF   68,F
1960:  MOVWF  77
1961:  MOVWF  76
1962:  BCF    0A.4
1963:  CALL   776
1964:  BSF    0A.4
1965:  MOVLW  05
1966:  SUBWF  68,W
1967:  BTFSS  03.2
1968:  GOTO   159
1969:  MOVLW  02
196A:  MOVWF  04
196B:  MOVF   3B,W
196C:  MOVWF  6C
196D:  MOVF   3A,W
196E:  MOVWF  6B
196F:  MOVF   39,W
1970:  MOVWF  6A
1971:  MOVF   38,W
1972:  MOVWF  69
1973:  MOVLW  01
1974:  MOVWF  6D
1975:  GOTO   000
1976:  MOVLW  20
1977:  MOVWF  76
1978:  BCF    0A.4
1979:  CALL   776
197A:  BSF    0A.4
197B:  MOVLW  DF
197C:  MOVWF  76
197D:  BCF    0A.4
197E:  CALL   776
197F:  BSF    0A.4
1980:  MOVLW  0D
1981:  MOVWF  69
1982:  MOVF   69,W
1983:  BCF    0A.4
1984:  BCF    0A.3
1985:  CALL   08E
1986:  BSF    0A.4
1987:  BSF    0A.3
1988:  INCF   69,F
1989:  MOVWF  77
198A:  MOVWF  76
198B:  BCF    0A.4
198C:  CALL   776
198D:  BSF    0A.4
198E:  MOVLW  14
198F:  SUBWF  69,W
1990:  BTFSS  03.2
1991:  GOTO   182
1992:  MOVF   4F,W
1993:  MOVWF  6A
1994:  MOVLW  1B
1995:  MOVWF  6B
1996:  CALL   0F8
1997:  MOVLW  3A
1998:  MOVWF  76
1999:  BCF    0A.4
199A:  CALL   776
199B:  BSF    0A.4
199C:  MOVF   4E,W
199D:  MOVWF  6A
199E:  MOVLW  1B
199F:  MOVWF  6B
19A0:  CALL   0F8
.................... } 
....................  
.................... //------------------------------------------------------------------------------------------------------------------------------------ 
....................  
.................... void representar_registros() 
.................... { 
....................    //Contadores para los bucles 
....................    unsigned int contador; 
....................    //Caracter para la introducción de las opciones 
....................    char caracter; 
....................  
....................    float media_dia_caldera;         //Tiempo medio que se enciende la caldera cada día 
....................    float valor;                     //Tiempo medio en minutos que se enciende el sistema por día 
....................  
....................    unsigned long valor_total;  //Tiempo total de encendido de la caldera 
....................    unsigned long valor_total_caldera; //Tiempo total de encendido del sistema 
....................  
....................    //Variables para almacenar valores provisionales 
....................    long tiempo_x_dia;         //Tiempo que se enciende cada día el sistema (minutos) 
....................    long tiempo_x_dia_caldera; //Tiempo que se enciende cada día la caldera (minutos) 
....................    int fecha[3];             //Día con el que estamos trabajando (día/mes/año) 
....................    long num_dias;             //Número de días que llevamos analizados 
....................  
....................    //Iniciamos a cero las otras variables 
....................    fecha[0] = fecha[1] = fecha[2] = 0; 
*
130D:  BSF    03.5
130E:  CLRF   24
130F:  MOVF   24,W
1310:  MOVWF  23
1311:  MOVWF  22
....................    num_dias = 0; 
1312:  CLRF   26
1313:  CLRF   25
....................  
....................    media_dia_caldera = 0; 
1314:  BCF    03.5
1315:  CLRF   6D
1316:  CLRF   6C
1317:  CLRF   6B
1318:  CLRF   6A
....................    valor = 0; 
1319:  CLRF   71
131A:  CLRF   70
131B:  CLRF   6F
131C:  CLRF   6E
....................    valor_total = 0; 
131D:  CLRF   73
131E:  CLRF   72
....................    valor_total_caldera = 0; 
131F:  CLRF   75
1320:  CLRF   74
....................  
....................    //Imprimimos el encabezamiento 
....................    printf("\rREGISTRO DE EVENTOS\r\r"); 
1321:  BSF    03.5
1322:  CLRF   27
1323:  MOVF   27,W
1324:  BCF    0A.4
1325:  BCF    03.5
1326:  CALL   0AC
1327:  BSF    0A.4
1328:  BSF    03.5
1329:  INCF   27,F
132A:  MOVWF  77
132B:  CLRWDT
132C:  BCF    03.5
132D:  BTFSC  0C.4
132E:  GOTO   331
132F:  BSF    03.5
1330:  GOTO   32B
1331:  MOVWF  19
1332:  MOVLW  16
1333:  BSF    03.5
1334:  SUBWF  27,W
1335:  BTFSS  03.2
1336:  GOTO   323
....................    printf("Fecha           Temp.    Min.S.  Min.C.\r"); 
1337:  CLRF   27
1338:  MOVF   27,W
1339:  BCF    0A.4
133A:  BCF    03.5
133B:  CALL   0C7
133C:  BSF    0A.4
133D:  BSF    03.5
133E:  INCF   27,F
133F:  MOVWF  77
1340:  CLRWDT
1341:  BCF    03.5
1342:  BTFSC  0C.4
1343:  GOTO   346
1344:  BSF    03.5
1345:  GOTO   340
1346:  MOVWF  19
1347:  MOVLW  05
1348:  BSF    03.5
1349:  SUBWF  27,W
134A:  BTFSS  03.2
134B:  GOTO   338
134C:  MOVLW  0B
134D:  MOVWF  28
134E:  MOVLW  20
134F:  CLRWDT
1350:  BCF    03.5
1351:  BTFSC  0C.4
1352:  GOTO   355
1353:  BSF    03.5
1354:  GOTO   34F
1355:  MOVWF  19
1356:  BSF    03.5
1357:  DECFSZ 28,F
1358:  GOTO   34E
1359:  MOVLW  05
135A:  MOVWF  29
135B:  MOVF   29,W
135C:  BCF    0A.4
135D:  BCF    03.5
135E:  CALL   0C7
135F:  BSF    0A.4
1360:  BSF    03.5
1361:  INCF   29,F
1362:  MOVWF  77
1363:  CLRWDT
1364:  BCF    03.5
1365:  BTFSC  0C.4
1366:  GOTO   369
1367:  BSF    03.5
1368:  GOTO   363
1369:  MOVWF  19
136A:  MOVLW  0A
136B:  BSF    03.5
136C:  SUBWF  29,W
136D:  BTFSS  03.2
136E:  GOTO   35B
136F:  MOVLW  04
1370:  MOVWF  2A
1371:  MOVLW  20
1372:  CLRWDT
1373:  BCF    03.5
1374:  BTFSC  0C.4
1375:  GOTO   378
1376:  BSF    03.5
1377:  GOTO   372
1378:  MOVWF  19
1379:  BSF    03.5
137A:  DECFSZ 2A,F
137B:  GOTO   371
137C:  MOVLW  0A
137D:  MOVWF  2B
137E:  MOVF   2B,W
137F:  BCF    0A.4
1380:  BCF    03.5
1381:  CALL   0C7
1382:  BSF    0A.4
1383:  BSF    03.5
1384:  INCF   2B,F
1385:  MOVWF  77
1386:  CLRWDT
1387:  BCF    03.5
1388:  BTFSC  0C.4
1389:  GOTO   38C
138A:  BSF    03.5
138B:  GOTO   386
138C:  MOVWF  19
138D:  MOVLW  19
138E:  BSF    03.5
138F:  SUBWF  2B,W
1390:  BTFSS  03.2
1391:  GOTO   37E
....................    printf("=======================================\r"); 
1392:  MOVLW  27
1393:  MOVWF  27
1394:  MOVLW  3D
1395:  CLRWDT
1396:  BCF    03.5
1397:  BTFSC  0C.4
1398:  GOTO   39B
1399:  BSF    03.5
139A:  GOTO   395
139B:  MOVWF  19
139C:  BSF    03.5
139D:  DECFSZ 27,F
139E:  GOTO   394
139F:  MOVLW  0D
13A0:  CLRWDT
13A1:  BCF    03.5
13A2:  BTFSC  0C.4
13A3:  GOTO   3A6
13A4:  BSF    03.5
13A5:  GOTO   3A0
13A6:  MOVWF  19
....................  
....................    //Recorremos todos los registros almacenados 
....................    for(contador=0; contador<num_registros; contador++) 
13A7:  CLRF   68
13A8:  MOVF   5C,F
13A9:  BTFSS  03.2
13AA:  GOTO   3AF
13AB:  MOVF   5B,W
13AC:  SUBWF  68,W
13AD:  BTFSC  03.0
13AE:  GOTO   590
....................    { 
....................       //Comenzamos leyendo los datos de memoria 
....................       lee_ee(eeprom_registros + contador*8, 8, data); 
13AF:  RLF    68,W
13B0:  MOVWF  77
13B1:  RLF    77,F
13B2:  RLF    77,F
13B3:  MOVLW  F8
13B4:  ANDWF  77,F
13B5:  MOVF   77,W
13B6:  ADDLW  10
13B7:  BSF    03.5
13B8:  MOVWF  27
13B9:  CLRF   29
13BA:  MOVF   27,W
13BB:  MOVWF  28
13BC:  MOVLW  08
13BD:  MOVWF  2A
13BE:  CLRF   2C
13BF:  MOVLW  45
13C0:  MOVWF  2B
....................  
....................       //Si cambiamos de día debemos gestionar los datos del nuevo día y almacenar los del anterior 
....................       if(fecha[0]!=data[0] || fecha[1]!=data[1] || fecha[2]!=data[2]) 
*
1420:  BCF    03.5
1421:  MOVF   45,W
1422:  BSF    03.5
1423:  SUBWF  22,W
1424:  BTFSS  03.2
1425:  GOTO   432
1426:  BCF    03.5
1427:  MOVF   46,W
1428:  BSF    03.5
1429:  SUBWF  23,W
142A:  BTFSS  03.2
142B:  GOTO   432
142C:  BCF    03.5
142D:  MOVF   47,W
142E:  BSF    03.5
142F:  SUBWF  24,W
1430:  BTFSC  03.2
1431:  GOTO   4A8
....................       { 
....................          //Lógicamente, no tenemos en cuenta para la media los días en los que no se enciende: 
....................          //días de verano, calurosos, etc. Esta información puede visualizarse en la media 
....................          //por meses. 
....................          //Guardamos los datos del día anterior si el día no es el primero 
....................          if(fecha[0]!=0) 
1432:  MOVF   22,F
1433:  BTFSC  03.2
1434:  GOTO   495
....................          { 
....................             //En la media de tiempo por día, acumulamos el tiempo que ha estado encendido el último día 
....................             valor = valor + (float)tiempo_x_dia; 
1435:  MOVF   7D,W
1436:  MOVWF  28
1437:  MOVF   7C,W
1438:  MOVWF  27
1439:  BCF    0A.4
143A:  BSF    0A.3
143B:  BCF    03.5
143C:  CALL   310
143D:  BSF    0A.4
143E:  BCF    0A.3
143F:  BCF    03.1
1440:  MOVF   71,W
1441:  BSF    03.5
1442:  MOVWF  2A
1443:  MOVF   70,W
1444:  MOVWF  29
1445:  BCF    03.5
1446:  MOVF   6F,W
1447:  BSF    03.5
1448:  MOVWF  28
1449:  BCF    03.5
144A:  MOVF   6E,W
144B:  BSF    03.5
144C:  MOVWF  27
144D:  MOVF   7A,W
144E:  MOVWF  2E
144F:  MOVF   79,W
1450:  MOVWF  2D
1451:  MOVF   78,W
1452:  MOVWF  2C
1453:  MOVF   77,W
1454:  MOVWF  2B
1455:  BCF    0A.4
1456:  BSF    0A.3
1457:  BCF    03.5
1458:  CALL   1CA
1459:  BSF    0A.4
145A:  BCF    0A.3
145B:  MOVF   7A,W
145C:  MOVWF  71
145D:  MOVF   79,W
145E:  MOVWF  70
145F:  MOVF   78,W
1460:  MOVWF  6F
1461:  MOVF   77,W
1462:  MOVWF  6E
....................             //Realizamos la misma operación con la media de encendido de la caldera 
....................             media_dia_caldera = media_dia_caldera + (float)tiempo_x_dia_caldera; 
1463:  BSF    03.5
1464:  MOVF   21,W
1465:  MOVWF  28
1466:  MOVF   20,W
1467:  MOVWF  27
1468:  BCF    0A.4
1469:  BSF    0A.3
146A:  BCF    03.5
146B:  CALL   310
146C:  BSF    0A.4
146D:  BCF    0A.3
146E:  BCF    03.1
146F:  MOVF   6D,W
1470:  BSF    03.5
1471:  MOVWF  2A
1472:  BCF    03.5
1473:  MOVF   6C,W
1474:  BSF    03.5
1475:  MOVWF  29
1476:  BCF    03.5
1477:  MOVF   6B,W
1478:  BSF    03.5
1479:  MOVWF  28
147A:  BCF    03.5
147B:  MOVF   6A,W
147C:  BSF    03.5
147D:  MOVWF  27
147E:  MOVF   7A,W
147F:  MOVWF  2E
1480:  MOVF   79,W
1481:  MOVWF  2D
1482:  MOVF   78,W
1483:  MOVWF  2C
1484:  MOVF   77,W
1485:  MOVWF  2B
1486:  BCF    0A.4
1487:  BSF    0A.3
1488:  BCF    03.5
1489:  CALL   1CA
148A:  BSF    0A.4
148B:  BCF    0A.3
148C:  MOVF   7A,W
148D:  MOVWF  6D
148E:  MOVF   79,W
148F:  MOVWF  6C
1490:  MOVF   78,W
1491:  MOVWF  6B
1492:  MOVF   77,W
1493:  MOVWF  6A
1494:  BSF    03.5
....................          } 
....................          //La sumatoria podría alcanzar un valor muy alto. El sistema no está preparado para estas eventualidades 
....................          //y debería ser reseteado cada cierto tiempo. Si el sistema va a utilizarse mucho (zonas muy frías o mal 
....................          //aisladas), el usuario debería informar al fabricante para aumentar la memoria de almacenamiento y el 
....................          //tamaño de las variables 
....................  
....................          //Modificamos la información del día 
....................          fecha[0] = data[0]; 
1495:  BCF    03.5
1496:  MOVF   45,W
1497:  BSF    03.5
1498:  MOVWF  22
....................          fecha[1] = data[1]; 
1499:  BCF    03.5
149A:  MOVF   46,W
149B:  BSF    03.5
149C:  MOVWF  23
....................          fecha[2] = data[2]; 
149D:  BCF    03.5
149E:  MOVF   47,W
149F:  BSF    03.5
14A0:  MOVWF  24
....................  
....................          //Aumentamos en 1 el número de días 
....................          num_dias++; 
14A1:  INCF   25,F
14A2:  BTFSC  03.2
14A3:  INCF   26,F
....................  
....................          //Reseteamos las variables acumulativas de tiempo por día 
....................          tiempo_x_dia = 0; 
14A4:  CLRF   7D
14A5:  CLRF   7C
....................          tiempo_x_dia_caldera = 0; 
14A6:  CLRF   21
14A7:  CLRF   20
....................       } 
....................  
....................       //Le sumamos al tiempo de encendido de sistema y caldera el correspondiente de este registro 
....................       tiempo_x_dia = tiempo_x_dia + data[6]; 
14A8:  BCF    03.5
14A9:  MOVF   4B,W
14AA:  ADDWF  7C,F
14AB:  BTFSC  03.0
14AC:  INCF   7D,F
....................       tiempo_x_dia_caldera = tiempo_x_dia_caldera + data[7]; 
14AD:  MOVF   4C,W
14AE:  BSF    03.5
14AF:  ADDWF  20,F
14B0:  BTFSC  03.0
14B1:  INCF   21,F
....................       //También incrementamos los tiempos totales 
....................       valor_total = valor_total + data[6]; 
14B2:  BCF    03.5
14B3:  MOVF   4B,W
14B4:  ADDWF  72,F
14B5:  BTFSC  03.0
14B6:  INCF   73,F
....................       valor_total_caldera = valor_total_caldera + data[7]; 
14B7:  MOVF   4C,W
14B8:  ADDWF  74,F
14B9:  BTFSC  03.0
14BA:  INCF   75,F
....................  
....................       //Representamos todos los datos, teniendo en cuenta algunos requisitos representativos 
....................       //para que los datos queden alineados (número menores que 10, que 100, etc). 
....................       if(data[0]<10) 
14BB:  MOVF   45,W
14BC:  SUBLW  09
14BD:  BTFSS  03.0
14BE:  GOTO   4C4
....................          printf(" "); 
14BF:  MOVLW  20
14C0:  CLRWDT
14C1:  BTFSS  0C.4
14C2:  GOTO   4C0
14C3:  MOVWF  19
....................  
....................       printf("%u/", data[0]); 
14C4:  MOVF   45,W
14C5:  BSF    03.5
14C6:  MOVWF  27
14C7:  MOVLW  1B
14C8:  MOVWF  28
14C9:  BCF    03.5
14CA:  CALL   124
14CB:  MOVLW  2F
14CC:  CLRWDT
14CD:  BTFSS  0C.4
14CE:  GOTO   4CC
14CF:  MOVWF  19
....................  
....................       if(data[1]<10) 
14D0:  MOVF   46,W
14D1:  SUBLW  09
14D2:  BTFSS  03.0
14D3:  GOTO   4D9
....................          printf("0"); 
14D4:  MOVLW  30
14D5:  CLRWDT
14D6:  BTFSS  0C.4
14D7:  GOTO   4D5
14D8:  MOVWF  19
....................  
....................       printf("%u/", data[1]); 
14D9:  MOVF   46,W
14DA:  BSF    03.5
14DB:  MOVWF  27
14DC:  MOVLW  1B
14DD:  MOVWF  28
14DE:  BCF    03.5
14DF:  CALL   124
14E0:  MOVLW  2F
14E1:  CLRWDT
14E2:  BTFSS  0C.4
14E3:  GOTO   4E1
14E4:  MOVWF  19
....................  
....................       if(data[2]<10) 
14E5:  MOVF   47,W
14E6:  SUBLW  09
14E7:  BTFSS  03.0
14E8:  GOTO   4EE
....................          printf("0"); 
14E9:  MOVLW  30
14EA:  CLRWDT
14EB:  BTFSS  0C.4
14EC:  GOTO   4EA
14ED:  MOVWF  19
....................  
....................       printf("%u  ", data[2]); 
14EE:  MOVF   47,W
14EF:  BSF    03.5
14F0:  MOVWF  27
14F1:  MOVLW  1B
14F2:  MOVWF  28
14F3:  BCF    03.5
14F4:  CALL   124
14F5:  MOVLW  20
14F6:  CLRWDT
14F7:  BTFSS  0C.4
14F8:  GOTO   4F6
14F9:  MOVWF  19
14FA:  MOVLW  20
14FB:  CLRWDT
14FC:  BTFSS  0C.4
14FD:  GOTO   4FB
14FE:  MOVWF  19
....................  
....................       if(data[3]<10) 
14FF:  MOVF   48,W
1500:  SUBLW  09
1501:  BTFSS  03.0
1502:  GOTO   508
....................          printf("0"); 
1503:  MOVLW  30
1504:  CLRWDT
1505:  BTFSS  0C.4
1506:  GOTO   504
1507:  MOVWF  19
....................  
....................       printf("%u:", data[3]); 
1508:  MOVF   48,W
1509:  BSF    03.5
150A:  MOVWF  27
150B:  MOVLW  1B
150C:  MOVWF  28
150D:  BCF    03.5
150E:  CALL   124
150F:  MOVLW  3A
1510:  CLRWDT
1511:  BTFSS  0C.4
1512:  GOTO   510
1513:  MOVWF  19
....................  
....................       if(data[4]<10) 
1514:  MOVF   49,W
1515:  SUBLW  09
1516:  BTFSS  03.0
1517:  GOTO   51D
....................          printf("0"); 
1518:  MOVLW  30
1519:  CLRWDT
151A:  BTFSS  0C.4
151B:  GOTO   519
151C:  MOVWF  19
....................  
....................       printf("%u ", data[4]); 
151D:  MOVF   49,W
151E:  BSF    03.5
151F:  MOVWF  27
1520:  MOVLW  1B
1521:  MOVWF  28
1522:  BCF    03.5
1523:  CALL   124
1524:  MOVLW  20
1525:  CLRWDT
1526:  BTFSS  0C.4
1527:  GOTO   525
1528:  MOVWF  19
....................  
....................       if(data[5]<10) 
1529:  MOVF   4A,W
152A:  SUBLW  09
152B:  BTFSS  03.0
152C:  GOTO   532
....................          printf(" "); 
152D:  MOVLW  20
152E:  CLRWDT
152F:  BTFSS  0C.4
1530:  GOTO   52E
1531:  MOVWF  19
....................  
....................       printf("%u      ", data[5]);       
1532:  MOVF   4A,W
1533:  BSF    03.5
1534:  MOVWF  27
1535:  MOVLW  1B
1536:  MOVWF  28
1537:  BCF    03.5
1538:  CALL   124
1539:  MOVLW  06
153A:  BSF    03.5
153B:  MOVWF  27
153C:  MOVLW  20
153D:  CLRWDT
153E:  BCF    03.5
153F:  BTFSC  0C.4
1540:  GOTO   543
1541:  BSF    03.5
1542:  GOTO   53D
1543:  MOVWF  19
1544:  BSF    03.5
1545:  DECFSZ 27,F
1546:  GOTO   53C
....................  
....................       if(data[6]<100) 
1547:  BCF    03.5
1548:  MOVF   4B,W
1549:  SUBLW  63
154A:  BTFSS  03.0
154B:  GOTO   551
....................          printf(" "); 
154C:  MOVLW  20
154D:  CLRWDT
154E:  BTFSS  0C.4
154F:  GOTO   54D
1550:  MOVWF  19
....................       if(data[6]<10) 
1551:  MOVF   4B,W
1552:  SUBLW  09
1553:  BTFSS  03.0
1554:  GOTO   55A
....................          printf(" "); 
1555:  MOVLW  20
1556:  CLRWDT
1557:  BTFSS  0C.4
1558:  GOTO   556
1559:  MOVWF  19
....................  
....................       printf("%u     ", data[6]); 
155A:  MOVF   4B,W
155B:  BSF    03.5
155C:  MOVWF  27
155D:  MOVLW  1B
155E:  MOVWF  28
155F:  BCF    03.5
1560:  CALL   124
1561:  MOVLW  05
1562:  BSF    03.5
1563:  MOVWF  27
1564:  MOVLW  20
1565:  CLRWDT
1566:  BCF    03.5
1567:  BTFSC  0C.4
1568:  GOTO   56B
1569:  BSF    03.5
156A:  GOTO   565
156B:  MOVWF  19
156C:  BSF    03.5
156D:  DECFSZ 27,F
156E:  GOTO   564
....................  
....................       if(data[7]<100) 
156F:  BCF    03.5
1570:  MOVF   4C,W
1571:  SUBLW  63
1572:  BTFSS  03.0
1573:  GOTO   579
....................          printf(" "); 
1574:  MOVLW  20
1575:  CLRWDT
1576:  BTFSS  0C.4
1577:  GOTO   575
1578:  MOVWF  19
....................       if(data[7]<10) 
1579:  MOVF   4C,W
157A:  SUBLW  09
157B:  BTFSS  03.0
157C:  GOTO   582
....................          printf(" "); 
157D:  MOVLW  20
157E:  CLRWDT
157F:  BTFSS  0C.4
1580:  GOTO   57E
1581:  MOVWF  19
....................  
....................       printf("%u\r", data[7]); 
1582:  MOVF   4C,W
1583:  BSF    03.5
1584:  MOVWF  27
1585:  MOVLW  1B
1586:  MOVWF  28
1587:  BCF    03.5
1588:  CALL   124
1589:  MOVLW  0D
158A:  CLRWDT
158B:  BTFSS  0C.4
158C:  GOTO   58A
158D:  MOVWF  19
....................  
....................    } 
158E:  INCF   68,F
158F:  GOTO   3A8
....................  
....................    //Debemos realizar la operación de guardado para el último día. El proceso es el mismo 
....................    //que hemos seguido arriba. 
....................    if(fecha[0]!=0) 
1590:  BSF    03.5
1591:  MOVF   22,F
1592:  BTFSC  03.2
1593:  GOTO   5F4
....................    { 
....................       valor = valor + (float)tiempo_x_dia; 
1594:  MOVF   7D,W
1595:  MOVWF  28
1596:  MOVF   7C,W
1597:  MOVWF  27
1598:  BCF    0A.4
1599:  BSF    0A.3
159A:  BCF    03.5
159B:  CALL   310
159C:  BSF    0A.4
159D:  BCF    0A.3
159E:  BCF    03.1
159F:  MOVF   71,W
15A0:  BSF    03.5
15A1:  MOVWF  2A
15A2:  MOVF   70,W
15A3:  MOVWF  29
15A4:  BCF    03.5
15A5:  MOVF   6F,W
15A6:  BSF    03.5
15A7:  MOVWF  28
15A8:  BCF    03.5
15A9:  MOVF   6E,W
15AA:  BSF    03.5
15AB:  MOVWF  27
15AC:  MOVF   7A,W
15AD:  MOVWF  2E
15AE:  MOVF   79,W
15AF:  MOVWF  2D
15B0:  MOVF   78,W
15B1:  MOVWF  2C
15B2:  MOVF   77,W
15B3:  MOVWF  2B
15B4:  BCF    0A.4
15B5:  BSF    0A.3
15B6:  BCF    03.5
15B7:  CALL   1CA
15B8:  BSF    0A.4
15B9:  BCF    0A.3
15BA:  MOVF   7A,W
15BB:  MOVWF  71
15BC:  MOVF   79,W
15BD:  MOVWF  70
15BE:  MOVF   78,W
15BF:  MOVWF  6F
15C0:  MOVF   77,W
15C1:  MOVWF  6E
....................       media_dia_caldera = media_dia_caldera + (float)tiempo_x_dia_caldera; 
15C2:  BSF    03.5
15C3:  MOVF   21,W
15C4:  MOVWF  28
15C5:  MOVF   20,W
15C6:  MOVWF  27
15C7:  BCF    0A.4
15C8:  BSF    0A.3
15C9:  BCF    03.5
15CA:  CALL   310
15CB:  BSF    0A.4
15CC:  BCF    0A.3
15CD:  BCF    03.1
15CE:  MOVF   6D,W
15CF:  BSF    03.5
15D0:  MOVWF  2A
15D1:  BCF    03.5
15D2:  MOVF   6C,W
15D3:  BSF    03.5
15D4:  MOVWF  29
15D5:  BCF    03.5
15D6:  MOVF   6B,W
15D7:  BSF    03.5
15D8:  MOVWF  28
15D9:  BCF    03.5
15DA:  MOVF   6A,W
15DB:  BSF    03.5
15DC:  MOVWF  27
15DD:  MOVF   7A,W
15DE:  MOVWF  2E
15DF:  MOVF   79,W
15E0:  MOVWF  2D
15E1:  MOVF   78,W
15E2:  MOVWF  2C
15E3:  MOVF   77,W
15E4:  MOVWF  2B
15E5:  BCF    0A.4
15E6:  BSF    0A.3
15E7:  BCF    03.5
15E8:  CALL   1CA
15E9:  BSF    0A.4
15EA:  BCF    0A.3
15EB:  MOVF   7A,W
15EC:  MOVWF  6D
15ED:  MOVF   79,W
15EE:  MOVWF  6C
15EF:  MOVF   78,W
15F0:  MOVWF  6B
15F1:  MOVF   77,W
15F2:  MOVWF  6A
15F3:  BSF    03.5
....................    } 
....................  
....................    //Calculamos la media como el cociente entre los valore de tiempo calculados y el número de 
....................    //días en los que se ha encendido la caldera 
....................    valor = valor/(float)num_dias; 
15F4:  MOVF   26,W
15F5:  MOVWF  28
15F6:  MOVF   25,W
15F7:  MOVWF  27
15F8:  BCF    0A.4
15F9:  BSF    0A.3
15FA:  BCF    03.5
15FB:  CALL   310
15FC:  BSF    0A.4
15FD:  BCF    0A.3
15FE:  MOVF   71,W
15FF:  BSF    03.5
1600:  MOVWF  2A
1601:  MOVF   70,W
1602:  MOVWF  29
1603:  BCF    03.5
1604:  MOVF   6F,W
1605:  BSF    03.5
1606:  MOVWF  28
1607:  BCF    03.5
1608:  MOVF   6E,W
1609:  BSF    03.5
160A:  MOVWF  27
160B:  MOVF   7A,W
160C:  MOVWF  2E
160D:  MOVF   79,W
160E:  MOVWF  2D
160F:  MOVF   78,W
1610:  MOVWF  2C
1611:  MOVF   77,W
1612:  MOVWF  2B
1613:  BCF    0A.4
1614:  BSF    0A.3
1615:  BCF    03.5
1616:  CALL   027
1617:  BSF    0A.4
1618:  BCF    0A.3
1619:  MOVF   7A,W
161A:  MOVWF  71
161B:  MOVF   79,W
161C:  MOVWF  70
161D:  MOVF   78,W
161E:  MOVWF  6F
161F:  MOVF   77,W
1620:  MOVWF  6E
....................    media_dia_caldera = media_dia_caldera/(float)num_dias; 
1621:  BSF    03.5
1622:  MOVF   26,W
1623:  MOVWF  28
1624:  MOVF   25,W
1625:  MOVWF  27
1626:  BCF    0A.4
1627:  BSF    0A.3
1628:  BCF    03.5
1629:  CALL   310
162A:  BSF    0A.4
162B:  BCF    0A.3
162C:  MOVF   6D,W
162D:  BSF    03.5
162E:  MOVWF  2A
162F:  BCF    03.5
1630:  MOVF   6C,W
1631:  BSF    03.5
1632:  MOVWF  29
1633:  BCF    03.5
1634:  MOVF   6B,W
1635:  BSF    03.5
1636:  MOVWF  28
1637:  BCF    03.5
1638:  MOVF   6A,W
1639:  BSF    03.5
163A:  MOVWF  27
163B:  MOVF   7A,W
163C:  MOVWF  2E
163D:  MOVF   79,W
163E:  MOVWF  2D
163F:  MOVF   78,W
1640:  MOVWF  2C
1641:  MOVF   77,W
1642:  MOVWF  2B
1643:  BCF    0A.4
1644:  BSF    0A.3
1645:  BCF    03.5
1646:  CALL   027
1647:  BSF    0A.4
1648:  BCF    0A.3
1649:  MOVF   7A,W
164A:  MOVWF  6D
164B:  MOVF   79,W
164C:  MOVWF  6C
164D:  MOVF   78,W
164E:  MOVWF  6B
164F:  MOVF   77,W
1650:  MOVWF  6A
....................  
....................    repetir: 
....................    //Menú para mostrar los datos 
....................    printf("\r"); 
1651:  MOVLW  0D
1652:  CLRWDT
1653:  BTFSS  0C.4
1654:  GOTO   652
1655:  MOVWF  19
....................    printf("0.Salir\r"); 
1656:  BSF    03.5
1657:  CLRF   27
1658:  MOVF   27,W
1659:  BCF    0A.4
165A:  BCF    03.5
165B:  CALL   0E5
165C:  BSF    0A.4
165D:  BSF    03.5
165E:  INCF   27,F
165F:  MOVWF  77
1660:  CLRWDT
1661:  BCF    03.5
1662:  BTFSC  0C.4
1663:  GOTO   666
1664:  BSF    03.5
1665:  GOTO   660
1666:  MOVWF  19
1667:  MOVLW  08
1668:  BSF    03.5
1669:  SUBWF  27,W
166A:  BTFSS  03.2
166B:  GOTO   658
....................    printf("1.Tiempos medios por dia\r"); 
166C:  CLRF   27
166D:  MOVF   27,W
166E:  BCF    0A.4
166F:  BCF    03.5
1670:  CALL   0F2
1671:  BSF    0A.4
1672:  BSF    03.5
1673:  INCF   27,F
1674:  MOVWF  77
1675:  CLRWDT
1676:  BCF    03.5
1677:  BTFSC  0C.4
1678:  GOTO   67B
1679:  BSF    03.5
167A:  GOTO   675
167B:  MOVWF  19
167C:  MOVLW  19
167D:  BSF    03.5
167E:  SUBWF  27,W
167F:  BTFSS  03.2
1680:  GOTO   66D
....................    printf("2.Tiempos totales\r"); 
1681:  CLRF   27
1682:  MOVF   27,W
1683:  BCF    0A.4
1684:  BCF    03.5
1685:  CALL   113
1686:  BSF    0A.4
1687:  BSF    03.5
1688:  INCF   27,F
1689:  MOVWF  77
168A:  CLRWDT
168B:  BCF    03.5
168C:  BTFSC  0C.4
168D:  GOTO   690
168E:  BSF    03.5
168F:  GOTO   68A
1690:  MOVWF  19
1691:  MOVLW  12
1692:  BSF    03.5
1693:  SUBWF  27,W
1694:  BTFSS  03.2
1695:  GOTO   682
....................    printf("\r"); 
1696:  MOVLW  0D
1697:  CLRWDT
1698:  BCF    03.5
1699:  BTFSC  0C.4
169A:  GOTO   69D
169B:  BSF    03.5
169C:  GOTO   697
169D:  MOVWF  19
....................  
....................    //Esperamos la introducción de una de las opciones por parte del técnico. 
....................    //Cuando se pulse uno de los botones, asignamos a la variable caracter el valor correspondiente. 
....................    caracter='J'; 
169E:  MOVLW  4A
169F:  MOVWF  69
....................    while(caracter!='0' && caracter!='1' && caracter!='2'){ 
16A0:  MOVF   69,W
16A1:  SUBLW  30
16A2:  BTFSC  03.2
16A3:  GOTO   6B2
16A4:  MOVF   69,W
16A5:  SUBLW  31
16A6:  BTFSC  03.2
16A7:  GOTO   6B2
16A8:  MOVF   69,W
16A9:  SUBLW  32
16AA:  BTFSC  03.2
16AB:  GOTO   6B2
....................       caracter=getch(); 
16AC:  CLRWDT
16AD:  BTFSS  0C.5
16AE:  GOTO   6AC
16AF:  MOVF   1A,W
16B0:  MOVWF  69
....................    } 
16B1:  GOTO   6A0
....................  
....................    switch(caracter) 
....................    { 
16B2:  MOVF   69,W
16B3:  XORLW  30
16B4:  BTFSC  03.2
16B5:  GOTO   6BD
16B6:  XORLW  01
16B7:  BTFSC  03.2
16B8:  GOTO   6BE
16B9:  XORLW  03
16BA:  BTFSC  03.2
16BB:  GOTO   742
16BC:  GOTO   7AE
....................       //En el caso 0, se sale del sistema 
....................       case '0': 
....................                //No se indica la salida para ahorrar memoria 
....................                break; 
16BD:  GOTO   7AE
....................  
....................       //En el caso 1, se muestran los valores medios 
....................       case '1': 
....................                printf("\rT. med.: %3.2f min\r\r", valor); 
16BE:  BSF    03.5
16BF:  CLRF   27
16C0:  MOVF   27,W
16C1:  BCF    0A.4
16C2:  BCF    03.5
16C3:  CALL   12A
16C4:  BSF    0A.4
16C5:  BSF    03.5
16C6:  INCF   27,F
16C7:  MOVWF  77
16C8:  CLRWDT
16C9:  BCF    03.5
16CA:  BTFSC  0C.4
16CB:  GOTO   6CE
16CC:  BSF    03.5
16CD:  GOTO   6C8
16CE:  MOVWF  19
16CF:  MOVLW  0A
16D0:  BSF    03.5
16D1:  SUBWF  27,W
16D2:  BTFSS  03.2
16D3:  GOTO   6C0
16D4:  MOVLW  02
16D5:  MOVWF  04
16D6:  MOVF   71,W
16D7:  MOVWF  2B
16D8:  MOVF   70,W
16D9:  MOVWF  2A
16DA:  BCF    03.5
16DB:  MOVF   6F,W
16DC:  BSF    03.5
16DD:  MOVWF  29
16DE:  BCF    03.5
16DF:  MOVF   6E,W
16E0:  BSF    03.5
16E1:  MOVWF  28
16E2:  MOVLW  02
16E3:  MOVWF  2C
16E4:  BCF    03.5
16E5:  CALL   1BB
16E6:  MOVLW  0F
16E7:  BSF    03.5
16E8:  MOVWF  28
16E9:  MOVF   28,W
16EA:  BCF    0A.4
16EB:  BCF    03.5
16EC:  CALL   12A
16ED:  BSF    0A.4
16EE:  BSF    03.5
16EF:  INCF   28,F
16F0:  MOVWF  77
16F1:  CLRWDT
16F2:  BCF    03.5
16F3:  BTFSC  0C.4
16F4:  GOTO   6F7
16F5:  BSF    03.5
16F6:  GOTO   6F1
16F7:  MOVWF  19
16F8:  MOVLW  15
16F9:  BSF    03.5
16FA:  SUBWF  28,W
16FB:  BTFSS  03.2
16FC:  GOTO   6E9
....................                printf("T. med. caldera: %3.2f min\r\r", media_dia_caldera); 
16FD:  CLRF   27
16FE:  MOVF   27,W
16FF:  BCF    0A.4
1700:  BCF    03.5
1701:  CALL   144
1702:  BSF    0A.4
1703:  BSF    03.5
1704:  INCF   27,F
1705:  MOVWF  77
1706:  CLRWDT
1707:  BCF    03.5
1708:  BTFSC  0C.4
1709:  GOTO   70C
170A:  BSF    03.5
170B:  GOTO   706
170C:  MOVWF  19
170D:  MOVLW  11
170E:  BSF    03.5
170F:  SUBWF  27,W
1710:  BTFSS  03.2
1711:  GOTO   6FE
1712:  MOVLW  02
1713:  MOVWF  04
1714:  BCF    03.5
1715:  MOVF   6D,W
1716:  BSF    03.5
1717:  MOVWF  2B
1718:  BCF    03.5
1719:  MOVF   6C,W
171A:  BSF    03.5
171B:  MOVWF  2A
171C:  BCF    03.5
171D:  MOVF   6B,W
171E:  BSF    03.5
171F:  MOVWF  29
1720:  BCF    03.5
1721:  MOVF   6A,W
1722:  BSF    03.5
1723:  MOVWF  28
1724:  MOVLW  02
1725:  MOVWF  2C
1726:  BCF    03.5
1727:  CALL   1BB
1728:  MOVLW  16
1729:  BSF    03.5
172A:  MOVWF  28
172B:  MOVF   28,W
172C:  BCF    0A.4
172D:  BCF    03.5
172E:  CALL   144
172F:  BSF    0A.4
1730:  BSF    03.5
1731:  INCF   28,F
1732:  MOVWF  77
1733:  CLRWDT
1734:  BCF    03.5
1735:  BTFSC  0C.4
1736:  GOTO   739
1737:  BSF    03.5
1738:  GOTO   733
1739:  MOVWF  19
173A:  MOVLW  1C
173B:  BSF    03.5
173C:  SUBWF  28,W
173D:  BTFSS  03.2
173E:  GOTO   72B
....................                goto repetir; 
173F:  BCF    03.5
1740:  GOTO   651
....................                break; 
1741:  GOTO   7AE
....................  
....................       //En el caso 2, se muestran los valores totales 
....................       case '2': 
....................                printf("\rT. total: %lu min\r\r", valor_total); 
1742:  BSF    03.5
1743:  CLRF   27
1744:  MOVF   27,W
1745:  BCF    0A.4
1746:  BCF    03.5
1747:  CALL   165
1748:  BSF    0A.4
1749:  BSF    03.5
174A:  INCF   27,F
174B:  MOVWF  77
174C:  CLRWDT
174D:  BCF    03.5
174E:  BTFSC  0C.4
174F:  GOTO   752
1750:  BSF    03.5
1751:  GOTO   74C
1752:  MOVWF  19
1753:  MOVLW  0B
1754:  BSF    03.5
1755:  SUBWF  27,W
1756:  BTFSS  03.2
1757:  GOTO   744
1758:  MOVLW  10
1759:  MOVWF  04
175A:  MOVF   73,W
175B:  MOVWF  29
175C:  MOVF   72,W
175D:  MOVWF  28
175E:  BCF    03.5
175F:  CALL   2AD
1760:  MOVLW  0E
1761:  BSF    03.5
1762:  MOVWF  28
1763:  MOVF   28,W
1764:  BCF    0A.4
1765:  BCF    03.5
1766:  CALL   165
1767:  BSF    0A.4
1768:  BSF    03.5
1769:  INCF   28,F
176A:  MOVWF  77
176B:  CLRWDT
176C:  BCF    03.5
176D:  BTFSC  0C.4
176E:  GOTO   771
176F:  BSF    03.5
1770:  GOTO   76B
1771:  MOVWF  19
1772:  MOVLW  14
1773:  BSF    03.5
1774:  SUBWF  28,W
1775:  BTFSS  03.2
1776:  GOTO   763
....................                printf("T. total caldera: %lu min\r\r", valor_total_caldera); 
1777:  CLRF   27
1778:  MOVF   27,W
1779:  BCF    0A.4
177A:  BCF    03.5
177B:  CALL   17E
177C:  BSF    0A.4
177D:  BSF    03.5
177E:  INCF   27,F
177F:  MOVWF  77
1780:  CLRWDT
1781:  BCF    03.5
1782:  BTFSC  0C.4
1783:  GOTO   786
1784:  BSF    03.5
1785:  GOTO   780
1786:  MOVWF  19
1787:  MOVLW  12
1788:  BSF    03.5
1789:  SUBWF  27,W
178A:  BTFSS  03.2
178B:  GOTO   778
178C:  MOVLW  10
178D:  MOVWF  04
178E:  MOVF   75,W
178F:  MOVWF  29
1790:  MOVF   74,W
1791:  MOVWF  28
1792:  BCF    03.5
1793:  CALL   2AD
1794:  MOVLW  15
1795:  BSF    03.5
1796:  MOVWF  28
1797:  MOVF   28,W
1798:  BCF    0A.4
1799:  BCF    03.5
179A:  CALL   17E
179B:  BSF    0A.4
179C:  BSF    03.5
179D:  INCF   28,F
179E:  MOVWF  77
179F:  CLRWDT
17A0:  BCF    03.5
17A1:  BTFSC  0C.4
17A2:  GOTO   7A5
17A3:  BSF    03.5
17A4:  GOTO   79F
17A5:  MOVWF  19
17A6:  MOVLW  1B
17A7:  BSF    03.5
17A8:  SUBWF  28,W
17A9:  BTFSS  03.2
17AA:  GOTO   797
....................                goto repetir; 
17AB:  BCF    03.5
17AC:  GOTO   651
....................                break; 
17AD:  GOTO   7AE
....................  
....................       //En los dos casos, vuelve a mostrarse el menú tras imprimir las estadísticas 
....................    } 
.................... } 
17AE:  BSF    0A.3
17AF:  BSF    0A.4
17B0:  GOTO   710 (RETURN)
....................  
.................... //------------------------------------------------------------------------------------------------------------------------------------ 

Configuration Fuses:
   Word  1: 2FE2   HS NOWDT PUT MCLR NOPROTECT NOCPD BROWNOUT IESO FCMEN NOLVP NODEBUG
   Word  2: 3FFF   NOWRT BORV40
