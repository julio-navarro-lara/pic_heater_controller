CCS PCH C Compiler, Version 3.249, 28193               26-feb-10 13:46

               Filename: E:\programming\sed\Proyecto 1\Material definitivo\Prototipo 1 optimizado\proyecto1.lst

               ROM used: 28434 bytes (87%)
                         Largest free fragment is 4330
               RAM used: 138 (9%) at main() level
                         722 (47%) worst case
               Stack:    8 worst case (7 in main + 1 for interrupts)

*
0000:  GOTO   5EC0
*
0008:  MOVWF  05
000A:  MOVFF  FD8,06
000E:  MOVFF  FE0,07
0012:  MOVLB  0
0014:  MOVFF  FE9,0D
0018:  MOVFF  FEA,08
001C:  MOVFF  FE1,09
0020:  MOVFF  FE2,0A
0024:  MOVFF  FD9,0B
0028:  MOVFF  FDA,0C
002C:  MOVFF  FF3,14
0030:  MOVFF  FF4,15
0034:  MOVFF  FFA,16
0038:  MOVFF  00,0F
003C:  MOVFF  01,10
0040:  MOVFF  02,11
0044:  MOVFF  03,12
0048:  MOVFF  04,13
004C:  BTFSS  F9D.0
004E:  GOTO   0058
0052:  BTFSC  F9E.0
0054:  GOTO   1298
0058:  BTFSS  FF2.4
005A:  GOTO   0064
005E:  BTFSC  FF2.1
0060:  GOTO   1288
0064:  BTFSS  FF0.3
0066:  GOTO   0070
006A:  BTFSC  FF0.0
006C:  GOTO   1290
0070:  MOVFF  0F,00
0074:  MOVFF  10,01
0078:  MOVFF  11,02
007C:  MOVFF  12,03
0080:  MOVFF  13,04
0084:  MOVFF  0D,FE9
0088:  MOVFF  08,FEA
008C:  MOVFF  09,FE1
0090:  MOVFF  0A,FE2
0094:  MOVFF  0B,FD9
0098:  MOVFF  0C,FDA
009C:  MOVFF  14,FF3
00A0:  MOVFF  15,FF4
00A4:  MOVFF  16,FFA
00A8:  MOVF   05,W
00AA:  MOVFF  07,FE0
00AE:  MOVFF  06,FD8
00B2:  RETFIE 0
.................... //***************************************************************** 
.................... //***   PROYECTO 1: Control de un sistema de calefacción de una *** 
.................... //***   vivienda utilizando un microcontrolador PIC18F4520      *** 
.................... //***************************************************************** 
.................... //Author: Julio Navarro Lara        2010 
....................  
....................  
....................  
.................... #include "18F4520.H" 
.................... //////// Standard Header file for the PIC18F4520 device //////////////// 
.................... #DEVICE PIC18F4520 //Aunque el convertidor A/D es de 10 bits, con esta directiva 
00B4:  MOVFF  FF2,0E
00B8:  BCF    FF2.7
00BA:  CLRF   FF7
00BC:  ADDLW  CE
00BE:  MOVWF  FF6
00C0:  MOVLW  00
00C2:  ADDWFC FF7,F
00C4:  TBLRD*+
00C6:  MOVF   FF5,W
00C8:  BTFSC  0E.7
00CA:  BSF    FF2.7
00CC:  RETURN 0
00CE:  DATA 2C,0F
00D0:  DATA 01,06
00D2:  MOVFF  FF2,0E
00D6:  BCF    FF2.7
00D8:  CLRF   FF7
00DA:  ADDLW  EC
00DC:  MOVWF  FF6
00DE:  MOVLW  00
00E0:  ADDWFC FF7,F
00E2:  TBLRD*+
00E4:  MOVF   FF5,W
00E6:  BTFSC  0E.7
00E8:  BSF    FF2.7
00EA:  RETURN 0
00EC:  DATA 31,32
00EE:  DATA 33,34
00F0:  DATA 35,36
00F2:  DATA 37,38
00F4:  DATA 39,53
00F6:  DATA 30,4E
00F8:  MOVFF  FF2,0E
00FC:  BCF    FF2.7
00FE:  CLRF   FF7
0100:  ADDLW  12
0102:  MOVWF  FF6
0104:  MOVLW  01
0106:  ADDWFC FF7,F
0108:  TBLRD*+
010A:  MOVF   FF5,W
010C:  BTFSC  0E.7
010E:  BSF    FF2.7
0110:  RETURN 0
0112:  DATA 49,6E
0114:  DATA 69,63
0116:  DATA 69,61
0118:  DATA 6C,69
011A:  DATA 7A,61
011C:  DATA 6E,64
011E:  DATA 6F,2E
0120:  DATA 2E,2E
0122:  DATA 00,00
0124:  MOVFF  FF2,0E
0128:  BCF    FF2.7
012A:  CLRF   FF7
012C:  ADDLW  3E
012E:  MOVWF  FF6
0130:  MOVLW  01
0132:  ADDWFC FF7,F
0134:  TBLRD*+
0136:  MOVF   FF5,W
0138:  BTFSC  0E.7
013A:  BSF    FF2.7
013C:  RETURN 0
013E:  DATA 53,69
0140:  DATA 73,74
0142:  DATA 65,6D
0144:  DATA 61,20
0146:  DATA 69,6E
0148:  DATA 69,63
014A:  DATA 69,61
014C:  DATA 6C,69
014E:  DATA 7A,61
0150:  DATA 64,6F
0152:  DATA 20,63
0154:  DATA 6F,6E
0156:  DATA 20,65
0158:  DATA 78,69
015A:  DATA 74,6F
015C:  DATA 21,0D
015E:  DATA 00,00
0160:  MOVFF  FF2,0E
0164:  BCF    FF2.7
0166:  CLRF   FF7
0168:  ADDLW  7A
016A:  MOVWF  FF6
016C:  MOVLW  01
016E:  ADDWFC FF7,F
0170:  TBLRD*+
0172:  MOVF   FF5,W
0174:  BTFSC  0E.7
0176:  BSF    FF2.7
0178:  RETURN 0
017A:  DATA 20,20
017C:  DATA 45,6E
017E:  DATA 63,65
0180:  DATA 6E,64
0182:  DATA 69,65
0184:  DATA 6E,64
0186:  DATA 6F,0A
0188:  DATA 20,20
018A:  DATA 73,69
018C:  DATA 73,74
018E:  DATA 65,6D
0190:  DATA 61,2E
0192:  DATA 2E,2E
0194:  DATA 00,00
0196:  MOVFF  FF2,0E
019A:  BCF    FF2.7
019C:  CLRF   FF7
019E:  ADDLW  B0
01A0:  MOVWF  FF6
01A2:  MOVLW  01
01A4:  ADDWFC FF7,F
01A6:  TBLRD*+
01A8:  MOVF   FF5,W
01AA:  BTFSC  0E.7
01AC:  BSF    FF2.7
01AE:  RETURN 0
01B0:  DATA 20,20
01B2:  DATA 41,70
01B4:  DATA 61,67
01B6:  DATA 61,6E
01B8:  DATA 64,6F
01BA:  DATA 0A,20
01BC:  DATA 20,73
01BE:  DATA 69,73
01C0:  DATA 74,65
01C2:  DATA 6D,61
01C4:  DATA 2E,2E
01C6:  DATA 2E,00
01C8:  MOVFF  FF2,0E
01CC:  BCF    FF2.7
01CE:  CLRF   FF7
01D0:  ADDLW  E2
01D2:  MOVWF  FF6
01D4:  MOVLW  01
01D6:  ADDWFC FF7,F
01D8:  TBLRD*+
01DA:  MOVF   FF5,W
01DC:  BTFSC  0E.7
01DE:  BSF    FF2.7
01E0:  RETURN 0
01E2:  DATA 20,20
01E4:  DATA 49,6E
01E6:  DATA 64,69
01E8:  DATA 71,75
01EA:  DATA 65,20
01EC:  DATA 6C,61
01EE:  DATA 20,0A
01F0:  DATA 20,20
01F2:  DATA 6F,70
01F4:  DATA 65,72
01F6:  DATA 61,63
01F8:  DATA 69,6F
01FA:  DATA 6E,00
01FC:  MOVFF  FF2,0E
0200:  BCF    FF2.7
0202:  CLRF   FF7
0204:  ADDLW  16
0206:  MOVWF  FF6
0208:  MOVLW  02
020A:  ADDWFC FF7,F
020C:  TBLRD*+
020E:  MOVF   FF5,W
0210:  BTFSC  0E.7
0212:  BSF    FF2.7
0214:  RETURN 0
0216:  DATA 4D,6F
0218:  DATA 64,69
021A:  DATA 66,69
021C:  DATA 63,61
021E:  DATA 72,0A
0220:  DATA 74,65
0222:  DATA 72,6D
0224:  DATA 6F,73
0226:  DATA 74,61
0228:  DATA 74,6F
022A:  DATA 20,25
022C:  DATA 2E,30
022E:  DATA 66,25
0230:  DATA 63,43
0232:  DATA 00,00
0234:  MOVFF  FF2,0E
0238:  BCF    FF2.7
023A:  CLRF   FF7
023C:  ADDLW  4E
023E:  MOVWF  FF6
0240:  MOVLW  02
0242:  ADDWFC FF7,F
0244:  TBLRD*+
0246:  MOVF   FF5,W
0248:  BTFSC  0E.7
024A:  BSF    FF2.7
024C:  RETURN 0
024E:  DATA 4E,75
0250:  DATA 65,76
0252:  DATA 6F,20
0254:  DATA 76,61
0256:  DATA 6C,6F
0258:  DATA 72,3A
025A:  DATA 0A,25
025C:  DATA 63,43
025E:  DATA 00,00
0260:  MOVFF  FF2,0E
0264:  BCF    FF2.7
0266:  CLRF   FF7
0268:  ADDLW  7A
026A:  MOVWF  FF6
026C:  MOVLW  02
026E:  ADDWFC FF7,F
0270:  TBLRD*+
0272:  MOVF   FF5,W
0274:  BTFSC  0E.7
0276:  BSF    FF2.7
0278:  RETURN 0
027A:  DATA 20,20
027C:  DATA 41,70
027E:  DATA 6C,69
0280:  DATA 63,61
0282:  DATA 6E,64
0284:  DATA 6F,0A
0286:  DATA 20,20
0288:  DATA 63,61
028A:  DATA 6D,62
028C:  DATA 69,6F
028E:  DATA 73,2E
0290:  DATA 2E,2E
0292:  DATA 00,00
0294:  MOVFF  FF2,0E
0298:  BCF    FF2.7
029A:  CLRF   FF7
029C:  ADDLW  AE
029E:  MOVWF  FF6
02A0:  MOVLW  02
02A2:  ADDWFC FF7,F
02A4:  TBLRD*+
02A6:  MOVF   FF5,W
02A8:  BTFSC  0E.7
02AA:  BSF    FF2.7
02AC:  RETURN 0
02AE:  DATA 20,20
02B0:  DATA 20,56
02B2:  DATA 61,6C
02B4:  DATA 6F,72
02B6:  DATA 0A,20
02B8:  DATA 20,20
02BA:  DATA 69,6E
02BC:  DATA 63,6F
02BE:  DATA 72,72
02C0:  DATA 65,63
02C2:  DATA 74,6F
02C4:  DATA 00,00
02C6:  MOVFF  FF2,0E
02CA:  BCF    FF2.7
02CC:  CLRF   FF7
02CE:  ADDLW  E0
02D0:  MOVWF  FF6
02D2:  MOVLW  02
02D4:  ADDWFC FF7,F
02D6:  TBLRD*+
02D8:  MOVF   FF5,W
02DA:  BTFSC  0E.7
02DC:  BSF    FF2.7
02DE:  RETURN 0
02E0:  DATA 20,50
02E2:  DATA 72,6F
02E4:  DATA 67,72
02E6:  DATA 61,6D
02E8:  DATA 61,72
02EA:  DATA 0A,20
02EC:  DATA 73,69
02EE:  DATA 73,74
02F0:  DATA 65,6D
02F2:  DATA 61,00
02F4:  MOVFF  FF2,0E
02F8:  BCF    FF2.7
02FA:  CLRF   FF7
02FC:  ADDLW  0E
02FE:  MOVWF  FF6
0300:  MOVLW  03
0302:  ADDWFC FF7,F
0304:  TBLRD*+
0306:  MOVF   FF5,W
0308:  BTFSC  0E.7
030A:  BSF    FF2.7
030C:  RETURN 0
030E:  DATA 20,49
0310:  DATA 4E,54
0312:  DATA 45,52
0314:  DATA 56,41
0316:  DATA 4C,4F
0318:  DATA 20,25
031A:  DATA 69,0A
031C:  DATA 3A,3A
031E:  DATA 00,00
0320:  MOVFF  FF2,0E
0324:  BCF    FF2.7
0326:  CLRF   FF7
0328:  ADDLW  3A
032A:  MOVWF  FF6
032C:  MOVLW  03
032E:  ADDWFC FF7,F
0330:  TBLRD*+
0332:  MOVF   FF5,W
0334:  BTFSC  0E.7
0336:  BSF    FF2.7
0338:  RETURN 0
033A:  DATA 20,20
033C:  DATA 20,56
033E:  DATA 61,6C
0340:  DATA 6F,72
0342:  DATA 65,73
0344:  DATA 0A,20
0346:  DATA 20,20
0348:  DATA 69,6E
034A:  DATA 63,6F
034C:  DATA 72,72
034E:  DATA 65,63
0350:  DATA 74,6F
0352:  DATA 73,00
0354:  MOVFF  FF2,0E
0358:  BCF    FF2.7
035A:  CLRF   FF7
035C:  ADDLW  6E
035E:  MOVWF  FF6
0360:  MOVLW  03
0362:  ADDWFC FF7,F
0364:  TBLRD*+
0366:  MOVF   FF5,W
0368:  BTFSC  0E.7
036A:  BSF    FF2.7
036C:  RETURN 0
036E:  DATA 49,6E
0370:  DATA 74,65
0372:  DATA 72,76
0374:  DATA 61,6C
0376:  DATA 6F,20
0378:  DATA 6C,69
037A:  DATA 6D,69
037C:  DATA 74,65
037E:  DATA 0A,64
0380:  DATA 65,20
0382:  DATA 34,20
0384:  DATA 68,6F
0386:  DATA 72,61
0388:  DATA 73,00
038A:  MOVFF  FF2,0E
038E:  BCF    FF2.7
0390:  CLRF   FF7
0392:  ADDLW  A4
0394:  MOVWF  FF6
0396:  MOVLW  03
0398:  ADDWFC FF7,F
039A:  TBLRD*+
039C:  MOVF   FF5,W
039E:  BTFSC  0E.7
03A0:  BSF    FF2.7
03A2:  RETURN 0
03A4:  DATA 54,65
03A6:  DATA 72,6D
03A8:  DATA 6F,73
03AA:  DATA 74,61
03AC:  DATA 74,6F
03AE:  DATA 20,25
03B0:  DATA 69,0A
03B2:  DATA 25,63
03B4:  DATA 43,00
03B6:  MOVFF  FF2,0E
03BA:  BCF    FF2.7
03BC:  CLRF   FF7
03BE:  ADDLW  D0
03C0:  MOVWF  FF6
03C2:  MOVLW  03
03C4:  ADDWFC FF7,F
03C6:  TBLRD*+
03C8:  MOVF   FF5,W
03CA:  BTFSC  0E.7
03CC:  BSF    FF2.7
03CE:  RETURN 0
03D0:  DATA 53,6F
03D2:  DATA 6C,61
03D4:  DATA 70,61
03D6:  DATA 6D,69
03D8:  DATA 65,6E
03DA:  DATA 74,6F
03DC:  DATA 0A,64
03DE:  DATA 65,20
03E0:  DATA 69,6E
03E2:  DATA 74,65
03E4:  DATA 72,76
03E6:  DATA 61,6C
03E8:  DATA 6F,73
03EA:  DATA 21,00
03EC:  MOVFF  FF2,0E
03F0:  BCF    FF2.7
03F2:  CLRF   FF7
03F4:  ADDLW  06
03F6:  MOVWF  FF6
03F8:  MOVLW  04
03FA:  ADDWFC FF7,F
03FC:  TBLRD*+
03FE:  MOVF   FF5,W
0400:  BTFSC  0E.7
0402:  BSF    FF2.7
0404:  RETURN 0
0406:  DATA 20,20
0408:  DATA 43,4C
040A:  DATA 41,56
040C:  DATA 45,3A
040E:  DATA 0A,20
0410:  DATA 20,00
0412:  MOVFF  FF2,0E
0416:  BCF    FF2.7
0418:  CLRF   FF7
041A:  ADDLW  2C
041C:  MOVWF  FF6
041E:  MOVLW  04
0420:  ADDWFC FF7,F
0422:  TBLRD*+
0424:  MOVF   FF5,W
0426:  BTFSC  0E.7
0428:  BSF    FF2.7
042A:  RETURN 0
042C:  DATA 20,20
042E:  DATA 4D,6F
0430:  DATA 64,6F
0432:  DATA 0A,20
0434:  DATA 20,72
0436:  DATA 65,76
0438:  DATA 69,73
043A:  DATA 69,6F
043C:  DATA 6E,00
043E:  MOVFF  FF2,0E
0442:  BCF    FF2.7
0444:  CLRF   FF7
0446:  ADDLW  58
0448:  MOVWF  FF6
044A:  MOVLW  04
044C:  ADDWFC FF7,F
044E:  TBLRD*+
0450:  MOVF   FF5,W
0452:  BTFSC  0E.7
0454:  BSF    FF2.7
0456:  RETURN 0
0458:  DATA 20,20
045A:  DATA 43,6C
045C:  DATA 61,76
045E:  DATA 65,0A
0460:  DATA 20,20
0462:  DATA 69,6E
0464:  DATA 63,6F
0466:  DATA 72,72
0468:  DATA 65,63
046A:  DATA 74,61
046C:  DATA 00,00
046E:  MOVFF  FF2,0E
0472:  BCF    FF2.7
0474:  CLRF   FF7
0476:  ADDLW  88
0478:  MOVWF  FF6
047A:  MOVLW  04
047C:  ADDWFC FF7,F
047E:  TBLRD*+
0480:  MOVF   FF5,W
0482:  BTFSC  0E.7
0484:  BSF    FF2.7
0486:  RETURN 0
0488:  DATA 20,20
048A:  DATA 41,6E
048C:  DATA 75,6C
048E:  DATA 61,6E
0490:  DATA 64,6F
0492:  DATA 0A,20
0494:  DATA 20,6F
0496:  DATA 70,65
0498:  DATA 72,61
049A:  DATA 63,69
049C:  DATA 6F,6E
049E:  DATA 2E,2E
04A0:  DATA 2E,00
04A2:  MOVFF  FF2,0E
04A6:  BCF    FF2.7
04A8:  CLRF   FF7
04AA:  ADDLW  BC
04AC:  MOVWF  FF6
04AE:  MOVLW  04
04B0:  ADDWFC FF7,F
04B2:  TBLRD*+
04B4:  MOVF   FF5,W
04B6:  BTFSC  0E.7
04B8:  BSF    FF2.7
04BA:  RETURN 0
04BC:  DATA 44,65
04BE:  DATA 6D,61
04C0:  DATA 73,69
04C2:  DATA 61,64
04C4:  DATA 6F,20
04C6:  DATA 74,69
04C8:  DATA 65,6D
04CA:  DATA 70,6F
04CC:  DATA 0A,65
04CE:  DATA 6E,63
04D0:  DATA 65,6E
04D2:  DATA 64,69
04D4:  DATA 64,6F
04D6:  DATA 21,00
04D8:  MOVFF  FF2,0E
04DC:  BCF    FF2.7
04DE:  CLRF   FF7
04E0:  ADDLW  F2
04E2:  MOVWF  FF6
04E4:  MOVLW  04
04E6:  ADDWFC FF7,F
04E8:  TBLRD*+
04EA:  MOVF   FF5,W
04EC:  BTFSC  0E.7
04EE:  BSF    FF2.7
04F0:  RETURN 0
04F2:  DATA 0D,49
04F4:  DATA 6E,69
04F6:  DATA 63,69
04F8:  DATA 61,6C
04FA:  DATA 69,7A
04FC:  DATA 61,63
04FE:  DATA 69,6F
0500:  DATA 6E,20
0502:  DATA 64,65
0504:  DATA 6C,20
0506:  DATA 73,69
0508:  DATA 73,74
050A:  DATA 65,6D
050C:  DATA 61,0D
050E:  DATA 00,00
0510:  MOVFF  FF2,0E
0514:  BCF    FF2.7
0516:  CLRF   FF7
0518:  ADDLW  2A
051A:  MOVWF  FF6
051C:  MOVLW  05
051E:  ADDWFC FF7,F
0520:  TBLRD*+
0522:  MOVF   FF5,W
0524:  BTFSC  0E.7
0526:  BSF    FF2.7
0528:  RETURN 0
052A:  DATA 2A,2A
052C:  DATA 2A,2A
052E:  DATA 2A,2A
0530:  DATA 2A,2A
0532:  DATA 2A,2A
0534:  DATA 2A,2A
0536:  DATA 2A,2A
0538:  DATA 2A,2A
053A:  DATA 2A,2A
053C:  DATA 2A,2A
053E:  DATA 2A,2A
0540:  DATA 2A,2A
0542:  DATA 2A,2A
0544:  DATA 0D,00
0546:  MOVFF  FF2,0E
054A:  BCF    FF2.7
054C:  CLRF   FF7
054E:  ADDLW  60
0550:  MOVWF  FF6
0552:  MOVLW  05
0554:  ADDWFC FF7,F
0556:  TBLRD*+
0558:  MOVF   FF5,W
055A:  BTFSC  0E.7
055C:  BSF    FF2.7
055E:  RETURN 0
0560:  DATA 44,69
0562:  DATA 61,20
0564:  DATA 64,65
0566:  DATA 20,6C
0568:  DATA 61,20
056A:  DATA 73,65
056C:  DATA 6D,61
056E:  DATA 6E,61
0570:  DATA 20,28
0572:  DATA 31,2D
0574:  DATA 3E,4C
0576:  DATA 75,6E
0578:  DATA 65,73
057A:  DATA 2C,20
057C:  DATA 32,2D
057E:  DATA 3E,4D
0580:  DATA 61,72
0582:  DATA 74,65
0584:  DATA 73,2C
0586:  DATA 20,2E
0588:  DATA 2E,2E
058A:  DATA 29,3A
058C:  DATA 20,4C
058E:  DATA 55,4E
0590:  DATA 45,53
0592:  DATA 20,20
0594:  DATA 20,20
0596:  DATA 00,00
0598:  MOVFF  FF2,0E
059C:  BCF    FF2.7
059E:  CLRF   FF7
05A0:  ADDLW  B2
05A2:  MOVWF  FF6
05A4:  MOVLW  05
05A6:  ADDWFC FF7,F
05A8:  TBLRD*+
05AA:  MOVF   FF5,W
05AC:  BTFSC  0E.7
05AE:  BSF    FF2.7
05B0:  RETURN 0
05B2:  DATA 08,08
05B4:  DATA 08,08
05B6:  DATA 08,08
05B8:  DATA 08,08
05BA:  DATA 08,4C
05BC:  DATA 55,4E
05BE:  DATA 45,53
05C0:  DATA 20,20
05C2:  DATA 20,20
05C4:  DATA 00,00
05C6:  MOVFF  FF2,0E
05CA:  BCF    FF2.7
05CC:  CLRF   FF7
05CE:  ADDLW  E0
05D0:  MOVWF  FF6
05D2:  MOVLW  05
05D4:  ADDWFC FF7,F
05D6:  TBLRD*+
05D8:  MOVF   FF5,W
05DA:  BTFSC  0E.7
05DC:  BSF    FF2.7
05DE:  RETURN 0
05E0:  DATA 08,08
05E2:  DATA 08,08
05E4:  DATA 08,08
05E6:  DATA 08,08
05E8:  DATA 08,4D
05EA:  DATA 41,52
05EC:  DATA 54,45
05EE:  DATA 53,20
05F0:  DATA 20,20
05F2:  DATA 00,00
05F4:  MOVFF  FF2,0E
05F8:  BCF    FF2.7
05FA:  CLRF   FF7
05FC:  ADDLW  0E
05FE:  MOVWF  FF6
0600:  MOVLW  06
0602:  ADDWFC FF7,F
0604:  TBLRD*+
0606:  MOVF   FF5,W
0608:  BTFSC  0E.7
060A:  BSF    FF2.7
060C:  RETURN 0
060E:  DATA 08,08
0610:  DATA 08,08
0612:  DATA 08,08
0614:  DATA 08,08
0616:  DATA 08,4D
0618:  DATA 49,45
061A:  DATA 52,43
061C:  DATA 4F,4C
061E:  DATA 45,53
0620:  DATA 00,00
0622:  MOVFF  FF2,0E
0626:  BCF    FF2.7
0628:  CLRF   FF7
062A:  ADDLW  3C
062C:  MOVWF  FF6
062E:  MOVLW  06
0630:  ADDWFC FF7,F
0632:  TBLRD*+
0634:  MOVF   FF5,W
0636:  BTFSC  0E.7
0638:  BSF    FF2.7
063A:  RETURN 0
063C:  DATA 08,08
063E:  DATA 08,08
0640:  DATA 08,08
0642:  DATA 08,08
0644:  DATA 08,4A
0646:  DATA 55,45
0648:  DATA 56,45
064A:  DATA 53,20
064C:  DATA 20,20
064E:  DATA 00,00
0650:  MOVFF  FF2,0E
0654:  BCF    FF2.7
0656:  CLRF   FF7
0658:  ADDLW  6A
065A:  MOVWF  FF6
065C:  MOVLW  06
065E:  ADDWFC FF7,F
0660:  TBLRD*+
0662:  MOVF   FF5,W
0664:  BTFSC  0E.7
0666:  BSF    FF2.7
0668:  RETURN 0
066A:  DATA 08,08
066C:  DATA 08,08
066E:  DATA 08,08
0670:  DATA 08,08
0672:  DATA 08,56
0674:  DATA 49,45
0676:  DATA 52,4E
0678:  DATA 45,53
067A:  DATA 20,20
067C:  DATA 00,00
067E:  MOVFF  FF2,0E
0682:  BCF    FF2.7
0684:  CLRF   FF7
0686:  ADDLW  98
0688:  MOVWF  FF6
068A:  MOVLW  06
068C:  ADDWFC FF7,F
068E:  TBLRD*+
0690:  MOVF   FF5,W
0692:  BTFSC  0E.7
0694:  BSF    FF2.7
0696:  RETURN 0
0698:  DATA 08,08
069A:  DATA 08,08
069C:  DATA 08,08
069E:  DATA 08,08
06A0:  DATA 08,53
06A2:  DATA 41,42
06A4:  DATA 41,44
06A6:  DATA 4F,20
06A8:  DATA 20,20
06AA:  DATA 00,00
06AC:  MOVFF  FF2,0E
06B0:  BCF    FF2.7
06B2:  CLRF   FF7
06B4:  ADDLW  C6
06B6:  MOVWF  FF6
06B8:  MOVLW  06
06BA:  ADDWFC FF7,F
06BC:  TBLRD*+
06BE:  MOVF   FF5,W
06C0:  BTFSC  0E.7
06C2:  BSF    FF2.7
06C4:  RETURN 0
06C6:  DATA 08,08
06C8:  DATA 08,08
06CA:  DATA 08,08
06CC:  DATA 08,08
06CE:  DATA 08,44
06D0:  DATA 4F,4D
06D2:  DATA 49,4E
06D4:  DATA 47,4F
06D6:  DATA 20,20
06D8:  DATA 00,00
06DA:  MOVFF  FF2,0E
06DE:  BCF    FF2.7
06E0:  CLRF   FF7
06E2:  ADDLW  F4
06E4:  MOVWF  FF6
06E6:  MOVLW  06
06E8:  ADDWFC FF7,F
06EA:  TBLRD*+
06EC:  MOVF   FF5,W
06EE:  BTFSC  0E.7
06F0:  BSF    FF2.7
06F2:  RETURN 0
06F4:  DATA 0D,46
06F6:  DATA 45,43
06F8:  DATA 48,41
06FA:  DATA 3A,20
06FC:  DATA 00,00
06FE:  MOVFF  FF2,0E
0702:  BCF    FF2.7
0704:  CLRF   FF7
0706:  ADDLW  18
0708:  MOVWF  FF6
070A:  MOVLW  07
070C:  ADDWFC FF7,F
070E:  TBLRD*+
0710:  MOVF   FF5,W
0712:  BTFSC  0E.7
0714:  BSF    FF2.7
0716:  RETURN 0
0718:  DATA 0D,52
071A:  DATA 65,73
071C:  DATA 65,74
071E:  DATA 65,61
0720:  DATA 6E,64
0722:  DATA 6F,20
0724:  DATA 69,6E
0726:  DATA 69,63
0728:  DATA 69,61
072A:  DATA 6C,69
072C:  DATA 7A,61
072E:  DATA 63,69
0730:  DATA 6F,6E
0732:  DATA 2E,2E
0734:  DATA 2E,0D
0736:  DATA 00,00
0738:  MOVFF  FF2,0E
073C:  BCF    FF2.7
073E:  CLRF   FF7
0740:  ADDLW  52
0742:  MOVWF  FF6
0744:  MOVLW  07
0746:  ADDWFC FF7,F
0748:  TBLRD*+
074A:  MOVF   FF5,W
074C:  BTFSC  0E.7
074E:  BSF    FF2.7
0750:  RETURN 0
0752:  DATA 0D,44
0754:  DATA 69,61
0756:  DATA 20,69
0758:  DATA 6E,63
075A:  DATA 6F,72
075C:  DATA 72,65
075E:  DATA 63,74
0760:  DATA 6F,2E
0762:  DATA 20,52
0764:  DATA 65,73
0766:  DATA 65,74
0768:  DATA 65,61
076A:  DATA 6E,64
076C:  DATA 6F,20
076E:  DATA 69,6E
0770:  DATA 69,63
0772:  DATA 69,61
0774:  DATA 6C,69
0776:  DATA 7A,61
0778:  DATA 63,69
077A:  DATA 6F,6E
077C:  DATA 2E,2E
077E:  DATA 2E,0D
0780:  DATA 00,00
0782:  MOVFF  FF2,0E
0786:  BCF    FF2.7
0788:  CLRF   FF7
078A:  ADDLW  9C
078C:  MOVWF  FF6
078E:  MOVLW  07
0790:  ADDWFC FF7,F
0792:  TBLRD*+
0794:  MOVF   FF5,W
0796:  BTFSC  0E.7
0798:  BSF    FF2.7
079A:  RETURN 0
079C:  DATA 2F,00
079E:  MOVFF  FF2,0E
07A2:  BCF    FF2.7
07A4:  CLRF   FF7
07A6:  ADDLW  B8
07A8:  MOVWF  FF6
07AA:  MOVLW  07
07AC:  ADDWFC FF7,F
07AE:  TBLRD*+
07B0:  MOVF   FF5,W
07B2:  BTFSC  0E.7
07B4:  BSF    FF2.7
07B6:  RETURN 0
07B8:  DATA 0D,4D
07BA:  DATA 65,73
07BC:  DATA 20,69
07BE:  DATA 6E,63
07C0:  DATA 6F,72
07C2:  DATA 72,65
07C4:  DATA 63,74
07C6:  DATA 6F,2E
07C8:  DATA 20,52
07CA:  DATA 65,73
07CC:  DATA 65,74
07CE:  DATA 65,61
07D0:  DATA 6E,64
07D2:  DATA 6F,20
07D4:  DATA 69,6E
07D6:  DATA 69,63
07D8:  DATA 69,61
07DA:  DATA 6C,69
07DC:  DATA 7A,61
07DE:  DATA 63,69
07E0:  DATA 6F,6E
07E2:  DATA 2E,2E
07E4:  DATA 2E,0D
07E6:  DATA 00,00
07E8:  MOVFF  FF2,0E
07EC:  BCF    FF2.7
07EE:  CLRF   FF7
07F0:  ADDLW  02
07F2:  MOVWF  FF6
07F4:  MOVLW  08
07F6:  ADDWFC FF7,F
07F8:  TBLRD*+
07FA:  MOVF   FF5,W
07FC:  BTFSC  0E.7
07FE:  BSF    FF2.7
0800:  RETURN 0
0802:  DATA 0D,45
0804:  DATA 72,72
0806:  DATA 6F,72
0808:  DATA 20,65
080A:  DATA 6E,20
080C:  DATA 6C,61
080E:  DATA 20,66
0810:  DATA 65,63
0812:  DATA 68,61
0814:  DATA 2E,20
0816:  DATA 52,65
0818:  DATA 73,65
081A:  DATA 74,65
081C:  DATA 61,6E
081E:  DATA 64,6F
0820:  DATA 20,69
0822:  DATA 6E,69
0824:  DATA 63,69
0826:  DATA 61,6C
0828:  DATA 69,7A
082A:  DATA 61,63
082C:  DATA 69,6F
082E:  DATA 6E,2E
0830:  DATA 2E,2E
0832:  DATA 0D,00
0834:  MOVFF  FF2,0E
0838:  BCF    FF2.7
083A:  CLRF   FF7
083C:  ADDLW  4E
083E:  MOVWF  FF6
0840:  MOVLW  08
0842:  ADDWFC FF7,F
0844:  TBLRD*+
0846:  MOVF   FF5,W
0848:  BTFSC  0E.7
084A:  BSF    FF2.7
084C:  RETURN 0
084E:  DATA 0D,41
0850:  DATA 6E,6E
0852:  DATA 6F,20
0854:  DATA 69,6E
0856:  DATA 63,6F
0858:  DATA 72,72
085A:  DATA 65,63
085C:  DATA 74,6F
085E:  DATA 2E,20
0860:  DATA 52,65
0862:  DATA 73,65
0864:  DATA 74,65
0866:  DATA 61,6E
0868:  DATA 64,6F
086A:  DATA 20,69
086C:  DATA 6E,69
086E:  DATA 63,69
0870:  DATA 61,6C
0872:  DATA 69,7A
0874:  DATA 61,63
0876:  DATA 69,6F
0878:  DATA 6E,2E
087A:  DATA 2E,2E
087C:  DATA 0D,00
087E:  MOVFF  FF2,0E
0882:  BCF    FF2.7
0884:  CLRF   FF7
0886:  ADDLW  98
0888:  MOVWF  FF6
088A:  MOVLW  08
088C:  ADDWFC FF7,F
088E:  TBLRD*+
0890:  MOVF   FF5,W
0892:  BTFSC  0E.7
0894:  BSF    FF2.7
0896:  RETURN 0
0898:  DATA 0D,45
089A:  DATA 6C,20
089C:  DATA 61,6E
089E:  DATA 6E,6F
08A0:  DATA 20,6E
08A2:  DATA 6F,20
08A4:  DATA 65,73
08A6:  DATA 20,62
08A8:  DATA 69,73
08AA:  DATA 69,65
08AC:  DATA 73,74
08AE:  DATA 6F,2E
08B0:  DATA 20,52
08B2:  DATA 65,73
08B4:  DATA 65,74
08B6:  DATA 65,61
08B8:  DATA 6E,64
08BA:  DATA 6F,20
08BC:  DATA 69,6E
08BE:  DATA 69,63
08C0:  DATA 69,61
08C2:  DATA 6C,69
08C4:  DATA 7A,61
08C6:  DATA 63,69
08C8:  DATA 6F,6E
08CA:  DATA 2E,2E
08CC:  DATA 2E,0D
08CE:  DATA 00,00
08D0:  MOVFF  FF2,0E
08D4:  BCF    FF2.7
08D6:  CLRF   FF7
08D8:  ADDLW  EA
08DA:  MOVWF  FF6
08DC:  MOVLW  08
08DE:  ADDWFC FF7,F
08E0:  TBLRD*+
08E2:  MOVF   FF5,W
08E4:  BTFSC  0E.7
08E6:  BSF    FF2.7
08E8:  RETURN 0
08EA:  DATA 0D,48
08EC:  DATA 4F,52
08EE:  DATA 41,3A
08F0:  DATA 20,00
08F2:  MOVFF  FF2,0E
08F6:  BCF    FF2.7
08F8:  CLRF   FF7
08FA:  ADDLW  0C
08FC:  MOVWF  FF6
08FE:  MOVLW  09
0900:  ADDWFC FF7,F
0902:  TBLRD*+
0904:  MOVF   FF5,W
0906:  BTFSC  0E.7
0908:  BSF    FF2.7
090A:  RETURN 0
090C:  DATA 0D,52
090E:  DATA 65,73
0910:  DATA 65,74
0912:  DATA 65,61
0914:  DATA 6E,64
0916:  DATA 6F,20
0918:  DATA 6C,61
091A:  DATA 20,69
091C:  DATA 6E,69
091E:  DATA 63,69
0920:  DATA 61,6C
0922:  DATA 69,7A
0924:  DATA 61,63
0926:  DATA 69,6F
0928:  DATA 6E,2E
092A:  DATA 2E,2E
092C:  DATA 0D,00
092E:  MOVFF  FF2,0E
0932:  BCF    FF2.7
0934:  CLRF   FF7
0936:  ADDLW  48
0938:  MOVWF  FF6
093A:  MOVLW  09
093C:  ADDWFC FF7,F
093E:  TBLRD*+
0940:  MOVF   FF5,W
0942:  BTFSC  0E.7
0944:  BSF    FF2.7
0946:  RETURN 0
0948:  DATA 20,20
094A:  DATA 48,6F
094C:  DATA 72,61
094E:  DATA 20,69
0950:  DATA 6E,63
0952:  DATA 6F,72
0954:  DATA 72,65
0956:  DATA 63,74
0958:  DATA 61,21
095A:  DATA 00,00
095C:  MOVFF  FF2,0E
0960:  BCF    FF2.7
0962:  CLRF   FF7
0964:  ADDLW  76
0966:  MOVWF  FF6
0968:  MOVLW  09
096A:  ADDWFC FF7,F
096C:  TBLRD*+
096E:  MOVF   FF5,W
0970:  BTFSC  0E.7
0972:  BSF    FF2.7
0974:  RETURN 0
0976:  DATA 3A,00
0978:  MOVFF  FF2,0E
097C:  BCF    FF2.7
097E:  CLRF   FF7
0980:  ADDLW  92
0982:  MOVWF  FF6
0984:  MOVLW  09
0986:  ADDWFC FF7,F
0988:  TBLRD*+
098A:  MOVF   FF5,W
098C:  BTFSC  0E.7
098E:  BSF    FF2.7
0990:  RETURN 0
0992:  DATA 20,20
0994:  DATA 4D,69
0996:  DATA 6E,75
0998:  DATA 74,6F
099A:  DATA 73,20
099C:  DATA 69,6E
099E:  DATA 63,6F
09A0:  DATA 72,72
09A2:  DATA 65,63
09A4:  DATA 74,6F
09A6:  DATA 73,21
09A8:  DATA 00,00
09AA:  MOVFF  FF2,0E
09AE:  BCF    FF2.7
09B0:  CLRF   FF7
09B2:  ADDLW  C4
09B4:  MOVWF  FF6
09B6:  MOVLW  09
09B8:  ADDWFC FF7,F
09BA:  TBLRD*+
09BC:  MOVF   FF5,W
09BE:  BTFSC  0E.7
09C0:  BSF    FF2.7
09C2:  RETURN 0
09C4:  DATA 0D,47
09C6:  DATA 75,61
09C8:  DATA 72,64
09CA:  DATA 61,6E
09CC:  DATA 64,6F
09CE:  DATA 20,63
09D0:  DATA 6F,6E
09D2:  DATA 66,69
09D4:  DATA 67,75
09D6:  DATA 72,61
09D8:  DATA 63,69
09DA:  DATA 6F,6E
09DC:  DATA 2E,2E
09DE:  DATA 2E,00
09E0:  MOVFF  FF2,0E
09E4:  BCF    FF2.7
09E6:  CLRF   FF7
09E8:  ADDLW  FA
09EA:  MOVWF  FF6
09EC:  MOVLW  09
09EE:  ADDWFC FF7,F
09F0:  TBLRD*+
09F2:  MOVF   FF5,W
09F4:  BTFSC  0E.7
09F6:  BSF    FF2.7
09F8:  RETURN 0
09FA:  DATA 0D,49
09FC:  DATA 6E,69
09FE:  DATA 63,69
0A00:  DATA 61,6E
0A02:  DATA 64,6F
0A04:  DATA 20,73
0A06:  DATA 69,73
0A08:  DATA 74,65
0A0A:  DATA 6D,61
0A0C:  DATA 2E,2E
0A0E:  DATA 2E,0D
0A10:  DATA 00,00
0A12:  MOVFF  FF2,0E
0A16:  BCF    FF2.7
0A18:  CLRF   FF7
0A1A:  ADDLW  2C
0A1C:  MOVWF  FF6
0A1E:  MOVLW  0A
0A20:  ADDWFC FF7,F
0A22:  TBLRD*+
0A24:  MOVF   FF5,W
0A26:  BTFSC  0E.7
0A28:  BSF    FF2.7
0A2A:  RETURN 0
0A2C:  DATA 25,33
0A2E:  DATA 2E,31
0A30:  DATA 66,25
0A32:  DATA 63,43
0A34:  DATA 20,20
0A36:  DATA 25,33
0A38:  DATA 2E,31
0A3A:  DATA 66,25
0A3C:  DATA 63,43
0A3E:  DATA 0A,48
0A40:  DATA 4F,52
0A42:  DATA 41,20
0A44:  DATA 2D,20
0A46:  DATA 00,00
0A48:  MOVFF  FF2,0E
0A4C:  BCF    FF2.7
0A4E:  CLRF   FF7
0A50:  ADDLW  62
0A52:  MOVWF  FF6
0A54:  MOVLW  0A
0A56:  ADDWFC FF7,F
0A58:  TBLRD*+
0A5A:  MOVF   FF5,W
0A5C:  BTFSC  0E.7
0A5E:  BSF    FF2.7
0A60:  RETURN 0
0A62:  DATA 30,00
0A64:  MOVFF  FF2,0E
0A68:  BCF    FF2.7
0A6A:  CLRF   FF7
0A6C:  ADDLW  7E
0A6E:  MOVWF  FF6
0A70:  MOVLW  0A
0A72:  ADDWFC FF7,F
0A74:  TBLRD*+
0A76:  MOVF   FF5,W
0A78:  BTFSC  0E.7
0A7A:  BSF    FF2.7
0A7C:  RETURN 0
0A7E:  DATA 0D,52
0A80:  DATA 45,47
0A82:  DATA 49,53
0A84:  DATA 54,52
0A86:  DATA 4F,20
0A88:  DATA 44,45
0A8A:  DATA 20,45
0A8C:  DATA 56,45
0A8E:  DATA 4E,54
0A90:  DATA 4F,53
0A92:  DATA 0D,00
0A94:  MOVFF  FF2,0E
0A98:  BCF    FF2.7
0A9A:  CLRF   FF7
0A9C:  ADDLW  AE
0A9E:  MOVWF  FF6
0AA0:  MOVLW  0A
0AA2:  ADDWFC FF7,F
0AA4:  TBLRD*+
0AA6:  MOVF   FF5,W
0AA8:  BTFSC  0E.7
0AAA:  BSF    FF2.7
0AAC:  RETURN 0
0AAE:  DATA 2A,2A
0AB0:  DATA 2A,2A
0AB2:  DATA 2A,2A
0AB4:  DATA 2A,2A
0AB6:  DATA 2A,2A
0AB8:  DATA 2A,2A
0ABA:  DATA 2A,2A
0ABC:  DATA 2A,2A
0ABE:  DATA 2A,2A
0AC0:  DATA 2A,0D
0AC2:  DATA 00,00
0AC4:  MOVFF  FF2,0E
0AC8:  BCF    FF2.7
0ACA:  CLRF   FF7
0ACC:  ADDLW  DE
0ACE:  MOVWF  FF6
0AD0:  MOVLW  0A
0AD2:  ADDWFC FF7,F
0AD4:  TBLRD*+
0AD6:  MOVF   FF5,W
0AD8:  BTFSC  0E.7
0ADA:  BSF    FF2.7
0ADC:  RETURN 0
0ADE:  DATA 4D,6F
0AE0:  DATA 6D,65
0AE2:  DATA 6E,74
0AE4:  DATA 6F,20
0AE6:  DATA 64,65
0AE8:  DATA 20,61
0AEA:  DATA 70,61
0AEC:  DATA 67,61
0AEE:  DATA 64,6F
0AF0:  DATA 20,20
0AF2:  DATA 20,20
0AF4:  DATA 20,54
0AF6:  DATA 65,6D
0AF8:  DATA 70,65
0AFA:  DATA 72,61
0AFC:  DATA 74,75
0AFE:  DATA 72,61
0B00:  DATA 31,20
0B02:  DATA 20,20
0B04:  DATA 20,20
0B06:  DATA 20,20
0B08:  DATA 54,65
0B0A:  DATA 6D,70
0B0C:  DATA 65,72
0B0E:  DATA 61,74
0B10:  DATA 75,72
0B12:  DATA 61,32
0B14:  DATA 20,20
0B16:  DATA 20,20
0B18:  DATA 20,20
0B1A:  DATA 20,20
0B1C:  DATA 20,54
0B1E:  DATA 65,72
0B20:  DATA 6D,6F
0B22:  DATA 73,74
0B24:  DATA 61,74
0B26:  DATA 6F,20
0B28:  DATA 20,20
0B2A:  DATA 20,20
0B2C:  DATA 20,20
0B2E:  DATA 20,4D
0B30:  DATA 69,6E
0B32:  DATA 75,74
0B34:  DATA 6F,73
0B36:  DATA 20,65
0B38:  DATA 6E,63
0B3A:  DATA 65,6E
0B3C:  DATA 64,69
0B3E:  DATA 64,6F
0B40:  DATA 20,20
0B42:  DATA 20,20
0B44:  DATA 20,20
0B46:  DATA 20,4D
0B48:  DATA 69,6E
0B4A:  DATA 75,74
0B4C:  DATA 6F,73
0B4E:  DATA 20,63
0B50:  DATA 61,6C
0B52:  DATA 64,65
0B54:  DATA 72,61
0B56:  DATA 0D,00
0B58:  MOVFF  FF2,0E
0B5C:  BCF    FF2.7
0B5E:  CLRF   FF7
0B60:  ADDLW  72
0B62:  MOVWF  FF6
0B64:  MOVLW  0B
0B66:  ADDWFC FF7,F
0B68:  TBLRD*+
0B6A:  MOVF   FF5,W
0B6C:  BTFSC  0E.7
0B6E:  BSF    FF2.7
0B70:  RETURN 0
0B72:  DATA 3D,3D
0B74:  DATA 3D,3D
0B76:  DATA 3D,3D
0B78:  DATA 3D,3D
0B7A:  DATA 3D,3D
0B7C:  DATA 3D,3D
0B7E:  DATA 3D,3D
0B80:  DATA 3D,3D
0B82:  DATA 3D,3D
0B84:  DATA 3D,3D
0B86:  DATA 3D,3D
0B88:  DATA 3D,3D
0B8A:  DATA 3D,3D
0B8C:  DATA 3D,3D
0B8E:  DATA 3D,3D
0B90:  DATA 3D,3D
0B92:  DATA 3D,3D
0B94:  DATA 3D,3D
0B96:  DATA 3D,3D
0B98:  DATA 3D,3D
0B9A:  DATA 3D,3D
0B9C:  DATA 3D,3D
0B9E:  DATA 3D,3D
0BA0:  DATA 3D,3D
0BA2:  DATA 3D,3D
0BA4:  DATA 3D,3D
0BA6:  DATA 3D,3D
0BA8:  DATA 3D,3D
0BAA:  DATA 3D,3D
0BAC:  DATA 3D,3D
0BAE:  DATA 3D,3D
0BB0:  DATA 3D,3D
0BB2:  DATA 3D,3D
0BB4:  DATA 3D,3D
0BB6:  DATA 3D,3D
0BB8:  DATA 3D,3D
0BBA:  DATA 3D,3D
0BBC:  DATA 3D,3D
0BBE:  DATA 3D,3D
0BC0:  DATA 3D,3D
0BC2:  DATA 3D,3D
0BC4:  DATA 3D,3D
0BC6:  DATA 3D,3D
0BC8:  DATA 3D,3D
0BCA:  DATA 3D,3D
0BCC:  DATA 3D,3D
0BCE:  DATA 3D,3D
0BD0:  DATA 3D,3D
0BD2:  DATA 3D,3D
0BD4:  DATA 3D,3D
0BD6:  DATA 3D,3D
0BD8:  DATA 3D,3D
0BDA:  DATA 3D,3D
0BDC:  DATA 3D,3D
0BDE:  DATA 3D,3D
0BE0:  DATA 3D,3D
0BE2:  DATA 3D,3D
0BE4:  DATA 3D,3D
0BE6:  DATA 3D,3D
0BE8:  DATA 3D,3D
0BEA:  DATA 3D,3D
0BEC:  DATA 3D,0D
0BEE:  DATA 00,00
0BF0:  MOVFF  FF2,0E
0BF4:  BCF    FF2.7
0BF6:  CLRF   FF7
0BF8:  ADDLW  0A
0BFA:  MOVWF  FF6
0BFC:  MOVLW  0C
0BFE:  ADDWFC FF7,F
0C00:  TBLRD*+
0C02:  MOVF   FF5,W
0C04:  BTFSC  0E.7
0C06:  BSF    FF2.7
0C08:  RETURN 0
0C0A:  DATA 20,00
0C0C:  MOVFF  FF2,0E
0C10:  BCF    FF2.7
0C12:  CLRF   FF7
0C14:  ADDLW  26
0C16:  MOVWF  FF6
0C18:  MOVLW  0C
0C1A:  ADDWFC FF7,F
0C1C:  TBLRD*+
0C1E:  MOVF   FF5,W
0C20:  BTFSC  0E.7
0C22:  BSF    FF2.7
0C24:  RETURN 0
0C26:  DATA 0D,3D
0C28:  DATA 3D,3D
0C2A:  DATA 3D,3D
0C2C:  DATA 3D,3D
0C2E:  DATA 3D,3D
0C30:  DATA 3D,3D
0C32:  DATA 3D,3D
0C34:  DATA 3D,3D
0C36:  DATA 3D,3D
0C38:  DATA 3D,3D
0C3A:  DATA 3D,3D
0C3C:  DATA 3D,3D
0C3E:  DATA 3D,3D
0C40:  DATA 3D,3D
0C42:  DATA 3D,3D
0C44:  DATA 3D,3D
0C46:  DATA 3D,3D
0C48:  DATA 3D,3D
0C4A:  DATA 3D,3D
0C4C:  DATA 3D,3D
0C4E:  DATA 3D,3D
0C50:  DATA 3D,3D
0C52:  DATA 3D,3D
0C54:  DATA 3D,3D
0C56:  DATA 3D,3D
0C58:  DATA 3D,3D
0C5A:  DATA 3D,3D
0C5C:  DATA 3D,3D
0C5E:  DATA 3D,3D
0C60:  DATA 3D,3D
0C62:  DATA 3D,3D
0C64:  DATA 3D,3D
0C66:  DATA 3D,3D
0C68:  DATA 3D,3D
0C6A:  DATA 3D,3D
0C6C:  DATA 3D,3D
0C6E:  DATA 3D,3D
0C70:  DATA 3D,3D
0C72:  DATA 3D,3D
0C74:  DATA 3D,3D
0C76:  DATA 3D,3D
0C78:  DATA 3D,3D
0C7A:  DATA 3D,3D
0C7C:  DATA 3D,3D
0C7E:  DATA 3D,3D
0C80:  DATA 3D,3D
0C82:  DATA 3D,3D
0C84:  DATA 3D,3D
0C86:  DATA 3D,3D
0C88:  DATA 3D,3D
0C8A:  DATA 3D,3D
0C8C:  DATA 3D,3D
0C8E:  DATA 3D,3D
0C90:  DATA 3D,3D
0C92:  DATA 3D,3D
0C94:  DATA 3D,3D
0C96:  DATA 3D,3D
0C98:  DATA 3D,3D
0C9A:  DATA 3D,3D
0C9C:  DATA 3D,3D
0C9E:  DATA 3D,3D
0CA0:  DATA 3D,3D
0CA2:  DATA 0D,00
0CA4:  MOVFF  FF2,0E
0CA8:  BCF    FF2.7
0CAA:  CLRF   FF7
0CAC:  ADDLW  BE
0CAE:  MOVWF  FF6
0CB0:  MOVLW  0C
0CB2:  ADDWFC FF7,F
0CB4:  TBLRD*+
0CB6:  MOVF   FF5,W
0CB8:  BTFSC  0E.7
0CBA:  BSF    FF2.7
0CBC:  RETURN 0
0CBE:  DATA BF,51
0CC0:  DATA 75,65
0CC2:  DATA 20,6F
0CC4:  DATA 70,65
0CC6:  DATA 72,61
0CC8:  DATA 63,69
0CCA:  DATA 6F,6E
0CCC:  DATA 20,64
0CCE:  DATA 65,73
0CD0:  DATA 65,61
0CD2:  DATA 20,72
0CD4:  DATA 65,61
0CD6:  DATA 6C,69
0CD8:  DATA 7A,61
0CDA:  DATA 72,3F
0CDC:  DATA 0D,00
0CDE:  MOVFF  FF2,0E
0CE2:  BCF    FF2.7
0CE4:  CLRF   FF7
0CE6:  ADDLW  F8
0CE8:  MOVWF  FF6
0CEA:  MOVLW  0C
0CEC:  ADDWFC FF7,F
0CEE:  TBLRD*+
0CF0:  MOVF   FF5,W
0CF2:  BTFSC  0E.7
0CF4:  BSF    FF2.7
0CF6:  RETURN 0
0CF8:  DATA 30,2E
0CFA:  DATA 20,53
0CFC:  DATA 61,6C
0CFE:  DATA 69,72
0D00:  DATA 0D,00
0D02:  MOVFF  FF2,0E
0D06:  BCF    FF2.7
0D08:  CLRF   FF7
0D0A:  ADDLW  1C
0D0C:  MOVWF  FF6
0D0E:  MOVLW  0D
0D10:  ADDWFC FF7,F
0D12:  TBLRD*+
0D14:  MOVF   FF5,W
0D16:  BTFSC  0E.7
0D18:  BSF    FF2.7
0D1A:  RETURN 0
0D1C:  DATA 31,2E
0D1E:  DATA 20,45
0D20:  DATA 78,74
0D22:  DATA 72,61
0D24:  DATA 65,72
0D26:  DATA 20,74
0D28:  DATA 69,65
0D2A:  DATA 6D,70
0D2C:  DATA 6F,73
0D2E:  DATA 20,6D
0D30:  DATA 65,64
0D32:  DATA 69,6F
0D34:  DATA 73,20
0D36:  DATA 70,6F
0D38:  DATA 72,20
0D3A:  DATA 64,69
0D3C:  DATA 61,0D
0D3E:  DATA 00,00
0D40:  MOVFF  FF2,0E
0D44:  BCF    FF2.7
0D46:  CLRF   FF7
0D48:  ADDLW  5A
0D4A:  MOVWF  FF6
0D4C:  MOVLW  0D
0D4E:  ADDWFC FF7,F
0D50:  TBLRD*+
0D52:  MOVF   FF5,W
0D54:  BTFSC  0E.7
0D56:  BSF    FF2.7
0D58:  RETURN 0
0D5A:  DATA 32,2E
0D5C:  DATA 20,45
0D5E:  DATA 78,74
0D60:  DATA 72,61
0D62:  DATA 65,72
0D64:  DATA 20,74
0D66:  DATA 69,65
0D68:  DATA 6D,70
0D6A:  DATA 6F,73
0D6C:  DATA 20,74
0D6E:  DATA 6F,74
0D70:  DATA 61,6C
0D72:  DATA 65,73
0D74:  DATA 0D,00
0D76:  MOVFF  FF2,0E
0D7A:  BCF    FF2.7
0D7C:  CLRF   FF7
0D7E:  ADDLW  90
0D80:  MOVWF  FF6
0D82:  MOVLW  0D
0D84:  ADDWFC FF7,F
0D86:  TBLRD*+
0D88:  MOVF   FF5,W
0D8A:  BTFSC  0E.7
0D8C:  BSF    FF2.7
0D8E:  RETURN 0
0D90:  DATA 33,2E
0D92:  DATA 20,45
0D94:  DATA 78,74
0D96:  DATA 72,61
0D98:  DATA 65,72
0D9A:  DATA 20,64
0D9C:  DATA 61,74
0D9E:  DATA 6F,73
0DA0:  DATA 20,6D
0DA2:  DATA 65,6E
0DA4:  DATA 73,75
0DA6:  DATA 61,6C
0DA8:  DATA 65,73
0DAA:  DATA 0D,00
0DAC:  MOVFF  FF2,0E
0DB0:  BCF    FF2.7
0DB2:  CLRF   FF7
0DB4:  ADDLW  C6
0DB6:  MOVWF  FF6
0DB8:  MOVLW  0D
0DBA:  ADDWFC FF7,F
0DBC:  TBLRD*+
0DBE:  MOVF   FF5,W
0DC0:  BTFSC  0E.7
0DC2:  BSF    FF2.7
0DC4:  RETURN 0
0DC6:  DATA 0D,53
0DC8:  DATA 61,6C
0DCA:  DATA 69,65
0DCC:  DATA 6E,64
0DCE:  DATA 6F,2E
0DD0:  DATA 2E,2E
0DD2:  DATA 0D,00
0DD4:  MOVFF  FF2,0E
0DD8:  BCF    FF2.7
0DDA:  CLRF   FF7
0DDC:  ADDLW  EE
0DDE:  MOVWF  FF6
0DE0:  MOVLW  0D
0DE2:  ADDWFC FF7,F
0DE4:  TBLRD*+
0DE6:  MOVF   FF5,W
0DE8:  BTFSC  0E.7
0DEA:  BSF    FF2.7
0DEC:  RETURN 0
0DEE:  DATA 0D,54
0DF0:  DATA 69,65
0DF2:  DATA 6D,70
0DF4:  DATA 6F,20
0DF6:  DATA 6D,65
0DF8:  DATA 64,69
0DFA:  DATA 6F,20
0DFC:  DATA 64,65
0DFE:  DATA 20,65
0E00:  DATA 6E,63
0E02:  DATA 65,6E
0E04:  DATA 64,69
0E06:  DATA 64,6F
0E08:  DATA 20,64
0E0A:  DATA 65,6C
0E0C:  DATA 20,73
0E0E:  DATA 69,73
0E10:  DATA 74,65
0E12:  DATA 6D,61
0E14:  DATA 20,70
0E16:  DATA 6F,72
0E18:  DATA 20,64
0E1A:  DATA 69,61
0E1C:  DATA 3A,20
0E1E:  DATA 25,33
0E20:  DATA 2E,32
0E22:  DATA 66,20
0E24:  DATA 6D,69
0E26:  DATA 6E,75
0E28:  DATA 74,6F
0E2A:  DATA 73,0D
0E2C:  DATA 0D,00
0E2E:  MOVFF  FF2,0E
0E32:  BCF    FF2.7
0E34:  CLRF   FF7
0E36:  ADDLW  48
0E38:  MOVWF  FF6
0E3A:  MOVLW  0E
0E3C:  ADDWFC FF7,F
0E3E:  TBLRD*+
0E40:  MOVF   FF5,W
0E42:  BTFSC  0E.7
0E44:  BSF    FF2.7
0E46:  RETURN 0
0E48:  DATA 54,69
0E4A:  DATA 65,6D
0E4C:  DATA 70,6F
0E4E:  DATA 20,6D
0E50:  DATA 65,64
0E52:  DATA 69,6F
0E54:  DATA 20,64
0E56:  DATA 65,20
0E58:  DATA 65,6E
0E5A:  DATA 63,65
0E5C:  DATA 6E,64
0E5E:  DATA 69,64
0E60:  DATA 6F,20
0E62:  DATA 64,65
0E64:  DATA 20,6C
0E66:  DATA 61,20
0E68:  DATA 63,61
0E6A:  DATA 6C,64
0E6C:  DATA 65,72
0E6E:  DATA 61,20
0E70:  DATA 70,6F
0E72:  DATA 72,20
0E74:  DATA 64,69
0E76:  DATA 61,3A
0E78:  DATA 20,25
0E7A:  DATA 33,2E
0E7C:  DATA 32,66
0E7E:  DATA 20,6D
0E80:  DATA 69,6E
0E82:  DATA 75,74
0E84:  DATA 6F,73
0E86:  DATA 0D,0D
0E88:  DATA 00,00
0E8A:  MOVFF  FF2,0E
0E8E:  BCF    FF2.7
0E90:  CLRF   FF7
0E92:  ADDLW  A4
0E94:  MOVWF  FF6
0E96:  MOVLW  0E
0E98:  ADDWFC FF7,F
0E9A:  TBLRD*+
0E9C:  MOVF   FF5,W
0E9E:  BTFSC  0E.7
0EA0:  BSF    FF2.7
0EA2:  RETURN 0
0EA4:  DATA 0D,54
0EA6:  DATA 69,65
0EA8:  DATA 6D,70
0EAA:  DATA 6F,20
0EAC:  DATA 74,6F
0EAE:  DATA 74,61
0EB0:  DATA 6C,20
0EB2:  DATA 64,65
0EB4:  DATA 20,65
0EB6:  DATA 6E,63
0EB8:  DATA 65,6E
0EBA:  DATA 64,69
0EBC:  DATA 64,6F
0EBE:  DATA 20,64
0EC0:  DATA 65,6C
0EC2:  DATA 20,73
0EC4:  DATA 69,73
0EC6:  DATA 74,65
0EC8:  DATA 6D,61
0ECA:  DATA 3A,20
0ECC:  DATA 25,6C
0ECE:  DATA 75,20
0ED0:  DATA 6D,69
0ED2:  DATA 6E,75
0ED4:  DATA 74,6F
0ED6:  DATA 73,0D
0ED8:  DATA 0D,00
0EDA:  MOVFF  FF2,0E
0EDE:  BCF    FF2.7
0EE0:  CLRF   FF7
0EE2:  ADDLW  F4
0EE4:  MOVWF  FF6
0EE6:  MOVLW  0E
0EE8:  ADDWFC FF7,F
0EEA:  TBLRD*+
0EEC:  MOVF   FF5,W
0EEE:  BTFSC  0E.7
0EF0:  BSF    FF2.7
0EF2:  RETURN 0
0EF4:  DATA 54,69
0EF6:  DATA 65,6D
0EF8:  DATA 70,6F
0EFA:  DATA 20,74
0EFC:  DATA 6F,74
0EFE:  DATA 61,6C
0F00:  DATA 20,64
0F02:  DATA 65,20
0F04:  DATA 65,6E
0F06:  DATA 63,65
0F08:  DATA 6E,64
0F0A:  DATA 69,64
0F0C:  DATA 6F,20
0F0E:  DATA 64,65
0F10:  DATA 20,6C
0F12:  DATA 61,20
0F14:  DATA 63,61
0F16:  DATA 6C,64
0F18:  DATA 65,72
0F1A:  DATA 61,3A
0F1C:  DATA 20,25
0F1E:  DATA 6C,75
0F20:  DATA 20,6D
0F22:  DATA 69,6E
0F24:  DATA 75,74
0F26:  DATA 6F,73
0F28:  DATA 0D,0D
0F2A:  DATA 00,00
0F2C:  MOVFF  FF2,0E
0F30:  BCF    FF2.7
0F32:  CLRF   FF7
0F34:  ADDLW  46
0F36:  MOVWF  FF6
0F38:  MOVLW  0F
0F3A:  ADDWFC FF7,F
0F3C:  TBLRD*+
0F3E:  MOVF   FF5,W
0F40:  BTFSC  0E.7
0F42:  BSF    FF2.7
0F44:  RETURN 0
0F46:  DATA 0D,32
0F48:  DATA 30,00
0F4A:  MOVFF  FF2,0E
0F4E:  BCF    FF2.7
0F50:  CLRF   FF7
0F52:  ADDLW  64
0F54:  MOVWF  FF6
0F56:  MOVLW  0F
0F58:  ADDWFC FF7,F
0F5A:  TBLRD*+
0F5C:  MOVF   FF5,W
0F5E:  BTFSC  0E.7
0F60:  BSF    FF2.7
0F62:  RETURN 0
0F64:  DATA 2D,2D
0F66:  DATA 2D,2D
0F68:  DATA 2D,2D
0F6A:  DATA 2D,2D
0F6C:  DATA 2D,2D
0F6E:  DATA 2D,2D
0F70:  DATA 2D,2D
0F72:  DATA 2D,2D
0F74:  DATA 2D,2D
0F76:  DATA 2D,2D
0F78:  DATA 2D,2D
0F7A:  DATA 2D,2D
0F7C:  DATA 2D,2D
0F7E:  DATA 2D,2D
0F80:  DATA 2D,2D
0F82:  DATA 2D,2D
0F84:  DATA 2D,2D
0F86:  DATA 2D,2D
0F88:  DATA 2D,2D
0F8A:  DATA 2D,2D
0F8C:  DATA 2D,2D
0F8E:  DATA 2D,2D
0F90:  DATA 2D,2D
0F92:  DATA 2D,2D
0F94:  DATA 2D,2D
0F96:  DATA 2D,2D
0F98:  DATA 2D,2D
0F9A:  DATA 2D,2D
0F9C:  DATA 2D,2D
0F9E:  DATA 2D,2D
0FA0:  DATA 2D,2D
0FA2:  DATA 2D,2D
0FA4:  DATA 2D,2D
0FA6:  DATA 2D,2D
0FA8:  DATA 2D,2D
0FAA:  DATA 2D,2D
0FAC:  DATA 2D,2D
0FAE:  DATA 2D,2D
0FB0:  DATA 2D,2D
0FB2:  DATA 2D,2D
0FB4:  DATA 2D,2D
0FB6:  DATA 2D,2D
0FB8:  DATA 2D,2D
0FBA:  DATA 2D,2D
0FBC:  DATA 2D,2D
0FBE:  DATA 2D,2D
0FC0:  DATA 2D,2D
0FC2:  DATA 2D,2D
0FC4:  DATA 2D,2D
0FC6:  DATA 2D,2D
0FC8:  DATA 2D,2D
0FCA:  DATA 2D,2D
0FCC:  DATA 2D,2D
0FCE:  DATA 2D,2D
0FD0:  DATA 2D,2D
0FD2:  DATA 2D,2D
0FD4:  DATA 2D,2D
0FD6:  DATA 2D,2D
0FD8:  DATA 0D,00
0FDA:  MOVFF  FF2,0E
0FDE:  BCF    FF2.7
0FE0:  CLRF   FF7
0FE2:  ADDLW  F4
0FE4:  MOVWF  FF6
0FE6:  MOVLW  0F
0FE8:  ADDWFC FF7,F
0FEA:  TBLRD*+
0FEC:  MOVF   FF5,W
0FEE:  BTFSC  0E.7
0FF0:  BSF    FF2.7
0FF2:  RETURN 0
0FF4:  DATA 20,20
0FF6:  DATA 20,20
0FF8:  DATA 20,20
0FFA:  DATA 20,20
0FFC:  DATA 20,20
0FFE:  DATA 20,20
1000:  DATA 20,20
1002:  DATA 54,69
1004:  DATA 65,6D
1006:  DATA 70,6F
1008:  DATA 20,6D
100A:  DATA 65,64
100C:  DATA 69,6F
100E:  DATA 20,64
1010:  DATA 65,20
1012:  DATA 65,6E
1014:  DATA 63,65
1016:  DATA 6E,64
1018:  DATA 69,64
101A:  DATA 6F,20
101C:  DATA 64,65
101E:  DATA 6C,20
1020:  DATA 73,69
1022:  DATA 73,74
1024:  DATA 65,6D
1026:  DATA 61,20
1028:  DATA 28,6D
102A:  DATA 69,6E
102C:  DATA 2F,64
102E:  DATA 69,61
1030:  DATA 29,20
1032:  DATA 20,20
1034:  DATA 20,20
1036:  DATA 20,54
1038:  DATA 69,65
103A:  DATA 6D,70
103C:  DATA 6F,20
103E:  DATA 6D,65
1040:  DATA 64,69
1042:  DATA 6F,20
1044:  DATA 64,65
1046:  DATA 20,65
1048:  DATA 6E,63
104A:  DATA 65,6E
104C:  DATA 64,69
104E:  DATA 64,6F
1050:  DATA 20,64
1052:  DATA 65,20
1054:  DATA 6C,61
1056:  DATA 20,63
1058:  DATA 61,6C
105A:  DATA 64,65
105C:  DATA 72,61
105E:  DATA 20,28
1060:  DATA 6D,69
1062:  DATA 6E,2F
1064:  DATA 64,69
1066:  DATA 61,29
1068:  DATA 0D,00
106A:  MOVFF  FF2,0E
106E:  BCF    FF2.7
1070:  CLRF   FF7
1072:  ADDLW  84
1074:  MOVWF  FF6
1076:  MOVLW  10
1078:  ADDWFC FF7,F
107A:  TBLRD*+
107C:  MOVF   FF5,W
107E:  BTFSC  0E.7
1080:  BSF    FF2.7
1082:  RETURN 0
1084:  DATA 45,4E
1086:  DATA 45,52
1088:  DATA 4F,25
108A:  DATA 33,2E
108C:  DATA 32,66
108E:  DATA 25,33
1090:  DATA 2E,32
1092:  DATA 66,0D
1094:  DATA 00,00
1096:  MOVFF  FF2,0E
109A:  BCF    FF2.7
109C:  CLRF   FF7
109E:  ADDLW  B0
10A0:  MOVWF  FF6
10A2:  MOVLW  10
10A4:  ADDWFC FF7,F
10A6:  TBLRD*+
10A8:  MOVF   FF5,W
10AA:  BTFSC  0E.7
10AC:  BSF    FF2.7
10AE:  RETURN 0
10B0:  DATA 46,45
10B2:  DATA 42,52
10B4:  DATA 45,52
10B6:  DATA 4F,25
10B8:  DATA 33,2E
10BA:  DATA 32,66
10BC:  DATA 25,33
10BE:  DATA 2E,32
10C0:  DATA 66,0D
10C2:  DATA 00,00
10C4:  MOVFF  FF2,0E
10C8:  BCF    FF2.7
10CA:  CLRF   FF7
10CC:  ADDLW  DE
10CE:  MOVWF  FF6
10D0:  MOVLW  10
10D2:  ADDWFC FF7,F
10D4:  TBLRD*+
10D6:  MOVF   FF5,W
10D8:  BTFSC  0E.7
10DA:  BSF    FF2.7
10DC:  RETURN 0
10DE:  DATA 4D,41
10E0:  DATA 52,5A
10E2:  DATA 4F,25
10E4:  DATA 33,2E
10E6:  DATA 32,66
10E8:  DATA 25,33
10EA:  DATA 2E,32
10EC:  DATA 66,0D
10EE:  DATA 00,00
10F0:  MOVFF  FF2,0E
10F4:  BCF    FF2.7
10F6:  CLRF   FF7
10F8:  ADDLW  0A
10FA:  MOVWF  FF6
10FC:  MOVLW  11
10FE:  ADDWFC FF7,F
1100:  TBLRD*+
1102:  MOVF   FF5,W
1104:  BTFSC  0E.7
1106:  BSF    FF2.7
1108:  RETURN 0
110A:  DATA 41,42
110C:  DATA 52,49
110E:  DATA 4C,25
1110:  DATA 33,2E
1112:  DATA 32,66
1114:  DATA 25,33
1116:  DATA 2E,32
1118:  DATA 66,0D
111A:  DATA 00,00
111C:  MOVFF  FF2,0E
1120:  BCF    FF2.7
1122:  CLRF   FF7
1124:  ADDLW  36
1126:  MOVWF  FF6
1128:  MOVLW  11
112A:  ADDWFC FF7,F
112C:  TBLRD*+
112E:  MOVF   FF5,W
1130:  BTFSC  0E.7
1132:  BSF    FF2.7
1134:  RETURN 0
1136:  DATA 4D,41
1138:  DATA 59,4F
113A:  DATA 25,33
113C:  DATA 2E,32
113E:  DATA 66,25
1140:  DATA 33,2E
1142:  DATA 32,66
1144:  DATA 0D,00
1146:  MOVFF  FF2,0E
114A:  BCF    FF2.7
114C:  CLRF   FF7
114E:  ADDLW  60
1150:  MOVWF  FF6
1152:  MOVLW  11
1154:  ADDWFC FF7,F
1156:  TBLRD*+
1158:  MOVF   FF5,W
115A:  BTFSC  0E.7
115C:  BSF    FF2.7
115E:  RETURN 0
1160:  DATA 4A,55
1162:  DATA 4E,49
1164:  DATA 4F,25
1166:  DATA 33,2E
1168:  DATA 32,66
116A:  DATA 25,33
116C:  DATA 2E,32
116E:  DATA 66,0D
1170:  DATA 00,00
1172:  MOVFF  FF2,0E
1176:  BCF    FF2.7
1178:  CLRF   FF7
117A:  ADDLW  8C
117C:  MOVWF  FF6
117E:  MOVLW  11
1180:  ADDWFC FF7,F
1182:  TBLRD*+
1184:  MOVF   FF5,W
1186:  BTFSC  0E.7
1188:  BSF    FF2.7
118A:  RETURN 0
118C:  DATA 4A,55
118E:  DATA 4C,49
1190:  DATA 4F,25
1192:  DATA 33,2E
1194:  DATA 32,66
1196:  DATA 25,33
1198:  DATA 2E,32
119A:  DATA 66,0D
119C:  DATA 00,00
119E:  MOVFF  FF2,0E
11A2:  BCF    FF2.7
11A4:  CLRF   FF7
11A6:  ADDLW  B8
11A8:  MOVWF  FF6
11AA:  MOVLW  11
11AC:  ADDWFC FF7,F
11AE:  TBLRD*+
11B0:  MOVF   FF5,W
11B2:  BTFSC  0E.7
11B4:  BSF    FF2.7
11B6:  RETURN 0
11B8:  DATA 41,47
11BA:  DATA 4F,53
11BC:  DATA 54,4F
11BE:  DATA 25,33
11C0:  DATA 2E,32
11C2:  DATA 66,25
11C4:  DATA 33,2E
11C6:  DATA 32,66
11C8:  DATA 0D,00
11CA:  MOVFF  FF2,0E
11CE:  BCF    FF2.7
11D0:  CLRF   FF7
11D2:  ADDLW  E4
11D4:  MOVWF  FF6
11D6:  MOVLW  11
11D8:  ADDWFC FF7,F
11DA:  TBLRD*+
11DC:  MOVF   FF5,W
11DE:  BTFSC  0E.7
11E0:  BSF    FF2.7
11E2:  RETURN 0
11E4:  DATA 53,45
11E6:  DATA 50,54
11E8:  DATA 49,45
11EA:  DATA 4D,42
11EC:  DATA 52,45
11EE:  DATA 25,33
11F0:  DATA 2E,32
11F2:  DATA 66,25
11F4:  DATA 33,2E
11F6:  DATA 32,66
11F8:  DATA 0D,00
11FA:  MOVFF  FF2,0E
11FE:  BCF    FF2.7
1200:  CLRF   FF7
1202:  ADDLW  14
1204:  MOVWF  FF6
1206:  MOVLW  12
1208:  ADDWFC FF7,F
120A:  TBLRD*+
120C:  MOVF   FF5,W
120E:  BTFSC  0E.7
1210:  BSF    FF2.7
1212:  RETURN 0
1214:  DATA 4F,43
1216:  DATA 54,55
1218:  DATA 42,52
121A:  DATA 45,25
121C:  DATA 33,2E
121E:  DATA 32,66
1220:  DATA 25,33
1222:  DATA 2E,32
1224:  DATA 66,0D
1226:  DATA 00,00
1228:  MOVFF  FF2,0E
122C:  BCF    FF2.7
122E:  CLRF   FF7
1230:  ADDLW  42
1232:  MOVWF  FF6
1234:  MOVLW  12
1236:  ADDWFC FF7,F
1238:  TBLRD*+
123A:  MOVF   FF5,W
123C:  BTFSC  0E.7
123E:  BSF    FF2.7
1240:  RETURN 0
1242:  DATA 4E,4F
1244:  DATA 56,49
1246:  DATA 45,4D
1248:  DATA 42,52
124A:  DATA 45,25
124C:  DATA 33,2E
124E:  DATA 32,66
1250:  DATA 25,33
1252:  DATA 2E,32
1254:  DATA 66,0D
1256:  DATA 00,00
1258:  MOVFF  FF2,0E
125C:  BCF    FF2.7
125E:  CLRF   FF7
1260:  ADDLW  72
1262:  MOVWF  FF6
1264:  MOVLW  12
1266:  ADDWFC FF7,F
1268:  TBLRD*+
126A:  MOVF   FF5,W
126C:  BTFSC  0E.7
126E:  BSF    FF2.7
1270:  RETURN 0
1272:  DATA 44,49
1274:  DATA 43,49
1276:  DATA 45,4D
1278:  DATA 42,52
127A:  DATA 45,25
127C:  DATA 33,2E
127E:  DATA 32,66
1280:  DATA 25,33
1282:  DATA 2E,32
1284:  DATA 66,0D
1286:  DATA 00,00
*
1404:  CLRF   00
1406:  CLRF   01
1408:  MOVF   xAF,W
140A:  BCF    FD8.0
140C:  BTFSC  xB0.0
140E:  ADDWF  00,F
1410:  RRCF   00,F
1412:  RRCF   01,F
1414:  BTFSC  xB0.1
1416:  ADDWF  00,F
1418:  RRCF   00,F
141A:  RRCF   01,F
141C:  BTFSC  xB0.2
141E:  ADDWF  00,F
1420:  RRCF   00,F
1422:  RRCF   01,F
1424:  BTFSC  xB0.3
1426:  ADDWF  00,F
1428:  RRCF   00,F
142A:  RRCF   01,F
142C:  BTFSC  xB0.4
142E:  ADDWF  00,F
1430:  RRCF   00,F
1432:  RRCF   01,F
1434:  BTFSC  xB0.5
1436:  ADDWF  00,F
1438:  RRCF   00,F
143A:  RRCF   01,F
143C:  BTFSC  xB0.6
143E:  ADDWF  00,F
1440:  RRCF   00,F
1442:  RRCF   01,F
1444:  BTFSC  xB0.7
1446:  ADDWF  00,F
1448:  RRCF   00,F
144A:  RRCF   01,F
144C:  GOTO   1528 (RETURN)
*
188E:  MOVLW  8E
1890:  MOVWF  00
1892:  MOVF   xA9,W
1894:  SUBWF  00,F
1896:  MOVFF  AA,02
189A:  MOVFF  AB,01
189E:  BSF    02.7
18A0:  MOVF   00,F
18A2:  BZ    18B6
18A4:  BCF    FD8.0
18A6:  MOVF   02,F
18A8:  BNZ   18AE
18AA:  MOVF   01,F
18AC:  BZ    18B6
18AE:  RRCF   02,F
18B0:  RRCF   01,F
18B2:  DECFSZ 00,F
18B4:  BRA    18A4
18B6:  BTFSS  xAA.7
18B8:  BRA    18C4
18BA:  COMF   01,F
18BC:  COMF   02,F
18BE:  INCF   01,F
18C0:  BTFSC  FD8.2
18C2:  INCF   02,F
18C4:  NOP   
18C6:  RETLW  00
18C8:  MOVF   xB6,W
18CA:  MULWF  xB8
18CC:  MOVFF  FF3,01
18D0:  MOVFF  FF4,00
18D4:  MULWF  xB9
18D6:  MOVF   FF3,W
18D8:  ADDWF  00,F
18DA:  MOVF   xB7,W
18DC:  MULWF  xB8
18DE:  MOVF   FF3,W
18E0:  ADDWFC 00,W
18E2:  MOVWF  02
18E4:  RETLW  00
*
1E82:  MOVFF  FF2,0E
1E86:  BCF    FF2.7
1E88:  ADDWF  FE8,W
1E8A:  ADDLW  A7
1E8C:  MOVWF  FF6
1E8E:  MOVLW  1E
1E90:  MOVWF  FF7
1E92:  BTFSC  FD8.0
1E94:  INCF   FF7,F
1E96:  TBLRD*-
1E98:  MOVF   FF5,W
1E9A:  MOVWF  FFA
1E9C:  TBLRD*
1E9E:  MOVF   FF5,W
1EA0:  BTFSC  0E.7
1EA2:  BSF    FF2.7
1EA4:  MOVWF  FF9
1EA6:  DATA EA,19
1EA8:  DATA 02,1A
1EAA:  DATA 1A,1A
1EAC:  DATA 32,1A
1EAE:  DATA 4A,1A
1EB0:  DATA 62,1A
1EB2:  DATA 7A,1A
*
20D4:  MOVLW  8E
20D6:  MOVWF  00
20D8:  MOVFF  B1,01
20DC:  MOVFF  B0,02
20E0:  CLRF   03
20E2:  BTFSS  xB1.7
20E4:  BRA    20F0
20E6:  COMF   01,F
20E8:  COMF   02,F
20EA:  INCF   02,F
20EC:  BNZ   20F0
20EE:  INCF   01,F
20F0:  MOVF   01,F
20F2:  BNZ   2106
20F4:  MOVFF  02,01
20F8:  CLRF   02
20FA:  MOVLW  08
20FC:  SUBWF  00,F
20FE:  MOVF   01,F
2100:  BNZ   2106
2102:  CLRF   00
2104:  BRA    211A
2106:  BCF    FD8.0
2108:  BTFSC  01.7
210A:  BRA    2114
210C:  RLCF   02,F
210E:  RLCF   01,F
2110:  DECF   00,F
2112:  BRA    2106
2114:  BTFSC  xB1.7
2116:  BRA    211A
2118:  BCF    01.7
211A:  NOP   
211C:  GOTO   2420 (RETURN)
2120:  MOVLB  2
2122:  MOVF   xAF,W
2124:  BTFSC  FD8.2
2126:  BRA    2272
2128:  MOVWF  xBB
212A:  MOVF   xB3,W
212C:  BTFSC  FD8.2
212E:  BRA    2272
2130:  SUBWF  xBB,F
2132:  BNC   213E
2134:  MOVLW  7F
2136:  ADDWF  xBB,F
2138:  BTFSC  FD8.0
213A:  BRA    2272
213C:  BRA    214A
213E:  MOVLW  81
2140:  SUBWF  xBB,F
2142:  BTFSS  FD8.0
2144:  BRA    2272
2146:  BTFSC  FD8.2
2148:  BRA    2272
214A:  MOVFF  2BB,00
214E:  CLRF   01
2150:  CLRF   02
2152:  CLRF   03
2154:  CLRF   xBA
2156:  MOVFF  2B0,2B9
215A:  BSF    xB9.7
215C:  MOVFF  2B1,2B8
2160:  MOVFF  2B2,2B7
2164:  MOVLW  19
2166:  MOVWF  xBB
2168:  MOVF   xB6,W
216A:  SUBWF  xB7,F
216C:  BC    2188
216E:  MOVLW  01
2170:  SUBWF  xB8,F
2172:  BC    2188
2174:  SUBWF  xB9,F
2176:  BC    2188
2178:  SUBWF  xBA,F
217A:  BC    2188
217C:  INCF   xBA,F
217E:  INCF   xB9,F
2180:  INCF   xB8,F
2182:  MOVF   xB6,W
2184:  ADDWF  xB7,F
2186:  BRA    21D8
2188:  MOVF   xB5,W
218A:  SUBWF  xB8,F
218C:  BC    21B2
218E:  MOVLW  01
2190:  SUBWF  xB9,F
2192:  BC    21B2
2194:  SUBWF  xBA,F
2196:  BC    21B2
2198:  INCF   xBA,F
219A:  INCF   xB9,F
219C:  MOVF   xB5,W
219E:  ADDWF  xB8,F
21A0:  MOVF   xB6,W
21A2:  ADDWF  xB7,F
21A4:  BNC   21D8
21A6:  INCF   xB8,F
21A8:  BNZ   21D8
21AA:  INCF   xB9,F
21AC:  BNZ   21D8
21AE:  INCF   xBA,F
21B0:  BRA    21D8
21B2:  MOVF   xB4,W
21B4:  IORLW  80
21B6:  SUBWF  xB9,F
21B8:  BC    21D6
21BA:  MOVLW  01
21BC:  SUBWF  xBA,F
21BE:  BC    21D6
21C0:  INCF   xBA,F
21C2:  MOVF   xB4,W
21C4:  IORLW  80
21C6:  ADDWF  xB9,F
21C8:  MOVF   xB5,W
21CA:  ADDWF  xB8,F
21CC:  BNC   21A0
21CE:  INCF   xB9,F
21D0:  BNZ   21A0
21D2:  INCF   xBA,F
21D4:  BRA    21A0
21D6:  BSF    03.0
21D8:  DECFSZ xBB,F
21DA:  BRA    21DE
21DC:  BRA    21F4
21DE:  BCF    FD8.0
21E0:  RLCF   xB7,F
21E2:  RLCF   xB8,F
21E4:  RLCF   xB9,F
21E6:  RLCF   xBA,F
21E8:  BCF    FD8.0
21EA:  RLCF   03,F
21EC:  RLCF   02,F
21EE:  RLCF   01,F
21F0:  RLCF   xBC,F
21F2:  BRA    2168
21F4:  BTFSS  xBC.0
21F6:  BRA    2204
21F8:  BCF    FD8.0
21FA:  RRCF   01,F
21FC:  RRCF   02,F
21FE:  RRCF   03,F
2200:  RRCF   xBC,F
2202:  BRA    2208
2204:  DECF   00,F
2206:  BZ    2272
2208:  BTFSC  xBC.7
220A:  BRA    2248
220C:  BCF    FD8.0
220E:  RLCF   xB7,F
2210:  RLCF   xB8,F
2212:  RLCF   xB9,F
2214:  RLCF   xBA,F
2216:  MOVF   xB6,W
2218:  SUBWF  xB7,F
221A:  BC    222A
221C:  MOVLW  01
221E:  SUBWF  xB8,F
2220:  BC    222A
2222:  SUBWF  xB9,F
2224:  BC    222A
2226:  SUBWF  xBA,F
2228:  BNC   225E
222A:  MOVF   xB5,W
222C:  SUBWF  xB8,F
222E:  BC    223A
2230:  MOVLW  01
2232:  SUBWF  xB9,F
2234:  BC    223A
2236:  SUBWF  xBA,F
2238:  BNC   225E
223A:  MOVF   xB4,W
223C:  IORLW  80
223E:  SUBWF  xB9,F
2240:  BC    2248
2242:  MOVLW  01
2244:  SUBWF  xBA,F
2246:  BNC   225E
2248:  INCF   03,F
224A:  BNZ   225E
224C:  INCF   02,F
224E:  BNZ   225E
2250:  INCF   01,F
2252:  BNZ   225E
2254:  INCF   00,F
2256:  BZ    2272
2258:  RRCF   01,F
225A:  RRCF   02,F
225C:  RRCF   03,F
225E:  MOVFF  2B0,2BB
2262:  MOVF   xB4,W
2264:  XORWF  xBB,F
2266:  BTFSS  xBB.7
2268:  BRA    226E
226A:  BSF    01.7
226C:  BRA    227A
226E:  BCF    01.7
2270:  BRA    227A
2272:  CLRF   00
2274:  CLRF   01
2276:  CLRF   02
2278:  CLRF   03
227A:  NOP   
227C:  MOVLB  0
227E:  RETLW  00
*
247A:  MOVFF  9E,A5
247E:  MOVF   xA2,W
2480:  XORWF  xA5,F
2482:  BTFSS  xA5.7
2484:  BRA    2490
2486:  BCF    FD8.2
2488:  BCF    FD8.0
248A:  BTFSC  x9E.7
248C:  BSF    FD8.0
248E:  BRA    24EE
2490:  MOVFF  9E,A5
2494:  MOVFF  A1,A6
2498:  MOVF   x9D,W
249A:  SUBWF  xA6,F
249C:  BZ    24AA
249E:  BTFSS  xA5.7
24A0:  BRA    24EE
24A2:  MOVF   FD8,W
24A4:  XORLW  01
24A6:  MOVWF  FD8
24A8:  BRA    24EE
24AA:  MOVFF  A2,A6
24AE:  MOVF   x9E,W
24B0:  SUBWF  xA6,F
24B2:  BZ    24C0
24B4:  BTFSS  xA5.7
24B6:  BRA    24EE
24B8:  MOVF   FD8,W
24BA:  XORLW  01
24BC:  MOVWF  FD8
24BE:  BRA    24EE
24C0:  MOVFF  A3,A6
24C4:  MOVF   x9F,W
24C6:  SUBWF  xA6,F
24C8:  BZ    24D6
24CA:  BTFSS  xA5.7
24CC:  BRA    24EE
24CE:  MOVF   FD8,W
24D0:  XORLW  01
24D2:  MOVWF  FD8
24D4:  BRA    24EE
24D6:  MOVFF  A4,A6
24DA:  MOVF   xA0,W
24DC:  SUBWF  xA6,F
24DE:  BZ    24EC
24E0:  BTFSS  xA5.7
24E2:  BRA    24EE
24E4:  MOVF   FD8,W
24E6:  XORLW  01
24E8:  MOVWF  FD8
24EA:  BRA    24EE
24EC:  BCF    FD8.0
24EE:  RETLW  00
24F0:  MOVLW  80
24F2:  BTFSS  FD8.1
24F4:  BRA    24FA
24F6:  MOVLB  2
24F8:  XORWF  xAE,F
24FA:  MOVLB  2
24FC:  CLRF   xB3
24FE:  CLRF   xB4
2500:  MOVFF  2AA,2B2
2504:  MOVF   xAE,W
2506:  XORWF  xB2,F
2508:  MOVF   xA9,W
250A:  BTFSC  FD8.2
250C:  BRA    26CC
250E:  MOVWF  xB1
2510:  MOVWF  00
2512:  MOVF   xAD,W
2514:  BTFSC  FD8.2
2516:  BRA    26DE
2518:  SUBWF  xB1,F
251A:  BTFSC  FD8.2
251C:  BRA    2624
251E:  BNC   259C
2520:  MOVFF  2AE,2B7
2524:  BSF    xB7.7
2526:  MOVFF  2AF,2B6
252A:  MOVFF  2B0,2B5
252E:  CLRF   xB4
2530:  BCF    FD8.0
2532:  RRCF   xB7,F
2534:  RRCF   xB6,F
2536:  RRCF   xB5,F
2538:  RRCF   xB4,F
253A:  DECFSZ xB1,F
253C:  BRA    252E
253E:  BTFSS  xB2.7
2540:  BRA    2548
2542:  BSF    xB3.0
2544:  BRA    2706
2546:  BCF    xB3.0
2548:  BCF    xB1.0
254A:  BSF    xB3.4
254C:  MOVLW  02
254E:  MOVWF  FEA
2550:  MOVLW  AC
2552:  MOVWF  FE9
2554:  BRA    272C
2556:  BCF    xB3.4
2558:  BTFSC  xB2.7
255A:  BRA    2570
255C:  BTFSS  xB1.0
255E:  BRA    2586
2560:  RRCF   xB7,F
2562:  RRCF   xB6,F
2564:  RRCF   xB5,F
2566:  RRCF   xB4,F
2568:  INCF   00,F
256A:  BTFSC  FD8.2
256C:  BRA    26FC
256E:  BRA    2586
2570:  BTFSC  xB7.7
2572:  BRA    258C
2574:  BCF    FD8.0
2576:  RLCF   xB4,F
2578:  RLCF   xB5,F
257A:  RLCF   xB6,F
257C:  RLCF   xB7,F
257E:  DECF   00,F
2580:  BTFSC  FD8.2
2582:  BRA    26FC
2584:  BRA    2570
2586:  BSF    xB3.6
2588:  BRA    2664
258A:  BCF    xB3.6
258C:  MOVFF  2AA,2B2
2590:  BTFSS  xAA.7
2592:  BRA    2598
2594:  BSF    xB7.7
2596:  BRA    26EE
2598:  BCF    xB7.7
259A:  BRA    26EE
259C:  MOVFF  2AD,2B1
25A0:  MOVFF  2AD,00
25A4:  MOVF   xA9,W
25A6:  SUBWF  xB1,F
25A8:  MOVFF  2AA,2B7
25AC:  BSF    xB7.7
25AE:  MOVFF  2AB,2B6
25B2:  MOVFF  2AC,2B5
25B6:  CLRF   xB4
25B8:  BCF    FD8.0
25BA:  RRCF   xB7,F
25BC:  RRCF   xB6,F
25BE:  RRCF   xB5,F
25C0:  RRCF   xB4,F
25C2:  DECFSZ xB1,F
25C4:  BRA    25B6
25C6:  BTFSS  xB2.7
25C8:  BRA    25D0
25CA:  BSF    xB3.1
25CC:  BRA    2706
25CE:  BCF    xB3.1
25D0:  BCF    xB1.0
25D2:  BSF    xB3.5
25D4:  MOVLW  02
25D6:  MOVWF  FEA
25D8:  MOVLW  B0
25DA:  MOVWF  FE9
25DC:  BRA    272C
25DE:  BCF    xB3.5
25E0:  BTFSC  xB2.7
25E2:  BRA    25F8
25E4:  BTFSS  xB1.0
25E6:  BRA    260E
25E8:  RRCF   xB7,F
25EA:  RRCF   xB6,F
25EC:  RRCF   xB5,F
25EE:  RRCF   xB4,F
25F0:  INCF   00,F
25F2:  BTFSC  FD8.2
25F4:  BRA    26FC
25F6:  BRA    260E
25F8:  BTFSC  xB7.7
25FA:  BRA    2614
25FC:  BCF    FD8.0
25FE:  RLCF   xB4,F
2600:  RLCF   xB5,F
2602:  RLCF   xB6,F
2604:  RLCF   xB7,F
2606:  DECF   00,F
2608:  BTFSC  FD8.2
260A:  BRA    26FC
260C:  BRA    25F8
260E:  BSF    xB3.7
2610:  BRA    2664
2612:  BCF    xB3.7
2614:  MOVFF  2AE,2B2
2618:  BTFSS  xAE.7
261A:  BRA    2620
261C:  BSF    xB7.7
261E:  BRA    26EE
2620:  BCF    xB7.7
2622:  BRA    26EE
2624:  MOVFF  2AE,2B7
2628:  BSF    xB7.7
262A:  MOVFF  2AF,2B6
262E:  MOVFF  2B0,2B5
2632:  BTFSS  xB2.7
2634:  BRA    263E
2636:  BCF    xB7.7
2638:  BSF    xB3.2
263A:  BRA    2706
263C:  BCF    xB3.2
263E:  CLRF   xB4
2640:  BCF    xB1.0
2642:  MOVLW  02
2644:  MOVWF  FEA
2646:  MOVLW  AC
2648:  MOVWF  FE9
264A:  BRA    272C
264C:  BTFSC  xB2.7
264E:  BRA    2688
2650:  MOVFF  2AA,2B2
2654:  BTFSS  xB1.0
2656:  BRA    2664
2658:  RRCF   xB7,F
265A:  RRCF   xB6,F
265C:  RRCF   xB5,F
265E:  RRCF   xB4,F
2660:  INCF   00,F
2662:  BZ    26FC
2664:  BTFSS  xB4.7
2666:  BRA    267E
2668:  INCF   xB5,F
266A:  BNZ   267E
266C:  INCF   xB6,F
266E:  BNZ   267E
2670:  INCF   xB7,F
2672:  BNZ   267E
2674:  RRCF   xB7,F
2676:  RRCF   xB6,F
2678:  RRCF   xB5,F
267A:  INCF   00,F
267C:  BZ    26FC
267E:  BTFSC  xB3.6
2680:  BRA    258A
2682:  BTFSC  xB3.7
2684:  BRA    2612
2686:  BRA    26C0
2688:  MOVLW  80
268A:  XORWF  xB7,F
268C:  BTFSS  xB7.7
268E:  BRA    2698
2690:  BRA    2706
2692:  MOVFF  2AE,2B2
2696:  BRA    26AC
2698:  MOVFF  2AA,2B2
269C:  MOVF   xB7,F
269E:  BNZ   26AC
26A0:  MOVF   xB6,F
26A2:  BNZ   26AC
26A4:  MOVF   xB5,F
26A6:  BNZ   26AC
26A8:  CLRF   00
26AA:  BRA    26EE
26AC:  BTFSC  xB7.7
26AE:  BRA    26C0
26B0:  BCF    FD8.0
26B2:  RLCF   xB4,F
26B4:  RLCF   xB5,F
26B6:  RLCF   xB6,F
26B8:  RLCF   xB7,F
26BA:  DECFSZ 00,F
26BC:  BRA    26AC
26BE:  BRA    26FC
26C0:  BTFSS  xB2.7
26C2:  BRA    26C8
26C4:  BSF    xB7.7
26C6:  BRA    26EE
26C8:  BCF    xB7.7
26CA:  BRA    26EE
26CC:  MOVFF  2AD,00
26D0:  MOVFF  2AE,2B7
26D4:  MOVFF  2AF,2B6
26D8:  MOVFF  2B0,2B5
26DC:  BRA    26EE
26DE:  MOVFF  2A9,00
26E2:  MOVFF  2AA,2B7
26E6:  MOVFF  2AB,2B6
26EA:  MOVFF  2AC,2B5
26EE:  MOVFF  2B7,01
26F2:  MOVFF  2B6,02
26F6:  MOVFF  2B5,03
26FA:  BRA    2764
26FC:  CLRF   00
26FE:  CLRF   01
2700:  CLRF   02
2702:  CLRF   03
2704:  BRA    2764
2706:  CLRF   xB4
2708:  COMF   xB5,F
270A:  COMF   xB6,F
270C:  COMF   xB7,F
270E:  COMF   xB4,F
2710:  INCF   xB4,F
2712:  BNZ   271E
2714:  INCF   xB5,F
2716:  BNZ   271E
2718:  INCF   xB6,F
271A:  BNZ   271E
271C:  INCF   xB7,F
271E:  BTFSC  xB3.0
2720:  BRA    2546
2722:  BTFSC  xB3.1
2724:  BRA    25CE
2726:  BTFSC  xB3.2
2728:  BRA    263C
272A:  BRA    2692
272C:  MOVF   FEF,W
272E:  ADDWF  xB5,F
2730:  BNC   273C
2732:  INCF   xB6,F
2734:  BNZ   273C
2736:  INCF   xB7,F
2738:  BTFSC  FD8.2
273A:  BSF    xB1.0
273C:  MOVF   FED,F
273E:  MOVF   FEF,W
2740:  ADDWF  xB6,F
2742:  BNC   274A
2744:  INCF   xB7,F
2746:  BTFSC  FD8.2
2748:  BSF    xB1.0
274A:  MOVF   FED,F
274C:  MOVF   FEF,W
274E:  BTFSC  FEF.7
2750:  BRA    2754
2752:  XORLW  80
2754:  ADDWF  xB7,F
2756:  BTFSC  FD8.0
2758:  BSF    xB1.0
275A:  BTFSC  xB3.4
275C:  BRA    2556
275E:  BTFSC  xB3.5
2760:  BRA    25DE
2762:  BRA    264C
2764:  NOP   
2766:  MOVLB  0
2768:  RETLW  00
276A:  MOVLW  8E
276C:  MOVWF  00
276E:  MOVFF  2B0,01
2772:  MOVFF  2AF,02
2776:  CLRF   03
2778:  MOVF   01,F
277A:  BNZ   278E
277C:  MOVFF  02,01
2780:  CLRF   02
2782:  MOVLW  08
2784:  SUBWF  00,F
2786:  MOVF   01,F
2788:  BNZ   278E
278A:  CLRF   00
278C:  BRA    279E
278E:  BCF    FD8.0
2790:  BTFSC  01.7
2792:  BRA    279C
2794:  RLCF   02,F
2796:  RLCF   01,F
2798:  DECF   00,F
279A:  BRA    278E
279C:  BCF    01.7
279E:  NOP   
27A0:  RETLW  00
*
2BA4:  MOVLB  2
2BA6:  MOVF   xC5,W
2BA8:  BTFSC  FD8.2
2BAA:  BRA    2C8E
2BAC:  MOVWF  00
2BAE:  MOVF   xC9,W
2BB0:  BTFSC  FD8.2
2BB2:  BRA    2C8E
2BB4:  ADDWF  00,F
2BB6:  BNC   2BC0
2BB8:  MOVLW  81
2BBA:  ADDWF  00,F
2BBC:  BC    2C8E
2BBE:  BRA    2BC8
2BC0:  MOVLW  7F
2BC2:  SUBWF  00,F
2BC4:  BNC   2C8E
2BC6:  BZ    2C8E
2BC8:  MOVFF  2C6,2CD
2BCC:  MOVF   xCA,W
2BCE:  XORWF  xCD,F
2BD0:  BSF    xC6.7
2BD2:  BSF    xCA.7
2BD4:  MOVF   xC8,W
2BD6:  MULWF  xCC
2BD8:  MOVFF  FF4,2CF
2BDC:  MOVF   xC7,W
2BDE:  MULWF  xCB
2BE0:  MOVFF  FF4,03
2BE4:  MOVFF  FF3,2CE
2BE8:  MULWF  xCC
2BEA:  MOVF   FF3,W
2BEC:  ADDWF  xCF,F
2BEE:  MOVF   FF4,W
2BF0:  ADDWFC xCE,F
2BF2:  MOVLW  00
2BF4:  ADDWFC 03,F
2BF6:  MOVF   xC8,W
2BF8:  MULWF  xCB
2BFA:  MOVF   FF3,W
2BFC:  ADDWF  xCF,F
2BFE:  MOVF   FF4,W
2C00:  ADDWFC xCE,F
2C02:  MOVLW  00
2C04:  CLRF   02
2C06:  ADDWFC 03,F
2C08:  ADDWFC 02,F
2C0A:  MOVF   xC6,W
2C0C:  MULWF  xCC
2C0E:  MOVF   FF3,W
2C10:  ADDWF  xCE,F
2C12:  MOVF   FF4,W
2C14:  ADDWFC 03,F
2C16:  MOVLW  00
2C18:  ADDWFC 02,F
2C1A:  MOVF   xC6,W
2C1C:  MULWF  xCB
2C1E:  MOVF   FF3,W
2C20:  ADDWF  03,F
2C22:  MOVF   FF4,W
2C24:  ADDWFC 02,F
2C26:  MOVLW  00
2C28:  CLRF   01
2C2A:  ADDWFC 01,F
2C2C:  MOVF   xC8,W
2C2E:  MULWF  xCA
2C30:  MOVF   FF3,W
2C32:  ADDWF  xCE,F
2C34:  MOVF   FF4,W
2C36:  ADDWFC 03,F
2C38:  MOVLW  00
2C3A:  ADDWFC 02,F
2C3C:  ADDWFC 01,F
2C3E:  MOVF   xC7,W
2C40:  MULWF  xCA
2C42:  MOVF   FF3,W
2C44:  ADDWF  03,F
2C46:  MOVF   FF4,W
2C48:  ADDWFC 02,F
2C4A:  MOVLW  00
2C4C:  ADDWFC 01,F
2C4E:  MOVF   xC6,W
2C50:  MULWF  xCA
2C52:  MOVF   FF3,W
2C54:  ADDWF  02,F
2C56:  MOVF   FF4,W
2C58:  ADDWFC 01,F
2C5A:  INCF   00,F
2C5C:  BTFSC  01.7
2C5E:  BRA    2C6A
2C60:  RLCF   xCE,F
2C62:  RLCF   03,F
2C64:  RLCF   02,F
2C66:  RLCF   01,F
2C68:  DECF   00,F
2C6A:  MOVLW  00
2C6C:  BTFSS  xCE.7
2C6E:  BRA    2C84
2C70:  INCF   03,F
2C72:  ADDWFC 02,F
2C74:  ADDWFC 01,F
2C76:  MOVF   01,W
2C78:  BNZ   2C84
2C7A:  MOVF   02,W
2C7C:  BNZ   2C84
2C7E:  MOVF   03,W
2C80:  BNZ   2C84
2C82:  INCF   00,F
2C84:  BTFSC  xCD.7
2C86:  BSF    01.7
2C88:  BTFSS  xCD.7
2C8A:  BCF    01.7
2C8C:  BRA    2C96
2C8E:  CLRF   00
2C90:  CLRF   01
2C92:  CLRF   02
2C94:  CLRF   03
2C96:  NOP   
2C98:  MOVLB  0
2C9A:  RETLW  00
*
2F22:  CLRF   01
2F24:  CLRF   02
2F26:  CLRF   00
2F28:  CLRF   03
2F2A:  MOVF   xA8,W
2F2C:  BNZ   2F32
2F2E:  MOVF   xA7,W
2F30:  BZ    2F62
2F32:  MOVLW  10
2F34:  MOVWF  xA9
2F36:  BCF    FD8.0
2F38:  RLCF   xA5,F
2F3A:  RLCF   xA6,F
2F3C:  RLCF   00,F
2F3E:  RLCF   03,F
2F40:  MOVF   xA8,W
2F42:  SUBWF  03,W
2F44:  BNZ   2F4A
2F46:  MOVF   xA7,W
2F48:  SUBWF  00,W
2F4A:  BNC   2F5A
2F4C:  MOVF   xA7,W
2F4E:  SUBWF  00,F
2F50:  BTFSS  FD8.0
2F52:  DECF   03,F
2F54:  MOVF   xA8,W
2F56:  SUBWF  03,F
2F58:  BSF    FD8.0
2F5A:  RLCF   01,F
2F5C:  RLCF   02,F
2F5E:  DECFSZ xA9,F
2F60:  BRA    2F36
2F62:  NOP   
2F64:  GOTO   31E4 (RETURN)
*
33D0:  MOVLB  2
33D2:  MOVF   xC5,W
33D4:  SUBLW  B6
33D6:  MOVWF  xC5
33D8:  CLRF   03
33DA:  MOVFF  2C6,2C9
33DE:  BSF    xC6.7
33E0:  BCF    FD8.0
33E2:  RRCF   xC6,F
33E4:  RRCF   xC7,F
33E6:  RRCF   xC8,F
33E8:  RRCF   03,F
33EA:  RRCF   02,F
33EC:  RRCF   01,F
33EE:  RRCF   00,F
33F0:  DECFSZ xC5,F
33F2:  BRA    33E0
33F4:  BTFSS  xC9.7
33F6:  BRA    340E
33F8:  COMF   00,F
33FA:  COMF   01,F
33FC:  COMF   02,F
33FE:  COMF   03,F
3400:  INCF   00,F
3402:  BTFSC  FD8.2
3404:  INCF   01,F
3406:  BTFSC  FD8.2
3408:  INCF   02,F
340A:  BTFSC  FD8.2
340C:  INCF   03,F
340E:  MOVLB  0
3410:  RETLW  00
3412:  CLRF   00
3414:  CLRF   01
3416:  CLRF   02
3418:  CLRF   03
341A:  MOVLB  2
341C:  CLRF   xCD
341E:  CLRF   xCE
3420:  CLRF   xCF
3422:  CLRF   xD0
3424:  MOVF   xCC,W
3426:  IORWF  xCB,W
3428:  IORWF  xCA,W
342A:  IORWF  xC9,W
342C:  BZ    3486
342E:  MOVLW  20
3430:  MOVWF  xD1
3432:  BCF    FD8.0
3434:  RLCF   xC5,F
3436:  RLCF   xC6,F
3438:  RLCF   xC7,F
343A:  RLCF   xC8,F
343C:  RLCF   xCD,F
343E:  RLCF   xCE,F
3440:  RLCF   xCF,F
3442:  RLCF   xD0,F
3444:  MOVF   xCC,W
3446:  SUBWF  xD0,W
3448:  BNZ   345A
344A:  MOVF   xCB,W
344C:  SUBWF  xCF,W
344E:  BNZ   345A
3450:  MOVF   xCA,W
3452:  SUBWF  xCE,W
3454:  BNZ   345A
3456:  MOVF   xC9,W
3458:  SUBWF  xCD,W
345A:  BNC   347A
345C:  MOVF   xC9,W
345E:  SUBWF  xCD,F
3460:  MOVF   xCA,W
3462:  BTFSS  FD8.0
3464:  INCFSZ xCA,W
3466:  SUBWF  xCE,F
3468:  MOVF   xCB,W
346A:  BTFSS  FD8.0
346C:  INCFSZ xCB,W
346E:  SUBWF  xCF,F
3470:  MOVF   xCC,W
3472:  BTFSS  FD8.0
3474:  INCFSZ xCC,W
3476:  SUBWF  xD0,F
3478:  BSF    FD8.0
347A:  RLCF   00,F
347C:  RLCF   01,F
347E:  RLCF   02,F
3480:  RLCF   03,F
3482:  DECFSZ xD1,F
3484:  BRA    3432
3486:  NOP   
3488:  MOVLW  02
348A:  MOVWF  FEA
348C:  MOVLW  CD
348E:  MOVWF  FE9
3490:  MOVLB  0
3492:  RETLW  00
3494:  MOVF   FE9,W
3496:  MOVWF  x9F
3498:  MOVF   x9E,W
349A:  MOVWF  xA1
349C:  BZ    34D6
349E:  MOVFF  9D,2C8
34A2:  MOVFF  9C,2C7
34A6:  MOVFF  9B,2C6
34AA:  MOVFF  9A,2C5
34AE:  MOVLB  2
34B0:  CLRF   xCC
34B2:  CLRF   xCB
34B4:  MOVLW  20
34B6:  MOVWF  xCA
34B8:  MOVLW  82
34BA:  MOVWF  xC9
34BC:  MOVLB  0
34BE:  CALL   2BA4
34C2:  MOVFF  03,9D
34C6:  MOVFF  02,9C
34CA:  MOVFF  01,9B
34CE:  MOVFF  00,9A
34D2:  DECFSZ xA1,F
34D4:  BRA    349E
34D6:  MOVFF  9D,2C8
34DA:  MOVFF  9C,2C7
34DE:  MOVFF  9B,2C6
34E2:  MOVFF  9A,2C5
34E6:  RCALL  33D0
34E8:  MOVFF  03,9D
34EC:  MOVFF  02,9C
34F0:  MOVFF  01,9B
34F4:  MOVFF  00,9A
34F8:  BTFSS  x9D.7
34FA:  BRA    3516
34FC:  DECF   x9F,F
34FE:  BSF    x9F.5
3500:  COMF   x9A,F
3502:  COMF   x9B,F
3504:  COMF   x9C,F
3506:  COMF   x9D,F
3508:  INCF   x9A,F
350A:  BTFSC  FD8.2
350C:  INCF   x9B,F
350E:  BTFSC  FD8.2
3510:  INCF   x9C,F
3512:  BTFSC  FD8.2
3514:  INCF   x9D,F
3516:  MOVLW  3B
3518:  MOVWF  xA6
351A:  MOVLW  9A
351C:  MOVWF  xA5
351E:  MOVLW  CA
3520:  MOVWF  xA4
3522:  CLRF   xA3
3524:  MOVLW  0A
3526:  MOVWF  xA1
3528:  MOVF   x9E,W
352A:  BTFSC  FD8.2
352C:  INCF   x9F,F
352E:  MOVFF  9D,2C8
3532:  MOVFF  9C,2C7
3536:  MOVFF  9B,2C6
353A:  MOVFF  9A,2C5
353E:  MOVFF  A6,2CC
3542:  MOVFF  A5,2CB
3546:  MOVFF  A4,2CA
354A:  MOVFF  A3,2C9
354E:  RCALL  3412
3550:  MOVF   01,W
3552:  MOVFF  FEF,9A
3556:  MOVFF  FEC,9B
355A:  MOVFF  FEC,9C
355E:  MOVFF  FEC,9D
3562:  MOVF   00,F
3564:  BNZ   3584
3566:  INCF   x9E,W
3568:  SUBWF  xA1,W
356A:  BZ    3584
356C:  MOVF   x9F,W
356E:  BZ    3588
3570:  ANDLW  0F
3572:  SUBWF  xA1,W
3574:  BZ    3578
3576:  BC    35EE
3578:  BTFSC  x9F.7
357A:  BRA    35EE
357C:  BTFSC  x9F.6
357E:  BRA    3588
3580:  MOVLW  20
3582:  BRA    35E4
3584:  MOVLW  20
3586:  ANDWF  x9F,F
3588:  BTFSS  x9F.5
358A:  BRA    35A6
358C:  BCF    x9F.5
358E:  MOVF   x9E,W
3590:  BTFSS  FD8.2
3592:  DECF   x9F,F
3594:  MOVF   00,W
3596:  MOVWF  x9F
3598:  MOVLW  2D
359A:  MOVWF  xA7
359C:  CALL   13C0
35A0:  MOVF   x9F,W
35A2:  MOVWF  00
35A4:  CLRF   x9F
35A6:  MOVF   x9E,W
35A8:  SUBWF  xA1,W
35AA:  BNZ   35C2
35AC:  MOVF   00,W
35AE:  MOVWF  x9F
35B0:  MOVLW  2E
35B2:  MOVWF  xA7
35B4:  CALL   13C0
35B8:  MOVF   x9F,W
35BA:  MOVWF  00
35BC:  MOVLW  20
35BE:  ANDWF  x9F,F
35C0:  MOVLW  00
35C2:  MOVLW  30
35C4:  BTFSS  x9F.5
35C6:  BRA    35E4
35C8:  BCF    x9F.5
35CA:  MOVF   x9E,W
35CC:  BTFSS  FD8.2
35CE:  DECF   x9F,F
35D0:  MOVF   00,W
35D2:  MOVWF  x9F
35D4:  MOVLW  2D
35D6:  MOVWF  xA7
35D8:  CALL   13C0
35DC:  MOVF   x9F,W
35DE:  MOVWF  00
35E0:  CLRF   x9F
35E2:  MOVLW  30
35E4:  ADDWF  00,F
35E6:  MOVFF  00,A7
35EA:  CALL   13C0
35EE:  MOVFF  A6,2C8
35F2:  MOVFF  A5,2C7
35F6:  MOVFF  A4,2C6
35FA:  MOVFF  A3,2C5
35FE:  MOVLB  2
3600:  CLRF   xCC
3602:  CLRF   xCB
3604:  CLRF   xCA
3606:  MOVLW  0A
3608:  MOVWF  xC9
360A:  MOVLB  0
360C:  RCALL  3412
360E:  MOVFF  03,A6
3612:  MOVFF  02,A5
3616:  MOVFF  01,A4
361A:  MOVFF  00,A3
361E:  DECFSZ xA1,F
3620:  BRA    352E
3622:  RETLW  00
*
36BA:  MOVLB  2
36BC:  MOVF   xAD,W
36BE:  CLRF   01
36C0:  SUBWF  xAC,W
36C2:  BC    36CA
36C4:  MOVFF  2AC,00
36C8:  BRA    36E2
36CA:  CLRF   00
36CC:  MOVLW  08
36CE:  MOVWF  xAE
36D0:  RLCF   xAC,F
36D2:  RLCF   00,F
36D4:  MOVF   xAD,W
36D6:  SUBWF  00,W
36D8:  BTFSC  FD8.0
36DA:  MOVWF  00
36DC:  RLCF   01,F
36DE:  DECFSZ xAE,F
36E0:  BRA    36D0
36E2:  MOVLB  0
36E4:  RETLW  00
36E6:  MOVLW  20
36E8:  BTFSS  x98.4
36EA:  MOVLW  30
36EC:  MOVWF  x99
36EE:  MOVFF  97,00
36F2:  BTFSS  x97.7
36F4:  BRA    3704
36F6:  COMF   00,F
36F8:  INCF   00,F
36FA:  MOVFF  00,97
36FE:  MOVLW  2D
3700:  MOVWF  x99
3702:  BSF    x98.7
3704:  MOVF   01,W
3706:  MOVFF  97,2AC
370A:  MOVLW  64
370C:  MOVLB  2
370E:  MOVWF  xAD
3710:  MOVLB  0
3712:  RCALL  36BA
3714:  MOVFF  00,97
3718:  MOVLW  30
371A:  ADDWF  01,W
371C:  MOVWF  x9A
371E:  MOVFF  97,2AC
3722:  MOVLW  0A
3724:  MOVLB  2
3726:  MOVWF  xAD
3728:  MOVLB  0
372A:  RCALL  36BA
372C:  MOVLW  30
372E:  ADDWF  00,W
3730:  MOVWF  x9C
3732:  MOVLW  30
3734:  ADDWF  01,W
3736:  MOVWF  x9B
3738:  MOVFF  99,00
373C:  BTFSS  x98.3
373E:  BRA    3744
3740:  BTFSS  x98.7
3742:  BCF    x98.2
3744:  BTFSC  x98.4
3746:  BRA    375E
3748:  BTFSS  x98.7
374A:  BRA    3790
374C:  BTFSC  x98.2
374E:  BRA    3790
3750:  MOVFF  00,9A
3754:  BTFSC  x98.1
3756:  BRA    3790
3758:  MOVFF  00,9B
375C:  BRA    3790
375E:  MOVLW  30
3760:  SUBWF  x9A,W
3762:  BNZ   3790
3764:  MOVFF  00,9A
3768:  MOVLW  20
376A:  MOVWF  x99
376C:  BTFSS  x98.3
376E:  BRA    3778
3770:  BCF    x98.2
3772:  BSF    x98.1
3774:  BTFSS  x98.7
3776:  BCF    x98.1
3778:  MOVLW  30
377A:  SUBWF  x9B,W
377C:  BNZ   3790
377E:  MOVFF  00,9B
3782:  MOVLW  20
3784:  MOVWF  x9A
3786:  BTFSS  x98.3
3788:  BRA    3778
378A:  BCF    x98.1
378C:  BTFSS  x98.7
378E:  BCF    x98.0
3790:  BTFSS  x98.2
3792:  BRA    379C
3794:  MOVFF  99,A7
3798:  CALL   13C0
379C:  BTFSS  x98.1
379E:  BRA    37A8
37A0:  MOVFF  9A,A7
37A4:  CALL   13C0
37A8:  BTFSS  x98.0
37AA:  BRA    37B4
37AC:  MOVFF  9B,A7
37B0:  CALL   13C0
37B4:  MOVFF  9C,A7
37B8:  CALL   13C0
37BC:  RETLW  00
*
3AF0:  MOVF   01,W
3AF2:  MOVFF  2AA,2AC
3AF6:  MOVLW  64
3AF8:  MOVLB  2
3AFA:  MOVWF  xAD
3AFC:  MOVLB  0
3AFE:  RCALL  36BA
3B00:  MOVFF  00,2AA
3B04:  MOVF   01,W
3B06:  MOVLW  30
3B08:  BNZ   3B1A
3B0A:  MOVLB  2
3B0C:  BTFSS  xAB.1
3B0E:  BRA    3B2C
3B10:  BTFSC  xAB.3
3B12:  BRA    3B2C
3B14:  BTFSC  xAB.4
3B16:  MOVLW  20
3B18:  BRA    3B22
3B1A:  MOVLB  2
3B1C:  BCF    xAB.3
3B1E:  BCF    xAB.4
3B20:  BSF    xAB.0
3B22:  ADDWF  01,F
3B24:  MOVF   01,W
3B26:  BTFSS  F9E.4
3B28:  BRA    3B26
3B2A:  MOVWF  FAD
3B2C:  MOVFF  2AA,2AC
3B30:  MOVLW  0A
3B32:  MOVWF  xAD
3B34:  MOVLB  0
3B36:  RCALL  36BA
3B38:  MOVFF  00,2AA
3B3C:  MOVF   01,W
3B3E:  MOVLW  30
3B40:  BNZ   3B52
3B42:  MOVLB  2
3B44:  BTFSC  xAB.3
3B46:  BRA    3B5E
3B48:  BTFSS  xAB.0
3B4A:  BRA    3B5E
3B4C:  BTFSC  xAB.4
3B4E:  MOVLW  20
3B50:  MOVLB  0
3B52:  ADDWF  01,F
3B54:  MOVF   01,W
3B56:  BTFSS  F9E.4
3B58:  BRA    3B56
3B5A:  MOVWF  FAD
3B5C:  MOVLB  2
3B5E:  MOVLW  30
3B60:  ADDWF  xAA,F
3B62:  MOVF   xAA,W
3B64:  BTFSS  F9E.4
3B66:  BRA    3B64
3B68:  MOVWF  FAD
3B6A:  MOVLB  0
3B6C:  RETLW  00
3B6E:  MOVF   FE9,W
3B70:  MOVLB  2
3B72:  MOVWF  xBD
3B74:  MOVF   xBC,W
3B76:  MOVWF  xBF
3B78:  BZ    3BB2
3B7A:  MOVFF  2BB,2C8
3B7E:  MOVFF  2BA,2C7
3B82:  MOVFF  2B9,2C6
3B86:  MOVFF  2B8,2C5
3B8A:  CLRF   xCC
3B8C:  CLRF   xCB
3B8E:  MOVLW  20
3B90:  MOVWF  xCA
3B92:  MOVLW  82
3B94:  MOVWF  xC9
3B96:  MOVLB  0
3B98:  CALL   2BA4
3B9C:  MOVFF  03,2BB
3BA0:  MOVFF  02,2BA
3BA4:  MOVFF  01,2B9
3BA8:  MOVFF  00,2B8
3BAC:  MOVLB  2
3BAE:  DECFSZ xBF,F
3BB0:  BRA    3B7A
3BB2:  MOVFF  2BB,2C8
3BB6:  MOVFF  2BA,2C7
3BBA:  MOVFF  2B9,2C6
3BBE:  MOVFF  2B8,2C5
3BC2:  MOVLB  0
3BC4:  RCALL  33D0
3BC6:  MOVFF  03,2BB
3BCA:  MOVFF  02,2BA
3BCE:  MOVFF  01,2B9
3BD2:  MOVFF  00,2B8
3BD6:  MOVLB  2
3BD8:  BTFSS  xBB.7
3BDA:  BRA    3BF6
3BDC:  DECF   xBD,F
3BDE:  BSF    xBD.5
3BE0:  COMF   xB8,F
3BE2:  COMF   xB9,F
3BE4:  COMF   xBA,F
3BE6:  COMF   xBB,F
3BE8:  INCF   xB8,F
3BEA:  BTFSC  FD8.2
3BEC:  INCF   xB9,F
3BEE:  BTFSC  FD8.2
3BF0:  INCF   xBA,F
3BF2:  BTFSC  FD8.2
3BF4:  INCF   xBB,F
3BF6:  MOVLW  3B
3BF8:  MOVWF  xC4
3BFA:  MOVLW  9A
3BFC:  MOVWF  xC3
3BFE:  MOVLW  CA
3C00:  MOVWF  xC2
3C02:  CLRF   xC1
3C04:  MOVLW  0A
3C06:  MOVWF  xBF
3C08:  MOVF   xBC,W
3C0A:  BTFSC  FD8.2
3C0C:  INCF   xBD,F
3C0E:  MOVFF  2BB,2C8
3C12:  MOVFF  2BA,2C7
3C16:  MOVFF  2B9,2C6
3C1A:  MOVFF  2B8,2C5
3C1E:  MOVFF  2C4,2CC
3C22:  MOVFF  2C3,2CB
3C26:  MOVFF  2C2,2CA
3C2A:  MOVFF  2C1,2C9
3C2E:  MOVLB  0
3C30:  CALL   3412
3C34:  MOVF   01,W
3C36:  MOVFF  FEF,2B8
3C3A:  MOVFF  FEC,2B9
3C3E:  MOVFF  FEC,2BA
3C42:  MOVFF  FEC,2BB
3C46:  MOVF   00,F
3C48:  BNZ   3C70
3C4A:  MOVLB  2
3C4C:  INCF   xBC,W
3C4E:  SUBWF  xBF,W
3C50:  BTFSS  FD8.2
3C52:  BRA    3C58
3C54:  MOVLB  0
3C56:  BRA    3C70
3C58:  MOVF   xBD,W
3C5A:  BZ    3C76
3C5C:  ANDLW  0F
3C5E:  SUBWF  xBF,W
3C60:  BZ    3C64
3C62:  BC    3CDC
3C64:  BTFSC  xBD.7
3C66:  BRA    3CDC
3C68:  BTFSC  xBD.6
3C6A:  BRA    3C76
3C6C:  MOVLW  20
3C6E:  BRA    3CD2
3C70:  MOVLW  20
3C72:  MOVLB  2
3C74:  ANDWF  xBD,F
3C76:  BTFSS  xBD.5
3C78:  BRA    3C94
3C7A:  BCF    xBD.5
3C7C:  MOVF   xBC,W
3C7E:  BTFSS  FD8.2
3C80:  DECF   xBD,F
3C82:  MOVF   00,W
3C84:  MOVWF  xBD
3C86:  MOVLW  2D
3C88:  BTFSS  F9E.4
3C8A:  BRA    3C88
3C8C:  MOVWF  FAD
3C8E:  MOVF   xBD,W
3C90:  MOVWF  00
3C92:  CLRF   xBD
3C94:  MOVF   xBC,W
3C96:  SUBWF  xBF,W
3C98:  BNZ   3CB0
3C9A:  MOVF   00,W
3C9C:  MOVWF  xBD
3C9E:  MOVLW  2E
3CA0:  BTFSS  F9E.4
3CA2:  BRA    3CA0
3CA4:  MOVWF  FAD
3CA6:  MOVF   xBD,W
3CA8:  MOVWF  00
3CAA:  MOVLW  20
3CAC:  ANDWF  xBD,F
3CAE:  MOVLW  00
3CB0:  MOVLW  30
3CB2:  BTFSS  xBD.5
3CB4:  BRA    3CD2
3CB6:  BCF    xBD.5
3CB8:  MOVF   xBC,W
3CBA:  BTFSS  FD8.2
3CBC:  DECF   xBD,F
3CBE:  MOVF   00,W
3CC0:  MOVWF  xBD
3CC2:  MOVLW  2D
3CC4:  BTFSS  F9E.4
3CC6:  BRA    3CC4
3CC8:  MOVWF  FAD
3CCA:  MOVF   xBD,W
3CCC:  MOVWF  00
3CCE:  CLRF   xBD
3CD0:  MOVLW  30
3CD2:  ADDWF  00,F
3CD4:  MOVF   00,W
3CD6:  BTFSS  F9E.4
3CD8:  BRA    3CD6
3CDA:  MOVWF  FAD
3CDC:  MOVFF  2C4,2C8
3CE0:  MOVFF  2C3,2C7
3CE4:  MOVFF  2C2,2C6
3CE8:  MOVFF  2C1,2C5
3CEC:  CLRF   xCC
3CEE:  CLRF   xCB
3CF0:  CLRF   xCA
3CF2:  MOVLW  0A
3CF4:  MOVWF  xC9
3CF6:  MOVLB  0
3CF8:  CALL   3412
3CFC:  MOVFF  03,2C4
3D00:  MOVFF  02,2C3
3D04:  MOVFF  01,2C2
3D08:  MOVFF  00,2C1
3D0C:  MOVLB  2
3D0E:  DECFSZ xBF,F
3D10:  BRA    3C0E
3D12:  MOVLB  0
3D14:  RETLW  00
3D16:  MOVFF  FEA,2B2
3D1A:  MOVFF  FE9,2B1
3D1E:  MOVLB  2
3D20:  SWAPF  xAB,W
3D22:  IORLW  F0
3D24:  MOVWF  xAD
3D26:  ADDWF  xAD,F
3D28:  ADDLW  E2
3D2A:  MOVWF  xAE
3D2C:  ADDLW  32
3D2E:  MOVWF  xB0
3D30:  MOVF   xAB,W
3D32:  ANDLW  0F
3D34:  ADDWF  xAE,F
3D36:  ADDWF  xAE,F
3D38:  ADDWF  xB0,F
3D3A:  ADDLW  E9
3D3C:  MOVWF  xAF
3D3E:  ADDWF  xAF,F
3D40:  ADDWF  xAF,F
3D42:  SWAPF  xAA,W
3D44:  ANDLW  0F
3D46:  ADDWF  xAF,F
3D48:  ADDWF  xB0,F
3D4A:  RLCF   xAF,F
3D4C:  RLCF   xB0,F
3D4E:  COMF   xB0,F
3D50:  RLCF   xB0,F
3D52:  MOVF   xAA,W
3D54:  ANDLW  0F
3D56:  ADDWF  xB0,F
3D58:  RLCF   xAD,F
3D5A:  MOVLW  07
3D5C:  MOVWF  xAC
3D5E:  MOVLW  0A
3D60:  DECF   xAF,F
3D62:  ADDWF  xB0,F
3D64:  BNC   3D60
3D66:  DECF   xAE,F
3D68:  ADDWF  xAF,F
3D6A:  BNC   3D66
3D6C:  DECF   xAD,F
3D6E:  ADDWF  xAE,F
3D70:  BNC   3D6C
3D72:  DECF   xAC,F
3D74:  ADDWF  xAD,F
3D76:  BNC   3D72
3D78:  MOVLW  02
3D7A:  MOVWF  FEA
3D7C:  MOVLW  AC
3D7E:  MOVWF  FE9
3D80:  MOVLW  07
3D82:  ANDWF  xB1,W
3D84:  BCF    xB1.6
3D86:  ADDWF  FE9,F
3D88:  MOVLW  B0
3D8A:  SUBWF  FE9,W
3D8C:  BTFSC  FD8.2
3D8E:  BSF    xB1.6
3D90:  MOVF   FEF,W
3D92:  MOVWF  00
3D94:  BNZ   3DA6
3D96:  BTFSC  xB1.6
3D98:  BRA    3DA6
3D9A:  BTFSC  xB1.4
3D9C:  BRA    3DB6
3D9E:  BTFSC  xB1.3
3DA0:  BRA    3DA6
3DA2:  MOVLW  20
3DA4:  BRA    3DAC
3DA6:  BSF    xB1.3
3DA8:  BCF    xB1.4
3DAA:  MOVLW  30
3DAC:  ADDWF  00,F
3DAE:  MOVF   00,W
3DB0:  BTFSS  F9E.4
3DB2:  BRA    3DB0
3DB4:  MOVWF  FAD
3DB6:  MOVF   FEE,W
3DB8:  BTFSS  xB1.6
3DBA:  BRA    3D88
3DBC:  MOVLB  0
3DBE:  RETLW  00
*
5958:  MOVFF  FF2,0E
595C:  BCF    FF2.7
595E:  ADDWF  FE8,W
5960:  ADDLW  7D
5962:  MOVWF  FF6
5964:  MOVLW  59
5966:  MOVWF  FF7
5968:  BTFSC  FD8.0
596A:  INCF   FF7,F
596C:  TBLRD*-
596E:  MOVF   FF5,W
5970:  MOVWF  FFA
5972:  TBLRD*
5974:  MOVF   FF5,W
5976:  BTFSC  0E.7
5978:  BSF    FF2.7
597A:  MOVWF  FF9
597C:  DATA E6,4B
597E:  DATA 08,4C
5980:  DATA CE,4C
5982:  DATA 80,4D
*
5BA4:  MOVF   01,W
5BA6:  MOVFF  96,2AC
5BAA:  MOVLW  64
5BAC:  MOVLB  2
5BAE:  MOVWF  xAD
5BB0:  MOVLB  0
5BB2:  CALL   36BA
5BB6:  MOVFF  00,96
5BBA:  MOVF   01,W
5BBC:  MOVLW  30
5BBE:  BNZ   5BCE
5BC0:  BTFSS  x97.1
5BC2:  BRA    5BDE
5BC4:  BTFSC  x97.3
5BC6:  BRA    5BDE
5BC8:  BTFSC  x97.4
5BCA:  MOVLW  20
5BCC:  BRA    5BD4
5BCE:  BCF    x97.3
5BD0:  BCF    x97.4
5BD2:  BSF    x97.0
5BD4:  ADDWF  01,F
5BD6:  MOVFF  01,A7
5BDA:  CALL   13C0
5BDE:  MOVFF  96,2AC
5BE2:  MOVLW  0A
5BE4:  MOVLB  2
5BE6:  MOVWF  xAD
5BE8:  MOVLB  0
5BEA:  CALL   36BA
5BEE:  MOVFF  00,96
5BF2:  MOVF   01,W
5BF4:  MOVLW  30
5BF6:  BNZ   5C04
5BF8:  BTFSC  x97.3
5BFA:  BRA    5C0E
5BFC:  BTFSS  x97.0
5BFE:  BRA    5C0E
5C00:  BTFSC  x97.4
5C02:  MOVLW  20
5C04:  ADDWF  01,F
5C06:  MOVFF  01,A7
5C0A:  CALL   13C0
5C0E:  MOVLW  30
5C10:  ADDWF  x96,F
5C12:  MOVFF  96,A7
5C16:  CALL   13C0
5C1A:  RETLW  00
....................                   //fijamos que el valor leído esté representado con 8 bits 
....................                   //(es decir de 00 a FF). 
....................                   //Para cambiar el rango de salida usamos: ADC=10 (000 a 3FF) 
....................                   //                                      ó ADC=16 (0000 a FFC0) 
.................... #list 
....................  
.................... #include "proyecto1.h" 
.................... //****************************************** 
.................... //Archivo de cabecera del Proyecto 1 
.................... //****************************************** 
.................... //Author: Julio Navarro Lara         2010 
....................  
.................... //Definimos los puertos del microcontrolador 
.................... #byte port_a = 0xF80 
.................... #byte port_b = 0xF81 
.................... #byte port_c = 0xF82 
.................... #byte port_d = 0xF83 
.................... #byte port_e = 0xF84 
....................  
.................... #bit sistema_encendido = 0xF83.4    //Pin que indica el encendido del sistema con un valor alto 
.................... #bit caldera_encendida = 0xF83.5    //Pin que indica el encendido de la caldera con un valor alto 
.................... #bit motor1 = 0xF83.6               //Pines que indican el encendido de los motores de circulación del agua con un valor alto 
.................... #bit motor2 = 0xF83.7               //El motor1 se refiere a la circulación del agua por los radiadores de la habitación 1, mientras 
....................                                     //que el motor2, a los radiadores de la habitación 2 
.................... #bit teclado1 = 0xF81.4             //Pines para gestionar la entrada del teclado 
.................... #bit teclado2 = 0xF81.5             //'' 
.................... #bit teclado3 = 0xF81.6             //'' 
.................... #bit teclado4 = 0xF81.7             //'' 
.................... #bit lcd_rs   = 0xF81.2             //Pin que controla la entrada RS de la pantalla LCD 
....................  
.................... //Parámetros de la pantalla LCD 
.................... #define LCD_ORDEN       0    //Código para enviar un orden 
.................... #define LCD_DATO        1    //Código para enviar un dato 
....................  
.................... #define LCD_CLEAR       0x01  //Orden para borrar la pantalla 
.................... #define LCD_NO_CURSOR   0x0C  //Orden para eliminar el cursor de la pantalla 
.................... #define LCD_CURSOR      0x0E  //Orden para visualizar el cursor en la pantalla 
.................... #define LCD_APAGAR      0x08  //Orden para apagar la pantalla 
....................  
.................... //Tiempo que se mantienen los mensajes temporales en pantalla (ms) 
.................... #define LCD_T_RETARDO   500 
....................  
.................... //Clave de acceso 
.................... #define clave           2401 
....................  
....................  
.................... //Parámetros del teclado 
.................... #define NUM_COLUMNAS 3     //Número de columnas del teclado matricial 
.................... #define NUM_FILAS    4     //Número de filas del teclado matricial 
.................... #define NO           100  //Codificación del NO en el método buscar_numero() 
.................... #define SI           101  //Codificación del SI en el método buscar_numero() 
....................  
.................... //Parámetros del conversor AD 
.................... #define termostato_caldera   3   //Entrada AD que se refiere a la temperatura de referencia de la caldera 
.................... #define temperatura_caldera  0   //Entrada AD que se refiere a la temperatura del agua en la caldera 
.................... #define histeresis_caldera   10   //Diferencia de histéresis para el agua de la caldera 
.................... //La histéresis es tan grande debido a que los potenciómetros incluidos en la simulación de PROTEUS no tienen 
.................... //más sensibilidad. Lo normal sería poner una histéresis de unos 5 ºC. 
.................... #define t_max_caldera        100  //Temperatura máxima a la que puede regularse la caldera 
.................... #define t_min_caldera        0  //Temperatura mínima a la que puede regularse la caldera 
.................... #define AD_num_valores       255 //Número de valores de escala del conversor (sensibilidad de los potenciómetros) 
....................  
.................... //Parámetros de control de temperatura 
.................... //Datos suministrados por el aparato de aire acondicionado (con bomba de calor) de mi casa 
.................... #define temp_max          32  //Temperatura máxima de regulación del termostato 
.................... #define temp_min          16  //Temperatura mínima de regulación del termostato 
....................  
....................  
.................... //Direcciones para la EEPROM 
.................... #define eeprom_termostato        0x10  //Valor del termostato 
.................... #define eeprom_num_intervalos    0x11  //Número de intervalos de programación de los que disponemos 
.................... #define eeprom_num_registros     0x12  //Número de registros de desconexión de los que se disponen 
.................... #define eeprom_anno_actual       0x14  //Año en el que nos encontramos 
.................... #define eeprom_anno_1_to_3       0x15  //Año en el que nos encontramos medido de 0 a 3 (llamado 1_to_3 por razones "históricas") 
.................... #define eeprom_programaciones    0x18  //Posición a partir de la cual se almacenan las programaciones de alarmas 
.................... #define eeprom_registros         0x50  //Posición a partir de la cual se almacenan los registros 
....................  
.................... #fuses HS, NOPROTECT, BROWNOUT, PUT, NOLVP, NOXINST, WDT4096, NOWDT 
.................... //El watchdog-timer salta cada 16.384 segundos, aproximadamente 
.................... #use delay(clock=8000000, restart_wdt) 
*
12A8:  CLRF   FEA
12AA:  MOVLW  B0
12AC:  MOVWF  FE9
12AE:  MOVF   FEF,W
12B0:  BZ    12D6
12B2:  MOVLW  02
12B4:  MOVWF  01
12B6:  MOVLW  BF
12B8:  MOVWF  00
12BA:  CLRWDT
12BC:  DECFSZ 00,F
12BE:  BRA    12BA
12C0:  DECFSZ 01,F
12C2:  BRA    12B6
12C4:  MOVLW  96
12C6:  MOVWF  00
12C8:  DECFSZ 00,F
12CA:  BRA    12C8
12CC:  NOP   
12CE:  NOP   
12D0:  CLRWDT
12D2:  DECFSZ FEF,F
12D4:  BRA    12B2
12D6:  RETLW  00
*
12F6:  MOVLW  09
12F8:  SUBWF  xB1,F
12FA:  BNC   1312
12FC:  CLRF   FEA
12FE:  MOVLW  B1
1300:  MOVWF  FE9
1302:  BCF    FD8.0
1304:  RRCF   FEF,F
1306:  MOVF   FEF,W
1308:  BZ    1312
130A:  BRA    130E
130C:  CLRWDT
130E:  DECFSZ FEF,F
1310:  BRA    130C
1312:  RETLW  00
.................... #use rs232(baud=4800, xmit=PIN_C6,rcv=PIN_C7) 
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  (x==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  (x<' ') 
.................... #define isprint(x)  (x>=' ') 
.................... #define isgraph(x)  (x>' ') 
.................... #define ispunct(x)  ((x>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(int *)==1 
.................... #define ptrdiff_t int 
.................... #else 
.................... #define ptrdiff_t long 
.................... #endif 
....................  
.................... #define size_t int 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: float atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... float atof(char * s); 
....................  
.................... /* Standard template: float atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... float atoe(char * s); 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int32 atoi32(char *s); 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, int8 base, char * s); 
....................  
.................... /* Standard template: signed long  atol(char * s) 
....................  * converts the initial portion of the string s to a signed long 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: float strtol(char * s,char *endptr) 
....................  * converts the initial portion of the string s to a float 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... float strtod(char *s,char *endptr); 
....................  
.................... /* Standard template: long strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr,signed int base); 
....................  
.................... /* Standard template: long strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... long strtoul(char *s,char *endptr,signed int base); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... long rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer,signed int denom); 
.................... ldiv_t ldiv(signed long numer,signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(int *)==1 
.................... #define ptrdiff_t int 
.................... #else 
.................... #define ptrdiff_t long 
.................... #endif 
....................  
.................... #define size_t int 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(int *)==1 
.................... #define ptrdiff_t int 
.................... #else 
.................... #define ptrdiff_t long 
.................... #endif 
....................  
.................... #define size_t int 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  (x==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  (x<' ') 
.................... #define isprint(x)  (x>=' ') 
.................... #define isgraph(x)  (x>' ') 
.................... #define ispunct(x)  ((x>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* compiler ignored the name 'strcpy()'; perhaps, it's reserved? 
....................    Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1*/ 
....................  
.................... char *strcopy(char *s1, char *s2) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; *s2 != 0; s++, s2++) { 
.................... 	  *s = *s2; 
....................   } 
....................   *s = *s2; 
....................   return(s1); 
.................... } 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   int n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,int c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, int c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... int *strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, int c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... int *strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
.................... 	 if (*sc2 == '\0') 
.................... 	    return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
.................... 	char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
.................... 	while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && *s == *t; ++s, ++t); 
....................  
.................... 		if (*t == '\0') 
.................... 			return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
.................... 	} 
.................... 	return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(int errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... int *strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer,signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer,signed long denom) 
.................... { 
....................    ldiv_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... float atof(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int sign = 0; 
....................    char c; 
....................    int ptr = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
....................  
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int sign = 0; 
....................    int expsign = 0; 
....................    char c; 
....................    int ptr = 0; 
....................    int i; 
....................    float exp = 1.0; 
....................    int expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
1450:  CLRF   xAD
....................    sign = 0; 
1452:  CLRF   xAB
....................    base = 10; 
1454:  MOVLW  0A
1456:  MOVWF  xAC
....................    result = 0; 
1458:  CLRF   xAA
....................  
....................    if (!s) 
145A:  MOVF   xA8,W
145C:  IORWF  xA9,W
145E:  BNZ   1466
....................       return 0; 
1460:  MOVLW  00
1462:  MOVWF  01
1464:  BRA    15E8
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
1466:  MOVF   xAD,W
1468:  INCF   xAD,F
146A:  CLRF   03
146C:  ADDWF  xA8,W
146E:  MOVWF  FE9
1470:  MOVF   xA9,W
1472:  ADDWFC 03,W
1474:  MOVWF  FEA
1476:  MOVFF  FEF,AE
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
147A:  MOVF   xAE,W
147C:  SUBLW  2D
147E:  BNZ   149A
....................    { 
....................       sign = 1;         // Set the sign to negative 
1480:  MOVLW  01
1482:  MOVWF  xAB
....................       c = s[index++]; 
1484:  MOVF   xAD,W
1486:  INCF   xAD,F
1488:  CLRF   03
148A:  ADDWF  xA8,W
148C:  MOVWF  FE9
148E:  MOVF   xA9,W
1490:  ADDWFC 03,W
1492:  MOVWF  FEA
1494:  MOVFF  FEF,AE
....................    } 
....................    else if (c == '+') 
1498:  BRA    14B4
149A:  MOVF   xAE,W
149C:  SUBLW  2B
149E:  BNZ   14B4
....................    { 
....................       c = s[index++]; 
14A0:  MOVF   xAD,W
14A2:  INCF   xAD,F
14A4:  CLRF   03
14A6:  ADDWF  xA8,W
14A8:  MOVWF  FE9
14AA:  MOVF   xA9,W
14AC:  ADDWFC 03,W
14AE:  MOVWF  FEA
14B0:  MOVFF  FEF,AE
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
14B4:  MOVF   xAE,W
14B6:  SUBLW  2F
14B8:  BTFSC  FD8.0
14BA:  BRA    15D8
14BC:  MOVF   xAE,W
14BE:  SUBLW  39
14C0:  BTFSS  FD8.0
14C2:  BRA    15D8
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
14C4:  MOVF   xAE,W
14C6:  SUBLW  30
14C8:  BNZ   150C
14CA:  CLRF   03
14CC:  MOVF   xAD,W
14CE:  ADDWF  xA8,W
14D0:  MOVWF  FE9
14D2:  MOVF   xA9,W
14D4:  ADDWFC 03,W
14D6:  MOVWF  FEA
14D8:  MOVF   FEF,W
14DA:  SUBLW  78
14DC:  BZ    14F2
14DE:  CLRF   03
14E0:  MOVF   xAD,W
14E2:  ADDWF  xA8,W
14E4:  MOVWF  FE9
14E6:  MOVF   xA9,W
14E8:  ADDWFC 03,W
14EA:  MOVWF  FEA
14EC:  MOVF   FEF,W
14EE:  SUBLW  58
14F0:  BNZ   150C
....................       { 
....................          base = 16; 
14F2:  MOVLW  10
14F4:  MOVWF  xAC
....................          index++; 
14F6:  INCF   xAD,F
....................          c = s[index++]; 
14F8:  MOVF   xAD,W
14FA:  INCF   xAD,F
14FC:  CLRF   03
14FE:  ADDWF  xA8,W
1500:  MOVWF  FE9
1502:  MOVF   xA9,W
1504:  ADDWFC 03,W
1506:  MOVWF  FEA
1508:  MOVFF  FEF,AE
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
150C:  MOVF   xAC,W
150E:  SUBLW  0A
1510:  BNZ   1548
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
1512:  MOVF   xAE,W
1514:  SUBLW  2F
1516:  BC    1546
1518:  MOVF   xAE,W
151A:  SUBLW  39
151C:  BNC   1546
....................             result = 10*result + (c - '0'); 
151E:  MOVLW  0A
1520:  MOVWF  xAF
1522:  MOVFF  AA,B0
1526:  BRA    1404
1528:  MOVLW  30
152A:  SUBWF  xAE,W
152C:  ADDWF  01,W
152E:  MOVWF  xAA
....................             c = s[index++]; 
1530:  MOVF   xAD,W
1532:  INCF   xAD,F
1534:  CLRF   03
1536:  ADDWF  xA8,W
1538:  MOVWF  FE9
153A:  MOVF   xA9,W
153C:  ADDWFC 03,W
153E:  MOVWF  FEA
1540:  MOVFF  FEF,AE
....................          } 
1544:  BRA    1512
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
1546:  BRA    15D8
1548:  MOVF   xAC,W
154A:  SUBLW  10
154C:  BNZ   15D8
....................       { 
....................          c = toupper(c); 
154E:  MOVF   xAE,W
1550:  SUBLW  60
1552:  BC    1560
1554:  MOVF   xAE,W
1556:  SUBLW  7A
1558:  BNC   1560
155A:  MOVF   xAE,W
155C:  ANDLW  DF
155E:  BRA    1562
1560:  MOVF   xAE,W
1562:  MOVWF  xAE
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
1564:  MOVF   xAE,W
1566:  SUBLW  2F
1568:  BC    1570
156A:  MOVF   xAE,W
156C:  SUBLW  39
156E:  BC    157C
1570:  MOVF   xAE,W
1572:  SUBLW  40
1574:  BC    15D8
1576:  MOVF   xAE,W
1578:  SUBLW  46
157A:  BNC   15D8
....................             if (c >= '0' && c <= '9') 
157C:  MOVF   xAE,W
157E:  SUBLW  2F
1580:  BC    159A
1582:  MOVF   xAE,W
1584:  SUBLW  39
1586:  BNC   159A
....................                result = (result << 4) + (c - '0'); 
1588:  SWAPF  xAA,W
158A:  MOVWF  xAF
158C:  MOVLW  F0
158E:  ANDWF  xAF,F
1590:  MOVLW  30
1592:  SUBWF  xAE,W
1594:  ADDWF  xAF,W
1596:  MOVWF  xAA
....................             else 
1598:  BRA    15AC
....................                result = (result << 4) + (c - 'A' + 10); 
159A:  SWAPF  xAA,W
159C:  MOVWF  xAF
159E:  MOVLW  F0
15A0:  ANDWF  xAF,F
15A2:  MOVLW  41
15A4:  SUBWF  xAE,W
15A6:  ADDLW  0A
15A8:  ADDWF  xAF,W
15AA:  MOVWF  xAA
....................  
....................             c = s[index++]; 
15AC:  MOVF   xAD,W
15AE:  INCF   xAD,F
15B0:  CLRF   03
15B2:  ADDWF  xA8,W
15B4:  MOVWF  FE9
15B6:  MOVF   xA9,W
15B8:  ADDWFC 03,W
15BA:  MOVWF  FEA
15BC:  MOVFF  FEF,AE
....................             c = toupper(c); 
15C0:  MOVF   xAE,W
15C2:  SUBLW  60
15C4:  BC    15D2
15C6:  MOVF   xAE,W
15C8:  SUBLW  7A
15CA:  BNC   15D2
15CC:  MOVF   xAE,W
15CE:  ANDLW  DF
15D0:  BRA    15D4
15D2:  MOVF   xAE,W
15D4:  MOVWF  xAE
....................          } 
15D6:  BRA    1564
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
15D8:  DECFSZ xAB,W
15DA:  BRA    15E4
15DC:  MOVF   xAC,W
15DE:  SUBLW  0A
15E0:  BNZ   15E4
....................        result = -result; 
15E2:  NEGF   xAA
....................  
....................    return(result); 
15E4:  MOVFF  AA,01
.................... } 
15E8:  RETLW  00
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... char * itoa(signed int32 num, int8 base, char *s) 
.................... { 
....................      int32 temp=1; 
....................      int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... float strtod(char *s,char *endptr) { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int sign = 0, point = 0; 
....................    char c; 
....................    int ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c=s[ptr++]; 
....................  
....................  
....................    while((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 0) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          point = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 1) { 
....................          pow10 = pow10*10; 
....................          result += (c - '0')/pow10; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '+') { 
....................          c = s[ptr++]; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................          *((char *)endptr)=s+ptr; 
....................       } 
....................       else 
....................          *((char *)endptr)=s; 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... long strtoul(char *s,char *endptr,signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-') 
....................    { 
....................       if (endptr) 
....................       { 
....................         *((char *)endptr)=s; 
....................       } 
....................       return 0; 
....................    } 
....................  
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    { 
....................       if (endptr) 
....................       { 
....................         *((char *)endptr)=s; 
....................       } 
....................       return 0; 
....................    } 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................       if (endptr) 
....................       { 
....................         *((char *)endptr)=s; 
....................       } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................         *((char *)endptr)=sc; 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr,signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    { 
....................       if (endptr) 
....................       { 
....................         *((char *)endptr)=s; 
....................       } 
....................       return 0; 
....................    } 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................       if (endptr) 
....................       { 
....................         *((char *)endptr)=s; 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................         *((char *)endptr)=sc; 
....................    return x; 
.................... } 
....................  
.................... signed int system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed = 1; 
....................  
.................... long rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned long)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... typedef signed int (*_Cmpfun)(char * p1,char * p2); 
....................  
.................... void qsort(char * qdata, int qitems, int qsize, _Cmpfun cmp) { 
....................    int m,j,i,l; 
....................    short done; 
....................    BYTE t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=TRUE; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = FALSE; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include "PCF8583.c" 
.................... // Funciones para el RTC I2c: PCF8583 
.................... // Este código no procede de CCS (no está totalmente verificado) 
.................... // Inluye funciones de conversión BCD-Binario 
.................... // y de lectura/escritura a través de I2C. 
....................  
.................... //Vamos a eliminar todos los casos en los que se habiliten las interrupciones globales 
.................... //Estas sentencias nos impedían utilizar estos métodos en las interrupciones 
....................  
.................... #ifndef PCF8583_SDA 
.................... #define PCF8583_SDA  PIN_C4 
.................... #define PCF8583_SCL  PIN_C3 
.................... #endif 
....................  
.................... #use i2c(master, sda=PCF8583_SDA, scl=PCF8583_SCL) 
*
1680:  MOVLW  08
1682:  MOVWF  01
1684:  NOP   
1686:  NOP   
1688:  NOP   
168A:  BCF    F8B.3
168C:  BCF    F94.3
168E:  NOP   
1690:  NOP   
1692:  NOP   
1694:  MOVLB  2
1696:  RLCF   xBA,F
1698:  BCF    F8B.4
169A:  BTFSC  FD8.0
169C:  BSF    F94.4
169E:  BTFSS  FD8.0
16A0:  BCF    F94.4
16A2:  BSF    F94.3
16A4:  BTFSS  F82.3
16A6:  BRA    16A4
16A8:  DECFSZ 01,F
16AA:  BRA    16AE
16AC:  BRA    16B2
16AE:  MOVLB  0
16B0:  BRA    1684
16B2:  NOP   
16B4:  NOP   
16B6:  BCF    F8B.3
16B8:  BCF    F94.3
16BA:  NOP   
16BC:  BSF    F94.4
16BE:  NOP   
16C0:  NOP   
16C2:  NOP   
16C4:  NOP   
16C6:  NOP   
16C8:  NOP   
16CA:  BSF    F94.3
16CC:  BTFSS  F82.3
16CE:  BRA    16CC
16D0:  CLRF   01
16D2:  NOP   
16D4:  NOP   
16D6:  NOP   
16D8:  BTFSC  F82.4
16DA:  BSF    01.0
16DC:  BCF    F8B.3
16DE:  BCF    F94.3
16E0:  BCF    F8B.4
16E2:  BCF    F94.4
16E4:  MOVLB  0
16E6:  RETLW  00
*
27A2:  MOVLW  08
27A4:  MOVLB  2
27A6:  MOVWF  xBB
27A8:  MOVFF  00,2BC
27AC:  BSF    F94.4
27AE:  NOP   
27B0:  NOP   
27B2:  NOP   
27B4:  BSF    F94.3
27B6:  BTFSS  F82.3
27B8:  BRA    27B6
27BA:  BTFSC  F82.4
27BC:  BSF    FD8.0
27BE:  BTFSS  F82.4
27C0:  BCF    FD8.0
27C2:  RLCF   01,F
27C4:  NOP   
27C6:  NOP   
27C8:  BCF    F94.3
27CA:  BCF    F8B.3
27CC:  DECFSZ xBB,F
27CE:  BRA    27AC
27D0:  BSF    F94.4
27D2:  NOP   
27D4:  NOP   
27D6:  NOP   
27D8:  BCF    F8B.4
27DA:  MOVF   xBC,W
27DC:  BTFSS  FD8.2
27DE:  BCF    F94.4
27E0:  NOP   
27E2:  BSF    F94.3
27E4:  BTFSS  F82.3
27E6:  BRA    27E4
27E8:  NOP   
27EA:  NOP   
27EC:  BCF    F8B.3
27EE:  BCF    F94.3
27F0:  NOP   
27F2:  NOP   
27F4:  NOP   
27F6:  BCF    F8B.4
27F8:  BCF    F94.4
27FA:  MOVLB  0
27FC:  RETLW  00
....................  
.................... #ifndef PCF8583_WRITE_ADDRESS 
.................... #define PCF8583_WRITE_ADDRESS 0xA0 
.................... #define PCF8583_READ_ADDRESS  0xA1 
.................... #endif 
....................  
.................... // Register addresses 
.................... #define PCF8583_CTRL_STATUS_REG    0x00 
.................... #define PCF8583_100S_REG           0x01 
.................... #define PCF8583_SECONDS_REG        0x02 
.................... #define PCF8583_MINUTES_REG        0x03 
.................... #define PCF8583_HOURS_REG          0x04 
.................... #define PCF8583_DATE_REG           0x05 
.................... #define PCF8583_MONTHS_REG         0x06 
.................... #define PCF8583_TIMER_REG          0x07 
....................  
.................... #define PCF8583_ALARM_CONTROL_REG  0x08 
.................... #define PCF8583_ALARM_100S_REG     0x09 
.................... #define PCF8583_ALARM_SECS_REG     0x0A 
.................... #define PCF8583_ALARM_MINS_REG     0x0B 
.................... #define PCF8583_ALARM_HOURS_REG    0x0C 
.................... #define PCF8583_ALARM_DATE_REG     0x0D 
.................... #define PCF8583_ALARM_MONTHS_REG   0x0E 
.................... #define PCF8583_ALARM_TIMER_REG    0x0F 
....................  
.................... // Use the first NVRAM address for the year byte. 
.................... #define PCF8583_YEAR_REG           0x10 
....................  
....................  
.................... // Commands for the Control/Status register. 
.................... #define PCF8583_START_COUNTING     0x00 
.................... #define PCF8583_STOP_COUNTING      0x80 
.................... #define PCF8583_ACTIVAR_ALARMA     0b00000100  //Palabra de activación de la alarma 
.................... #define PCF8583_DEFINIR_ALARMA     0b10010000  //Palabra para definir el comportamiento 
....................                                                //de la alarma en su registro 
....................  
.................... #define PCF8583_DESACTIVAR_INT     0b00010000 
....................  
....................  
.................... int8 alarma_activada=0; 
....................  
....................  
.................... char const weekday_names[7][10] = 
.................... { 
.................... {"DOM"}, 
.................... {"LUN"}, 
.................... {"MAR"}, 
.................... {"MIE"}, 
.................... {"JUE"}, 
.................... {"VIE"}, 
.................... {"SAB"} 
.................... }; 
....................  
.................... // This structure defines the user's date and time data. 
.................... // The values are stored as unsigned integers.  The user 
.................... // should declare a structure of this type in the application 
.................... // program. Then the address of the structure should be 
.................... // passed to the PCF8583 read/write functions in this 
.................... // driver, whenever you want to talk to the chip. 
.................... typedef struct 
.................... { 
.................... int8 seconds;    // 0 to 59 
.................... int8 minutes;    // 0 to 59 
.................... int8 hours;      // 0 to 23  (24-hour time) 
.................... int8 day;        // 1 to 31 
.................... int8 month;      // 1 to 12 
.................... int8 year;       // 00 to 99 
.................... int8 weekday;    // 0 = Sunday, 1 = Monday, etc. 
.................... }date_time_t; 
....................  
....................  
.................... //---------------------------------------------- 
.................... void PCF8583_write_byte(int8 address, int8 data) 
.................... { 
.................... disable_interrupts(GLOBAL); 
*
16E8:  BCF    FF2.6
16EA:  BCF    FF2.7
16EC:  BTFSC  FF2.7
16EE:  BRA    16EA
.................... i2c_start(); 
16F0:  BSF    F94.4
16F2:  NOP   
16F4:  NOP   
16F6:  BSF    F94.3
16F8:  NOP   
16FA:  NOP   
16FC:  NOP   
16FE:  BCF    F8B.4
1700:  BCF    F94.4
1702:  NOP   
1704:  NOP   
1706:  BCF    F8B.3
1708:  BCF    F94.3
.................... i2c_write(PCF8583_WRITE_ADDRESS); 
170A:  MOVLW  A0
170C:  MOVLB  2
170E:  MOVWF  xBA
1710:  MOVLB  0
1712:  RCALL  1680
.................... i2c_write(address); 
1714:  MOVFF  AE,2BA
1718:  RCALL  1680
.................... i2c_write(data); 
171A:  MOVFF  AF,2BA
171E:  RCALL  1680
.................... i2c_stop(); 
1720:  BCF    F94.4
1722:  NOP   
1724:  BSF    F94.3
1726:  BTFSS  F82.3
1728:  BRA    1726
172A:  NOP   
172C:  NOP   
172E:  NOP   
1730:  NOP   
1732:  NOP   
1734:  BSF    F94.4
1736:  NOP   
1738:  NOP   
.................... } 
173A:  RETLW  00
....................  
.................... //---------------------------------------------- 
.................... int8 PCF8583_read_byte(int8 address) 
.................... { 
.................... int8 retval; 
....................  
.................... disable_interrupts(GLOBAL); 
*
2824:  BCF    FF2.6
2826:  BCF    FF2.7
2828:  BTFSC  FF2.7
282A:  BRA    2826
.................... i2c_start(); 
282C:  BSF    F94.4
282E:  NOP   
2830:  NOP   
2832:  BSF    F94.3
2834:  NOP   
2836:  NOP   
2838:  NOP   
283A:  BCF    F8B.4
283C:  BCF    F94.4
283E:  NOP   
2840:  NOP   
2842:  BCF    F8B.3
2844:  BCF    F94.3
.................... i2c_write(PCF8583_WRITE_ADDRESS); 
2846:  MOVLW  A0
2848:  MOVLB  2
284A:  MOVWF  xBA
284C:  MOVLB  0
284E:  CALL   1680
.................... i2c_write(address); 
2852:  MOVFF  AE,2BA
2856:  CALL   1680
.................... i2c_start(); 
285A:  BSF    F94.4
285C:  NOP   
285E:  NOP   
2860:  BSF    F94.3
2862:  NOP   
2864:  NOP   
2866:  NOP   
2868:  BTFSS  F82.3
286A:  BRA    2868
286C:  BCF    F8B.4
286E:  BCF    F94.4
2870:  NOP   
2872:  NOP   
2874:  BCF    F8B.3
2876:  BCF    F94.3
.................... i2c_write(PCF8583_READ_ADDRESS); 
2878:  MOVLW  A1
287A:  MOVLB  2
287C:  MOVWF  xBA
287E:  MOVLB  0
2880:  CALL   1680
.................... retval = i2c_read(0); 
2884:  CLRF   00
2886:  RCALL  27A2
2888:  MOVFF  01,AF
.................... i2c_stop(); 
288C:  BCF    F94.4
288E:  NOP   
2890:  BSF    F94.3
2892:  BTFSS  F82.3
2894:  BRA    2892
2896:  NOP   
2898:  NOP   
289A:  NOP   
289C:  NOP   
289E:  NOP   
28A0:  BSF    F94.4
28A2:  NOP   
28A4:  NOP   
....................  
.................... return(retval); 
28A6:  MOVFF  AF,01
.................... } 
28AA:  GOTO   2A46 (RETURN)
....................  
....................  
.................... void PCF8583_init(void) 
.................... { 
.................... PCF8583_write_byte(PCF8583_CTRL_STATUS_REG, 
....................                               PCF8583_START_COUNTING); 
.................... } 
....................  
.................... //---------------------------------------------- 
.................... // This function converts an 8 bit binary value 
.................... // to an 8 bit BCD value. 
.................... // The input range must be from 0 to 99. 
....................  
.................... int8 bin2bcd(int8 value) 
.................... { 
.................... char retval; 
....................  
.................... retval = 0; 
*
1660:  CLRF   xAE
....................  
.................... while(1) 
....................   { 
....................    // Get the tens digit by doing multiple subtraction 
....................    // of 10 from the binary value. 
....................    if(value >= 10) 
1662:  MOVF   xAD,W
1664:  SUBLW  09
1666:  BC    1672
....................      { 
....................       value -= 10; 
1668:  MOVLW  0A
166A:  SUBWF  xAD,F
....................       retval += 0x10; 
166C:  MOVLW  10
166E:  ADDWF  xAE,F
....................      } 
....................    else // Get the ones digit by adding the remainder. 
1670:  BRA    1678
....................      { 
....................       retval += value; 
1672:  MOVF   xAD,W
1674:  ADDWF  xAE,F
....................       break; 
1676:  BRA    167A
....................      } 
....................    } 
1678:  BRA    1662
....................  
.................... return(retval); 
167A:  MOVFF  AE,01
.................... } 
167E:  RETLW  00
....................  
.................... //---------------------------------------------- 
.................... // This function converts an 8 bit BCD value to 
.................... // an 8 bit binary value. 
.................... // The input range must be from 00 to 99. 
....................  
.................... char bcd2bin(char bcd_value) 
.................... { 
.................... char temp; 
....................  
.................... temp = bcd_value; 
*
27FE:  MOVFF  B1,B2
....................  
.................... // Shifting the upper digit right by 1 is 
.................... // the same as multiplying it by 8. 
.................... temp >>= 1; 
2802:  BCF    FD8.0
2804:  RRCF   xB2,F
....................  
.................... // Isolate the bits for the upper digit. 
.................... temp &= 0x78; 
2806:  MOVLW  78
2808:  ANDWF  xB2,F
....................  
.................... // Now return: (Tens * 8) + (Tens * 2) + Ones 
.................... return(temp + (temp >> 2) + (bcd_value & 0x0f)); 
280A:  RRCF   xB2,W
280C:  MOVWF  00
280E:  RRCF   00,F
2810:  MOVLW  3F
2812:  ANDWF  00,F
2814:  MOVF   00,W
2816:  ADDWF  xB2,W
2818:  MOVWF  xB3
281A:  MOVF   xB1,W
281C:  ANDLW  0F
281E:  ADDWF  xB3,W
2820:  MOVWF  01
....................  
.................... } 
2822:  RETLW  00
....................  
.................... //---------------------------------------------- 
.................... void PCF8583_set_datetime(date_time_t *dt) 
.................... { 
.................... int8 bcd_sec; 
.................... int8 bcd_min; 
.................... int8 bcd_hrs; 
.................... int8 bcd_day; 
.................... int8 bcd_mon; 
....................  
.................... // Convert the input date/time into BCD values 
.................... // that are formatted for the PCF8583 registers. 
.................... bcd_sec = bin2bcd(dt->seconds); 
*
173C:  MOVF   xA5,W
173E:  MOVWF  FE9
1740:  MOVFF  A6,FEA
1744:  MOVFF  FEF,AC
1748:  MOVFF  AC,AD
174C:  RCALL  1660
174E:  MOVFF  01,A7
.................... bcd_min = bin2bcd(dt->minutes); 
1752:  MOVLW  01
1754:  ADDWF  xA5,W
1756:  MOVWF  FE9
1758:  MOVLW  00
175A:  ADDWFC xA6,W
175C:  MOVWF  FEA
175E:  MOVFF  FEF,AC
1762:  MOVFF  AC,AD
1766:  RCALL  1660
1768:  MOVFF  01,A8
.................... bcd_hrs = bin2bcd(dt->hours); 
176C:  MOVLW  02
176E:  ADDWF  xA5,W
1770:  MOVWF  FE9
1772:  MOVLW  00
1774:  ADDWFC xA6,W
1776:  MOVWF  FEA
1778:  MOVFF  FEF,AC
177C:  MOVFF  AC,AD
1780:  RCALL  1660
1782:  MOVFF  01,A9
.................... bcd_day = bin2bcd(dt->day) | (dt->year << 6); 
1786:  MOVLW  03
1788:  ADDWF  xA5,W
178A:  MOVWF  FE9
178C:  MOVLW  00
178E:  ADDWFC xA6,W
1790:  MOVWF  FEA
1792:  MOVFF  FEF,AC
1796:  MOVFF  AC,AD
179A:  RCALL  1660
179C:  MOVLW  05
179E:  ADDWF  xA5,W
17A0:  MOVWF  FE9
17A2:  MOVLW  00
17A4:  ADDWFC xA6,W
17A6:  MOVWF  FEA
17A8:  SWAPF  FEF,W
17AA:  MOVWF  00
17AC:  RLCF   00,F
17AE:  RLCF   00,F
17B0:  MOVLW  C0
17B2:  ANDWF  00,F
17B4:  MOVF   00,W
17B6:  IORWF  01,W
17B8:  MOVWF  xAA
.................... bcd_mon = bin2bcd(dt->month) | (dt->weekday << 5); 
17BA:  MOVLW  04
17BC:  ADDWF  xA5,W
17BE:  MOVWF  FE9
17C0:  MOVLW  00
17C2:  ADDWFC xA6,W
17C4:  MOVWF  FEA
17C6:  MOVFF  FEF,AC
17CA:  MOVFF  AC,AD
17CE:  RCALL  1660
17D0:  MOVLW  06
17D2:  ADDWF  xA5,W
17D4:  MOVWF  FE9
17D6:  MOVLW  00
17D8:  ADDWFC xA6,W
17DA:  MOVWF  FEA
17DC:  SWAPF  FEF,W
17DE:  MOVWF  00
17E0:  RLCF   00,F
17E2:  MOVLW  E0
17E4:  ANDWF  00,F
17E6:  MOVF   00,W
17E8:  IORWF  01,W
17EA:  MOVWF  xAB
....................  
.................... // Stop the RTC from counting, before we write to 
.................... // the date and time registers. 
.................... PCF8583_write_byte(PCF8583_CTRL_STATUS_REG, 
....................                               PCF8583_STOP_COUNTING); 
17EC:  CLRF   xAE
17EE:  MOVLW  80
17F0:  MOVWF  xAF
17F2:  RCALL  16E8
....................  
.................... // Write to the date and time registers.  Disable interrupts 
.................... // so they can't disrupt the i2c operations. 
.................... disable_interrupts(GLOBAL); 
17F4:  BCF    FF2.6
17F6:  BCF    FF2.7
17F8:  BTFSC  FF2.7
17FA:  BRA    17F6
.................... i2c_start(); 
17FC:  BSF    F94.4
17FE:  NOP   
1800:  NOP   
1802:  BSF    F94.3
1804:  NOP   
1806:  NOP   
1808:  NOP   
180A:  BCF    F8B.4
180C:  BCF    F94.4
180E:  NOP   
1810:  NOP   
1812:  BCF    F8B.3
1814:  BCF    F94.3
.................... i2c_write(PCF8583_WRITE_ADDRESS); 
1816:  MOVLW  A0
1818:  MOVLB  2
181A:  MOVWF  xBA
181C:  MOVLB  0
181E:  RCALL  1680
.................... i2c_write(PCF8583_100S_REG);   // Start at 100's reg. 
1820:  MOVLW  01
1822:  MOVLB  2
1824:  MOVWF  xBA
1826:  MOVLB  0
1828:  RCALL  1680
.................... i2c_write(0x00);               // Set 100's reg = 0 
182A:  MOVLB  2
182C:  CLRF   xBA
182E:  MOVLB  0
1830:  RCALL  1680
.................... i2c_write(bcd_sec); 
1832:  MOVFF  A7,2BA
1836:  RCALL  1680
.................... i2c_write(bcd_min); 
1838:  MOVFF  A8,2BA
183C:  RCALL  1680
.................... i2c_write(bcd_hrs); 
183E:  MOVFF  A9,2BA
1842:  RCALL  1680
.................... i2c_write(bcd_day); 
1844:  MOVFF  AA,2BA
1848:  RCALL  1680
.................... i2c_write(bcd_mon); 
184A:  MOVFF  AB,2BA
184E:  RCALL  1680
.................... i2c_stop(); 
1850:  BCF    F94.4
1852:  NOP   
1854:  BSF    F94.3
1856:  BTFSS  F82.3
1858:  BRA    1856
185A:  NOP   
185C:  NOP   
185E:  NOP   
1860:  NOP   
1862:  NOP   
1864:  BSF    F94.4
1866:  NOP   
1868:  NOP   
....................  
.................... // Write the year byte to the first NVRAM location. 
.................... // Leave it in binary format. 
.................... PCF8583_write_byte(PCF8583_YEAR_REG, dt->year); 
186A:  MOVLW  05
186C:  ADDWF  xA5,W
186E:  MOVWF  FE9
1870:  MOVLW  00
1872:  ADDWFC xA6,W
1874:  MOVWF  FEA
1876:  MOVFF  FEF,AC
187A:  MOVLW  10
187C:  MOVWF  xAE
187E:  MOVFF  AC,AF
1882:  RCALL  16E8
....................  
.................... // Now allow the PCF8583 to start counting again. 
.................... PCF8583_write_byte(PCF8583_CTRL_STATUS_REG, 
....................                               PCF8583_START_COUNTING); 
1884:  CLRF   xAE
1886:  CLRF   xAF
1888:  RCALL  16E8
.................... } 
188A:  GOTO   1DEE (RETURN)
....................  
.................... //---------------------------------------------- 
.................... // Read the Date and Time from the hardware registers 
.................... // in the PCF8583.   We don't have to disable counting 
.................... // during read operations, because according to the data 
.................... // sheet, if any of the lower registers (1 to 7) is read, 
.................... // all of them are loaded into "capture" registers. 
.................... // All further reading within that cycle is done from 
.................... // those registers. 
....................  
.................... void PCF8583_read_datetime(date_time_t *dt) 
.................... { 
.................... int8 year_bits; 
.................... int8 year; 
....................  
.................... int8 bcd_sec; 
.................... int8 bcd_min; 
.................... int8 bcd_hrs; 
.................... int8 bcd_day; 
.................... int8 bcd_mon; 
....................  
.................... // Disable interrupts so the i2c process is not disrupted. 
.................... disable_interrupts(GLOBAL); 
*
28AE:  BCF    FF2.6
28B0:  BCF    FF2.7
28B2:  BTFSC  FF2.7
28B4:  BRA    28B0
....................  
.................... // Read the date/time registers inside the PCF8583. 
.................... i2c_start(); 
28B6:  BSF    F94.4
28B8:  NOP   
28BA:  NOP   
28BC:  BSF    F94.3
28BE:  NOP   
28C0:  NOP   
28C2:  NOP   
28C4:  BCF    F8B.4
28C6:  BCF    F94.4
28C8:  NOP   
28CA:  NOP   
28CC:  BCF    F8B.3
28CE:  BCF    F94.3
.................... i2c_write(PCF8583_WRITE_ADDRESS); 
28D0:  MOVLW  A0
28D2:  MOVLB  2
28D4:  MOVWF  xBA
28D6:  MOVLB  0
28D8:  CALL   1680
.................... i2c_write(PCF8583_SECONDS_REG);   // Start at seconds reg. 
28DC:  MOVLW  02
28DE:  MOVLB  2
28E0:  MOVWF  xBA
28E2:  MOVLB  0
28E4:  CALL   1680
.................... i2c_start(); 
28E8:  BSF    F94.4
28EA:  NOP   
28EC:  NOP   
28EE:  BSF    F94.3
28F0:  NOP   
28F2:  NOP   
28F4:  NOP   
28F6:  BTFSS  F82.3
28F8:  BRA    28F6
28FA:  BCF    F8B.4
28FC:  BCF    F94.4
28FE:  NOP   
2900:  NOP   
2902:  BCF    F8B.3
2904:  BCF    F94.3
.................... i2c_write(PCF8583_READ_ADDRESS); 
2906:  MOVLW  A1
2908:  MOVLB  2
290A:  MOVWF  xBA
290C:  MOVLB  0
290E:  CALL   1680
....................  
.................... bcd_sec = i2c_read(); 
2912:  MOVLW  01
2914:  MOVWF  00
2916:  RCALL  27A2
2918:  MOVFF  01,A9
.................... bcd_min = i2c_read(); 
291C:  MOVLW  01
291E:  MOVWF  00
2920:  RCALL  27A2
2922:  MOVFF  01,AA
.................... bcd_hrs = i2c_read(); 
2926:  MOVLW  01
2928:  MOVWF  00
292A:  RCALL  27A2
292C:  MOVFF  01,AB
.................... bcd_day = i2c_read(); 
2930:  MOVLW  01
2932:  MOVWF  00
2934:  RCALL  27A2
2936:  MOVFF  01,AC
.................... bcd_mon = i2c_read(0); 
293A:  CLRF   00
293C:  RCALL  27A2
293E:  MOVFF  01,AD
.................... i2c_stop(); 
2942:  BCF    F94.4
2944:  NOP   
2946:  BSF    F94.3
2948:  BTFSS  F82.3
294A:  BRA    2948
294C:  NOP   
294E:  NOP   
2950:  NOP   
2952:  NOP   
2954:  NOP   
2956:  BSF    F94.4
2958:  NOP   
295A:  NOP   
....................  
....................  
.................... // Convert the date/time values from BCD to 
.................... // unsigned 8-bit integers.  Unpack the bits 
.................... // in the PCF8583 registers where required. 
.................... dt->seconds = bcd2bin(bcd_sec); 
295C:  MOVFF  A5,01
2960:  MOVFF  A6,03
2964:  MOVFF  A5,AE
2968:  MOVFF  A6,AF
296C:  MOVFF  A9,B1
2970:  RCALL  27FE
2972:  MOVFF  AF,FEA
2976:  MOVFF  AE,FE9
297A:  MOVFF  01,FEF
.................... dt->minutes = bcd2bin(bcd_min); 
297E:  MOVLW  01
2980:  ADDWF  xA5,W
2982:  MOVWF  01
2984:  MOVLW  00
2986:  ADDWFC xA6,W
2988:  MOVWF  03
298A:  MOVFF  01,AE
298E:  MOVWF  xAF
2990:  MOVFF  AA,B1
2994:  RCALL  27FE
2996:  MOVFF  AF,FEA
299A:  MOVFF  AE,FE9
299E:  MOVFF  01,FEF
.................... dt->hours   = bcd2bin(bcd_hrs & 0x3F); 
29A2:  MOVLW  02
29A4:  ADDWF  xA5,W
29A6:  MOVWF  01
29A8:  MOVLW  00
29AA:  ADDWFC xA6,W
29AC:  MOVWF  03
29AE:  MOVFF  01,AE
29B2:  MOVWF  xAF
29B4:  MOVF   xAB,W
29B6:  ANDLW  3F
29B8:  MOVWF  xB0
29BA:  MOVWF  xB1
29BC:  RCALL  27FE
29BE:  MOVFF  AF,FEA
29C2:  MOVFF  AE,FE9
29C6:  MOVFF  01,FEF
.................... dt->day     = bcd2bin(bcd_day & 0x3F); 
29CA:  MOVLW  03
29CC:  ADDWF  xA5,W
29CE:  MOVWF  01
29D0:  MOVLW  00
29D2:  ADDWFC xA6,W
29D4:  MOVWF  03
29D6:  MOVFF  01,AE
29DA:  MOVWF  xAF
29DC:  MOVF   xAC,W
29DE:  ANDLW  3F
29E0:  MOVWF  xB0
29E2:  MOVWF  xB1
29E4:  RCALL  27FE
29E6:  MOVFF  AF,FEA
29EA:  MOVFF  AE,FE9
29EE:  MOVFF  01,FEF
.................... dt->month   = bcd2bin(bcd_mon & 0x1F); 
29F2:  MOVLW  04
29F4:  ADDWF  xA5,W
29F6:  MOVWF  01
29F8:  MOVLW  00
29FA:  ADDWFC xA6,W
29FC:  MOVWF  03
29FE:  MOVFF  01,AE
2A02:  MOVWF  xAF
2A04:  MOVF   xAD,W
2A06:  ANDLW  1F
2A08:  MOVWF  xB0
2A0A:  MOVWF  xB1
2A0C:  RCALL  27FE
2A0E:  MOVFF  AF,FEA
2A12:  MOVFF  AE,FE9
2A16:  MOVFF  01,FEF
.................... dt->weekday = bcd_mon >> 5; 
2A1A:  MOVLW  06
2A1C:  ADDWF  xA5,W
2A1E:  MOVWF  FE9
2A20:  MOVLW  00
2A22:  ADDWFC xA6,W
2A24:  MOVWF  FEA
2A26:  SWAPF  xAD,W
2A28:  MOVWF  00
2A2A:  RRCF   00,F
2A2C:  MOVLW  07
2A2E:  ANDWF  00,F
2A30:  MOVFF  00,FEF
.................... year_bits   = bcd_day >> 6; 
2A34:  SWAPF  xAC,W
2A36:  MOVWF  xA7
2A38:  RRCF   xA7,F
2A3A:  RRCF   xA7,F
2A3C:  MOVLW  03
2A3E:  ANDWF  xA7,F
....................  
.................... // Read the year byte from NVRAM. 
.................... // This is an added feature of this driver. 
.................... year = PCF8583_read_byte(PCF8583_YEAR_REG); 
2A40:  MOVLW  10
2A42:  MOVWF  xAE
2A44:  BRA    2824
2A46:  MOVFF  01,A8
....................  
.................... // Check if the two "year bits" were incremented by 
.................... // the PCF8583.  If so, increment the 8-bit year 
.................... // byte (read from NVRAM) by the same amount. 
.................... while(year_bits != (year & 3)) 
....................       year++; 
2A4A:  MOVF   xA8,W
2A4C:  ANDLW  03
2A4E:  SUBWF  xA7,W
2A50:  BZ    2A56
2A52:  INCF   xA8,F
2A54:  BRA    2A4A
....................  
.................... dt->year = year; 
2A56:  MOVLW  05
2A58:  ADDWF  xA5,W
2A5A:  MOVWF  FE9
2A5C:  MOVLW  00
2A5E:  ADDWFC xA6,W
2A60:  MOVWF  FEA
2A62:  MOVFF  A8,FEF
....................  
.................... // Now update the year byte in the NVRAM 
.................... // inside the PCF8583. 
.................... PCF8583_write_byte(PCF8583_YEAR_REG, year); 
2A66:  MOVLW  10
2A68:  MOVWF  xAE
2A6A:  MOVFF  A8,AF
2A6E:  CALL   16E8
....................  
.................... } 
2A72:  RETLW  00
....................  
.................... //Método que permite establecer una alarma, dados horas, minutos y segundos 
.................... //Author: Julio Navarro Lara 
.................... void PCF8583_establecer_alarma(int8 horas, int8 minutos, int8 segundos){ 
....................    int8 bcd_horas; 
....................    int8 bcd_minutos; 
....................    int8 bcd_segundos; 
....................  
....................    //Transformamos a BCD las horas y los minutos introducidos 
....................    bcd_horas = bin2bcd(horas); 
*
2A9C:  MOVFF  97,AD
2AA0:  CALL   1660
2AA4:  MOVFF  01,9A
....................    bcd_minutos = bin2bcd(minutos); 
2AA8:  MOVFF  98,AD
2AAC:  CALL   1660
2AB0:  MOVFF  01,9B
....................    bcd_segundos = bin2bcd(segundos); 
2AB4:  MOVFF  99,AD
2AB8:  CALL   1660
2ABC:  MOVFF  01,9C
....................  
....................    //Paramos de contar el tiempo para escribir los datos 
....................    PCF8583_write_byte(PCF8583_CTRL_STATUS_REG, 
....................                               PCF8583_STOP_COUNTING); 
2AC0:  CLRF   xAE
2AC2:  MOVLW  80
2AC4:  MOVWF  xAF
2AC6:  CALL   16E8
....................  
....................    //Definimos las condiciones de la alarma 
....................    PCF8583_write_byte(PCF8583_ALARM_CONTROL_REG, 
....................                               PCF8583_DEFINIR_ALARMA); 
2ACA:  MOVLW  08
2ACC:  MOVWF  xAE
2ACE:  MOVLW  90
2AD0:  MOVWF  xAF
2AD2:  CALL   16E8
....................  
....................    //Desactivamos las interrupciones para que no interfieran en la escritura i2c 
....................    disable_interrupts(GLOBAL); 
2AD6:  BCF    FF2.6
2AD8:  BCF    FF2.7
2ADA:  BTFSC  FF2.7
2ADC:  BRA    2AD8
....................    i2c_start(); 
2ADE:  BSF    F94.4
2AE0:  NOP   
2AE2:  NOP   
2AE4:  BSF    F94.3
2AE6:  NOP   
2AE8:  NOP   
2AEA:  NOP   
2AEC:  BCF    F8B.4
2AEE:  BCF    F94.4
2AF0:  NOP   
2AF2:  NOP   
2AF4:  BCF    F8B.3
2AF6:  BCF    F94.3
....................    i2c_write(PCF8583_WRITE_ADDRESS); 
2AF8:  MOVLW  A0
2AFA:  MOVLB  2
2AFC:  MOVWF  xBA
2AFE:  MOVLB  0
2B00:  CALL   1680
....................    //Escribimos en los registros de hora y minutos 
....................    i2c_write(PCF8583_ALARM_100S_REG); 
2B04:  MOVLW  09
2B06:  MOVLB  2
2B08:  MOVWF  xBA
2B0A:  MOVLB  0
2B0C:  CALL   1680
....................    i2c_write(0x00); 
2B10:  MOVLB  2
2B12:  CLRF   xBA
2B14:  MOVLB  0
2B16:  CALL   1680
....................    i2c_write(bcd_segundos); 
2B1A:  MOVFF  9C,2BA
2B1E:  CALL   1680
....................    i2c_write(bcd_minutos); 
2B22:  MOVFF  9B,2BA
2B26:  CALL   1680
....................    i2c_write(bcd_horas); 
2B2A:  MOVFF  9A,2BA
2B2E:  CALL   1680
....................    i2c_stop(); 
2B32:  BCF    F94.4
2B34:  NOP   
2B36:  BSF    F94.3
2B38:  BTFSS  F82.3
2B3A:  BRA    2B38
2B3C:  NOP   
2B3E:  NOP   
2B40:  NOP   
2B42:  NOP   
2B44:  NOP   
2B46:  BSF    F94.4
2B48:  NOP   
2B4A:  NOP   
....................  
....................    //OJO! No volvemos a activar las interrupciones por si llamamos al método 
....................    //dentro de una rutina de interrupción 
....................  
....................    //Activamos la alarma 
....................    PCF8583_write_byte(PCF8583_CTRL_STATUS_REG, 
....................                               PCF8583_ACTIVAR_ALARMA); 
2B4C:  CLRF   xAE
2B4E:  MOVLW  04
2B50:  MOVWF  xAF
2B52:  CALL   16E8
....................  
....................  
....................  
....................    //Activamos el flag indicador de alarma 
....................    alarma_activada = TRUE; 
2B56:  MOVLW  01
2B58:  MOVWF  1E
....................  
.................... } 
2B5A:  RETLW  00
....................  
.................... #include "LCDeasy.c" 
.................... ////----------------------------------------------------------------------------//// 
.................... // 	Funciones para la gestion del display LCD de la EasyPIC3 
.................... //	con el compilador de CCS. 
.................... //	Es una adaptación del archivo LCD.c de CCS para las prácticas de la 
.................... //	asignatura, y por tanto no distribuible a usuarios no autorizados. 
.................... //------------------------------------------------------------------------------//// 
....................  
.................... //  lcd_init()   Inicializa el LCD: debe ser llamada antes que las otras funciones. 
.................... // 
.................... //  lcd_putc(c)  Visualiza c en la siguiente posición del display. 
.................... //               Caracteres especiales de control: 
.................... //                      \f  Borrar display 
.................... //                      \n  Saltar a la segunda linea 
.................... //                      \b  Retroceder una posición. 
.................... // 
.................... //  lcd_gotoxy(x,y) Selecciona la nueva posicion de escritura en el display. 
.................... //                  (la esquina superior izquierda es 1,1) 
.................... // 
.................... //  lcd_getc(x,y)   Devuelve el caracter de la posicion x,y del display. 
.................... //			(esta función no va en la EASYPIC3, pues R/W=0) 
.................... // 
.................... //  lcd_send_byte(rs,byte)	escribe byte en el registro de datos(con rs=1) o de 
.................... //				instrucciones (con rs=0). 
.................... //------------------------------------------------------------------------------// 
.................... // Conexion del LCD con el PIC: 
.................... //     RB0 -- 
.................... //     RB1 -- 
.................... //     RB2  rs 
.................... //     RB3  Enable 
.................... //     RB4  D4 
.................... //     RB5  D5 
.................... //     RB6  D6 
.................... //     RB7  D7 
.................... // 
.................... // Los pines D0-D3 del LCD no se usan 
.................... // El pin RB0 del PIC no se usa 
.................... // El pin RB1 no está conectado en la tarjeta, 
.................... // podría ser para r/w 
....................  
.................... // Un-comment the following define to use port B 
.................... #define use_portb_lcd TRUE 		//LINEA DES-COMENTADA---------------- 
....................  
....................  
.................... struct lcd_pin_map {                 // This structure is overlayed 
....................            int unused : 2 ;	//MODIFICADA PARA EASYPIC-------------------- 
.................... 	   //BOOLEAN rw;		//MODIFICADA PARA EASYPIC-------------------- 
.................... 	   BOOLEAN rs;           // on to an I/O port to gain 
....................            BOOLEAN ENABLE;            // access to the LCD pins. 
....................            		           	// The bits are allocated from 
....................            			          // low order up.  ENABLE will 
....................            int     data : 4;         	// be pin B3------------------------- 
....................         } lcd; 
....................  
....................  
.................... #if defined(__PCH__) 
.................... #if defined use_portb_lcd 
....................    #byte lcd = 0xF81                   // This puts the entire structure 
.................... #else 
....................    #byte lcd = 0xF83                   // This puts the entire structure 
.................... #endif 
.................... #else 
.................... #if defined use_portb_lcd 
....................    #byte lcd = 6                  // on to port B (at address 6) 
.................... #else 
....................    #byte lcd = 8                 // on to port D (at address 8) 
.................... #endif 
.................... #endif 
....................  
.................... #if defined use_portb_lcd 
....................    #define set_tris_lcd(x) set_tris_b(x) 
.................... #else 
....................    #define set_tris_lcd(x) set_tris_d(x) 
.................... #endif 
....................  
....................  
.................... #define lcd_type 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #define lcd_line_two 0x40    // LCD RAM address for the second line 
....................  
....................  
.................... BYTE const LCD_INIT_STRING[4] = {0x24 | (lcd_type << 2), 0xF, 1, 6}; 
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................  
....................  
....................                              // The following are used for setting 
....................                              // the I/O port direction register. 
....................  
.................... struct lcd_pin_map const LCD_WRITE = {3,0,0,0}; // For write mode all pins are out 
.................... struct lcd_pin_map const LCD_READ = {3,0,0,15}; // For read mode data pins are in 
....................  
....................  
....................  
.................... BYTE lcd_read_byte() { 
....................       BYTE low,high; 
....................       set_tris_lcd(LCD_READ); 
....................       //////lcd.rw = 1; 
....................       delay_cycles(1); 
....................       lcd.enable = 1; 
....................       delay_cycles(1); 
....................       high = lcd.data; 
....................       lcd.enable = 0; 
....................       delay_cycles(1); 
....................       lcd.enable = 1; 
....................       delay_us(1); 
....................       low = lcd.data; 
....................       lcd.enable = 0; 
....................       set_tris_lcd(LCD_WRITE); 
....................       return( (high<<4) | low); 
.................... } 
....................  
....................  
.................... void lcd_send_nibble( BYTE n ) { 
....................       lcd.data = n; 
*
12D8:  SWAPF  xAF,W
12DA:  ANDLW  F0
12DC:  MOVWF  00
12DE:  MOVLW  0F
12E0:  ANDWF  F81,W
12E2:  IORWF  00,W
12E4:  MOVWF  F81
....................       delay_cycles(1); 
12E6:  NOP   
....................       lcd.enable = 1; 
12E8:  BSF    F81.3
....................       delay_us(2); 
12EA:  CLRWDT
12EC:  NOP   
12EE:  NOP   
12F0:  NOP   
....................       lcd.enable = 0; 
12F2:  BCF    F81.3
.................... } 
12F4:  RETLW  00
....................  
....................  
.................... void lcd_send_byte( BYTE address, BYTE n ) { 
....................  
....................       lcd.rs = 0; 
*
1314:  BCF    F81.2
....................       delay_us(3000); 
1316:  CLRWDT
1318:  MOVLW  02
131A:  MOVWF  xB0
131C:  RCALL  12A8
131E:  MOVLW  09
1320:  MOVWF  xAE
1322:  MOVLW  6D
1324:  MOVWF  xB1
1326:  RCALL  12F6
1328:  DECFSZ xAE,F
132A:  BRA    1322
.................... //      while ( bit_test(lcd_read_byte(),7) ) ; 
....................       lcd.rs = address; 
132C:  BTFSS  xAC.0
132E:  BCF    F81.2
1330:  BTFSC  xAC.0
1332:  BSF    F81.2
....................       delay_cycles(1); 
1334:  NOP   
....................       //////////lcd.rw = 0; 
....................       delay_cycles(1); 
1336:  NOP   
....................       lcd.enable = 0; 
1338:  BCF    F81.3
....................       lcd_send_nibble(n >> 4); 
133A:  SWAPF  xAD,W
133C:  MOVWF  xAE
133E:  MOVLW  0F
1340:  ANDWF  xAE,F
1342:  MOVFF  AE,AF
1346:  RCALL  12D8
....................       lcd_send_nibble(n & 0xf); 
1348:  MOVF   xAD,W
134A:  ANDLW  0F
134C:  MOVWF  xAE
134E:  MOVWF  xAF
1350:  RCALL  12D8
.................... } 
1352:  RETLW  00
....................  
....................  
.................... void lcd_init() { 
....................     BYTE i; 
....................     set_tris_lcd(LCD_WRITE); 
1354:  MOVLW  03
1356:  MOVWF  F93
....................     lcd.rs = 0; 
1358:  BCF    F81.2
....................     /////lcd.rw = 0; 
....................     lcd.enable = 0; 
135A:  BCF    F81.3
....................     delay_ms(50); 
135C:  MOVLW  32
135E:  MOVWF  xB0
1360:  RCALL  12A8
....................     //for(i=1;i<=3;++i) { 
....................     //   lcd_send_nibble(3); 
....................     //  delay_ms(5); 
....................     //} 
....................     lcd_send_nibble(2); 
1362:  MOVLW  02
1364:  MOVWF  xAF
1366:  RCALL  12D8
....................     delay_ms(5); 
1368:  MOVLW  05
136A:  MOVWF  xB0
136C:  RCALL  12A8
....................     for(i=0;i<=3;++i) 
136E:  CLRF   x95
1370:  MOVF   x95,W
1372:  SUBLW  03
1374:  BNC   139A
....................        { lcd_send_byte(0,LCD_INIT_STRING[i]); 
1376:  CLRF   03
1378:  MOVF   x95,W
137A:  MOVFF  FF2,96
137E:  BCF    FF2.7
1380:  CALL   00B4
1384:  BTFSC  x96.7
1386:  BSF    FF2.7
1388:  MOVWF  x97
138A:  CLRF   xAC
138C:  MOVWF  xAD
138E:  RCALL  1314
....................         delay_ms(5); } 
1390:  MOVLW  05
1392:  MOVWF  xB0
1394:  RCALL  12A8
1396:  INCF   x95,F
1398:  BRA    1370
.................... } 
139A:  GOTO   5F18 (RETURN)
....................  
....................  
.................... void lcd_gotoxy( BYTE x, BYTE y) { 
....................    BYTE address; 
....................  
....................    if(y!=1) 
139E:  DECFSZ xA9,W
13A0:  BRA    13A4
13A2:  BRA    13AA
....................      address=lcd_line_two; 
13A4:  MOVLW  40
13A6:  MOVWF  xAA
....................    else 
13A8:  BRA    13AC
....................      address=0; 
13AA:  CLRF   xAA
....................    address+=x-1; 
13AC:  MOVLW  01
13AE:  SUBWF  xA8,W
13B0:  ADDWF  xAA,F
....................    lcd_send_byte(0,0x80|address); 
13B2:  MOVF   xAA,W
13B4:  IORLW  80
13B6:  MOVWF  xAB
13B8:  CLRF   xAC
13BA:  MOVWF  xAD
13BC:  RCALL  1314
.................... } 
13BE:  RETLW  00
....................  
.................... void lcd_putc( char c) { 
....................    switch (c) { 
13C0:  MOVF   xA7,W
13C2:  XORLW  0C
13C4:  BZ    13D0
13C6:  XORLW  06
13C8:  BZ    13E0
13CA:  XORLW  02
13CC:  BZ    13EC
13CE:  BRA    13F6
....................      case '\f'   : lcd_send_byte(0,1); 
13D0:  CLRF   xAC
13D2:  MOVLW  01
13D4:  MOVWF  xAD
13D6:  RCALL  1314
....................                    delay_ms(2); 
13D8:  MOVLW  02
13DA:  MOVWF  xB0
13DC:  RCALL  12A8
....................                                            break; 
13DE:  BRA    1402
....................      case '\n'   : lcd_gotoxy(1,2);        break; 
13E0:  MOVLW  01
13E2:  MOVWF  xA8
13E4:  MOVLW  02
13E6:  MOVWF  xA9
13E8:  RCALL  139E
13EA:  BRA    1402
....................      case '\b'   : lcd_send_byte(0,0x10);  break; 
13EC:  CLRF   xAC
13EE:  MOVLW  10
13F0:  MOVWF  xAD
13F2:  RCALL  1314
13F4:  BRA    1402
....................      default     : lcd_send_byte(1,c);     break; 
13F6:  MOVLW  01
13F8:  MOVWF  xAC
13FA:  MOVFF  A7,AD
13FE:  RCALL  1314
1400:  BRA    1402
....................    } 
.................... } 
1402:  RETLW  00
....................  
.................... char lcd_getc( BYTE x, BYTE y) { 
....................    char value; 
....................  
....................     lcd_gotoxy(x,y); 
....................     while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................     lcd.rs=1; 
....................     value = lcd_read_byte(); 
....................     lcd.rs=0; 
....................     return(value); 
.................... } 
....................  
.................... #include "1wire.c" 
.................... /***********************1Wire Class***********************/ 
.................... /*Funciones básicas para comunicación con un solo sensor 1wire */ 
.................... /*********************************************************/ 
.................... /*-------1-wire definitions-------*/ 
....................  
.................... #define ONE_WIRE_PIN PIN_A5 //modificar de acuerdo con la tarjeta 
....................  
....................  
.................... /************onewire_reset*************************************************/ 
.................... void onewire_reset()  // OK if just using a single permanently connected device 
.................... { 
....................  output_low(ONE_WIRE_PIN); 
*
1EB4:  BCF    F92.5
1EB6:  BCF    F89.5
....................  delay_us( 500 ); // pull 1-wire low for reset pulse 
1EB8:  CLRWDT
1EBA:  MOVLW  02
1EBC:  MOVWF  xB0
1EBE:  MOVLW  F7
1EC0:  MOVWF  xB1
1EC2:  CALL   12F6
1EC6:  DECFSZ xB0,F
1EC8:  BRA    1EBE
....................  output_float(ONE_WIRE_PIN); // float 1-wire high 
1ECA:  BSF    F92.5
....................  delay_us( 500 ); // wait-out remaining initialisation window. 
1ECC:  CLRWDT
1ECE:  MOVLW  02
1ED0:  MOVWF  xB0
1ED2:  MOVLW  F7
1ED4:  MOVWF  xB1
1ED6:  CALL   12F6
1EDA:  DECFSZ xB0,F
1EDC:  BRA    1ED2
....................  output_float(ONE_WIRE_PIN); 
1EDE:  BSF    F92.5
.................... } 
1EE0:  RETLW  00
....................  
.................... /*********************** onewire_write() ********************************/ 
.................... /*Esta función escribe un byte en el sensor.*/ 
.................... /* */ 
.................... /*Parametros: byte - el byte a escribir en el 1wire */ 
....................  
.................... void onewire_write(int data) 
.................... { 
....................  int count; 
....................  
....................  for (count=0; count<8; ++count) 
1EE2:  CLRF   xB2
1EE4:  MOVF   xB2,W
1EE6:  SUBLW  07
1EE8:  BNC   1F1E
....................  { 
....................   output_low(ONE_WIRE_PIN); 
1EEA:  BCF    F92.5
1EEC:  BCF    F89.5
....................   delay_us( 2 ); // pull 1-wire low to initiate write time-slot. 
1EEE:  CLRWDT
1EF0:  NOP   
1EF2:  NOP   
1EF4:  NOP   
....................   output_bit(ONE_WIRE_PIN, shift_right(&data,1,0)); // set output bit on 1-wire 
1EF6:  BCF    FD8.0
1EF8:  RRCF   xB1,F
1EFA:  BC    1F00
1EFC:  BCF    F89.5
1EFE:  BRA    1F02
1F00:  BSF    F89.5
1F02:  BCF    F92.5
....................   delay_us( 60 ); // wait until end of write slot. 
1F04:  CLRWDT
1F06:  MOVLW  27
1F08:  MOVWF  00
1F0A:  DECFSZ 00,F
1F0C:  BRA    1F0A
1F0E:  NOP   
....................   output_float(ONE_WIRE_PIN); // set 1-wire high again, 
1F10:  BSF    F92.5
....................   delay_us( 2 ); // for more than 1us minimum. 
1F12:  CLRWDT
1F14:  NOP   
1F16:  NOP   
1F18:  NOP   
....................  } 
1F1A:  INCF   xB2,F
1F1C:  BRA    1EE4
.................... } 
1F1E:  RETLW  00
....................  
.................... /*********************** read1wire() *********************************/ 
.................... /*Esta función lee un dato de 8 bits del sensor.*/ 
.................... /*Devuelve: dato de 8-bit (1-byte)*/ 
....................  
.................... int onewire_read() 
.................... { 
....................  int count, data; 
....................  
....................  for (count=0; count<8; ++count) 
*
208C:  CLRF   xB0
208E:  MOVF   xB0,W
2090:  SUBLW  07
2092:  BNC   20CE
....................  { 
....................   output_low(ONE_WIRE_PIN); 
2094:  BCF    F92.5
2096:  BCF    F89.5
....................   delay_us( 2 ); // pull 1-wire low to initiate read time-slot. 
2098:  CLRWDT
209A:  NOP   
209C:  NOP   
209E:  NOP   
....................   output_float(ONE_WIRE_PIN); // now let 1-wire float high, 
20A0:  BSF    F92.5
....................   delay_us( 8 ); // let device state stabilise, 
20A2:  CLRWDT
20A4:  MOVLW  04
20A6:  MOVWF  00
20A8:  DECFSZ 00,F
20AA:  BRA    20A8
20AC:  NOP   
20AE:  NOP   
....................   shift_right(&data,1,input(ONE_WIRE_PIN)); // and load result. 
20B0:  BSF    F92.5
20B2:  BTFSC  F80.5
20B4:  BRA    20BA
20B6:  BCF    FD8.0
20B8:  BRA    20BC
20BA:  BSF    FD8.0
20BC:  RRCF   xB1,F
....................   delay_us( 120 ); // wait until end of read slot. 
20BE:  CLRWDT
20C0:  MOVLW  4F
20C2:  MOVWF  00
20C4:  DECFSZ 00,F
20C6:  BRA    20C4
20C8:  NOP   
....................  } 
20CA:  INCF   xB0,F
20CC:  BRA    208E
....................  
....................  return( data ); 
20CE:  MOVFF  B1,01
.................... } 
20D2:  RETLW  00
....................  
.................... void ow_write_bit(int1 data) 
.................... { 
....................   output_low(ONE_WIRE_PIN); 
*
1F5A:  BCF    F92.5
1F5C:  BCF    F89.5
....................   delay_us( 2 ); // pull 1-wire low to initiate write time-slot. 
1F5E:  CLRWDT
1F60:  NOP   
1F62:  NOP   
1F64:  NOP   
....................   output_bit(ONE_WIRE_PIN, data); // set output bit on 1-wire 
1F66:  MOVF   x9D,F
1F68:  BNZ   1F6E
1F6A:  BCF    F89.5
1F6C:  BRA    1F70
1F6E:  BSF    F89.5
1F70:  BCF    F92.5
....................   delay_us( 60 ); // wait until end of write slot. 
1F72:  CLRWDT
1F74:  MOVLW  27
1F76:  MOVWF  00
1F78:  DECFSZ 00,F
1F7A:  BRA    1F78
1F7C:  NOP   
....................   output_float(ONE_WIRE_PIN); // set 1-wire high again, 
1F7E:  BSF    F92.5
....................   delay_us( 2 ); // for more than 1us minimum. 
1F80:  CLRWDT
1F82:  NOP   
1F84:  NOP   
1F86:  NOP   
.................... } 
1F88:  RETLW  00
....................  
.................... int1 ow_read_bit() 
.................... { 
....................   int1 data; 
....................  
....................   output_low(ONE_WIRE_PIN); 
*
1F20:  BCF    F92.5
1F22:  BCF    F89.5
....................   delay_us( 2 ); // pull 1-wire low to initiate read time-slot. 
1F24:  CLRWDT
1F26:  NOP   
1F28:  NOP   
1F2A:  NOP   
....................   output_float(ONE_WIRE_PIN); // now let 1-wire float high, 
1F2C:  BSF    F92.5
....................   delay_us( 8 ); // let device state stabilise, 
1F2E:  CLRWDT
1F30:  MOVLW  04
1F32:  MOVWF  00
1F34:  DECFSZ 00,F
1F36:  BRA    1F34
1F38:  NOP   
1F3A:  NOP   
....................   data = input(ONE_WIRE_PIN); // and load result. 
1F3C:  BSF    F92.5
1F3E:  BCF    x9D.0
1F40:  BTFSC  F80.5
1F42:  BSF    x9D.0
....................   delay_us( 120 ); // wait until end of read slot. 
1F44:  CLRWDT
1F46:  MOVLW  4F
1F48:  MOVWF  00
1F4A:  DECFSZ 00,F
1F4C:  BRA    1F4A
1F4E:  NOP   
....................  
....................   return( data ); 
1F50:  MOVLW  00
1F52:  BTFSC  x9D.0
1F54:  MOVLW  01
1F56:  MOVWF  01
.................... } 
1F58:  RETLW  00
....................  
.................... /////////////////////////////////////////////////////////////////// 
....................  
.................... void write_bit(int1 bitval) 
.................... { 
....................    output_low(ONE_WIRE_PIN); 
....................  
....................    if(bitval == 1) { 
....................       delay_us(1);      // 1uS min. Original code relied on 8051 being slow 
....................       output_float(ONE_WIRE_PIN); 
....................    } 
....................    delay_us(105);       // Wait for end of timeslot 
....................    output_float(ONE_WIRE_PIN); 
.................... } 
....................  
.................... int8 read_bit(void) 
.................... { 
....................    output_low(ONE_WIRE_PIN); 
....................    delay_us(1);         // 1uS min. Original code relied on 8051 being slow 
....................    output_float(ONE_WIRE_PIN); 
....................    delay_us(20);        // Wait at least 15mS from start of time slot 
....................    return(input(ONE_WIRE_PIN));   // Delay to finish time slot (total 60 to 120uS) 
.................... }                       // must be done next. 
....................  
....................  
....................  
.................... #include "ds1820.c" 
....................  
.................... /***************************************************/ 
.................... /*Driver básico del termómetro/termostato ds1820.c */ 
.................... // 
.................... //Realiza una secuencia completa de incialización, conversión 
.................... //de temperatura, y lectura del (único) sensor de temperatura 
.................... //con alimentación externa (no parásita). 
.................... // 
.................... /***************************************************/ 
....................  
.................... float ds1820_read(int* dir) 
.................... { 
....................  int8 busy=0, temp1, temp2; 
*
2280:  CLRF   xA7
....................  signed int16 temp3; 
....................  float result; 
....................  
....................  onewire_reset();     // Cada acceso al sensor debe iniciarse con reset 
2282:  RCALL  1EB4
....................  onewire_write(0x55); //Instrucción MATCH ROM 
2284:  MOVLW  55
2286:  MOVWF  xB1
2288:  RCALL  1EE2
....................  //Mandamos por el one wire la dirección dir de 64 bits 
....................  onewire_write(dir[0]); 
228A:  MOVFF  A5,FE9
228E:  MOVFF  A6,FEA
2292:  MOVFF  FEF,B0
2296:  MOVFF  B0,B1
229A:  RCALL  1EE2
....................  onewire_write(dir[1]); 
229C:  MOVLW  01
229E:  ADDWF  xA5,W
22A0:  MOVWF  FE9
22A2:  MOVLW  00
22A4:  ADDWFC xA6,W
22A6:  MOVWF  FEA
22A8:  MOVFF  FEF,B0
22AC:  MOVFF  B0,B1
22B0:  RCALL  1EE2
....................  onewire_write(dir[2]); 
22B2:  MOVLW  02
22B4:  ADDWF  xA5,W
22B6:  MOVWF  FE9
22B8:  MOVLW  00
22BA:  ADDWFC xA6,W
22BC:  MOVWF  FEA
22BE:  MOVFF  FEF,B0
22C2:  MOVFF  B0,B1
22C6:  RCALL  1EE2
....................  onewire_write(dir[3]); 
22C8:  MOVLW  03
22CA:  ADDWF  xA5,W
22CC:  MOVWF  FE9
22CE:  MOVLW  00
22D0:  ADDWFC xA6,W
22D2:  MOVWF  FEA
22D4:  MOVFF  FEF,B0
22D8:  MOVFF  B0,B1
22DC:  RCALL  1EE2
....................  onewire_write(dir[4]); 
22DE:  MOVLW  04
22E0:  ADDWF  xA5,W
22E2:  MOVWF  FE9
22E4:  MOVLW  00
22E6:  ADDWFC xA6,W
22E8:  MOVWF  FEA
22EA:  MOVFF  FEF,B0
22EE:  MOVFF  B0,B1
22F2:  RCALL  1EE2
....................  onewire_write(dir[5]); 
22F4:  MOVLW  05
22F6:  ADDWF  xA5,W
22F8:  MOVWF  FE9
22FA:  MOVLW  00
22FC:  ADDWFC xA6,W
22FE:  MOVWF  FEA
2300:  MOVFF  FEF,B0
2304:  MOVFF  B0,B1
2308:  RCALL  1EE2
....................  onewire_write(dir[6]); 
230A:  MOVLW  06
230C:  ADDWF  xA5,W
230E:  MOVWF  FE9
2310:  MOVLW  00
2312:  ADDWFC xA6,W
2314:  MOVWF  FEA
2316:  MOVFF  FEF,B0
231A:  MOVFF  B0,B1
231E:  RCALL  1EE2
....................  onewire_write(dir[7]); 
2320:  MOVLW  07
2322:  ADDWF  xA5,W
2324:  MOVWF  FE9
2326:  MOVLW  00
2328:  ADDWFC xA6,W
232A:  MOVWF  FEA
232C:  MOVFF  FEF,B0
2330:  MOVFF  B0,B1
2334:  RCALL  1EE2
....................  onewire_write(0x44); //Orden de inicio de conversión de temperatura 
2336:  MOVLW  44
2338:  MOVWF  xB1
233A:  RCALL  1EE2
....................  
....................  while (busy == 0) 	//el sensor mantiene la linea a 0 mientras realiza la conversión 
....................   busy = onewire_read(); //y la deja a 1 al completarla 
233C:  MOVF   xA7,F
233E:  BNZ   2348
2340:  RCALL  208C
2342:  MOVFF  01,A7
2346:  BRA    233C
....................  
....................  onewire_reset(); 
2348:  RCALL  1EB4
....................  onewire_write(0x55); //Instrucción MATCH ROM 
234A:  MOVLW  55
234C:  MOVWF  xB1
234E:  RCALL  1EE2
....................  onewire_write(dir[0]); 
2350:  MOVFF  A5,FE9
2354:  MOVFF  A6,FEA
2358:  MOVFF  FEF,B0
235C:  MOVFF  B0,B1
2360:  RCALL  1EE2
....................  onewire_write(dir[1]); 
2362:  MOVLW  01
2364:  ADDWF  xA5,W
2366:  MOVWF  FE9
2368:  MOVLW  00
236A:  ADDWFC xA6,W
236C:  MOVWF  FEA
236E:  MOVFF  FEF,B0
2372:  MOVFF  B0,B1
2376:  RCALL  1EE2
....................  onewire_write(dir[2]); 
2378:  MOVLW  02
237A:  ADDWF  xA5,W
237C:  MOVWF  FE9
237E:  MOVLW  00
2380:  ADDWFC xA6,W
2382:  MOVWF  FEA
2384:  MOVFF  FEF,B0
2388:  MOVFF  B0,B1
238C:  RCALL  1EE2
....................  onewire_write(dir[3]); 
238E:  MOVLW  03
2390:  ADDWF  xA5,W
2392:  MOVWF  FE9
2394:  MOVLW  00
2396:  ADDWFC xA6,W
2398:  MOVWF  FEA
239A:  MOVFF  FEF,B0
239E:  MOVFF  B0,B1
23A2:  RCALL  1EE2
....................  onewire_write(dir[4]); 
23A4:  MOVLW  04
23A6:  ADDWF  xA5,W
23A8:  MOVWF  FE9
23AA:  MOVLW  00
23AC:  ADDWFC xA6,W
23AE:  MOVWF  FEA
23B0:  MOVFF  FEF,B0
23B4:  MOVFF  B0,B1
23B8:  RCALL  1EE2
....................  onewire_write(dir[5]); 
23BA:  MOVLW  05
23BC:  ADDWF  xA5,W
23BE:  MOVWF  FE9
23C0:  MOVLW  00
23C2:  ADDWFC xA6,W
23C4:  MOVWF  FEA
23C6:  MOVFF  FEF,B0
23CA:  MOVFF  B0,B1
23CE:  RCALL  1EE2
....................  onewire_write(dir[6]); 
23D0:  MOVLW  06
23D2:  ADDWF  xA5,W
23D4:  MOVWF  FE9
23D6:  MOVLW  00
23D8:  ADDWFC xA6,W
23DA:  MOVWF  FEA
23DC:  MOVFF  FEF,B0
23E0:  MOVFF  B0,B1
23E4:  RCALL  1EE2
....................  onewire_write(dir[7]); 
23E6:  MOVLW  07
23E8:  ADDWF  xA5,W
23EA:  MOVWF  FE9
23EC:  MOVLW  00
23EE:  ADDWFC xA6,W
23F0:  MOVWF  FEA
23F2:  MOVFF  FEF,B0
23F6:  MOVFF  B0,B1
23FA:  RCALL  1EE2
....................  onewire_write(0xBE); //Envío de la orden READ SCRATCHPAD (lectura de la memoria temporal) 
23FC:  MOVLW  BE
23FE:  MOVWF  xB1
2400:  RCALL  1EE2
....................  temp1 = onewire_read(); //lectura del LSB de la temperatura 
2402:  RCALL  208C
2404:  MOVFF  01,A8
....................  temp2 = onewire_read(); //lectura del MSB de la temperatura 
2408:  RCALL  208C
240A:  MOVFF  01,A9
....................  
....................  temp3 = make16(temp2, temp1); // 
240E:  MOVFF  A9,AB
2412:  MOVFF  A8,AA
....................  result = (float) temp3 / 2.0;   //Cálculo para el DS18S20 con 0.5 grad C de resolución 
2416:  MOVFF  AB,B1
241A:  MOVFF  AA,B0
241E:  BRA    20D4
2420:  MOVFF  00,B0
2424:  MOVFF  01,B1
2428:  MOVFF  02,B2
242C:  MOVFF  03,B3
2430:  MOVFF  03,2B2
2434:  MOVFF  02,2B1
2438:  MOVFF  01,2B0
243C:  MOVFF  00,2AF
2440:  MOVLB  2
2442:  CLRF   xB6
2444:  CLRF   xB5
2446:  CLRF   xB4
2448:  MOVLW  80
244A:  MOVWF  xB3
244C:  MOVLB  0
244E:  RCALL  2120
2450:  MOVFF  03,AF
2454:  MOVFF  02,AE
2458:  MOVFF  01,AD
245C:  MOVFF  00,AC
.................... // result = (float) temp3 / 16.0;  //Cálculo para el DS18B20 con 0.1 grad C de resolución 
....................  
....................  delay_ms(200); 
2460:  MOVLW  C8
2462:  MOVWF  xB0
2464:  CALL   12A8
....................  return(result); 
2468:  MOVFF  AC,00
246C:  MOVFF  AD,01
2470:  MOVFF  AE,02
2474:  MOVFF  AF,03
.................... } 
2478:  RETLW  00
....................  
.................... //Recoge las direcciones de dos dispositivos y las devuelve en los vectores de int pasados como 
.................... //argumento (cada instrucción ocupa 64 bits). Funciona también si hay más dispositivos conectados, 
.................... //pero sólo devuelve las direcciones de dos de ellos. 
.................... void ds1820_recoger_direcciones(int* dir1, int* dir2) 
.................... { 
....................    int contador, contador2; 
....................    int bit1, bit2; 
....................  
....................    onewire_reset(); 
*
1F8A:  RCALL  1EB4
....................    onewire_write(0xF0); //Función ROM SEARCH 
1F8C:  MOVLW  F0
1F8E:  MOVWF  xB1
1F90:  RCALL  1EE2
....................  
....................    //Recorremos el array de 8 ints que contiene la dirección 
....................    for(contador=0; contador<8; contador++) 
1F92:  CLRF   x99
1F94:  MOVF   x99,W
1F96:  SUBLW  07
1F98:  BNC   200A
....................    { 
....................       for(contador2=0; contador2<8; contador2++) 
1F9A:  CLRF   x9A
1F9C:  MOVF   x9A,W
1F9E:  SUBLW  07
1FA0:  BNC   2006
....................       { 
....................         //Leemos el bit correspondiente de dirección de los dispositivos 
....................         bit1 = ow_read_bit(); 
1FA2:  RCALL  1F20
1FA4:  MOVFF  01,9B
....................  
....................         //Leemos el segundo bit, que será el complemento del anterior si no hay conflictos 
....................         bit2 = ow_read_bit(); 
1FA8:  RCALL  1F20
1FAA:  MOVFF  01,9C
....................  
....................         //Si los bits son complementarios, tenemos que todos los dispositivos tienen el mismo bit de 
....................         //dirección en esa posición. 
....................         if(bit1!=bit2) 
1FAE:  MOVF   x9C,W
1FB0:  SUBWF  x9B,W
1FB2:  BZ    1FDE
....................         { 
....................            shift_right(&(dir1[contador]),1,bit1); //Guardamos el resultado 
1FB4:  CLRF   03
1FB6:  MOVF   x99,W
1FB8:  ADDWF  x95,W
1FBA:  MOVWF  x9D
1FBC:  MOVF   x96,W
1FBE:  ADDWFC 03,W
1FC0:  MOVWF  x9E
1FC2:  MOVF   x9B,F
1FC4:  BNZ   1FCA
1FC6:  BCF    FD8.0
1FC8:  BRA    1FCC
1FCA:  BSF    FD8.0
1FCC:  MOVFF  9E,FEA
1FD0:  MOVFF  9D,FE9
1FD4:  RRCF   FED,F
....................  
....................            //Escribimos el bit de dirección para confirmar a los dispositivos la identificación 
....................            ow_write_bit(bit1); 
1FD6:  MOVFF  9B,9D
1FDA:  RCALL  1F5A
....................         }else 
1FDC:  BRA    2002
....................         { 
....................            //Si no son complementarios, habrá conflicto, y habrá al menos un dispositivo con 0 en esa 
....................            //posición y al menos uno con 1. Elegimos el que tiene el 1 enviando un 1 por la línea e 
....................            //inhabilitándose los que tienen 0, que ya no contestarán a la función. 
....................            shift_right(&(dir1[contador]),1,1); 
1FDE:  CLRF   03
1FE0:  MOVF   x99,W
1FE2:  ADDWF  x95,W
1FE4:  MOVWF  x9D
1FE6:  MOVF   x96,W
1FE8:  ADDWFC 03,W
1FEA:  MOVWF  x9E
1FEC:  MOVFF  9E,FEA
1FF0:  MOVFF  9D,FE9
1FF4:  MOVLW  00
1FF6:  ADDWF  FE9,F
1FF8:  BSF    FD8.0
1FFA:  RRCF   FED,F
....................  
....................            ow_write_bit(1); 
1FFC:  MOVLW  01
1FFE:  MOVWF  x9D
2000:  RCALL  1F5A
....................         } 
....................       } 
2002:  INCF   x9A,F
2004:  BRA    1F9C
....................    } 
2006:  INCF   x99,F
2008:  BRA    1F94
....................  
....................    //Repetimos exactamente el mismo proceso pero eligiendo en los conflictos el dispositivo con 0. 
....................    onewire_reset(); 
200A:  RCALL  1EB4
....................    onewire_write(0xF0); 
200C:  MOVLW  F0
200E:  MOVWF  xB1
2010:  RCALL  1EE2
....................  
....................    for(contador=0; contador<8; contador++) 
2012:  CLRF   x99
2014:  MOVF   x99,W
2016:  SUBLW  07
2018:  BNC   2088
....................    { 
....................       for(contador2=0; contador2<8; contador2++) 
201A:  CLRF   x9A
201C:  MOVF   x9A,W
201E:  SUBLW  07
2020:  BNC   2084
....................       { 
....................         bit1 = ow_read_bit(); 
2022:  RCALL  1F20
2024:  MOVFF  01,9B
....................  
....................         bit2 = ow_read_bit(); 
2028:  RCALL  1F20
202A:  MOVFF  01,9C
....................  
....................         if(bit1!=bit2) 
202E:  MOVF   x9C,W
2030:  SUBWF  x9B,W
2032:  BZ    205E
....................         { 
....................            shift_right(&(dir2[contador]),1,bit1); 
2034:  CLRF   03
2036:  MOVF   x99,W
2038:  ADDWF  x97,W
203A:  MOVWF  x9D
203C:  MOVF   x98,W
203E:  ADDWFC 03,W
2040:  MOVWF  x9E
2042:  MOVF   x9B,F
2044:  BNZ   204A
2046:  BCF    FD8.0
2048:  BRA    204C
204A:  BSF    FD8.0
204C:  MOVFF  9E,FEA
2050:  MOVFF  9D,FE9
2054:  RRCF   FED,F
....................  
....................            ow_write_bit(bit1); 
2056:  MOVFF  9B,9D
205A:  RCALL  1F5A
....................         }else 
205C:  BRA    2080
....................         { 
....................            shift_right(&(dir2[contador]),1,0); 
205E:  CLRF   03
2060:  MOVF   x99,W
2062:  ADDWF  x97,W
2064:  MOVWF  x9D
2066:  MOVF   x98,W
2068:  ADDWFC 03,W
206A:  MOVWF  x9E
206C:  MOVFF  9E,FEA
2070:  MOVFF  9D,FE9
2074:  MOVLW  00
2076:  ADDWF  FE9,F
2078:  BCF    FD8.0
207A:  RRCF   FED,F
....................  
....................            ow_write_bit(0); 
207C:  CLRF   x9D
207E:  RCALL  1F5A
....................         } 
....................       } 
2080:  INCF   x9A,F
2082:  BRA    201C
....................    } 
2084:  INCF   x99,F
2086:  BRA    2014
....................  
.................... } 
2088:  GOTO   5F5E (RETURN)
....................  
.................... #include "teclado.c" 
.................... //*********************************************************************************** 
.................... // Método que permite gestionar un teclado matricial de 4x3 conectado a los pines 
.................... // B4B5B6B7 (filas) y a los D0D1D2 (columnas). El puerto D deberá estar definido como 
.................... // port_d y los bits utilizados de B deberán ser "tecladox", dónde x va de 1 a 4 
.................... //*********************************************************************************** 
.................... //Author: Julio Navarro Lara 
....................  
.................... //Definimos los caracteres que corresponden a cada botón del teclado 
.................... const char caracteres[12]={'1','2','3','4','5','6','7','8','9','S','0','N'}; 
....................  
.................... //Método para detectar la pulsación de una tecla. Devuelve el caracter pulsado. 
.................... char find_key() 
.................... { 
....................    //Variables auxiliares 
....................    int8 fila, columna, temp, contador, puertoB; 
....................    char key = 0; //Tecla pulsada 
*
32CC:  CLRF   x9D
....................  
....................    //Recorremos las filas forzando un valor con el puerto B para detectar 
....................    //la tecla pulsada 
....................    for(fila=0; fila < NUM_FILAS; fila++){ 
32CE:  CLRF   x98
32D0:  MOVF   x98,W
32D2:  SUBLW  03
32D4:  BTFSS  FD8.0
32D6:  BRA    33B4
....................  
....................       //Forzamos la salida de B a que tenga todo 1 menos la posición a inspeccionar 
....................       puertoB = ~(1 << fila); 
32D8:  MOVLW  01
32DA:  MOVWF  00
32DC:  MOVF   x98,W
32DE:  MOVWF  01
32E0:  BZ    32EA
32E2:  BCF    FD8.0
32E4:  RLCF   00,F
32E6:  DECFSZ 01,F
32E8:  BRA    32E2
32EA:  MOVF   00,W
32EC:  XORLW  FF
32EE:  MOVWF  x9C
....................       teclado1 = puertoB & 0b1; 
32F0:  MOVF   x9C,W
32F2:  ANDLW  01
32F4:  MOVWF  01
32F6:  BTFSC  FE8.0
32F8:  BRA    32FE
32FA:  BCF    F81.4
32FC:  BRA    3300
32FE:  BSF    F81.4
....................       teclado2 = (puertoB & 0b10) >> 1; 
3300:  MOVF   x9C,W
3302:  ANDLW  02
3304:  MOVWF  00
3306:  BCF    FD8.0
3308:  RRCF   00,F
330A:  MOVFF  00,01
330E:  BTFSC  00.0
3310:  BRA    3316
3312:  BCF    F81.5
3314:  BRA    3318
3316:  BSF    F81.5
....................       teclado3 = (puertoB & 0b100) >> 2; 
3318:  MOVF   x9C,W
331A:  ANDLW  04
331C:  MOVWF  00
331E:  RRCF   00,F
3320:  RRCF   00,F
3322:  MOVLW  3F
3324:  ANDWF  00,F
3326:  MOVFF  00,01
332A:  BTFSC  00.0
332C:  BRA    3332
332E:  BCF    F81.6
3330:  BRA    3334
3332:  BSF    F81.6
....................       teclado4 = (puertoB & 0b1000) >> 3; 
3334:  MOVF   x9C,W
3336:  ANDLW  08
3338:  MOVWF  00
333A:  RRCF   00,F
333C:  RRCF   00,F
333E:  RRCF   00,F
3340:  MOVLW  1F
3342:  ANDWF  00,F
3344:  MOVFF  00,01
3348:  BTFSC  00.0
334A:  BRA    3350
334C:  BCF    F81.7
334E:  BRA    3352
3350:  BSF    F81.7
....................  
....................       //Introducimos un poco de retraso 
....................       for(contador=0; contador<100; contador++); 
3352:  CLRF   x9B
3354:  MOVF   x9B,W
3356:  SUBLW  63
3358:  BNC   335E
335A:  INCF   x9B,F
335C:  BRA    3354
....................  
....................       //Guardamos el valor que aparece en el puerto D 
....................       //(en sus 3 bits menos significativos) 
....................       temp = port_d & 0b00000111; 
335E:  MOVF   F83,W
3360:  ANDLW  07
3362:  MOVWF  x9A
....................  
....................       //Iteramos en base a esto para ver si alguna columna está activa 
....................       //Una vez localizada la columna, podemos encontrar el caracter teniendo en cuenta 
....................       //también la fila que está activa. 
....................       for(columna=0; columna < NUM_COLUMNAS; columna++){ 
3364:  CLRF   x99
3366:  MOVF   x99,W
3368:  SUBLW  02
336A:  BNC   33B0
....................  
....................          //Realizamos la operación AND entre el valor que hay y un 1 desplazado 
....................          //según la columna que nos encontremos 
....................          if((temp & (1 << columna))==0) 
336C:  MOVLW  01
336E:  MOVWF  00
3370:  MOVF   x99,W
3372:  MOVWF  01
3374:  BZ    337E
3376:  BCF    FD8.0
3378:  RLCF   00,F
337A:  DECFSZ 01,F
337C:  BRA    3376
337E:  MOVF   00,W
3380:  ANDWF  x9A,W
3382:  BNZ   33AC
....................          { 
....................             //Si da 0, hemos localizado la columna dónde se encuentra la tecla 
....................             //Guardamos su índice teniendo en cuenta que las teclas se numeran de izquierda a derecha y 
....................             //de arriba a abajo. 
....................             int8 index; 
....................             index = (fila*NUM_COLUMNAS)+(2-columna); 
3384:  MOVF   x98,W
3386:  MULLW  03
3388:  MOVFF  FF3,9F
338C:  MOVLW  02
338E:  BSF    FD8.0
3390:  SUBFWB x99,W
3392:  ADDWF  x9F,W
3394:  MOVWF  x9E
....................  
....................             //Buscamos la tecla a la que se hace referencia 
....................             key = caracteres[index]; 
3396:  CLRF   03
3398:  MOVF   x9E,W
339A:  MOVFF  FF2,9F
339E:  BCF    FF2.7
33A0:  CALL   00D2
33A4:  BTFSC  x9F.7
33A6:  BSF    FF2.7
33A8:  MOVWF  x9D
....................  
....................             //Saltamos para salirnos del bucle 
....................             goto hecho; 
33AA:  BRA    33B4
....................  
....................          } 
....................  
....................       } 
33AC:  INCF   x99,F
33AE:  BRA    3366
....................    } 
33B0:  INCF   x98,F
33B2:  BRA    32D0
....................  
....................    hecho: 
....................  
....................    //Devolvemos el caracter 
....................    return key; 
33B4:  MOVFF  9D,01
....................  
.................... } 
33B8:  RETLW  00
....................  
.................... //Devuelve la tecla pulsada, esperando a que el usuario la suelte 
.................... char get_key() 
.................... { 
....................    char key; 
....................    //Detectamos la tecla pulsada 
....................    key=find_key(); 
33BA:  RCALL  32CC
33BC:  MOVFF  01,97
....................    //Si se pulsa alguna tecla, nos esperamos hasta que se suelte para recoger el valor 
....................    if(key) 
33C0:  MOVF   x97,F
33C2:  BZ    33CA
....................       while(find_key() != 0); 
33C4:  RCALL  32CC
33C6:  MOVF   01,F
33C8:  BNZ   33C4
....................    return key; 
33CA:  MOVFF  97,01
.................... } 
33CE:  RETLW  00
....................  
....................  
....................  
.................... #include "eeprom.c" 
.................... //****************************************************** 
.................... //Programa para escritura y lectura de la memoria EEPROM 
.................... //****************************************************** 
.................... //Author: Julio Navarro Lara 
....................  
....................  
.................... //Definimos las palabras de control, que constan de tres partes 
.................... //   - Los bits más altos de direccionamiento del dispositivo (fijos): 1010 
.................... //   - Los bits de dirección configurables A2A1A0: 111 (en este caso) 
.................... //   - El bit R/W', 1 para lectura y 0 para escritura 
.................... #define CONTROL_W 0b10101110 
.................... #define CONTROL_R 0b10101111 
....................  
.................... void graba_ee(long int dir, int tam, int *wdata) 
.................... { 
....................    boolean ack; 
....................    int i; 
....................    //Escribimos la palabra de control 
....................    do{ 
....................       i2c_start(); 
*
18E6:  BSF    F94.4
18E8:  NOP   
18EA:  NOP   
18EC:  BSF    F94.3
18EE:  NOP   
18F0:  NOP   
18F2:  NOP   
18F4:  BCF    F8B.4
18F6:  BCF    F94.4
18F8:  NOP   
18FA:  NOP   
18FC:  BCF    F8B.3
18FE:  BCF    F94.3
....................       ack=i2c_write(CONTROL_W); 
1900:  MOVLW  AE
1902:  MOVLB  2
1904:  MOVWF  xBA
1906:  MOVLB  0
1908:  RCALL  1680
190A:  MOVF   01,W
190C:  BTFSC  01.0
190E:  BRA    1914
1910:  BCF    xB0.0
1912:  BRA    1916
1914:  BSF    xB0.0
....................    }while(ack); //Esperamos a que el dispositivo responda 
1916:  BTFSC  xB0.0
1918:  BRA    18E6
....................    //Cuando está listo, devuelve un ACK como 0 
....................    //Mandamos la dirección en la que se quiere escribir 
....................    i2c_write(dir>>8); 
191A:  MOVFF  AC,B2
191E:  CLRF   xB3
1920:  MOVFF  AC,2BA
1924:  RCALL  1680
....................    i2c_write(dir & 255); 
1926:  MOVFF  AB,B2
192A:  CLRF   xB3
192C:  MOVFF  AB,2BA
1930:  RCALL  1680
....................  
....................    //Escribimos los datos contenidos en wdata 
....................    for(i=0;i<tam;i++){ 
1932:  CLRF   xB1
1934:  MOVF   xAD,W
1936:  SUBWF  xB1,W
1938:  BC    195A
....................       i2c_write(*wdata); 
193A:  MOVFF  AF,03
193E:  MOVFF  AE,FE9
1942:  MOVFF  AF,FEA
1946:  MOVFF  FEF,B2
194A:  MOVFF  B2,2BA
194E:  RCALL  1680
....................       wdata++; 
1950:  INCF   xAE,F
1952:  BTFSC  FD8.2
1954:  INCF   xAF,F
....................    } 
1956:  INCF   xB1,F
1958:  BRA    1934
....................  
....................    //Finalizamos la comunicación 
....................    i2c_stop(); 
195A:  BCF    F94.4
195C:  NOP   
195E:  BSF    F94.3
1960:  BTFSS  F82.3
1962:  BRA    1960
1964:  NOP   
1966:  NOP   
1968:  NOP   
196A:  NOP   
196C:  NOP   
196E:  BSF    F94.4
1970:  NOP   
1972:  NOP   
.................... } 
1974:  RETLW  00
....................  
.................... void lee_ee(long int dir, int tam, int8 *rdata) 
.................... { 
....................    boolean ack; 
....................    int i; 
....................    //Comenzamos escribiendo la dirección que queremos consultar 
....................    //al igual que ya hicimos con el método de escritura 
....................    do{ 
....................       i2c_start(); 
*
3A00:  BSF    F94.4
3A02:  NOP   
3A04:  NOP   
3A06:  BSF    F94.3
3A08:  NOP   
3A0A:  NOP   
3A0C:  NOP   
3A0E:  BCF    F8B.4
3A10:  BCF    F94.4
3A12:  NOP   
3A14:  NOP   
3A16:  BCF    F8B.3
3A18:  BCF    F94.3
....................       ack=i2c_write(CONTROL_W); 
3A1A:  MOVLW  AE
3A1C:  MOVLB  2
3A1E:  MOVWF  xBA
3A20:  MOVLB  0
3A22:  CALL   1680
3A26:  MOVF   01,W
3A28:  BTFSC  01.0
3A2A:  BRA    3A32
3A2C:  MOVLB  2
3A2E:  BCF    xB6.0
3A30:  BRA    3A36
3A32:  MOVLB  2
3A34:  BSF    xB6.0
....................    }while(ack); //Esperamos a que el dispositivo responda 
3A36:  BTFSS  xB6.0
3A38:  BRA    3A3E
3A3A:  MOVLB  0
3A3C:  BRA    3A00
....................    i2c_write(dir>>8); 
3A3E:  MOVFF  2B2,2B8
3A42:  CLRF   xB9
3A44:  MOVFF  2B2,2BA
3A48:  MOVLB  0
3A4A:  CALL   1680
....................    i2c_write(dir & 255); 
3A4E:  MOVLB  2
3A50:  MOVFF  2B1,2B8
3A54:  CLRF   xB9
3A56:  MOVFF  2B1,2BA
3A5A:  MOVLB  0
3A5C:  CALL   1680
....................  
....................    //Reiniciamos la comunicación para leer los datos 
....................    i2c_start(); 
3A60:  BSF    F94.4
3A62:  NOP   
3A64:  NOP   
3A66:  BSF    F94.3
3A68:  NOP   
3A6A:  NOP   
3A6C:  NOP   
3A6E:  BTFSS  F82.3
3A70:  BRA    3A6E
3A72:  BCF    F8B.4
3A74:  BCF    F94.4
3A76:  NOP   
3A78:  NOP   
3A7A:  BCF    F8B.3
3A7C:  BCF    F94.3
....................    //Escribimos palabra de control de escritura 
....................    i2c_write(CONTROL_R); 
3A7E:  MOVLW  AF
3A80:  MOVLB  2
3A82:  MOVWF  xBA
3A84:  MOVLB  0
3A86:  CALL   1680
....................  
....................    //Leemos hasta que completemos el bus 
....................    for(i=0; i<tam-1; i++){ 
3A8A:  MOVLB  2
3A8C:  CLRF   xB7
3A8E:  MOVLW  01
3A90:  SUBWF  xB3,W
3A92:  SUBWF  xB7,W
3A94:  BC    3ABC
....................       //Se responde en cada caso con ACK 
....................       //(la función i2c_read tiene su argumento al revés: 1 corresponde a 
....................       //ACK y 0 a NACK, cuando en la línea un valor bajo es ACK y uno alto, NACK) 
....................       *rdata=i2c_read(1); 
3A96:  MOVFF  2B5,03
3A9A:  MOVFF  2B4,FE9
3A9E:  MOVFF  2B5,FEA
3AA2:  MOVLW  01
3AA4:  MOVWF  00
3AA6:  MOVLB  0
3AA8:  CALL   27A2
3AAC:  MOVFF  01,FEF
....................       rdata++; 
3AB0:  MOVLB  2
3AB2:  INCF   xB4,F
3AB4:  BTFSC  FD8.2
3AB6:  INCF   xB5,F
....................    } 
3AB8:  INCF   xB7,F
3ABA:  BRA    3A8E
....................    //Debemos terminar la lectura con un NACK 
....................    *rdata=i2c_read(0); 
3ABC:  MOVFF  2B5,03
3AC0:  MOVFF  2B4,FE9
3AC4:  MOVFF  2B5,FEA
3AC8:  CLRF   00
3ACA:  MOVLB  0
3ACC:  CALL   27A2
3AD0:  MOVFF  01,FEF
....................    i2c_stop(); 
3AD4:  BCF    F94.4
3AD6:  NOP   
3AD8:  BSF    F94.3
3ADA:  BTFSS  F82.3
3ADC:  BRA    3ADA
3ADE:  NOP   
3AE0:  NOP   
3AE2:  NOP   
3AE4:  NOP   
3AE6:  NOP   
3AE8:  BSF    F94.4
3AEA:  NOP   
3AEC:  NOP   
.................... } 
3AEE:  RETLW  00
....................  
....................  
....................  
.................... #use fast_io(A) 
.................... #use fast_io(B) 
.................... #use fast_io(C) 
.................... #use fast_io(D) 
....................  
.................... int1 temperatura_caldera_superada; //Control de la histéresis en la caldera 
.................... int1 temp_habitacion_superada1;  //Control de la histéresis del ambiente 
.................... int1 temp_habitacion_superada2; 
.................... int1 encendido_por_alarma; //Indica si la última vez que se encendió fue en respuesta o no a una alarma 
.................... int1 toca_encender; //Indica si la próxima alarma es de encendido o de apagado 
.................... float termostato1; //Temperatura límite de la zona 1 de la vivienda 
.................... float termostato2; //Temperatura límite de la zona 2 de la vivienda 
.................... float termostato_provisional; //Valor de termostato provisional para cuando saltan las alarmas 
.................... float temperatura1; //Temperatura de la zona 1 de la vivienda 
.................... float temperatura2; //Temperatura de la zona 2 de la vivienda 
.................... float histeresis_vivienda = 0.5; //Intervalo de histéresis de la vivienda 
.................... char key; //Tecla a pulsar 
.................... char keys[2]; //Cadena para almacenar números como caracteres 
....................  
.................... //Estructura de un intervalo de programación 
.................... typedef struct 
.................... { 
....................    unsigned int horas_inicio;    //Hora a la que se inicia el encendido 
....................    unsigned int minutos_inicio;  // 
....................    unsigned int horas_fin;       //Hora a la que se apaga el sistema 
....................    unsigned int minutos_fin;     // 
....................    unsigned int termostato;      //Termostato vigente en ese intervalo 
.................... }programacion; 
....................  
.................... //Vector que incluye todas las programaciones horarias 
.................... //La información se distribuye en grupos de 5: hora_inicio, minutos_inicio, 
.................... //hora_fin, minutos_fin y termostato. 
.................... programacion programaciones[5]; 
....................  
.................... //Programación en curso en este momento 
.................... programacion prg; 
.................... int num_intervalos; //Número de intervalos de programación con los que contamos 
.................... int posicion_alarmas; //Variable que apunta a la posición de la próxima alarma 
....................  
.................... //Estructura para leer el tiempo del reloj 
.................... date_time_t tiempo; 
....................  
.................... //Registro de la hora en la que se enciende el sistema 
.................... int hora_encendido; 
.................... int minutos_encendido; 
....................  
.................... //Registro de la hora en la que se enciende la caldera 
.................... //Se supone que el encendido de la caldera se realiza en intervalos cortos, 
.................... //que se alcanza la temperatura deseada relativamente rápido. 
.................... int hora_caldera; 
.................... int minutos_caldera; 
.................... int segundos_caldera; 
.................... //Tiempo total de encendido de la caldera en cada intervalo de encendido del sistema 
.................... long t_total_caldera; 
....................  
.................... //Variables para el registro en memoria 
.................... unsigned long num_registros;  //Número de registros de fechas almacenados 
.................... int anno_actual;             //Año en el que estamos (de 0 a 99) 
.................... int anno_actual_0_to_3;      //Año en el que estamos (de 0 a 3) 
....................  
.................... //Flag para activar las interrupciones 
.................... int1 led_int; 
.................... int1 alarma_int; 
.................... int1 timer_int; 
....................  
.................... //Arrays para almacenar las direcciones de las ROM de ambos sensores de temperatura 
.................... int dir1[8], dir2[8]; 
....................  
.................... //Contador para medir el tiempo transcurrido con el menú activo 
.................... unsigned int contador_tiempo; 
....................  
....................  
.................... //Listado de métodos utilizados ordenados por orden alfabético 
.................... //************************************************************ 
.................... //Mostramos aquí una breve explicación de cada uno. El interior de los métodos está 
.................... //descrito después del método main. 
....................  
.................... //apagar_caldera() -> Apaga la caldera, almacenando el tiempo que ha estado encendida. 
.................... void apagar_caldera(); 
.................... //apagar_sistema() -> Realiza todas las operaciones necesarias para el apagado 
.................... //del sistema, como el almacenamiento de los datos necesarios en memoria. 
.................... void apagar_sistema(); 
.................... //buscar_numero() -> Escanea el teclado hasta encontrar un número de dos cifras o hasta que se decida salir 
.................... //mediante la pulsación de los botones de SI o NO. 
.................... int buscar_numero(); 
.................... //buscar_numero_rs232() -> Registra la introducción de un número de dos cifras mediante la interfaz RS232 y 
.................... //lo devuelve. Además, si se pulsa el "backspace" durante el proceso, devuelve el código correspondiente a NO 
.................... int buscar_numero_rs232(); 
.................... //comp_caldera() -> Devuelve TRUE si debemos apagar la caldera. Esta función tiene en cuenta 
.................... //cierta histéresis para evitar ciclos continuos de apagado-encendido. Hay que considerar 
.................... //que sólo puede emplearse una vez que la temperatura del agua ha superado ya el valor necesario. 
.................... int comp_caldera(); 
.................... //comprobar_hora(int hora1, int min1, int hora2, int min2) -> Devuelve TRUE 
.................... //si hora1:min1 corresponde a un tiempo menor o igual que hora2:min2. 
.................... int comprobar_hora(int hora1,int min1, int hora2, int min2); 
.................... //comprobar_temperatura() -> Devuelve un código según la temperatura de los dos sensores: 
.................... //0: Ninguno de los dos supera la temperatura del termostato 
.................... //1: El sensor 1 supera la temperatura del termostato 
.................... //2: El sensor 2 supera la temperatura del termostato 
.................... //3: Ambos sensores superan la temperatura del termostato 
.................... int comprobar_temperatura(); 
.................... //diferencia_tiempo(int hora1, int min1, int hora2, int min2) -> Calcula la 
.................... //diferencia de tiempo en minutos entre hora1:min1 y hora2:min2. 
.................... //Si hora1:min1 es mayor que hora2:min2, los considera en días consecutivos. 
.................... long diferencia_tiempo(int hora1,int min1, int hora2, int min2); 
.................... //diferencia_tiempo_sec(int hora1, int min1, int sec1, int hora2, int min2, int sec2) -> 
.................... //Calcula la diferencia de tiempo en segundos entre hora1:min1:sec1 y hora2:min2:sec2 
.................... //Si hora1:min1:sec1 es mayor que hora2:min2:sec2, los considera en días consecutivos 
.................... long diferencia_tiempo_sec(int hora1,int min1, int sec1, int hora2, int min2, int sec2); 
.................... //encender_caldera() -> Enciende la caldera, almacenando el tiempo de encendido en 
.................... //las variables correspondientes. 
.................... void encender_caldera(); 
.................... //encender_sistema() -> Realiza todas las operaciones necesarias para el encendido 
.................... //del sistema, como registro del tiempo de inicio. 
.................... void encender_sistema(); 
.................... //grabar_programaciones() -> Graba los datos de las programaciones en la memoria EEPROM. 
.................... void grabar_programaciones(); 
.................... //inicializacion() -> Lleva a cabo la inicialización del sistema (introducción de hora y fecha, 
.................... //puesta a punto de variables, etc) 
.................... void inicializacion(); 
.................... //leer_programaciones() -> Recupera de la memoria los datos de las programaciones. 
.................... void leer_programaciones(); 
.................... //mostrar_temperatura() -> Muestra en la pantalla LCD la temperatura actual y la hora. 
.................... void mostrar_temperatura(); 
.................... //ordenar_programaciones -> Ordena las programaciones por orden creciente de hora. 
.................... void ordenar_programaciones(); 
.................... //programar_proxima_alarma() -> Programa la próxima alarma que tendrá lugar. 
.................... //Siempre se tratará de una alarma para el encendido. 
.................... void programar_proxima_alarma(); 
.................... //representar_registros() -> Representa la información de los registros en el puerto RS232 
.................... //Nunca guardamos la información de los registros para no saturar la memoria y 
.................... //aprovechamos la representación de los datos para calcular medias y demás y así 
.................... //no tener que realizar un segundo barrido de lectura en memoria. 
.................... void representar_registros(); 
.................... //seleccionar_alarma() -> Selecciona la alarma más cercana a la hora en la que nos encontramos, 
.................... //en el caso de que las hubiese. 
.................... void seleccionar_alarma(); 
....................  
.................... //-------------------------------------------------------------------------------- 
....................  
.................... //Gestión de interrupciones de activación de la alarma 
.................... #INT_EXT 
.................... alarma(){ 
....................    //Se activa el flag correspondiente 
....................    alarma_int = TRUE; 
*
1288:  BSF    1F.6
.................... } 
....................  
.................... //Gestión de interrupciones de activación de la interfaz de usuario 
128A:  BCF    FF2.1
128C:  GOTO   0070
.................... #INT_EXT1 
.................... activacion_led(){ 
....................    //Se activa el flag correspondiente 
....................    led_int = TRUE; 
1290:  BSF    1F.5
.................... } 
....................  
.................... //Interrupción de reloj para controlar el tiempo que está activo el menú 
1292:  BCF    FF0.0
1294:  GOTO   0070
.................... #INT_TIMER1 
.................... void contador(){ 
....................    //Aumentamos en uno el valor del contador 
....................    contador_tiempo++; 
1298:  INCF   7D,F
....................    //Si llega a 76 (unos 20 segundos), activamos el flag correspondiente 
....................    if(contador_tiempo >= 76) 
129A:  MOVF   7D,W
129C:  SUBLW  4B
129E:  BC    12A2
....................       timer_int = TRUE; 
12A0:  BSF    1F.7
.................... } 
....................  
.................... //*********************************************************** 
.................... //Método main 
.................... //*********************************************************** 
12A2:  BCF    F9E.0
12A4:  GOTO   0070
.................... main() 
.................... { 
*
5EC0:  CLRF   FF8
5EC2:  BCF    FD0.7
5EC4:  BSF    0D.7
5EC6:  CLRF   FEA
5EC8:  CLRF   FE9
5ECA:  BCF    FB8.3
5ECC:  MOVLW  19
5ECE:  MOVWF  FAF
5ED0:  MOVLW  22
5ED2:  MOVWF  FAC
5ED4:  MOVLW  90
5ED6:  MOVWF  FAB
5ED8:  MOVF   FC1,W
5EDA:  ANDLW  C0
5EDC:  IORLW  0F
5EDE:  MOVWF  FC1
5EE0:  MOVLW  07
5EE2:  MOVWF  FB4
5EE4:  CLRF   18
5EE6:  CLRF   19
5EE8:  MOVLW  01
5EEA:  MOVWF  1A
5EEC:  CLRF   1B
5EEE:  CLRF   1C
5EF0:  CLRF   1D
5EF2:  CLRF   1E
5EF4:  MOVLW  7E
5EF6:  MOVWF  34
5EF8:  CLRF   35
5EFA:  CLRF   36
5EFC:  CLRF   37
....................    //Vector para recoger los datos iniciales leídos de memoria 
....................    int data[6]; 
....................  
....................    //Valor auxiliar 
....................    int valor; 
....................  
....................    //Inicializamos salidas 
....................    //Comenzamos con todo apagado (sistema, motor y caldera) 
....................    sistema_encendido = FALSE; 
5EFE:  BCF    F83.4
....................    motor1 = FALSE; 
5F00:  BCF    F83.6
....................    motor2 = FALSE; 
5F02:  BCF    F83.7
....................    caldera_encendida = FALSE; 
5F04:  BCF    F83.5
....................    encendido_por_alarma = FALSE; 
5F06:  BCF    1F.3
....................    t_total_caldera = 0; //El tiempo total de encendido de la caldera también lo ponemos a 0 
5F08:  CLRF   68
5F0A:  CLRF   67
....................  
....................    //Establecemos el estado de los puertos como entradas o salidas 
....................    set_tris_b(0x03); 
5F0C:  MOVLW  03
5F0E:  MOVWF  F93
....................    set_tris_d(0x0F); 
5F10:  MOVLW  0F
5F12:  MOVWF  F95
....................  
....................  
....................    //Inicializamos la pantalla lcd 
....................    lcd_init(); 
5F14:  GOTO   1354
....................  
....................    //Mostramos un mensaje de inicio 
....................    lcd_send_byte(LCD_ORDEN, LCD_CLEAR); 
5F18:  CLRF   xAC
5F1A:  MOVLW  01
5F1C:  MOVWF  xAD
5F1E:  CALL   1314
....................    lcd_send_byte(LCD_ORDEN, LCD_NO_CURSOR); 
5F22:  CLRF   xAC
5F24:  MOVLW  0C
5F26:  MOVWF  xAD
5F28:  CALL   1314
....................    printf(lcd_putc, "Inicializando..."); 
5F2C:  CLRF   x95
5F2E:  MOVF   x95,W
5F30:  CALL   00F8
5F34:  IORLW  00
5F36:  BZ    5F42
5F38:  INCF   x95,F
5F3A:  MOVWF  xA7
5F3C:  CALL   13C0
5F40:  BRA    5F2E
....................  
....................    /* 
....................    NOTA: En el guión se nos pide que se realice la inicialización del sistema cuando 
....................    éste se instala, introduciendo fecha y hora y reseteando los datos de memoria para 
....................    iniciar el funcionamiento. Esto lo hace en nuestro programa la funcion inicializar. 
....................    Sin embargo, se ha preferido, dado que PROTEUS actualiza su reloj con el del ordenador, 
....................    dejar inhabilitada esta rutina para así disponer de datos históricos guardados en la 
....................    EEPROM y poder analizarlos. Debido a que nuestra simulación no puede estar las 24 horas 
....................    funcionando (entre otras cosas, porque el PCF se para) es la única forma de simular 
....................    que el sistema está siempre encendido. 
....................       De todas formas, la rutina está implementada con plena operatividad. Si se quiere 
....................    inicializar el sistema como ocurriría en la vida real, simplemente descomentar las dos 
....................    líneas de código que siguen a este comentario y comentar el trozo de código que está 
....................    enmarcado por las ristras de arrobas (@), un poco más abajo. 
....................    */ 
....................  
....................  
....................    inicializacion(); 
5F42:  GOTO   1976
....................    PCF8583_write_byte(PCF8583_CTRL_STATUS_REG, PCF8583_START_COUNTING); 
5F46:  CLRF   xAE
5F48:  CLRF   xAF
5F4A:  CALL   16E8
....................  
....................  
....................    //Recogemos las direcciones de los sensores de temperatura 
....................    ds1820_recoger_direcciones(dir1, dir2); 
5F4E:  CLRF   x96
5F50:  MOVLW  6D
5F52:  MOVWF  x95
5F54:  CLRF   x98
5F56:  MOVLW  75
5F58:  MOVWF  x97
5F5A:  GOTO   1F8A
....................  
....................    //Propiedades de conversión analógico digital 
....................    //Establecemos el comparador entre A0 y A3, y entre A1 y A2 
....................    setup_comparator(A0_A3_A1_A2); 
5F5E:  MOVLW  02
5F60:  MOVWF  FB4
5F62:  MOVF   F92,W
5F64:  IORLW  0F
5F66:  MOVWF  F92
5F68:  CLRWDT
5F6A:  MOVLW  06
5F6C:  MOVWF  00
5F6E:  DECFSZ 00,F
5F70:  BRA    5F6E
5F72:  MOVF   FB4,W
5F74:  BCF    FA1.6
....................    //Caracterizamos los puertos A0 a A3 como entradas analógicas 
....................    setup_adc_ports(AN0_TO_AN3); 
5F76:  MOVF   FC1,W
5F78:  ANDLW  C0
5F7A:  IORLW  0B
5F7C:  MOVWF  FC1
....................    //Definimos el reloj de conversión 
....................    setup_adc(adc_clock_div_32); 
5F7E:  MOVF   FC0,W
5F80:  ANDLW  C0
5F82:  IORLW  02
5F84:  MOVWF  FC0
5F86:  BCF    FC0.7
5F88:  BSF    FC2.0
....................  
.................... /* 
....................    //@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ 
....................  
....................    //Recuperación de datos de la memoria 
....................    //Recuperamos a partir de la dirección eeprom_termostato los datos en 
....................    //el siguiente orden: termostato, número de intervalos de alarma, número de registros 
....................    //de encendido de la caldera, año actual en valores de 0 a 99 y año actual en valores de 0 a 3. 
....................    lee_ee(eeprom_termostato, 6, data); 
....................    termostato1 = termostato2 = (float)data[0]; 
....................    num_intervalos = data[1]; 
....................    //El número de registros está almacenado en un long y debemos realizar la conversión desde dos int 
....................    num_registros = (long)data[2]*256 + (long)data[3]; 
....................    anno_actual = data[4]; 
....................    anno_actual_0_to_3 = data[5]; 
....................  
....................    //Lee las programaciones de alarmas guardadas en memoria 
....................    leer_programaciones(); 
....................  
....................    //Comprobamos si hay alarmas programadas en memoria 
....................    if(num_intervalos!=0) 
....................    { 
....................       //Si las hay, seleccionamos la siguiente y programamos su activación 
....................       seleccionar_alarma(); 
....................       programar_proxima_alarma(); 
....................       toca_encender = TRUE; 
....................    }else 
....................    { 
....................       //Si no, simplemente inciamos la cuenta del reloj 
....................       PCF8583_write_byte(PCF8583_CTRL_STATUS_REG, 
....................                               PCF8583_START_COUNTING); 
....................    } 
....................  
....................    //@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ 
.................... */ 
....................  
....................    //Leemos la temperatura de las dos zonas de la vivienda 
....................    temperatura1 = ds1820_read(dir1); 
5F8A:  CLRF   xA6
5F8C:  MOVLW  6D
5F8E:  MOVWF  xA5
5F90:  CALL   2280
5F94:  MOVFF  03,2F
5F98:  MOVFF  02,2E
5F9C:  MOVFF  01,2D
5FA0:  MOVFF  00,2C
....................    temperatura2 = ds1820_read(dir2); 
5FA4:  CLRF   xA6
5FA6:  MOVLW  75
5FA8:  MOVWF  xA5
5FAA:  CALL   2280
5FAE:  MOVFF  03,33
5FB2:  MOVFF  02,32
5FB6:  MOVFF  01,31
5FBA:  MOVFF  00,30
....................  
....................    if(temperatura1 >= termostato1) 
5FBE:  MOVFF  23,A0
5FC2:  MOVFF  22,9F
5FC6:  MOVFF  21,9E
5FCA:  MOVFF  20,9D
5FCE:  MOVFF  2F,A4
5FD2:  MOVFF  2E,A3
5FD6:  MOVFF  2D,A2
5FDA:  MOVFF  2C,A1
5FDE:  CALL   247A
5FE2:  BC    5FE6
5FE4:  BNZ   6020
....................    { 
....................       //Si supera el valor del termostato, lo indicamos con el flag 
....................       temp_habitacion_superada1 = TRUE; 
5FE6:  BSF    1F.1
....................       //Tendremos que establecer un nuevo termostato teniendo en cuenta la histéresis de la temperatura 
....................       termostato1 = termostato1 - histeresis_vivienda; 
5FE8:  BSF    FD8.1
5FEA:  MOVFF  23,2AC
5FEE:  MOVFF  22,2AB
5FF2:  MOVFF  21,2AA
5FF6:  MOVFF  20,2A9
5FFA:  MOVFF  37,2B0
5FFE:  MOVFF  36,2AF
6002:  MOVFF  35,2AE
6006:  MOVFF  34,2AD
600A:  CALL   24F0
600E:  MOVFF  03,23
6012:  MOVFF  02,22
6016:  MOVFF  01,21
601A:  MOVFF  00,20
....................    }else 
601E:  BRA    6022
....................       //Si no se supera, se indica también 
....................       temp_habitacion_superada1 = FALSE; 
6020:  BCF    1F.1
....................  
....................    if(temperatura2 >= termostato2) 
6022:  MOVFF  27,A0
6026:  MOVFF  26,9F
602A:  MOVFF  25,9E
602E:  MOVFF  24,9D
6032:  MOVFF  33,A4
6036:  MOVFF  32,A3
603A:  MOVFF  31,A2
603E:  MOVFF  30,A1
6042:  CALL   247A
6046:  BC    604A
6048:  BNZ   6084
....................    { 
....................       //Si supera el valor del termostato, lo indicamos con el flag 
....................       temp_habitacion_superada2 = TRUE; 
604A:  BSF    1F.2
....................       //Tendremos que establecer un nuevo termostato teniendo en cuenta la histéresis de la temperatura 
....................       termostato2 = termostato2 - histeresis_vivienda; 
604C:  BSF    FD8.1
604E:  MOVFF  27,2AC
6052:  MOVFF  26,2AB
6056:  MOVFF  25,2AA
605A:  MOVFF  24,2A9
605E:  MOVFF  37,2B0
6062:  MOVFF  36,2AF
6066:  MOVFF  35,2AE
606A:  MOVFF  34,2AD
606E:  CALL   24F0
6072:  MOVFF  03,27
6076:  MOVFF  02,26
607A:  MOVFF  01,25
607E:  MOVFF  00,24
....................    }else 
6082:  BRA    6086
....................       //Si no se supera, se indica también 
....................       temp_habitacion_superada2 = FALSE; 
6084:  BCF    1F.2
....................  
....................  
....................    if(!C1OUT) 
6086:  BTFSC  FB4.6
6088:  BRA    608E
....................       //Si la temperatura del agua en la caldera supera el termostato, activamos el flag 
....................       temperatura_caldera_superada = TRUE; 
608A:  BSF    1F.0
....................    else 
608C:  BRA    6090
....................       //Si no es así, lo desactivamos 
....................       temperatura_caldera_superada = FALSE; 
608E:  BCF    1F.0
....................  
....................    //Desactivamos los flag de las interrupciones 
....................    alarma_int = led_int = FALSE; 
6090:  BCF    1F.5
6092:  BCF    1F.6
....................  
....................    //Determinamos que la patilla de interrupción de la alarma se activa al pasar de alta a baja 
....................    ext_int_edge(0, H_TO_L); 
6094:  BCF    FF1.6
....................     
....................    //Configuramos las interrupciones del temporizador 
....................    setup_timer_1(T1_INTERNAL | T1_DIV_BY_8); 
6096:  MOVLW  B5
6098:  MOVWF  FCD
....................  
....................    //Activamos las interrupciones del puerto B0 y B1 
....................    enable_interrupts(INT_EXT); 
609A:  BSF    FF2.4
....................    enable_interrupts(INT_EXT1); 
609C:  BSF    FF0.3
....................    enable_interrupts(GLOBAL); 
609E:  MOVLW  C0
60A0:  IORWF  FF2,F
....................  
....................    //Mostramos un mensaje que indica al técnico el éxito en la inicialización 
....................    printf("Sistema inicializado con exito!\r"); 
60A2:  CLRF   x95
60A4:  MOVF   x95,W
60A6:  CALL   0124
60AA:  IORLW  00
60AC:  BZ    60B8
60AE:  INCF   x95,F
60B0:  BTFSS  F9E.4
60B2:  BRA    60B0
60B4:  MOVWF  FAD
60B6:  BRA    60A4
....................  
....................    //Repetimos la siguiente rutina hasta que se desconecte el micro 
....................    while(1){ 
....................       inicio: 
....................       //Inhabilitamos el perro guardián para que no interfiera con las gestión de interrupciones y 
....................       //con la medida de la temperatura 
....................       setup_wdt(WDT_OFF); 
60B8:  BCF    FD1.0
....................  
....................       //Si la interrupción de alarma se activa, gestionamos el proceso 
....................       if(alarma_int) 
60BA:  BTFSS  1F.6
60BC:  BRA    62AC
....................       { 
....................          //Variables para almacenar el tiempo 
....................          int hora, minutos; 
....................  
....................          //Desactivamos las interrupciones para que no interfieran con la gestión de la alarma 
....................          disable_interrupts(GLOBAL); 
60BE:  BCF    FF2.6
60C0:  BCF    FF2.7
60C2:  BTFSC  FF2.7
60C4:  BRA    60C0
....................  
....................          //Desactivamos el flag de la alarma en el PCF8583 
....................          PCF8583_write_byte(PCF8583_CTRL_STATUS_REG, 
....................                                  PCF8583_START_COUNTING); 
60C6:  CLRF   xAE
60C8:  CLRF   xAF
60CA:  CALL   16E8
....................  
....................          if(toca_encender) 
60CE:  BTFSS  1F.4
60D0:  BRA    6236
....................          { 
....................             if(!sistema_encendido) 
60D2:  BTFSC  F83.4
60D4:  BRA    621C
....................             { 
....................                //Ejecutamos esto si se trata de una alarma de encendido y el sistema 
....................                //está apagado. 
....................                //Actualizamos el termostato, guardando el valor que había ya (teniendo en 
....................                //cuenta la histéresis) 
....................                if(temp_habitacion_superada1) 
60D6:  BTFSS  1F.1
60D8:  BRA    6112
....................                   termostato_provisional = termostato1 + histeresis_vivienda; 
60DA:  BCF    FD8.1
60DC:  MOVFF  23,2AC
60E0:  MOVFF  22,2AB
60E4:  MOVFF  21,2AA
60E8:  MOVFF  20,2A9
60EC:  MOVFF  37,2B0
60F0:  MOVFF  36,2AF
60F4:  MOVFF  35,2AE
60F8:  MOVFF  34,2AD
60FC:  CALL   24F0
6100:  MOVFF  03,2B
6104:  MOVFF  02,2A
6108:  MOVFF  01,29
610C:  MOVFF  00,28
....................                else 
6110:  BRA    6122
....................                   termostato_provisional = termostato1; 
6112:  MOVFF  23,2B
6116:  MOVFF  22,2A
611A:  MOVFF  21,29
611E:  MOVFF  20,28
....................  
....................                termostato1 = termostato2 = prg.termostato; 
6122:  MOVLB  2
6124:  CLRF   xB0
6126:  MOVFF  58,2AF
612A:  MOVLB  0
612C:  CALL   276A
6130:  MOVFF  03,27
6134:  MOVFF  02,26
6138:  MOVFF  01,25
613C:  MOVFF  00,24
6140:  MOVFF  27,23
6144:  MOVFF  26,22
6148:  MOVFF  25,21
614C:  MOVFF  24,20
....................  
....................                //Si la temperatura no está superada, desactivamos los flag por si acaso 
....................                //lo estaba con el otro valor de termostato. 
....................                if(ds1820_read(dir1) < termostato1) 
6150:  CLRF   xA6
6152:  MOVLW  6D
6154:  MOVWF  xA5
6156:  CALL   2280
615A:  MOVFF  00,95
615E:  MOVFF  01,96
6162:  MOVFF  02,97
6166:  MOVFF  03,98
616A:  MOVFF  03,A0
616E:  MOVFF  02,9F
6172:  MOVFF  01,9E
6176:  MOVFF  00,9D
617A:  MOVFF  23,A4
617E:  MOVFF  22,A3
6182:  MOVFF  21,A2
6186:  MOVFF  20,A1
618A:  CALL   247A
618E:  BNC   6192
....................                   temp_habitacion_superada1 = FALSE; 
6190:  BCF    1F.1
....................                if(ds1820_read(dir2) < termostato2) 
6192:  CLRF   xA6
6194:  MOVLW  75
6196:  MOVWF  xA5
6198:  CALL   2280
619C:  MOVFF  00,95
61A0:  MOVFF  01,96
61A4:  MOVFF  02,97
61A8:  MOVFF  03,98
61AC:  MOVFF  03,A0
61B0:  MOVFF  02,9F
61B4:  MOVFF  01,9E
61B8:  MOVFF  00,9D
61BC:  MOVFF  27,A4
61C0:  MOVFF  26,A3
61C4:  MOVFF  25,A2
61C8:  MOVFF  24,A1
61CC:  CALL   247A
61D0:  BNC   61D4
....................                   temp_habitacion_superada2 = FALSE; 
61D2:  BCF    1F.2
....................  
....................                //Determinamos la próxima alarma como de apagado 
....................                toca_encender = FALSE; 
61D4:  BCF    1F.4
....................  
....................                //Activamos el flag de sistema encendido por alarma 
....................                encendido_por_alarma = TRUE; 
61D6:  BSF    1F.3
....................                //Mostramos un mensaje 
....................                lcd_send_byte(LCD_ORDEN,LCD_CLEAR); 
61D8:  CLRF   xAC
61DA:  MOVLW  01
61DC:  MOVWF  xAD
61DE:  CALL   1314
....................                printf(lcd_putc, "  Encendiendo\n  sistema..."); 
61E2:  CLRF   x95
61E4:  MOVF   x95,W
61E6:  CALL   0160
61EA:  IORLW  00
61EC:  BZ    61F8
61EE:  INCF   x95,F
61F0:  MOVWF  xA7
61F2:  CALL   13C0
61F6:  BRA    61E4
....................                //Encendemos el sistema 
....................                encender_sistema(); 
61F8:  CALL   2A74
....................  
....................                //Recogemos el tiempo en el que debe de saltar la alarma de apagado. 
....................                //Lo hacemos mediante variables auxiliares para dividir mejor las tareas 
....................                //y no condensar todo en una línea. 
....................                hora = prg.horas_fin; 
61FC:  MOVFF  56,85
....................                minutos = prg.minutos_fin; 
6200:  MOVFF  57,86
....................  
....................                delay_ms(250); //Retraso para evitar solapamiento de alarmas 
6204:  MOVLW  FA
6206:  MOVWF  xB0
6208:  CALL   12A8
....................                               //(que salte una dos veces seguidas o algo así) 
....................  
....................                //Establecemos la alarma de apagado del sistema (segundos=0) 
....................                PCF8583_establecer_alarma(hora, minutos, 0); 
620C:  MOVFF  85,97
6210:  MOVFF  86,98
6214:  CLRF   x99
6216:  CALL   2A9C
....................  
....................             }else 
621A:  BRA    6234
....................             { 
....................                //Si se trata de una alarma de encendido y el sistema está encendido 
....................                delay_ms(250); //Retraso para evitar solapamiento de alarmas 
621C:  MOVLW  FA
621E:  MOVWF  xB0
6220:  CALL   12A8
....................  
....................                //Nos vamos a la siguiente alarma 
....................                posicion_alarmas++; 
6224:  INCF   5A,F
....................                //Si hemos llegado al final de la lista, volvemos al principio 
....................                if(posicion_alarmas==num_intervalos) 
6226:  MOVF   59,W
6228:  SUBWF  5A,W
622A:  BNZ   622E
....................                   posicion_alarmas = 0; 
622C:  CLRF   5A
....................  
....................                //Programamos la próxima alarma de encendido 
....................                programar_proxima_alarma(); 
622E:  CALL   2B5C
....................  
....................                //Determinamos que la siguiente es de encendido 
....................                toca_encender = TRUE; 
6232:  BSF    1F.4
....................             } 
....................          }else 
6234:  BRA    629C
....................          { 
....................             //Si se trata de una alarma de apagado 
....................  
....................             delay_ms(250); //Retraso para evitar el solapamiento de alarmas 
6236:  MOVLW  FA
6238:  MOVWF  xB0
623A:  CALL   12A8
....................  
....................             if(sistema_encendido && encendido_por_alarma) 
623E:  BTFSS  F83.4
6240:  BRA    628C
6242:  BTFSS  1F.3
6244:  BRA    628C
....................             { 
....................                //Si el sistema está encendido y se trata de un encendido por alarma: 
....................                //Restauramos el valor del termostato que había antes de la alarma 
....................                termostato1 = termostato2 = termostato_provisional; 
6246:  MOVFF  2B,27
624A:  MOVFF  2A,26
624E:  MOVFF  29,25
6252:  MOVFF  28,24
6256:  MOVFF  27,23
625A:  MOVFF  26,22
625E:  MOVFF  25,21
6262:  MOVFF  24,20
....................                //Determinamos que la próxima vez que se encienda no sea por alarma 
....................                encendido_por_alarma = FALSE; 
6266:  BCF    1F.3
....................                //Mostramos un mensaje 
....................                lcd_send_byte(LCD_ORDEN,LCD_CLEAR); 
6268:  CLRF   xAC
626A:  MOVLW  01
626C:  MOVWF  xAD
626E:  CALL   1314
....................                printf(lcd_putc, "  Apagando\n  sistema..."); 
6272:  CLRF   x95
6274:  MOVF   x95,W
6276:  CALL   0196
627A:  IORLW  00
627C:  BZ    6288
627E:  INCF   x95,F
6280:  MOVWF  xA7
6282:  CALL   13C0
6286:  BRA    6274
....................                //Apagamos el sistema 
....................                apagar_sistema(); 
6288:  CALL   2F68
....................             } 
....................  
....................             //Nos vamos a la siguiente alarma 
....................             posicion_alarmas++; 
628C:  INCF   5A,F
....................             //Si llegamos al final de la lista, volvemos al principio 
....................             if(posicion_alarmas==num_intervalos) 
628E:  MOVF   59,W
6290:  SUBWF  5A,W
6292:  BNZ   6296
....................                posicion_alarmas = 0; 
6294:  CLRF   5A
....................  
....................             //Programamos la próxima alarma de encendido 
....................             programar_proxima_alarma(); 
6296:  CALL   2B5C
....................  
....................             //Y activamos que, efectivamente, se trata de una alarma de encendido 
....................             toca_encender = TRUE; 
629A:  BSF    1F.4
....................          } 
....................  
....................          //Activamos de nuevo la alarma 
....................          PCF8583_write_byte(PCF8583_CTRL_STATUS_REG, 
....................                                  PCF8583_ACTIVAR_ALARMA); 
629C:  CLRF   xAE
629E:  MOVLW  04
62A0:  MOVWF  xAF
62A2:  CALL   16E8
....................  
....................          //Desactivamos el flag de interrupción 
....................          alarma_int = FALSE; 
62A6:  BCF    1F.6
....................  
....................          //Volvemos a activar las interrupciones 
....................          enable_interrupts(GLOBAL); 
62A8:  MOVLW  C0
62AA:  IORWF  FF2,F
....................       } 
....................  
....................  
....................       //Si se activa la interrupción de interfaz con el usuario, se gestiona el proceso 
....................       if(led_int) 
62AC:  BTFSS  1F.5
62AE:  GOTO   6DF2
....................       { 
....................          //Contadores 
....................          int contador, contador2; 
....................          //Variable para la conversión de los valores de teclado 
....................          long numero; 
....................          //Variables provisionales para buscar en la lista de programaciones 
....................          programacion pr, pr2; 
....................  
....................          //Desactivamos interrupciones 
....................          disable_interrupts(INT_EXT); 
62B2:  BCF    FF2.4
....................          disable_interrupts(INT_EXT1); 
62B4:  BCF    FF0.3
....................          disable_interrupts(GLOBAL); 
62B6:  BCF    FF2.6
62B8:  BCF    FF2.7
62BA:  BTFSC  FF2.7
62BC:  BRA    62B8
....................  
....................          //Ponemos en key un caracter cualquiera para que no se corresponda 
....................          //con ningún botón del teclado. 
....................          key='J'; 
62BE:  MOVLW  4A
62C0:  MOVWF  38
....................  
....................          //Mostramos un mensaje al usuario para que elija su opción 
....................          lcd_send_byte(LCD_ORDEN,LCD_CLEAR); 
62C2:  CLRF   xAC
62C4:  MOVLW  01
62C6:  MOVWF  xAD
62C8:  CALL   1314
....................          printf(lcd_putc, "  Indique la \n  operacion"); 
62CC:  CLRF   x95
62CE:  MOVF   x95,W
62D0:  CALL   01C8
62D4:  IORLW  00
62D6:  BZ    62E2
62D8:  INCF   x95,F
62DA:  MOVWF  xA7
62DC:  CALL   13C0
62E0:  BRA    62CE
....................  
....................          //Activamos el temporizador para controlar el tiempo que el menú está activo, 
....................          //poniendo el contador a 0. 
....................          contador_tiempo = 0; 
62E2:  CLRF   7D
....................          enable_interrupts(INT_TIMER1); 
62E4:  BSF    F9D.0
....................          enable_interrupts(GLOBAL); 
62E6:  MOVLW  C0
62E8:  IORWF  FF2,F
....................  
....................          //Mientras que la tecla pulsada no sea una de las válidas, seguimos barriendo el teclado 
....................          while(key!='1' && key!='2' && key!='3' && key!='4' && key!='N'){ 
62EA:  MOVF   38,W
62EC:  SUBLW  31
62EE:  BZ    631C
62F0:  MOVF   38,W
62F2:  SUBLW  32
62F4:  BZ    631C
62F6:  MOVF   38,W
62F8:  SUBLW  33
62FA:  BZ    631C
62FC:  MOVF   38,W
62FE:  SUBLW  34
6300:  BZ    631C
6302:  MOVF   38,W
6304:  SUBLW  4E
6306:  BZ    631C
....................             key=get_key(); 
6308:  CALL   33BA
630C:  MOVFF  01,38
....................             //Si el tiempo de espera consignado expira, es equivalente a pulsar la tecla NO para salir. 
....................             if(timer_int){ 
6310:  BTFSS  1F.7
6312:  BRA    631A
....................                key='N'; 
6314:  MOVLW  4E
6316:  MOVWF  38
....................                timer_int = FALSE; //Desactivamos flag 
6318:  BCF    1F.7
....................             } 
....................          } 
631A:  BRA    62EA
....................           
....................          //Volvemos a deshabilitar la interrupción que controla el tiempo de espera 
....................          disable_interrupts(INT_TIMER1); 
631C:  BCF    F9D.0
....................          disable_interrupts(GLOBAL); 
631E:  BCF    FF2.6
6320:  BCF    FF2.7
6322:  BTFSC  FF2.7
6324:  BRA    6320
....................           
....................  
....................          //Se elige la opción pertinente 
....................          switch(key) 
....................          { 
6326:  MOVF   38,W
6328:  XORLW  31
632A:  BZ    634A
632C:  XORLW  03
632E:  BZ    63C6
6330:  XORLW  01
6332:  BTFSC  FD8.2
6334:  BRA    6734
6336:  XORLW  07
6338:  BTFSC  FD8.2
633A:  GOTO   6C02
633E:  XORLW  7A
6340:  BTFSC  FD8.2
6342:  GOTO   6DAC
6346:  GOTO   6DE8
....................             //Si es 1, entramos en la opción de apagado y encendido manual del sistema 
....................             case '1': 
....................                      //Si el sistema está apagado, lo encendemos 
....................                      if(!sistema_encendido) 
634A:  BTFSC  F83.4
634C:  BRA    6374
....................                      { 
....................                         lcd_send_byte(LCD_ORDEN,LCD_CLEAR); 
634E:  CLRF   xAC
6350:  MOVLW  01
6352:  MOVWF  xAD
6354:  CALL   1314
....................                         printf(lcd_putc, "  Encendiendo\n  sistema..."); 
6358:  CLRF   x95
635A:  MOVF   x95,W
635C:  CALL   0160
6360:  IORLW  00
6362:  BZ    636E
6364:  INCF   x95,F
6366:  MOVWF  xA7
6368:  CALL   13C0
636C:  BRA    635A
....................                         encender_sistema(); 
636E:  CALL   2A74
....................                      }else 
6372:  BRA    63C2
....................                      //Si está encendido, lo apagamos 
....................                      { 
....................                         lcd_send_byte(LCD_ORDEN,LCD_CLEAR); 
6374:  CLRF   xAC
6376:  MOVLW  01
6378:  MOVWF  xAD
637A:  CALL   1314
....................                         printf(lcd_putc, "  Apagando\n  sistema..."); 
637E:  CLRF   x95
6380:  MOVF   x95,W
6382:  CALL   0196
6386:  IORLW  00
6388:  BZ    6394
638A:  INCF   x95,F
638C:  MOVWF  xA7
638E:  CALL   13C0
6392:  BRA    6380
....................                         apagar_sistema(); 
6394:  CALL   2F68
....................                         //Si los motores estaban en marcha, debemos apagarlos 
....................                         motor1 = FALSE; 
6398:  BCF    F83.6
....................                         motor2 = FALSE; 
639A:  BCF    F83.7
....................  
....................                         //Si estaba encendido por alguna alarma debemos indicarlo 
....................                         if(encendido_por_alarma) 
639C:  BTFSS  1F.3
639E:  BRA    63C2
....................                         { 
....................                            //Recuperamos el valor del termostato 
....................                            termostato1 = termostato2 = termostato_provisional; 
63A0:  MOVFF  2B,27
63A4:  MOVFF  2A,26
63A8:  MOVFF  29,25
63AC:  MOVFF  28,24
63B0:  MOVFF  27,23
63B4:  MOVFF  26,22
63B8:  MOVFF  25,21
63BC:  MOVFF  24,20
....................                            encendido_por_alarma = FALSE; 
63C0:  BCF    1F.3
....................                         } 
....................                      } 
....................                      break; 
63C2:  GOTO   6DE8
....................  
....................  
....................             //Si es 2, entramos en la opción de configuración del termostato 
....................             case '2': 
....................  
....................                      //Mostramos el valor del termostato actual 
....................                      lcd_send_byte(LCD_ORDEN, LCD_CLEAR); 
63C6:  CLRF   xAC
63C8:  MOVLW  01
63CA:  MOVWF  xAD
63CC:  CALL   1314
....................                      //Para considerar el valor del termostato hay que tener en cuenta el valor de la histéresis. 
....................                      //El termostato de la vivienda es único y no depende de la habitación en la que nos encontremos. 
....................                      if(temp_habitacion_superada1) 
63D0:  BTFSS  1F.1
63D2:  BRA    644E
....................                         printf(lcd_putc, "Modificar\ntermostato %.0f%cC",termostato1+histeresis_vivienda,223); 
63D4:  BCF    FD8.1
63D6:  MOVFF  23,2AC
63DA:  MOVFF  22,2AB
63DE:  MOVFF  21,2AA
63E2:  MOVFF  20,2A9
63E6:  MOVFF  37,2B0
63EA:  MOVFF  36,2AF
63EE:  MOVFF  35,2AE
63F2:  MOVFF  34,2AD
63F6:  CALL   24F0
63FA:  MOVFF  00,95
63FE:  MOVFF  01,96
6402:  MOVFF  02,97
6406:  MOVFF  03,98
640A:  CLRF   x99
640C:  MOVF   x99,W
640E:  CALL   01FC
6412:  INCF   x99,F
6414:  MOVWF  00
6416:  MOVWF  xA7
6418:  CALL   13C0
641C:  MOVLW  15
641E:  SUBWF  x99,W
6420:  BNZ   640C
6422:  MOVLW  89
6424:  MOVWF  FE9
6426:  MOVFF  98,9D
642A:  MOVFF  97,9C
642E:  MOVFF  96,9B
6432:  MOVFF  95,9A
6436:  CLRF   x9E
6438:  CALL   3494
643C:  MOVLW  DF
643E:  MOVWF  xA7
6440:  CALL   13C0
6444:  MOVLW  43
6446:  MOVWF  xA7
6448:  CALL   13C0
....................                      else 
644C:  BRA    6490
....................                         printf(lcd_putc, "Modificar\ntermostato %.0f%cC",termostato1,223); 
644E:  CLRF   x95
6450:  MOVF   x95,W
6452:  CALL   01FC
6456:  INCF   x95,F
6458:  MOVWF  00
645A:  MOVWF  xA7
645C:  CALL   13C0
6460:  MOVLW  15
6462:  SUBWF  x95,W
6464:  BNZ   6450
6466:  MOVLW  89
6468:  MOVWF  FE9
646A:  MOVFF  23,9D
646E:  MOVFF  22,9C
6472:  MOVFF  21,9B
6476:  MOVFF  20,9A
647A:  CLRF   x9E
647C:  CALL   3494
6480:  MOVLW  DF
6482:  MOVWF  xA7
6484:  CALL   13C0
6488:  MOVLW  43
648A:  MOVWF  xA7
648C:  CALL   13C0
....................  
....................                      //Retardamos cierto tiempo para que el usuario vea correctamente los datos de la pantalla 
....................                      delay_ms(LCD_T_RETARDO*2); 
6490:  MOVLW  04
6492:  MOVWF  x95
6494:  MOVLW  FA
6496:  MOVWF  xB0
6498:  CALL   12A8
649C:  DECFSZ x95,F
649E:  BRA    6494
....................  
....................                      //Pedimos la introducción de nuevo valor 
....................                      lcd_send_byte(LCD_ORDEN, LCD_CLEAR); 
64A0:  CLRF   xAC
64A2:  MOVLW  01
64A4:  MOVWF  xAD
64A6:  CALL   1314
....................                      lcd_send_byte(LCD_ORDEN, LCD_CURSOR); //Activamos el cursor en la pantalla 
64AA:  CLRF   xAC
64AC:  MOVLW  0E
64AE:  MOVWF  xAD
64B0:  CALL   1314
....................                      printf(lcd_putc, "Nuevo valor:\n       %cC",223); 
64B4:  CLRF   x95
64B6:  MOVF   x95,W
64B8:  CALL   0234
64BC:  INCF   x95,F
64BE:  MOVWF  00
64C0:  MOVWF  xA7
64C2:  CALL   13C0
64C6:  MOVLW  0D
64C8:  SUBWF  x95,W
64CA:  BNZ   64B6
64CC:  MOVLW  07
64CE:  MOVWF  x96
64D0:  MOVLW  20
64D2:  MOVWF  xA7
64D4:  CALL   13C0
64D8:  DECFSZ x96,F
64DA:  BRA    64D0
64DC:  MOVLW  DF
64DE:  MOVWF  xA7
64E0:  CALL   13C0
64E4:  MOVLW  43
64E6:  MOVWF  xA7
64E8:  CALL   13C0
....................                      lcd_gotoxy(6,2); 
64EC:  MOVLW  06
64EE:  MOVWF  xA8
64F0:  MOVLW  02
64F2:  MOVWF  xA9
64F4:  CALL   139E
....................  
....................                      //Recogemos el número de dos cifras introducido por el teclado 
....................                      valor=buscar_numero(); 
64F8:  CALL   3624
64FC:  MOVFF  01,84
....................  
....................                      //Si se pulsa la tecla SI o NO, salimos 
....................                      if(valor==NO || valor==SI) 
6500:  MOVF   x84,W
6502:  SUBLW  64
6504:  BZ    650C
6506:  MOVF   x84,W
6508:  SUBLW  65
650A:  BNZ   6512
....................                         goto salir; 
650C:  GOTO   6DAC
....................                      else 
6510:  BRA    6732
....................                      { 
....................                         //Retardamos cierto tiempo para permitir al usuario visualizar el valor que ha introducido 
....................                         delay_ms(LCD_T_RETARDO); 
6512:  MOVLW  02
6514:  MOVWF  x95
6516:  MOVLW  FA
6518:  MOVWF  xB0
651A:  CALL   12A8
651E:  DECFSZ x95,F
6520:  BRA    6516
....................  
....................                         //Mostramos un mensaje de aplicación de cambios y desactivamos el cursor 
....................                         lcd_send_byte(LCD_ORDEN, LCD_CLEAR); 
6522:  CLRF   xAC
6524:  MOVLW  01
6526:  MOVWF  xAD
6528:  CALL   1314
....................                         lcd_send_byte(LCD_ORDEN, LCD_NO_CURSOR); 
652C:  CLRF   xAC
652E:  MOVLW  0C
6530:  MOVWF  xAD
6532:  CALL   1314
....................                         printf(lcd_putc, "  Aplicando\n  cambios..."); 
6536:  CLRF   x95
6538:  MOVF   x95,W
653A:  CALL   0260
653E:  IORLW  00
6540:  BZ    654C
6542:  INCF   x95,F
6544:  MOVWF  xA7
6546:  CALL   13C0
654A:  BRA    6538
....................  
....................                         if(valor<=temp_max && valor>=temp_min) 
654C:  MOVF   x84,W
654E:  SUBLW  20
6550:  BTFSS  FD8.0
6552:  BRA    6702
6554:  MOVF   x84,W
6556:  SUBLW  0F
6558:  BTFSC  FD8.0
655A:  BRA    6702
....................                         { 
....................                            //Si el valor está dentro de los límites propuestos, guardamos el valor nuevo 
....................  
....................                            //Leemos la temperatura de la zona1 de la vivienda 
....................                            temperatura1 = ds1820_read(dir1); 
655C:  CLRF   xA6
655E:  MOVLW  6D
6560:  MOVWF  xA5
6562:  CALL   2280
6566:  MOVFF  03,2F
656A:  MOVFF  02,2E
656E:  MOVFF  01,2D
6572:  MOVFF  00,2C
....................                            if(temperatura1 >= (float)valor) 
6576:  MOVLB  2
6578:  CLRF   xB0
657A:  MOVFF  84,2AF
657E:  MOVLB  0
6580:  CALL   276A
6584:  MOVFF  03,A0
6588:  MOVFF  02,9F
658C:  MOVFF  01,9E
6590:  MOVFF  00,9D
6594:  MOVFF  2F,A4
6598:  MOVFF  2E,A3
659C:  MOVFF  2D,A2
65A0:  MOVFF  2C,A1
65A4:  CALL   247A
65A8:  BC    65AC
65AA:  BNZ   6604
....................                            { 
....................                               //Si supera el valor del termostato, lo indicamos con el flag 
....................                               temp_habitacion_superada1 = TRUE; 
65AC:  BSF    1F.1
....................                               //Guardamos el termostato nuevo teniendo en cuenta la histeresis de la vivienda 
....................                               termostato1 = (float)valor - histeresis_vivienda; 
65AE:  MOVLB  2
65B0:  CLRF   xB0
65B2:  MOVFF  84,2AF
65B6:  MOVLB  0
65B8:  CALL   276A
65BC:  MOVFF  00,95
65C0:  MOVFF  01,96
65C4:  MOVFF  02,97
65C8:  MOVFF  03,98
65CC:  BSF    FD8.1
65CE:  MOVFF  03,2AC
65D2:  MOVFF  02,2AB
65D6:  MOVFF  01,2AA
65DA:  MOVFF  00,2A9
65DE:  MOVFF  37,2B0
65E2:  MOVFF  36,2AF
65E6:  MOVFF  35,2AE
65EA:  MOVFF  34,2AD
65EE:  CALL   24F0
65F2:  MOVFF  03,23
65F6:  MOVFF  02,22
65FA:  MOVFF  01,21
65FE:  MOVFF  00,20
....................                            }else 
6602:  BRA    6624
....................                            { 
....................                               //Si no se supera, se indica también 
....................                               temp_habitacion_superada1 = FALSE; 
6604:  BCF    1F.1
....................                               //Se guarda el valor tal cual 
....................                               termostato1 = (float)valor; 
6606:  MOVLB  2
6608:  CLRF   xB0
660A:  MOVFF  84,2AF
660E:  MOVLB  0
6610:  CALL   276A
6614:  MOVFF  03,23
6618:  MOVFF  02,22
661C:  MOVFF  01,21
6620:  MOVFF  00,20
....................                            } 
....................  
....................                            //Repetimos el proceso con la zona2 de la vivienda 
....................                            temperatura2 = ds1820_read(dir2); 
6624:  CLRF   xA6
6626:  MOVLW  75
6628:  MOVWF  xA5
662A:  CALL   2280
662E:  MOVFF  03,33
6632:  MOVFF  02,32
6636:  MOVFF  01,31
663A:  MOVFF  00,30
....................                            if(temperatura2 >= (float)valor) 
663E:  MOVLB  2
6640:  CLRF   xB0
6642:  MOVFF  84,2AF
6646:  MOVLB  0
6648:  CALL   276A
664C:  MOVFF  03,A0
6650:  MOVFF  02,9F
6654:  MOVFF  01,9E
6658:  MOVFF  00,9D
665C:  MOVFF  33,A4
6660:  MOVFF  32,A3
6664:  MOVFF  31,A2
6668:  MOVFF  30,A1
666C:  CALL   247A
6670:  BC    6674
6672:  BNZ   66CC
....................                            { 
....................                               //Si supera el valor del termostato, lo indicamos con el flag 
....................                               temp_habitacion_superada2 = TRUE; 
6674:  BSF    1F.2
....................                               //Guardamos el termostato nuevo teniendo en cuenta la histeresis de la vivienda 
....................                               termostato2 = (float)valor - histeresis_vivienda; 
6676:  MOVLB  2
6678:  CLRF   xB0
667A:  MOVFF  84,2AF
667E:  MOVLB  0
6680:  CALL   276A
6684:  MOVFF  00,95
6688:  MOVFF  01,96
668C:  MOVFF  02,97
6690:  MOVFF  03,98
6694:  BSF    FD8.1
6696:  MOVFF  03,2AC
669A:  MOVFF  02,2AB
669E:  MOVFF  01,2AA
66A2:  MOVFF  00,2A9
66A6:  MOVFF  37,2B0
66AA:  MOVFF  36,2AF
66AE:  MOVFF  35,2AE
66B2:  MOVFF  34,2AD
66B6:  CALL   24F0
66BA:  MOVFF  03,27
66BE:  MOVFF  02,26
66C2:  MOVFF  01,25
66C6:  MOVFF  00,24
....................                            }else 
66CA:  BRA    66EC
....................                            { 
....................                               //Si no se supera, se indica también 
....................                               temp_habitacion_superada2 = FALSE; 
66CC:  BCF    1F.2
....................                               //Se guarda el valor tal cual 
....................                               termostato2 = (float)valor; 
66CE:  MOVLB  2
66D0:  CLRF   xB0
66D2:  MOVFF  84,2AF
66D6:  MOVLB  0
66D8:  CALL   276A
66DC:  MOVFF  03,27
66E0:  MOVFF  02,26
66E4:  MOVFF  01,25
66E8:  MOVFF  00,24
....................                            } 
....................  
....................                            //Guardamos el nuevo valor del termostato en memoria 
....................                            graba_ee(eeprom_termostato, 1, &valor); 
66EC:  CLRF   xAC
66EE:  MOVLW  10
66F0:  MOVWF  xAB
66F2:  MOVLW  01
66F4:  MOVWF  xAD
66F6:  CLRF   xAF
66F8:  MOVLW  84
66FA:  MOVWF  xAE
66FC:  CALL   18E6
....................  
....................                         } 
....................                         else 
6700:  BRA    6732
....................                         { 
....................                            //Si el valor es incorrecto, mostramos un mensaje de error 
....................                            lcd_send_byte(LCD_ORDEN, LCD_CLEAR); 
6702:  CLRF   xAC
6704:  MOVLW  01
6706:  MOVWF  xAD
6708:  CALL   1314
....................                            printf(lcd_putc, "   Valor\n   incorrecto"); 
670C:  CLRF   x95
670E:  MOVF   x95,W
6710:  CALL   0294
6714:  IORLW  00
6716:  BZ    6722
6718:  INCF   x95,F
671A:  MOVWF  xA7
671C:  CALL   13C0
6720:  BRA    670E
....................                            delay_ms(LCD_T_RETARDO); 
6722:  MOVLW  02
6724:  MOVWF  x95
6726:  MOVLW  FA
6728:  MOVWF  xB0
672A:  CALL   12A8
672E:  DECFSZ x95,F
6730:  BRA    6726
....................                         } 
....................                      } 
....................  
....................                      break; 
6732:  BRA    6DE8
....................  
....................  
....................             //Si es 3, entramos en la opción de configuración de las alarmas 
....................             case '3': 
....................  
....................                      //Mostramos el encabezamiento de la operación 
....................                      lcd_send_byte(LCD_ORDEN, LCD_CLEAR); 
6734:  CLRF   xAC
6736:  MOVLW  01
6738:  MOVWF  xAD
673A:  CALL   1314
....................                      printf(lcd_putc," Programar\n sistema"); 
673E:  CLRF   x95
6740:  MOVF   x95,W
6742:  CALL   02C6
6746:  IORLW  00
6748:  BZ    6754
674A:  INCF   x95,F
674C:  MOVWF  xA7
674E:  CALL   13C0
6752:  BRA    6740
....................                      delay_ms(LCD_T_RETARDO); 
6754:  MOVLW  02
6756:  MOVWF  x95
6758:  MOVLW  FA
675A:  MOVWF  xB0
675C:  CALL   12A8
6760:  DECFSZ x95,F
6762:  BRA    6758
....................  
....................                      //Tenemos la posibilidad de introducir 5 intervalos de alarma. 
....................                      //Se va guiando al usuario por la configuración de cada intervalo mediante el siguiente bucle 
....................                      for(contador=0; contador<5; contador++) 
6764:  CLRF   x87
6766:  MOVF   x87,W
6768:  SUBLW  04
676A:  BTFSS  FD8.0
676C:  BRA    6BB8
....................                      { 
....................                         //Se muestra el intervalo a configurar 
....................                         lcd_send_byte(LCD_ORDEN, LCD_CLEAR); 
676E:  CLRF   xAC
6770:  MOVLW  01
6772:  MOVWF  xAD
6774:  CALL   1314
....................                         printf(lcd_putc, " INTERVALO %i\n   :      :",contador+1); 
6778:  MOVLW  01
677A:  ADDWF  x87,W
677C:  MOVWF  x95
677E:  CLRF   x96
6780:  MOVF   x96,W
6782:  CALL   02F4
6786:  INCF   x96,F
6788:  MOVWF  00
678A:  MOVWF  xA7
678C:  CALL   13C0
6790:  MOVLW  0B
6792:  SUBWF  x96,W
6794:  BNZ   6780
6796:  MOVFF  95,97
679A:  MOVLW  1F
679C:  MOVWF  x98
679E:  CALL   36E6
67A2:  MOVLW  0A
67A4:  MOVWF  xA7
67A6:  CALL   13C0
67AA:  MOVLW  03
67AC:  MOVWF  x97
67AE:  MOVLW  20
67B0:  MOVWF  xA7
67B2:  CALL   13C0
67B6:  DECFSZ x97,F
67B8:  BRA    67AE
67BA:  MOVLW  3A
67BC:  MOVWF  xA7
67BE:  CALL   13C0
67C2:  MOVLW  06
67C4:  MOVWF  x98
67C6:  MOVLW  20
67C8:  MOVWF  xA7
67CA:  CALL   13C0
67CE:  DECFSZ x98,F
67D0:  BRA    67C6
67D2:  MOVLW  3A
67D4:  MOVWF  xA7
67D6:  CALL   13C0
....................                         lcd_gotoxy(2,2); 
67DA:  MOVLW  02
67DC:  MOVWF  xA8
67DE:  MOVWF  xA9
67E0:  CALL   139E
....................                         lcd_send_byte(LCD_ORDEN, LCD_CURSOR); 
67E4:  CLRF   xAC
67E6:  MOVLW  0E
67E8:  MOVWF  xAD
67EA:  CALL   1314
....................  
....................                         //Se pide al usuario el valor de hora de inicio de la alarma 
....................                         pr.horas_inicio = buscar_numero(); 
67EE:  CALL   3624
67F2:  MOVFF  01,8B
....................  
....................                         //Si se pulsa el botón de NO, se sale de la configuración 
....................                         if(pr.horas_inicio==NO) 
67F6:  MOVF   x8B,W
67F8:  SUBLW  64
67FA:  BNZ   67FE
....................                            goto salir; 
67FC:  BRA    6DAC
....................  
....................                         //Si se pulsa Sí, se indica que no quieren introducirse más alarmas 
....................                         if(pr.horas_inicio==SI) 
67FE:  MOVF   x8B,W
6800:  SUBLW  65
6802:  BNZ   6816
....................                         { 
....................                            //Si era la primera alarma que se gestionaba, se interpreta como que 
....................                            //no se quiere activar ninguna alarma 
....................                            if(contador==0) 
6804:  MOVF   x87,F
6806:  BNZ   6814
....................                            { 
....................                               //Desactivamos las alarmas 
....................                               PCF8583_write_byte(PCF8583_CTRL_STATUS_REG, 
....................                                     PCF8583_START_COUNTING); 
6808:  CLRF   xAE
680A:  CLRF   xAF
680C:  CALL   16E8
....................                               //Salimos 
....................                               goto salir; 
6810:  BRA    6DAC
....................                            } 
....................                            else 
6812:  BRA    6816
....................                               //Salimos simplemente del bucle 
....................                               break; 
6814:  BRA    6BB8
....................                         } 
....................  
....................                         //Movemos el cursor en la pantalla 
....................                         lcd_gotoxy(5,2); 
6816:  MOVLW  05
6818:  MOVWF  xA8
681A:  MOVLW  02
681C:  MOVWF  xA9
681E:  CALL   139E
....................  
....................                         //Se pide al usuario el valor de los minutos de inicio 
....................                         pr.minutos_inicio = buscar_numero(); 
6822:  CALL   3624
6826:  MOVFF  01,8C
....................  
....................                         //Si se pulsa NO, se sale 
....................                         if(pr.minutos_inicio==NO) 
682A:  MOVF   x8C,W
682C:  SUBLW  64
682E:  BNZ   6832
....................                            goto salir; 
6830:  BRA    6DAC
....................  
....................                         //Si se pulsa SI, interrumpimos la introducción de alarmas 
....................                         if(pr.minutos_inicio==SI) 
6832:  MOVF   x8C,W
6834:  SUBLW  65
6836:  BNZ   684A
....................                         { 
....................                            //Si es el primer intervalo, interpretamos como que el usuario 
....................                            //no quiere programar alarmas 
....................                            if(contador==0) 
6838:  MOVF   x87,F
683A:  BNZ   6848
....................                            { 
....................                               //Desactivamos las alarmas 
....................                               PCF8583_write_byte(PCF8583_CTRL_STATUS_REG, 
....................                                     PCF8583_START_COUNTING); 
683C:  CLRF   xAE
683E:  CLRF   xAF
6840:  CALL   16E8
....................                               goto salir; 
6844:  BRA    6DAC
....................                            } 
....................                            else 
6846:  BRA    684A
....................                               //Salimos del bucle 
....................                               break; 
6848:  BRA    6BB8
....................                         } 
....................  
....................                         //******************************************************************************** 
....................                         //Los comentarios a partir de este punto y hasta la siguiente línea de asteriscos 
....................                         //son equivalentes a los mostrados arriba pero esta vez con la hora de finalización 
....................  
....................                         lcd_gotoxy(9,2); 
684A:  MOVLW  09
684C:  MOVWF  xA8
684E:  MOVLW  02
6850:  MOVWF  xA9
6852:  CALL   139E
....................  
....................                         pr.horas_fin = buscar_numero(); 
6856:  CALL   3624
685A:  MOVFF  01,8D
....................  
....................                         if(pr.horas_fin==NO) 
685E:  MOVF   x8D,W
6860:  SUBLW  64
6862:  BNZ   6866
....................                            goto salir; 
6864:  BRA    6DAC
....................  
....................                         if(pr.horas_fin==SI) 
6866:  MOVF   x8D,W
6868:  SUBLW  65
686A:  BNZ   687E
....................                         { 
....................                            if(contador==0) 
686C:  MOVF   x87,F
686E:  BNZ   687C
....................                            { 
....................                               PCF8583_write_byte(PCF8583_CTRL_STATUS_REG, 
....................                                     PCF8583_START_COUNTING); 
6870:  CLRF   xAE
6872:  CLRF   xAF
6874:  CALL   16E8
....................                               goto salir; 
6878:  BRA    6DAC
....................                            } 
....................                            else 
687A:  BRA    687E
....................                               break; 
687C:  BRA    6BB8
....................                         } 
....................  
....................  
....................                         lcd_gotoxy(12,2); 
687E:  MOVLW  0C
6880:  MOVWF  xA8
6882:  MOVLW  02
6884:  MOVWF  xA9
6886:  CALL   139E
....................  
....................                         pr.minutos_fin = buscar_numero(); 
688A:  CALL   3624
688E:  MOVFF  01,8E
....................  
....................                         if(pr.minutos_fin==NO) 
6892:  MOVF   x8E,W
6894:  SUBLW  64
6896:  BNZ   689A
....................                            goto salir; 
6898:  BRA    6DAC
....................  
....................                         if(pr.minutos_fin==SI) 
689A:  MOVF   x8E,W
689C:  SUBLW  65
689E:  BNZ   68B2
....................                         { 
....................                            if(contador==0) 
68A0:  MOVF   x87,F
68A2:  BNZ   68B0
....................                            { 
....................                               PCF8583_write_byte(PCF8583_CTRL_STATUS_REG, 
....................                                     PCF8583_START_COUNTING); 
68A4:  CLRF   xAE
68A6:  CLRF   xAF
68A8:  CALL   16E8
....................                               goto salir; 
68AC:  BRA    6DAC
....................                            } 
....................                            else 
68AE:  BRA    68B2
....................                               break; 
68B0:  BRA    6BB8
....................                         } 
....................  
....................                         //Ver comentarios arriba 
....................                         //************************************************************ 
....................  
....................                         //Desactivamos el cursor de la pantalla 
....................                         lcd_send_byte(LCD_ORDEN, LCD_NO_CURSOR); 
68B2:  CLRF   xAC
68B4:  MOVLW  0C
68B6:  MOVWF  xAD
68B8:  CALL   1314
....................  
....................                         //Introducimos cierto retardo para que el usuario pueda visualizar los valores introducidos en la pantalla 
....................                         delay_ms(LCD_T_RETARDO); 
68BC:  MOVLW  02
68BE:  MOVWF  x95
68C0:  MOVLW  FA
68C2:  MOVWF  xB0
68C4:  CALL   12A8
68C8:  DECFSZ x95,F
68CA:  BRA    68C0
....................  
....................                         //Comprobamos que los valores introducidos son correctos: horas menores que 24 y minutos menores que 60 
....................                         //Además, comprobamos que la hora de finalización no vaya antes que la de inicio 
....................                         if(pr.horas_inicio>23 || pr.horas_fin>23 || pr.minutos_inicio>59 || pr.minutos_fin>59 
....................                               || comprobar_hora(pr.horas_fin,pr.minutos_fin,pr.horas_inicio,pr.minutos_inicio)) 
68CC:  MOVF   x8B,W
68CE:  SUBLW  17
68D0:  BNC   68FC
68D2:  MOVF   x8D,W
68D4:  SUBLW  17
68D6:  BNC   68FC
68D8:  MOVF   x8C,W
68DA:  SUBLW  3B
68DC:  BNC   68FC
68DE:  MOVF   x8E,W
68E0:  SUBLW  3B
68E2:  BNC   68FC
68E4:  MOVFF  8D,AF
68E8:  MOVFF  8E,B0
68EC:  MOVFF  8B,B1
68F0:  MOVFF  8C,B2
68F4:  CALL   2C9C
68F8:  MOVF   01,F
68FA:  BZ    6930
....................                         { 
....................                            //Si se produce un error de este tipo, se indica 
....................                            lcd_send_byte(LCD_ORDEN, LCD_CLEAR); 
68FC:  CLRF   xAC
68FE:  MOVLW  01
6900:  MOVWF  xAD
6902:  CALL   1314
....................                            printf(lcd_putc, "   Valores\n   incorrectos"); 
6906:  CLRF   x95
6908:  MOVF   x95,W
690A:  CALL   0320
690E:  IORLW  00
6910:  BZ    691C
6912:  INCF   x95,F
6914:  MOVWF  xA7
6916:  CALL   13C0
691A:  BRA    6908
....................                            delay_ms(LCD_T_RETARDO); 
691C:  MOVLW  02
691E:  MOVWF  x95
6920:  MOVLW  FA
6922:  MOVWF  xB0
6924:  CALL   12A8
6928:  DECFSZ x95,F
692A:  BRA    6920
....................                            //Se repite la última iteración del bloque 
....................                            contador--; 
692C:  DECF   x87,F
....................                            continue; 
692E:  BRA    6BB4
....................                         } 
....................  
....................                         //No puede haber un intervalo de encendido de más de 4 horas. 
....................                         //Esto deriva de un problema propio de almacenamiento de números enteros, pero es perfectamente lógico 
....................                         //que un sistema de calefacción tenga un tiempo máximo de encendido para regular el uso abusivo del sistema 
....................                         //y evitar averías por un funcionamiento muy prolongado. 
....................                         if(diferencia_tiempo(pr.horas_inicio, pr.minutos_inicio, pr.horas_fin, pr.minutos_fin)>240) 
6930:  MOVFF  8B,A5
6934:  MOVFF  8C,A6
6938:  MOVFF  8D,A7
693C:  MOVFF  8E,A8
6940:  CALL   2CD0
6944:  MOVFF  02,96
6948:  MOVFF  01,95
694C:  MOVF   x96,F
694E:  BNZ   6956
6950:  MOVF   x95,W
6952:  SUBLW  F0
6954:  BC    698A
....................                         { 
....................                            //Mostramos un aviso 
....................                            lcd_send_byte(LCD_ORDEN, LCD_CLEAR); 
6956:  CLRF   xAC
6958:  MOVLW  01
695A:  MOVWF  xAD
695C:  CALL   1314
....................                            printf(lcd_putc, "Intervalo limite\nde 4 horas"); 
6960:  CLRF   x95
6962:  MOVF   x95,W
6964:  CALL   0354
6968:  IORLW  00
696A:  BZ    6976
696C:  INCF   x95,F
696E:  MOVWF  xA7
6970:  CALL   13C0
6974:  BRA    6962
....................                            delay_ms(LCD_T_RETARDO); 
6976:  MOVLW  02
6978:  MOVWF  x95
697A:  MOVLW  FA
697C:  MOVWF  xB0
697E:  CALL   12A8
6982:  DECFSZ x95,F
6984:  BRA    697A
....................                            //Se repite la última iteración del bloque 
....................                            contador--; 
6986:  DECF   x87,F
....................                            continue; 
6988:  BRA    6BB4
....................  
....................                         } 
....................  
....................                         //El usuario debe ahora introducir el valor del temostato para ese periodo de encendido 
....................                         lcd_send_byte(LCD_ORDEN, LCD_CLEAR); 
698A:  CLRF   xAC
698C:  MOVLW  01
698E:  MOVWF  xAD
6990:  CALL   1314
....................                         printf(lcd_putc, "Termostato %i\n      %cC", contador+1, 223); 
6994:  MOVLW  01
6996:  ADDWF  x87,W
6998:  MOVWF  x95
699A:  CLRF   x96
699C:  MOVF   x96,W
699E:  CALL   038A
69A2:  INCF   x96,F
69A4:  MOVWF  00
69A6:  MOVWF  xA7
69A8:  CALL   13C0
69AC:  MOVLW  0B
69AE:  SUBWF  x96,W
69B0:  BNZ   699C
69B2:  MOVFF  95,97
69B6:  MOVLW  1F
69B8:  MOVWF  x98
69BA:  CALL   36E6
69BE:  MOVLW  0A
69C0:  MOVWF  xA7
69C2:  CALL   13C0
69C6:  MOVLW  06
69C8:  MOVWF  x97
69CA:  MOVLW  20
69CC:  MOVWF  xA7
69CE:  CALL   13C0
69D2:  DECFSZ x97,F
69D4:  BRA    69CA
69D6:  MOVLW  DF
69D8:  MOVWF  xA7
69DA:  CALL   13C0
69DE:  MOVLW  43
69E0:  MOVWF  xA7
69E2:  CALL   13C0
....................                         lcd_gotoxy(4,2); 
69E6:  MOVLW  04
69E8:  MOVWF  xA8
69EA:  MOVLW  02
69EC:  MOVWF  xA9
69EE:  CALL   139E
....................                         lcd_send_byte(LCD_ORDEN, LCD_CURSOR); //Activamos el cursor 
69F2:  CLRF   xAC
69F4:  MOVLW  0E
69F6:  MOVWF  xAD
69F8:  CALL   1314
....................  
....................                         //Recogemos el número introducido por el usuario 
....................                         pr.termostato = buscar_numero(); 
69FC:  CALL   3624
6A00:  MOVFF  01,8F
....................  
....................                         //Eliminamos el cursor 
....................                         lcd_send_byte(LCD_ORDEN, LCD_NO_CURSOR); 
6A04:  CLRF   xAC
6A06:  MOVLW  0C
6A08:  MOVWF  xAD
6A0A:  CALL   1314
....................  
....................                         //Retardamos para que el usuario pueda ver el valor que ha introducido 
....................                         delay_ms(LCD_T_RETARDO); 
6A0E:  MOVLW  02
6A10:  MOVWF  x95
6A12:  MOVLW  FA
6A14:  MOVWF  xB0
6A16:  CALL   12A8
6A1A:  DECFSZ x95,F
6A1C:  BRA    6A12
....................  
....................                         //Si no se cumplen los límites de temperatura especificados para el termostato, no es válido el valor 
....................                         if(pr.termostato>temp_max || pr.termostato<temp_min) 
6A1E:  MOVF   x8F,W
6A20:  SUBLW  20
6A22:  BNC   6A2A
6A24:  MOVF   x8F,W
6A26:  SUBLW  0F
6A28:  BNC   6A5E
....................                         { 
....................                            //Se muestra un mensaje de error 
....................                            lcd_send_byte(LCD_ORDEN, LCD_CLEAR); 
6A2A:  CLRF   xAC
6A2C:  MOVLW  01
6A2E:  MOVWF  xAD
6A30:  CALL   1314
....................                            printf(lcd_putc, "   Valor\n   incorrecto"); 
6A34:  CLRF   x95
6A36:  MOVF   x95,W
6A38:  CALL   0294
6A3C:  IORLW  00
6A3E:  BZ    6A4A
6A40:  INCF   x95,F
6A42:  MOVWF  xA7
6A44:  CALL   13C0
6A48:  BRA    6A36
....................                            delay_ms(LCD_T_RETARDO); 
6A4A:  MOVLW  02
6A4C:  MOVWF  x95
6A4E:  MOVLW  FA
6A50:  MOVWF  xB0
6A52:  CALL   12A8
6A56:  DECFSZ x95,F
6A58:  BRA    6A4E
....................                            //Se repite la última iteración 
....................                            contador--; 
6A5A:  DECF   x87,F
....................                            continue; 
6A5C:  BRA    6BB4
....................                         } 
....................  
....................                         //Comprobamos que los intervalos sean correctos respecto a los otros, es decir, 
....................                         //que no haya solapamiento entre los distintos intervalos programados. 
....................                         for(contador2=0; contador2<contador; contador2++) 
6A5E:  CLRF   x88
6A60:  MOVF   x87,W
6A62:  SUBWF  x88,W
6A64:  BTFSC  FD8.0
6A66:  BRA    6B90
....................                         { 
....................                            //Tomamos las programaciones almacenadas anteriormente 
....................                            pr2 = programaciones[contador2]; 
6A68:  MOVF   x88,W
6A6A:  MULLW  05
6A6C:  MOVF   FF3,W
6A6E:  CLRF   03
6A70:  ADDLW  3B
6A72:  MOVWF  01
6A74:  MOVLW  00
6A76:  ADDWFC 03,F
6A78:  MOVFF  01,95
6A7C:  MOVFF  03,96
6A80:  CLRF   FEA
6A82:  MOVLW  90
6A84:  MOVWF  FE9
6A86:  MOVFF  03,FE2
6A8A:  MOVFF  01,FE1
6A8E:  MOVLW  05
6A90:  MOVWF  01
6A92:  MOVFF  FE6,FEE
6A96:  DECFSZ 01,F
6A98:  BRA    6A92
....................  
....................                            //Controlamos todas las posibilidades de solapamiento 
....................                            if( 
....................                               (comprobar_hora(pr2.horas_inicio, pr2.minutos_inicio, pr.horas_fin, pr.minutos_fin) && 
....................                               !comprobar_hora(pr2.horas_inicio, pr2.minutos_inicio, pr.horas_inicio, pr.minutos_inicio)) 
....................  
....................                               ||(comprobar_hora(pr2.horas_fin, pr2.minutos_fin, pr.horas_fin, pr.minutos_fin) && 
....................                                 !comprobar_hora(pr2.horas_fin, pr2.minutos_fin, pr.horas_inicio, pr.minutos_inicio)) 
....................  
....................                               ||(comprobar_hora(pr.horas_inicio, pr.minutos_inicio, pr2.horas_fin, pr2.minutos_fin) && 
....................                                 !comprobar_hora(pr.horas_inicio, pr.minutos_inicio, pr2.horas_inicio, pr2.minutos_inicio)) 
....................  
....................                               ||(comprobar_hora(pr.horas_fin, pr.minutos_fin, pr2.horas_fin, pr2.minutos_fin) && 
....................                                 !comprobar_hora(pr.horas_fin, pr.minutos_fin, pr2.horas_inicio, pr2.minutos_inicio)) 
....................                            ) 
6A9A:  MOVFF  90,AF
6A9E:  MOVFF  91,B0
6AA2:  MOVFF  8D,B1
6AA6:  MOVFF  8E,B2
6AAA:  CALL   2C9C
6AAE:  MOVF   01,F
6AB0:  BZ    6ACA
6AB2:  MOVFF  90,AF
6AB6:  MOVFF  91,B0
6ABA:  MOVFF  8B,B1
6ABE:  MOVFF  8C,B2
6AC2:  CALL   2C9C
6AC6:  MOVF   01,F
6AC8:  BZ    6B5A
6ACA:  MOVFF  92,AF
6ACE:  MOVFF  93,B0
6AD2:  MOVFF  8D,B1
6AD6:  MOVFF  8E,B2
6ADA:  CALL   2C9C
6ADE:  MOVF   01,F
6AE0:  BZ    6AFA
6AE2:  MOVFF  92,AF
6AE6:  MOVFF  93,B0
6AEA:  MOVFF  8B,B1
6AEE:  MOVFF  8C,B2
6AF2:  CALL   2C9C
6AF6:  MOVF   01,F
6AF8:  BZ    6B5A
6AFA:  MOVFF  8B,AF
6AFE:  MOVFF  8C,B0
6B02:  MOVFF  92,B1
6B06:  MOVFF  93,B2
6B0A:  CALL   2C9C
6B0E:  MOVF   01,F
6B10:  BZ    6B2A
6B12:  MOVFF  8B,AF
6B16:  MOVFF  8C,B0
6B1A:  MOVFF  90,B1
6B1E:  MOVFF  91,B2
6B22:  CALL   2C9C
6B26:  MOVF   01,F
6B28:  BZ    6B5A
6B2A:  MOVFF  8D,AF
6B2E:  MOVFF  8E,B0
6B32:  MOVFF  92,B1
6B36:  MOVFF  93,B2
6B3A:  CALL   2C9C
6B3E:  MOVF   01,F
6B40:  BZ    6B8C
6B42:  MOVFF  8D,AF
6B46:  MOVFF  8E,B0
6B4A:  MOVFF  90,B1
6B4E:  MOVFF  91,B2
6B52:  CALL   2C9C
6B56:  MOVF   01,F
6B58:  BNZ   6B8C
....................                            { 
....................                               //Si hay solapamiento, mostramos un mensaje de error y salimos 
....................                               lcd_send_byte(LCD_ORDEN, LCD_CLEAR); 
6B5A:  CLRF   xAC
6B5C:  MOVLW  01
6B5E:  MOVWF  xAD
6B60:  CALL   1314
....................                               printf(lcd_putc, "Solapamiento\nde intervalos!"); 
6B64:  CLRF   x95
6B66:  MOVF   x95,W
6B68:  CALL   03B6
6B6C:  IORLW  00
6B6E:  BZ    6B7A
6B70:  INCF   x95,F
6B72:  MOVWF  xA7
6B74:  CALL   13C0
6B78:  BRA    6B66
....................                               delay_ms(LCD_T_RETARDO*2); 
6B7A:  MOVLW  04
6B7C:  MOVWF  x95
6B7E:  MOVLW  FA
6B80:  MOVWF  xB0
6B82:  CALL   12A8
6B86:  DECFSZ x95,F
6B88:  BRA    6B7E
....................                               goto salir; 
6B8A:  BRA    6DAC
....................                            } 
....................                         } 
6B8C:  INCF   x88,F
6B8E:  BRA    6A60
....................  
....................                         //Añadimos esta programación a la lista de programaciones 
....................                         programaciones[contador]=pr; 
6B90:  MOVF   x87,W
6B92:  MULLW  05
6B94:  MOVF   FF3,W
6B96:  CLRF   03
6B98:  ADDLW  3B
6B9A:  MOVWF  FE9
6B9C:  MOVLW  00
6B9E:  ADDWFC 03,W
6BA0:  MOVWF  FEA
6BA2:  CLRF   FE2
6BA4:  MOVLW  8B
6BA6:  MOVWF  FE1
6BA8:  MOVLW  05
6BAA:  MOVWF  01
6BAC:  MOVFF  FE6,FEE
6BB0:  DECFSZ 01,F
6BB2:  BRA    6BAC
....................                      } 
6BB4:  INCF   x87,F
6BB6:  BRA    6766
....................  
....................                      //Mostramos un mensaje 
....................                      lcd_send_byte(LCD_ORDEN,LCD_CLEAR); 
6BB8:  CLRF   xAC
6BBA:  MOVLW  01
6BBC:  MOVWF  xAD
6BBE:  CALL   1314
....................                      lcd_send_byte(LCD_ORDEN,LCD_NO_CURSOR); 
6BC2:  CLRF   xAC
6BC4:  MOVLW  0C
6BC6:  MOVWF  xAD
6BC8:  CALL   1314
....................                      printf(lcd_putc, "  Aplicando\n  cambios..."); 
6BCC:  CLRF   x95
6BCE:  MOVF   x95,W
6BD0:  CALL   0260
6BD4:  IORLW  00
6BD6:  BZ    6BE2
6BD8:  INCF   x95,F
6BDA:  MOVWF  xA7
6BDC:  CALL   13C0
6BE0:  BRA    6BCE
....................  
....................                      //Habilitamos la alarma 
....................                      PCF8583_write_byte(PCF8583_CTRL_STATUS_REG, 
....................                                  PCF8583_ACTIVAR_ALARMA); 
6BE2:  CLRF   xAE
6BE4:  MOVLW  04
6BE6:  MOVWF  xAF
6BE8:  CALL   16E8
....................  
....................                      //Guardamos el número de intervalos configurados 
....................                      num_intervalos = contador; 
6BEC:  MOVFF  87,59
....................  
....................                      //Ordenamos las programaciones por orden de hora de inicio 
....................                      ordenar_programaciones(); 
6BF0:  GOTO   37BE
....................  
....................                      //Seleccionamos la próxima alarma a ejecutar 
....................                      seleccionar_alarma(); 
6BF4:  GOTO   38F6
....................  
....................                      //Programamos la próxima alarma para que salte el reloj en el momento indicado 
....................                      programar_proxima_alarma(); 
6BF8:  CALL   2B5C
....................  
....................                      //Indicamos que se trata de una alarma de encendido 
....................                      toca_encender = TRUE; 
6BFC:  BSF    1F.4
....................  
....................                      //Guardamos las programaciones introducidas 
....................                      grabar_programaciones(); 
6BFE:  GOTO   3978
....................  
....................                      break; 
....................  
....................  
....................             //Si es 4, entramos en el modo de revisión y obtención de datos históricos 
....................             case '4': 
....................                      key = 'J'; //Carácter falso para permitir la entrada de datos 
6C02:  MOVLW  4A
6C04:  MOVWF  38
....................                      //Solicitamos la introducción de una clave 
....................                      lcd_send_byte(LCD_ORDEN, LCD_CLEAR); 
6C06:  CLRF   xAC
6C08:  MOVLW  01
6C0A:  MOVWF  xAD
6C0C:  CALL   1314
....................                      lcd_send_byte(LCD_ORDEN, LCD_CURSOR); 
6C10:  CLRF   xAC
6C12:  MOVLW  0E
6C14:  MOVWF  xAD
6C16:  CALL   1314
....................                      printf(lcd_putc, "  CLAVE:\n  "); 
6C1A:  CLRF   x95
6C1C:  MOVF   x95,W
6C1E:  CALL   03EC
6C22:  IORLW  00
6C24:  BZ    6C30
6C26:  INCF   x95,F
6C28:  MOVWF  xA7
6C2A:  CALL   13C0
6C2E:  BRA    6C1C
....................  
....................                      //Habilitamos de nuevo el temporizador para evitar 
....................                      //que el menú esté mucho tiempo activo 
....................                      contador_tiempo = 0; 
6C30:  CLRF   7D
....................                      enable_interrupts(INT_TIMER1); 
6C32:  BSF    F9D.0
....................                      enable_interrupts(GLOBAL); 
6C34:  MOVLW  C0
6C36:  IORWF  FF2,F
....................                       
....................                      //Introducimos primero los dos primero dígitos 
....................                      contador = 0; 
6C38:  CLRF   x87
....................                      while(contador!=2) 
....................                      { 
6C3A:  MOVF   x87,W
6C3C:  SUBLW  02
6C3E:  BZ    6C80
....................                         key = get_key(); 
6C40:  CALL   33BA
6C44:  MOVFF  01,38
....................                         //Si se trata de un número, lo guardamos y mostramos un asterisco 
....................                         //por tratarse de una clave 
....................                         if(isdigit(key)){ 
6C48:  MOVF   38,W
6C4A:  SUBLW  2F
6C4C:  BC    6C76
6C4E:  MOVF   38,W
6C50:  SUBLW  39
6C52:  BNC   6C76
....................                            //Reseteamos el contador de espera 
....................                            contador_tiempo = 0; 
6C54:  CLRF   7D
....................                            lcd_putc('*'); 
6C56:  MOVLW  2A
6C58:  MOVWF  xA7
6C5A:  CALL   13C0
....................                            keys[contador] = key; 
6C5E:  CLRF   03
6C60:  MOVF   x87,W
6C62:  ADDLW  39
6C64:  MOVWF  FE9
6C66:  MOVLW  00
6C68:  ADDWFC 03,W
6C6A:  MOVWF  FEA
6C6C:  MOVFF  38,FEF
....................                            key = 'J'; 
6C70:  MOVLW  4A
6C72:  MOVWF  38
....................                            contador++; 
6C74:  INCF   x87,F
....................                         } 
....................                         //Si transcurre el tiempo máximo, salimos, anulando el flag 
....................                         if(timer_int){ 
6C76:  BTFSS  1F.7
6C78:  BRA    6C7E
....................                            timer_int = FALSE; 
6C7A:  BCF    1F.7
....................                            goto salir; 
6C7C:  BRA    6DAC
....................                         } 
....................                      } 
6C7E:  BRA    6C3A
....................  
....................                      //Convertimos los dígitos introducidos a un valor numérico 
....................                      numero = atoi(keys); 
6C80:  CLRF   xA9
6C82:  MOVLW  39
6C84:  MOVWF  xA8
6C86:  CALL   1450
6C8A:  CLRF   03
6C8C:  MOVFF  01,89
6C90:  MOVFF  03,8A
....................  
....................                      //Repetimos la operación con los dos dígitos menos significativos 
....................                      contador = 0; 
6C94:  CLRF   x87
....................                      while(contador!=2) 
....................                      { 
6C96:  MOVF   x87,W
6C98:  SUBLW  02
6C9A:  BZ    6CDC
....................                         key = get_key(); 
6C9C:  CALL   33BA
6CA0:  MOVFF  01,38
....................                         if(isdigit(key)){ 
6CA4:  MOVF   38,W
6CA6:  SUBLW  2F
6CA8:  BC    6CD2
6CAA:  MOVF   38,W
6CAC:  SUBLW  39
6CAE:  BNC   6CD2
....................                            //Reseteamos el contador de espera 
....................                            contador_tiempo = 0; 
6CB0:  CLRF   7D
....................                            lcd_putc('*'); 
6CB2:  MOVLW  2A
6CB4:  MOVWF  xA7
6CB6:  CALL   13C0
....................                            keys[contador] = key; 
6CBA:  CLRF   03
6CBC:  MOVF   x87,W
6CBE:  ADDLW  39
6CC0:  MOVWF  FE9
6CC2:  MOVLW  00
6CC4:  ADDWFC 03,W
6CC6:  MOVWF  FEA
6CC8:  MOVFF  38,FEF
....................                            key = 'J'; 
6CCC:  MOVLW  4A
6CCE:  MOVWF  38
....................                            contador++; 
6CD0:  INCF   x87,F
....................                         } 
....................                         //Si transcurre el tiempo máximo, salimos, suprimiendo el flag 
....................                         if(timer_int){ 
6CD2:  BTFSS  1F.7
6CD4:  BRA    6CDA
....................                            timer_int = FALSE; 
6CD6:  BCF    1F.7
....................                            goto salir; 
6CD8:  BRA    6DAC
....................                         } 
....................                      } 
6CDA:  BRA    6C96
....................                       
....................                      //Deshabilitamos el control de la espera 
....................                      disable_interrupts(INT_TIMER1); 
6CDC:  BCF    F9D.0
....................                      disable_interrupts(GLOBAL); 
6CDE:  BCF    FF2.6
6CE0:  BCF    FF2.7
6CE2:  BTFSC  FF2.7
6CE4:  BRA    6CE0
....................  
....................                      //Construimos la clave a partir de las dos lecturas 
....................                      numero = numero*100 + atoi(keys); 
6CE6:  MOVFF  8A,B7
6CEA:  MOVFF  89,B6
6CEE:  CLRF   xB9
6CF0:  MOVLW  64
6CF2:  MOVWF  xB8
6CF4:  CALL   18C8
6CF8:  MOVFF  02,96
6CFC:  MOVFF  01,95
6D00:  CLRF   xA9
6D02:  MOVLW  39
6D04:  MOVWF  xA8
6D06:  CALL   1450
6D0A:  CLRF   03
6D0C:  MOVF   01,W
6D0E:  BTFSC  FE8.7
6D10:  DECF   03,F
6D12:  ADDWF  x95,W
6D14:  MOVWF  01
6D16:  MOVF   x96,W
6D18:  ADDWFC 03,F
6D1A:  MOVFF  01,89
6D1E:  MOVFF  03,8A
....................  
....................                      //Retardamos un poco para que el usuario pueda ver que ha introducido 4 dígitos 
....................                      delay_ms(LCD_T_RETARDO); 
6D22:  MOVLW  02
6D24:  MOVWF  x95
6D26:  MOVLW  FA
6D28:  MOVWF  xB0
6D2A:  CALL   12A8
6D2E:  DECFSZ x95,F
6D30:  BRA    6D26
....................  
....................                      if(numero == clave) 
6D32:  MOVF   x89,W
6D34:  SUBLW  61
6D36:  BNZ   6D6E
6D38:  MOVF   x8A,W
6D3A:  SUBLW  09
6D3C:  BNZ   6D6E
....................                      { 
....................                         //Si la clave es correcta, entramos en el modo revisión 
....................                         lcd_send_byte(LCD_ORDEN, LCD_CLEAR); 
6D3E:  CLRF   xAC
6D40:  MOVLW  01
6D42:  MOVWF  xAD
6D44:  CALL   1314
....................                         lcd_send_byte(LCD_ORDEN, LCD_NO_CURSOR); 
6D48:  CLRF   xAC
6D4A:  MOVLW  0C
6D4C:  MOVWF  xAD
6D4E:  CALL   1314
....................                         printf(lcd_putc, "  Modo\n  revision"); 
6D52:  CLRF   x95
6D54:  MOVF   x95,W
6D56:  CALL   0412
6D5A:  IORLW  00
6D5C:  BZ    6D68
6D5E:  INCF   x95,F
6D60:  MOVWF  xA7
6D62:  CALL   13C0
6D66:  BRA    6D54
....................                         //Representamos el contenido de los registros y activamos la interfaz RS-232 
....................                         representar_registros(); 
6D68:  GOTO   3DC0
....................                      }else 
6D6C:  BRA    6DAA
....................                      { 
....................                         //Si la clave es incorrecta, lo indicamos y salimos 
....................                         lcd_send_byte(LCD_ORDEN, LCD_CLEAR); 
6D6E:  CLRF   xAC
6D70:  MOVLW  01
6D72:  MOVWF  xAD
6D74:  CALL   1314
....................                         lcd_send_byte(LCD_ORDEN, LCD_NO_CURSOR); 
6D78:  CLRF   xAC
6D7A:  MOVLW  0C
6D7C:  MOVWF  xAD
6D7E:  CALL   1314
....................                         printf(lcd_putc, "  Clave\n  incorrecta"); 
6D82:  CLRF   x95
6D84:  MOVF   x95,W
6D86:  CALL   043E
6D8A:  IORLW  00
6D8C:  BZ    6D98
6D8E:  INCF   x95,F
6D90:  MOVWF  xA7
6D92:  CALL   13C0
6D96:  BRA    6D84
....................                         delay_ms(LCD_T_RETARDO); 
6D98:  MOVLW  02
6D9A:  MOVWF  x95
6D9C:  MOVLW  FA
6D9E:  MOVWF  xB0
6DA0:  CALL   12A8
6DA4:  DECFSZ x95,F
6DA6:  BRA    6D9C
....................                         goto salir; 
6DA8:  BRA    6DAC
....................                      } 
....................  
....................                      break; 
6DAA:  BRA    6DE8
....................  
....................  
....................             //Si se pulsa NO, salimos del menú de interfaz con el usuario 
....................             case 'N': 
....................                      //Aquí confluyen todas las salidas de esta rutina 
....................                      salir: 
....................                      //Se muestra un mensaje de finalización 
....................                      lcd_send_byte(LCD_ORDEN,LCD_CLEAR); 
6DAC:  CLRF   xAC
6DAE:  MOVLW  01
6DB0:  MOVWF  xAD
6DB2:  CALL   1314
....................                      lcd_send_byte(LCD_ORDEN,LCD_NO_CURSOR); 
6DB6:  CLRF   xAC
6DB8:  MOVLW  0C
6DBA:  MOVWF  xAD
6DBC:  CALL   1314
....................                      printf(lcd_putc, "  Anulando\n  operacion..."); 
6DC0:  CLRF   x95
6DC2:  MOVF   x95,W
6DC4:  CALL   046E
6DC8:  IORLW  00
6DCA:  BZ    6DD6
6DCC:  INCF   x95,F
6DCE:  MOVWF  xA7
6DD0:  CALL   13C0
6DD4:  BRA    6DC2
....................                      delay_ms(LCD_T_RETARDO); 
6DD6:  MOVLW  02
6DD8:  MOVWF  x95
6DDA:  MOVLW  FA
6DDC:  MOVWF  xB0
6DDE:  CALL   12A8
6DE2:  DECFSZ x95,F
6DE4:  BRA    6DDA
....................                      break; 
6DE6:  BRA    6DE8
....................  
....................          } 
....................  
....................          //Volvemos a habilitar las interrupciones 
....................          enable_interrupts(GLOBAL); 
6DE8:  MOVLW  C0
6DEA:  IORWF  FF2,F
....................          enable_interrupts(INT_EXT); 
6DEC:  BSF    FF2.4
....................          enable_interrupts(INT_EXT1); 
6DEE:  BSF    FF0.3
....................  
....................          //Se desactiva el flag de indicación de la interrupción 
....................          led_int = FALSE; 
6DF0:  BCF    1F.5
....................       } 
....................  
....................       //Comenzamos el bloque de comprobación de parámetros y activación de los procesos necesarios. 
....................  
....................       //Comparamos primero la temperatura del agua en la caldera. Esta comprobación se 
....................       //realiza siempre, independientemente de que el sistema esté o no encendido. 
....................       if(C1OUT) 
6DF2:  BTFSS  FB4.6
6DF4:  BRA    6E14
....................       { 
....................          //Entramos aquí si la temperatura de la caldera es menor que la necesaria 
....................          if(temperatura_caldera_superada) 
6DF6:  BTFSS  1F.0
6DF8:  BRA    6E0A
....................          { 
....................             //Si la temperatura de la caldera estaba superada la última vez, tenemos en cuenta cierta histéresis 
....................             //de los valores. 
....................             if(!comp_caldera()) 
6DFA:  GOTO   5984
6DFE:  MOVF   01,F
6E00:  BNZ   6E08
....................             { 
....................                //Si la temperatura de la caldera es menor que la necesaria, encendemos la caldera. 
....................                temperatura_caldera_superada = FALSE; 
6E02:  BCF    1F.0
....................                encender_caldera(); 
6E04:  CALL   5B4A
....................             } 
....................  
....................          } 
....................          else if(!caldera_encendida) 
6E08:  BRA    6E12
6E0A:  BTFSC  F83.5
6E0C:  BRA    6E12
....................          { 
....................             //Si no estaba encendida, la encendemos 
....................             encender_caldera(); 
6E0E:  CALL   5B4A
....................          } 
....................       } 
....................       else 
6E12:  BRA    6E22
....................       { 
....................          //Si la temperatura de la caldera es mayor que la necesaria, apagamos la caldera si está encendida 
....................          //y activamos el flag correspondiente 
....................          if(!temperatura_caldera_superada) 
6E14:  BTFSC  1F.0
6E16:  BRA    6E1A
....................             temperatura_caldera_superada = TRUE; 
6E18:  BSF    1F.0
....................          if(caldera_encendida) 
6E1A:  BTFSS  F83.5
6E1C:  BRA    6E22
....................             apagar_caldera(); 
6E1E:  GOTO   5B64
....................       } 
....................  
....................       //Leemos el código de estado de los sensores 
....................       valor = comprobar_temperatura(); 
6E22:  GOTO   5D06
6E26:  MOVFF  01,84
....................  
....................       //Comprobamos que el sistema no lleve encendido más de 4 horas, ya que en ese caso hay riesgo de avería 
....................       //(en realidad esta limitación deriva de un problema propio de representación en memoria). 
....................       //Ya leimos el tiempo en comprobar_temperatura(), así que no necesitamos leerlo de nuevo. 
....................       if(sistema_encendido && diferencia_tiempo(hora_encendido, minutos_encendido, tiempo.hours, tiempo.minutes)>240) 
6E2A:  BTFSS  F83.4
6E2C:  BRA    6ED6
6E2E:  MOVFF  62,A5
6E32:  MOVFF  63,A6
6E36:  MOVFF  5D,A7
6E3A:  MOVFF  5C,A8
6E3E:  CALL   2CD0
6E42:  MOVFF  02,96
6E46:  MOVFF  01,95
6E4A:  MOVF   x96,F
6E4C:  BNZ   6E54
6E4E:  MOVF   x95,W
6E50:  SUBLW  F0
6E52:  BC    6ED6
....................       { 
....................          //Si la diferencia de tiempo es mayor que 4 horas, lo indicamos y apagamos los motores y el sistema 
....................          lcd_send_byte(LCD_ORDEN,LCD_CLEAR); 
6E54:  CLRF   xAC
6E56:  MOVLW  01
6E58:  MOVWF  xAD
6E5A:  CALL   1314
....................          printf(lcd_putc, "Demasiado tiempo\nencendido!"); 
6E5E:  CLRF   x95
6E60:  MOVF   x95,W
6E62:  CALL   04A2
6E66:  IORLW  00
6E68:  BZ    6E74
6E6A:  INCF   x95,F
6E6C:  MOVWF  xA7
6E6E:  CALL   13C0
6E72:  BRA    6E60
....................          delay_ms(2*LCD_T_RETARDO); 
6E74:  MOVLW  04
6E76:  MOVWF  x95
6E78:  MOVLW  FA
6E7A:  MOVWF  xB0
6E7C:  CALL   12A8
6E80:  DECFSZ x95,F
6E82:  BRA    6E78
....................          lcd_send_byte(LCD_ORDEN,LCD_CLEAR); 
6E84:  CLRF   xAC
6E86:  MOVLW  01
6E88:  MOVWF  xAD
6E8A:  CALL   1314
....................          printf(lcd_putc, "  Apagando\n  sistema..."); 
6E8E:  CLRF   x95
6E90:  MOVF   x95,W
6E92:  CALL   0196
6E96:  IORLW  00
6E98:  BZ    6EA4
6E9A:  INCF   x95,F
6E9C:  MOVWF  xA7
6E9E:  CALL   13C0
6EA2:  BRA    6E90
....................          apagar_sistema(); 
6EA4:  CALL   2F68
....................  
....................          motor1 = FALSE; 
6EA8:  BCF    F83.6
....................          motor2 = FALSE; 
6EAA:  BCF    F83.7
....................  
....................          //Si estaba encendido por alguna alarma, recuperamos el termostato anterior. 
....................          if(encendido_por_alarma) 
6EAC:  BTFSS  1F.3
6EAE:  BRA    6ED2
....................          { 
....................             termostato1 = termostato2 = termostato_provisional; 
6EB0:  MOVFF  2B,27
6EB4:  MOVFF  2A,26
6EB8:  MOVFF  29,25
6EBC:  MOVFF  28,24
6EC0:  MOVFF  27,23
6EC4:  MOVFF  26,22
6EC8:  MOVFF  25,21
6ECC:  MOVFF  24,20
....................             encendido_por_alarma = FALSE; 
6ED0:  BCF    1F.3
....................          } 
....................  
....................          goto inicio; 
6ED2:  GOTO   60B8
....................  
....................       } 
....................  
....................       //Comprobamos ahora la temperatura de la vivienda. Esto se realiza sólo si el sistema está encendido 
....................       if(valor && sistema_encendido && temperatura_caldera_superada) 
6ED6:  MOVF   x84,F
6ED8:  BZ    6F00
6EDA:  BTFSS  F83.4
6EDC:  BRA    6F00
6EDE:  BTFSS  1F.0
6EE0:  BRA    6F00
....................       { 
....................          //Si la temperatura es menor que la necesaria, el sistema está encendido y la temperatura del 
....................          //agua en la caldera es la adecuada, encendemos el motor de circulación del agua necesario 
....................          if(valor==1) 
6EE2:  DECFSZ x84,W
6EE4:  BRA    6EEA
....................          { 
....................             motor1 = TRUE; 
6EE6:  BSF    F83.6
....................             motor2 = FALSE; 
6EE8:  BCF    F83.7
....................          } 
....................          if(valor==2) 
6EEA:  MOVF   x84,W
6EEC:  SUBLW  02
6EEE:  BNZ   6EF4
....................          { 
....................             motor1 = FALSE; 
6EF0:  BCF    F83.6
....................             motor2 = TRUE; 
6EF2:  BSF    F83.7
....................          } 
....................          if(valor==3) 
6EF4:  MOVF   x84,W
6EF6:  SUBLW  03
6EF8:  BNZ   6EFE
....................          { 
....................             motor1 = TRUE; 
6EFA:  BSF    F83.6
....................             motor2 = TRUE; 
6EFC:  BSF    F83.7
....................          } 
....................  
....................       } 
....................       else 
6EFE:  BRA    6F04
....................       { 
....................         //Si no se cumplen las condiciones, apagamos los motores si están encendidos 
....................         motor1 = FALSE; 
6F00:  BCF    F83.6
....................         motor2 = FALSE; 
6F02:  BCF    F83.7
....................       } 
....................  
....................       //Activamos el perro guardián 
....................       setup_wdt(WDT_ON); 
6F04:  BSF    FD1.0
....................  
....................       //Ponemos a "dormir" al microcontrolador para que el gasto de energía sea menor 
....................       //Esto lo hacemos sólo si no se han levantado los flags de interrupción en estos segundos, 
....................       //ya que esto provocaría que se aplazase la gestión de la interrupción hasta que saltase el 
....................       //perro guardián. 
....................       if(!alarma_int && !led_int) 
6F06:  BTFSC  1F.6
6F08:  BRA    6F10
6F0A:  BTFSC  1F.5
6F0C:  BRA    6F10
....................          sleep(); 
6F0E:  SLEEP 
....................  
....................    } 
6F10:  GOTO   60B8
....................  
.................... } 
....................  
.................... ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 
.................... //**************************************************************************** 
.................... //    Descripción de los métodos utilizados ordenados por orden alfabético 
.................... //**************************************************************************** 
.................... //Puede verse una explicación general de su función al principio del programa 
....................  
.................... void apagar_caldera() 
.................... { 
6F14:  SLEEP 
....................    int hora, minutos, segundos; //Variables para el tiempo 
....................  
....................    //Leemos el tiempo 
....................    PCF8583_read_datetime(&tiempo); 
*
5B64:  CLRF   xA6
5B66:  MOVLW  5B
5B68:  MOVWF  xA5
5B6A:  CALL   28AE
....................  
....................    //Copiamos en las variables 
....................    hora = tiempo.hours; 
5B6E:  MOVFF  5D,95
....................    minutos = tiempo.minutes; 
5B72:  MOVFF  5C,96
....................    segundos = tiempo.seconds; 
5B76:  MOVFF  5B,97
....................  
....................    //Sumamos al tiempo total de encendido de la caldera el tiempo que ha estado encendida esta vez 
....................    t_total_caldera = t_total_caldera + diferencia_tiempo_sec(hora_caldera, minutos_caldera, segundos_caldera, hora, minutos, segundos); 
5B7A:  MOVFF  64,A5
5B7E:  MOVFF  65,A6
5B82:  MOVFF  66,A7
5B86:  MOVFF  95,A8
5B8A:  MOVFF  96,A9
5B8E:  MOVFF  97,AA
5B92:  CALL   2DC4
5B96:  MOVF   01,W
5B98:  ADDWF  67,F
5B9A:  MOVF   02,W
5B9C:  ADDWFC 68,F
....................  
....................    //Apagamos la caldera 
....................    caldera_encendida = FALSE; 
5B9E:  BCF    F83.5
.................... } 
5BA0:  GOTO   6E22 (RETURN)
....................  
.................... //----------------------------------------------------------------------------------------------------------------------------------------- 
....................  
.................... void apagar_sistema() 
.................... { 
....................    long minutos_trans;  //Minutos transcurridos desde el encendido del sistema 
....................    int t_entera, t_decimal; //Temperatura del hogar en ese momento (parte entera y decimal) 
....................    float temperatura;  //Temperatura leída 
....................    int data[8];  //Vector para almacenar los datos a guardar 
....................  
....................    //Apagamos el sistema 
....................    sistema_encendido = FALSE; 
*
2F68:  BCF    F83.4
....................  
....................    //Guardamos todos los datos en memoria. Esto llevará tiempo, así que apagamos también los motores 
....................    //para no esperar a la rutina de comprobación de la temperatura 
....................    motor1 = FALSE; 
2F6A:  BCF    F83.6
....................    motor2 = FALSE; 
2F6C:  BCF    F83.7
....................  
....................    //Si llegamos al límite de la memoria, se resetea el indicador 
....................    if((eeprom_registros + num_registros*2*8)>=0x1000) 
2F6E:  BCF    FD8.0
2F70:  RLCF   69,W
2F72:  MOVWF  xA5
2F74:  RLCF   6A,W
2F76:  MOVWF  xA6
2F78:  RLCF   xA5,W
2F7A:  MOVWF  02
2F7C:  RLCF   xA6,W
2F7E:  MOVWF  03
2F80:  RLCF   02,F
2F82:  RLCF   03,F
2F84:  RLCF   02,F
2F86:  RLCF   03,F
2F88:  MOVLW  F8
2F8A:  ANDWF  02,F
2F8C:  MOVF   02,W
2F8E:  ADDLW  50
2F90:  MOVWF  xA7
2F92:  MOVLW  00
2F94:  ADDWFC 03,W
2F96:  MOVWF  xA8
2F98:  SUBLW  0F
2F9A:  BC    2FA0
....................       num_registros = 0; 
2F9C:  CLRF   6A
2F9E:  CLRF   69
....................  
....................    //Leemos el tiempo actual 
....................    PCF8583_read_datetime(&tiempo); 
2FA0:  CLRF   xA6
2FA2:  MOVLW  5B
2FA4:  MOVWF  xA5
2FA6:  RCALL  28AE
....................  
....................    //Almacenamos en el vector los valores del tiempo 
....................    data[0] = tiempo.day;                  //Día de desconexión 
2FA8:  MOVFF  5E,9D
....................    data[1] = tiempo.month;                //Mes de desconexión 
2FAC:  MOVFF  5F,9E
....................    data[2] = tiempo.hours;                //Hora de desconexión 
2FB0:  MOVFF  5D,9F
....................    data[3] = tiempo.minutes;              //Minutos de desconexión 
2FB4:  MOVFF  5C,A0
....................  
....................    //Leemos la temperatura de la zona 1 en ese momento 
....................    temperatura1 = ds1820_read(dir1); 
2FB8:  CLRF   xA6
2FBA:  MOVLW  6D
2FBC:  MOVWF  xA5
2FBE:  CALL   2280
2FC2:  MOVFF  03,2F
2FC6:  MOVFF  02,2E
2FCA:  MOVFF  01,2D
2FCE:  MOVFF  00,2C
....................  
....................    //Descomponemos la temperatura en su parte entera y parte decimal para almacenarla 
....................    t_entera = (int)temperatura1; 
2FD2:  MOVFF  2F,AC
2FD6:  MOVFF  2E,AB
2FDA:  MOVFF  2D,AA
2FDE:  MOVFF  2C,A9
2FE2:  CALL   188E
2FE6:  MOVFF  01,97
....................    t_decimal = (int)((temperatura1-t_entera)*100); 
2FEA:  MOVLB  2
2FEC:  CLRF   xB0
2FEE:  MOVFF  97,2AF
2FF2:  MOVLB  0
2FF4:  CALL   276A
2FF8:  BSF    FD8.1
2FFA:  MOVFF  2F,2AC
2FFE:  MOVFF  2E,2AB
3002:  MOVFF  2D,2AA
3006:  MOVFF  2C,2A9
300A:  MOVFF  03,2B0
300E:  MOVFF  02,2AF
3012:  MOVFF  01,2AE
3016:  MOVFF  00,2AD
301A:  CALL   24F0
301E:  MOVFF  00,A5
3022:  MOVFF  01,A6
3026:  MOVFF  02,A7
302A:  MOVFF  03,A8
302E:  MOVFF  03,2C8
3032:  MOVFF  02,2C7
3036:  MOVFF  01,2C6
303A:  MOVFF  00,2C5
303E:  MOVLB  2
3040:  CLRF   xCC
3042:  CLRF   xCB
3044:  MOVLW  48
3046:  MOVWF  xCA
3048:  MOVLW  85
304A:  MOVWF  xC9
304C:  MOVLB  0
304E:  RCALL  2BA4
3050:  MOVFF  03,AC
3054:  MOVFF  02,AB
3058:  MOVFF  01,AA
305C:  MOVFF  00,A9
3060:  CALL   188E
3064:  MOVFF  01,98
....................  
....................    //Almacenamos los valores 
....................    data[4] = t_entera;                    //Valor entero de última temperatura medida en la zona 1 
3068:  MOVFF  97,A1
....................    data[5] = t_decimal;                   //Valor decimal de última temperatura medida en la zona 1 
306C:  MOVFF  98,A2
....................  
....................    //Repetimos el proceso con la temperatura de la zona 2 
....................    temperatura2 = ds1820_read(dir2); 
3070:  CLRF   xA6
3072:  MOVLW  75
3074:  MOVWF  xA5
3076:  CALL   2280
307A:  MOVFF  03,33
307E:  MOVFF  02,32
3082:  MOVFF  01,31
3086:  MOVFF  00,30
....................    t_entera = (int)temperatura2; 
308A:  MOVFF  33,AC
308E:  MOVFF  32,AB
3092:  MOVFF  31,AA
3096:  MOVFF  30,A9
309A:  CALL   188E
309E:  MOVFF  01,97
....................    t_decimal = (int)((temperatura2-t_entera)*100); 
30A2:  MOVLB  2
30A4:  CLRF   xB0
30A6:  MOVFF  97,2AF
30AA:  MOVLB  0
30AC:  CALL   276A
30B0:  BSF    FD8.1
30B2:  MOVFF  33,2AC
30B6:  MOVFF  32,2AB
30BA:  MOVFF  31,2AA
30BE:  MOVFF  30,2A9
30C2:  MOVFF  03,2B0
30C6:  MOVFF  02,2AF
30CA:  MOVFF  01,2AE
30CE:  MOVFF  00,2AD
30D2:  CALL   24F0
30D6:  MOVFF  00,A5
30DA:  MOVFF  01,A6
30DE:  MOVFF  02,A7
30E2:  MOVFF  03,A8
30E6:  MOVFF  03,2C8
30EA:  MOVFF  02,2C7
30EE:  MOVFF  01,2C6
30F2:  MOVFF  00,2C5
30F6:  MOVLB  2
30F8:  CLRF   xCC
30FA:  CLRF   xCB
30FC:  MOVLW  48
30FE:  MOVWF  xCA
3100:  MOVLW  85
3102:  MOVWF  xC9
3104:  MOVLB  0
3106:  RCALL  2BA4
3108:  MOVFF  03,AC
310C:  MOVFF  02,AB
3110:  MOVFF  01,AA
3114:  MOVFF  00,A9
3118:  CALL   188E
311C:  MOVFF  01,98
....................  
....................    //Almacenamos 
....................    data[6] = t_entera;                    //Valor entero de última temperatura medida en la zona 2 
3120:  MOVFF  97,A3
....................    data[7] = t_decimal;                   //Valor decimal de última temperatura medida en la zona 2 
3124:  MOVFF  98,A4
....................  
....................    //Grabamos los datos en memoria 
....................    graba_ee((unsigned long)eeprom_registros + num_registros*(unsigned long)2*(unsigned long)8, 8, data); 
3128:  BCF    FD8.0
312A:  RLCF   69,W
312C:  MOVWF  xA5
312E:  RLCF   6A,W
3130:  MOVWF  xA6
3132:  RLCF   xA5,W
3134:  MOVWF  02
3136:  RLCF   xA6,W
3138:  MOVWF  03
313A:  RLCF   02,F
313C:  RLCF   03,F
313E:  RLCF   02,F
3140:  RLCF   03,F
3142:  MOVLW  F8
3144:  ANDWF  02,F
3146:  MOVF   02,W
3148:  ADDLW  50
314A:  MOVWF  xA7
314C:  MOVLW  00
314E:  ADDWFC 03,W
3150:  MOVWF  xA8
3152:  MOVWF  xAC
3154:  MOVFF  A7,AB
3158:  MOVLW  08
315A:  MOVWF  xAD
315C:  CLRF   xAF
315E:  MOVLW  9D
3160:  MOVWF  xAE
3162:  CALL   18E6
....................  
....................  
....................    //Calculamos el año en el que nos encontramos 
....................    if(anno_actual_0_to_3 != tiempo.year) 
3166:  MOVF   60,W
3168:  SUBWF  6C,W
316A:  BZ    318C
....................    { 
....................       //Si el año que teníamos almacenado no es igual que el que marca el reloj, 
....................       //debemos de actualizar las variables correspondientes. 
....................       anno_actual++; 
316C:  INCF   6B,F
....................       anno_actual_0_to_3++; 
316E:  INCF   6C,F
....................  
....................       //Guardamos los valores en el vector data 
....................       data[0] = anno_actual; 
3170:  MOVFF  6B,9D
....................       data[1] = anno_actual_0_to_3; 
3174:  MOVFF  6C,9E
....................  
....................       //Guardamos los valores en memoria 
....................       graba_ee(eeprom_anno_actual, 2, data); 
3178:  CLRF   xAC
317A:  MOVLW  14
317C:  MOVWF  xAB
317E:  MOVLW  02
3180:  MOVWF  xAD
3182:  CLRF   xAF
3184:  MOVLW  9D
3186:  MOVWF  xAE
3188:  CALL   18E6
....................    } 
....................  
....................    //Guardamos el año en el que nos encontramos 
....................    data[0] = anno_actual; 
318C:  MOVFF  6B,9D
....................  
....................    //Calculamos los minutos transcurridos desde el encendido como una diferencia de tiempos 
....................    minutos_trans = diferencia_tiempo(hora_encendido, minutos_encendido, tiempo.hours, tiempo.minutes); 
3190:  MOVFF  62,A5
3194:  MOVFF  63,A6
3198:  MOVFF  5D,A7
319C:  MOVFF  5C,A8
31A0:  RCALL  2CD0
31A2:  MOVFF  02,96
31A6:  MOVFF  01,95
....................  
....................    //Si la caldera estaba encendida, sumamos el último intervalo de encendido al tiempo total 
....................    if(caldera_encendida) 
31AA:  BTFSS  F83.5
31AC:  BRA    31D0
....................       t_total_caldera = t_total_caldera + diferencia_tiempo_sec(hora_caldera, minutos_caldera, segundos_caldera, tiempo.hours, tiempo.minutes, tiempo.seconds); 
31AE:  MOVFF  64,A5
31B2:  MOVFF  65,A6
31B6:  MOVFF  66,A7
31BA:  MOVFF  5D,A8
31BE:  MOVFF  5C,A9
31C2:  MOVFF  5B,AA
31C6:  RCALL  2DC4
31C8:  MOVF   01,W
31CA:  ADDWF  67,F
31CC:  MOVF   02,W
31CE:  ADDWFC 68,F
....................  
....................    //Guardamos los dos tiempos calculados 
....................    data[1] = (unsigned int)minutos_trans;          //Minutos transcurridos desde el encendido 
31D0:  MOVFF  95,9E
....................    data[2] = (unsigned int)(t_total_caldera/60);   //Tiempo total que ha estado encendida la caldera 
31D4:  MOVFF  68,A6
31D8:  MOVFF  67,A5
31DC:  CLRF   xA8
31DE:  MOVLW  3C
31E0:  MOVWF  xA7
31E2:  BRA    2F22
31E4:  MOVFF  01,9F
....................                                                    //en este intervalo (en minutos) 
....................  
....................    //Guardamos también el valor del termostato teniendo en cuenta la histéresis 
....................    if(temp_habitacion_superada1) 
31E8:  BTFSS  1F.1
31EA:  BRA    322C
....................       data[3]=(int)(termostato1+histeresis_vivienda); 
31EC:  BCF    FD8.1
31EE:  MOVFF  23,2AC
31F2:  MOVFF  22,2AB
31F6:  MOVFF  21,2AA
31FA:  MOVFF  20,2A9
31FE:  MOVFF  37,2B0
3202:  MOVFF  36,2AF
3206:  MOVFF  35,2AE
320A:  MOVFF  34,2AD
320E:  CALL   24F0
3212:  MOVFF  03,AC
3216:  MOVFF  02,AB
321A:  MOVFF  01,AA
321E:  MOVFF  00,A9
3222:  CALL   188E
3226:  MOVFF  01,A0
....................    else 
322A:  BRA    3244
....................       data[3]=(int)termostato1; 
322C:  MOVFF  23,AC
3230:  MOVFF  22,AB
3234:  MOVFF  21,AA
3238:  MOVFF  20,A9
323C:  CALL   188E
3240:  MOVFF  01,A0
....................  
....................    //Grabamos esta segunda tanda de datos 
....................    graba_ee((unsigned long)eeprom_registros + num_registros*2*8 + 8, 4, data); 
3244:  BCF    FD8.0
3246:  RLCF   69,W
3248:  MOVWF  xA5
324A:  RLCF   6A,W
324C:  MOVWF  xA6
324E:  RLCF   xA5,W
3250:  MOVWF  02
3252:  RLCF   xA6,W
3254:  MOVWF  03
3256:  RLCF   02,F
3258:  RLCF   03,F
325A:  RLCF   02,F
325C:  RLCF   03,F
325E:  MOVLW  F8
3260:  ANDWF  02,F
3262:  MOVF   02,W
3264:  ADDLW  50
3266:  MOVWF  xA7
3268:  MOVLW  00
326A:  ADDWFC 03,W
326C:  MOVWF  xA8
326E:  MOVLW  08
3270:  ADDWF  xA7,W
3272:  MOVWF  xA9
3274:  MOVLW  00
3276:  ADDWFC xA8,W
3278:  MOVWF  xAA
327A:  MOVWF  xAC
327C:  MOVFF  A9,AB
3280:  MOVLW  04
3282:  MOVWF  xAD
3284:  CLRF   xAF
3286:  MOVLW  9D
3288:  MOVWF  xAE
328A:  CALL   18E6
....................  
....................    //Aumentamos en uno el número de registros 
....................    num_registros++; 
328E:  INCF   69,F
3290:  BTFSC  FD8.2
3292:  INCF   6A,F
....................  
....................    //Guardamos el número de registros en memoria (descomponiendo antes en dos int) 
....................    data[0] = (int)(num_registros/256); 
3294:  MOVF   6A,W
3296:  MOVWF  x9D
....................    data[1] = (int)(num_registros - data[0]*256); 
3298:  CLRF   xB7
329A:  MOVFF  9D,B6
329E:  MOVLW  01
32A0:  MOVWF  xB9
32A2:  CLRF   xB8
32A4:  CALL   18C8
32A8:  MOVF   01,W
32AA:  SUBWF  69,W
32AC:  MOVWF  00
32AE:  MOVF   02,W
32B0:  SUBWFB 6A,W
32B2:  MOVFF  00,9E
....................  
....................    graba_ee(eeprom_num_registros, 2, data); 
32B6:  CLRF   xAC
32B8:  MOVLW  12
32BA:  MOVWF  xAB
32BC:  MOVLW  02
32BE:  MOVWF  xAD
32C0:  CLRF   xAF
32C2:  MOVLW  9D
32C4:  MOVWF  xAE
32C6:  CALL   18E6
.................... } 
32CA:  RETLW  00
....................  
.................... //----------------------------------------------------------------------------------------------------------------------------------------- 
....................  
.................... int buscar_numero(){ 
....................    //Variables auxiliares 
....................    int contador = 0; 
*
3624:  CLRF   x95
....................    int numero; 
....................  
....................    //Carácter falso para evitar confusiones 
....................    key = 'J'; 
3626:  MOVLW  4A
3628:  MOVWF  38
....................  
....................    //Habilitamos el temporizador para evitar que el usuario mantenga 
....................    //mucho tiempo el menú activo 
....................    contador_tiempo = 0; 
362A:  CLRF   7D
....................    enable_interrupts(INT_TIMER1); 
362C:  BSF    F9D.0
....................    enable_interrupts(GLOBAL); 
362E:  MOVLW  C0
3630:  IORWF  FF2,F
....................  
....................    //Se continua la búsqueda hasta que no se pulse SI o NO o hasta 
....................    //que no se introduzca un número de 2 cifras. 
....................    while(key != 'N' && key!='S' && contador!=2) 
....................    { 
3632:  MOVF   38,W
3634:  SUBLW  4E
3636:  BZ    3684
3638:  MOVF   38,W
363A:  SUBLW  53
363C:  BZ    3684
363E:  MOVF   x95,W
3640:  SUBLW  02
3642:  BZ    3684
....................       key = get_key(); 
3644:  RCALL  33BA
3646:  MOVFF  01,38
....................       //Si la tecla corresponde a un dígito, la imprimimos por pantalla 
....................       //y pasamos a la siguiente 
....................       if(isdigit(key)){ 
364A:  MOVF   38,W
364C:  SUBLW  2F
364E:  BC    3678
3650:  MOVF   38,W
3652:  SUBLW  39
3654:  BNC   3678
....................          //Reseteamos el contador de tiempo 
....................          contador_tiempo = 0; 
3656:  CLRF   7D
....................          lcd_putc(key); 
3658:  MOVFF  38,A7
365C:  CALL   13C0
....................          keys[contador] = key; 
3660:  CLRF   03
3662:  MOVF   x95,W
3664:  ADDLW  39
3666:  MOVWF  FE9
3668:  MOVLW  00
366A:  ADDWFC 03,W
366C:  MOVWF  FEA
366E:  MOVFF  38,FEF
....................          key = 'J'; 
3672:  MOVLW  4A
3674:  MOVWF  38
....................          contador++; 
3676:  INCF   x95,F
....................       } 
....................       //Si salta el tiempo previsto, devuelve el valor de anulación de la operación 
....................       if(timer_int){ 
3678:  BTFSS  1F.7
367A:  BRA    3682
....................          key = 'N'; 
367C:  MOVLW  4E
367E:  MOVWF  38
....................          timer_int = FALSE; //Desactivamos el flag 
3680:  BCF    1F.7
....................       } 
....................    } 
3682:  BRA    3632
....................     
....................    //Volvemos a deshabilitar la interrupción del timer 
....................    disable_interrupts(INT_TIMER1); 
3684:  BCF    F9D.0
....................    disable_interrupts(GLOBAL); 
3686:  BCF    FF2.6
3688:  BCF    FF2.7
368A:  BTFSC  FF2.7
368C:  BRA    3688
....................  
....................    //Si la tecla es NO, devolvemos el código correspondiente 
....................    if(key == 'N') 
368E:  MOVF   38,W
3690:  SUBLW  4E
3692:  BNZ   369A
....................       return NO; 
3694:  MOVLW  64
3696:  MOVWF  01
3698:  BRA    36B8
....................  
....................    //Procedemos de la misma manera si es SÍ 
....................    if(key == 'S') 
369A:  MOVF   38,W
369C:  SUBLW  53
369E:  BNZ   36A6
....................       return SI; 
36A0:  MOVLW  65
36A2:  MOVWF  01
36A4:  BRA    36B8
....................  
....................    //Transformamos los caracteres a entero 
....................    numero = atoi(keys); 
36A6:  CLRF   xA9
36A8:  MOVLW  39
36AA:  MOVWF  xA8
36AC:  CALL   1450
36B0:  MOVFF  01,96
....................  
....................    //Devolvemos el resultado 
....................    return numero; 
36B4:  MOVFF  96,01
.................... } 
36B8:  RETLW  00
....................  
.................... //----------------------------------------------------------------------------------------------------------------------------------------- 
....................  
.................... int buscar_numero_rs232(){ 
....................    char c[3]; //Cadena que contendrá los números en caracteres 
....................  
....................    //Iniciamos los caracteres a valores nulos que no se correspondan con números 
....................    //Además, esto nos servirá para que c[2] marque el fin de la cadena a la hora de aplicar 
....................    //el método atoi(). 
....................    c[0]=c[1]=c[2]='\0'; 
*
15EA:  CLRF   xA7
15EC:  MOVFF  A7,A6
15F0:  MOVFF  A6,A5
....................  
....................    //Leemos la primera cifra del número 
....................    while(!isdigit(c[0]) && c[0]!='\b') 
....................       c[0]=getch(); 
15F4:  MOVF   xA5,W
15F6:  SUBLW  2F
15F8:  BC    1600
15FA:  MOVF   xA5,W
15FC:  SUBLW  39
15FE:  BC    1610
1600:  MOVF   xA5,W
1602:  SUBLW  08
1604:  BZ    1610
1606:  BTFSS  F9E.5
1608:  BRA    1606
160A:  MOVFF  FAE,A5
160E:  BRA    15F4
....................    //Si se trata de un "backspace", devolvemos un mensaje de anulación de operación 
....................    if(c[0]=='\b') 
1610:  MOVF   xA5,W
1612:  SUBLW  08
1614:  BNZ   161C
....................       return NO; 
1616:  MOVLW  64
1618:  MOVWF  01
161A:  BRA    165E
....................    //Imprimimos la primera cifra 
....................    printf("%c", c[0]); 
161C:  MOVF   xA5,W
161E:  BTFSS  F9E.4
1620:  BRA    161E
1622:  MOVWF  FAD
....................  
....................    //Leemos la segunda cifra del número, procediendo de la misma manera 
....................    while(!isdigit(c[1]) && c[1]!='\b') 
....................       c[1]=getch(); 
1624:  MOVF   xA6,W
1626:  SUBLW  2F
1628:  BC    1630
162A:  MOVF   xA6,W
162C:  SUBLW  39
162E:  BC    1640
1630:  MOVF   xA6,W
1632:  SUBLW  08
1634:  BZ    1640
1636:  BTFSS  F9E.5
1638:  BRA    1636
163A:  MOVFF  FAE,A6
163E:  BRA    1624
....................    if(c[1]=='\b') 
1640:  MOVF   xA6,W
1642:  SUBLW  08
1644:  BNZ   164C
....................       return NO; 
1646:  MOVLW  64
1648:  MOVWF  01
164A:  BRA    165E
....................    printf("%c", c[1]); 
164C:  MOVF   xA6,W
164E:  BTFSS  F9E.4
1650:  BRA    164E
1652:  MOVWF  FAD
....................  
....................    //Transformamos a entero la cadena y la devolvemos 
....................    return atoi(c); 
1654:  CLRF   xA9
1656:  MOVLW  A5
1658:  MOVWF  xA8
165A:  RCALL  1450
165C:  MOVF   01,W
.................... } 
165E:  RETLW  00
....................  
.................... //----------------------------------------------------------------------------------------------------------------------------------------- 
....................  
.................... int comp_caldera() 
.................... { 
....................    //Suponemos una variación de la temperatura del agua en la caldera de t_max_calderaºC 
....................    //a t_min_calderaºC, con una precisión que depende del potenciómetro. 
....................  
....................    //Variables para registrar el termostato y la temperatura de la caldera 
....................    float termo, temp; 
....................  
....................    //Establecemos como entrada analógica a analizar la del termostato 
....................    set_adc_channel(termostato_caldera); 
*
5984:  MOVLW  0C
5986:  MOVWF  01
5988:  MOVF   FC2,W
598A:  ANDLW  C3
598C:  IORWF  01,W
598E:  MOVWF  FC2
....................    delay_us(10);  //Retraso para posibilitar la lectura 
5990:  CLRWDT
5992:  MOVLW  06
5994:  MOVWF  00
5996:  DECFSZ 00,F
5998:  BRA    5996
....................    //Transformamos el valor analógico leído en la escala utilizada por el termostato 
....................    termo = t_min_caldera + ((t_max_caldera-t_min_caldera)*(float)read_adc())/AD_num_valores; 
599A:  BSF    FC2.1
599C:  BTFSC  FC2.1
599E:  BRA    599C
59A0:  MOVF   FC4,W
59A2:  MOVLB  2
59A4:  CLRF   xB0
59A6:  MOVWF  xAF
59A8:  MOVLB  0
59AA:  CALL   276A
59AE:  MOVLB  2
59B0:  CLRF   xC8
59B2:  CLRF   xC7
59B4:  MOVLW  48
59B6:  MOVWF  xC6
59B8:  MOVLW  85
59BA:  MOVWF  xC5
59BC:  MOVFF  03,2CC
59C0:  MOVFF  02,2CB
59C4:  MOVFF  01,2CA
59C8:  MOVFF  00,2C9
59CC:  MOVLB  0
59CE:  CALL   2BA4
59D2:  MOVFF  00,9D
59D6:  MOVFF  01,9E
59DA:  MOVFF  02,9F
59DE:  MOVFF  03,A0
59E2:  MOVFF  03,2B2
59E6:  MOVFF  02,2B1
59EA:  MOVFF  01,2B0
59EE:  MOVFF  00,2AF
59F2:  MOVLB  2
59F4:  CLRF   xB6
59F6:  CLRF   xB5
59F8:  MOVLW  7F
59FA:  MOVWF  xB4
59FC:  MOVLW  86
59FE:  MOVWF  xB3
5A00:  MOVLB  0
5A02:  CALL   2120
5A06:  BCF    FD8.1
5A08:  MOVLB  2
5A0A:  CLRF   xAC
5A0C:  CLRF   xAB
5A0E:  CLRF   xAA
5A10:  CLRF   xA9
5A12:  MOVFF  03,2B0
5A16:  MOVFF  02,2AF
5A1A:  MOVFF  01,2AE
5A1E:  MOVFF  00,2AD
5A22:  MOVLB  0
5A24:  CALL   24F0
5A28:  MOVFF  03,98
5A2C:  MOVFF  02,97
5A30:  MOVFF  01,96
5A34:  MOVFF  00,95
....................  
....................    //Establecemos como entrada analógica a analizar la de la temperatura del agua 
....................    set_adc_channel(temperatura_caldera); 
5A38:  MOVLW  00
5A3A:  MOVWF  01
5A3C:  MOVF   FC2,W
5A3E:  ANDLW  C3
5A40:  IORWF  01,W
5A42:  MOVWF  FC2
....................    delay_us(10); //Retraso para posibilitar la lectura 
5A44:  CLRWDT
5A46:  MOVLW  06
5A48:  MOVWF  00
5A4A:  DECFSZ 00,F
5A4C:  BRA    5A4A
....................    //Transformamos el valor analógico leído a la escala utlizada en la temperatura 
....................    temp = t_min_caldera + ((t_max_caldera-t_min_caldera)*(float)read_adc())/AD_num_valores; 
5A4E:  BSF    FC2.1
5A50:  BTFSC  FC2.1
5A52:  BRA    5A50
5A54:  MOVF   FC4,W
5A56:  MOVLB  2
5A58:  CLRF   xB0
5A5A:  MOVWF  xAF
5A5C:  MOVLB  0
5A5E:  CALL   276A
5A62:  MOVLB  2
5A64:  CLRF   xC8
5A66:  CLRF   xC7
5A68:  MOVLW  48
5A6A:  MOVWF  xC6
5A6C:  MOVLW  85
5A6E:  MOVWF  xC5
5A70:  MOVFF  03,2CC
5A74:  MOVFF  02,2CB
5A78:  MOVFF  01,2CA
5A7C:  MOVFF  00,2C9
5A80:  MOVLB  0
5A82:  CALL   2BA4
5A86:  MOVFF  00,9D
5A8A:  MOVFF  01,9E
5A8E:  MOVFF  02,9F
5A92:  MOVFF  03,A0
5A96:  MOVFF  03,2B2
5A9A:  MOVFF  02,2B1
5A9E:  MOVFF  01,2B0
5AA2:  MOVFF  00,2AF
5AA6:  MOVLB  2
5AA8:  CLRF   xB6
5AAA:  CLRF   xB5
5AAC:  MOVLW  7F
5AAE:  MOVWF  xB4
5AB0:  MOVLW  86
5AB2:  MOVWF  xB3
5AB4:  MOVLB  0
5AB6:  CALL   2120
5ABA:  BCF    FD8.1
5ABC:  MOVLB  2
5ABE:  CLRF   xAC
5AC0:  CLRF   xAB
5AC2:  CLRF   xAA
5AC4:  CLRF   xA9
5AC6:  MOVFF  03,2B0
5ACA:  MOVFF  02,2AF
5ACE:  MOVFF  01,2AE
5AD2:  MOVFF  00,2AD
5AD6:  MOVLB  0
5AD8:  CALL   24F0
5ADC:  MOVFF  03,9C
5AE0:  MOVFF  02,9B
5AE4:  MOVFF  01,9A
5AE8:  MOVFF  00,99
....................  
....................    //Comparamos ambas temperaturas teniendo en cuenta la histéresis de la caldera 
....................    if(temp > termo-histeresis_caldera) 
5AEC:  BSF    FD8.1
5AEE:  MOVFF  98,2AC
5AF2:  MOVFF  97,2AB
5AF6:  MOVFF  96,2AA
5AFA:  MOVFF  95,2A9
5AFE:  MOVLB  2
5B00:  CLRF   xB0
5B02:  CLRF   xAF
5B04:  MOVLW  20
5B06:  MOVWF  xAE
5B08:  MOVLW  82
5B0A:  MOVWF  xAD
5B0C:  MOVLB  0
5B0E:  CALL   24F0
5B12:  MOVFF  03,A0
5B16:  MOVFF  02,9F
5B1A:  MOVFF  01,9E
5B1E:  MOVFF  00,9D
5B22:  MOVFF  9C,A4
5B26:  MOVFF  9B,A3
5B2A:  MOVFF  9A,A2
5B2E:  MOVFF  99,A1
5B32:  CALL   247A
5B36:  BNC   5B40
....................       return TRUE; 
5B38:  MOVLW  01
5B3A:  MOVWF  01
5B3C:  BRA    5B46
....................    else 
5B3E:  BRA    5B46
....................       return FALSE; 
5B40:  MOVLW  00
5B42:  MOVWF  01
5B44:  BRA    5B46
.................... } 
5B46:  GOTO   6DFE (RETURN)
....................  
.................... //----------------------------------------------------------------------------------------------------------------------------------------- 
....................  
.................... int comprobar_hora(int hora1, int min1, int hora2, int min2) 
.................... { 
....................    //Si hora1 es menor, devolvemos TRUE 
....................    if(hora1 < hora2) 
*
2C9C:  MOVF   xB1,W
2C9E:  SUBWF  xAF,W
2CA0:  BC    2CA8
....................       return TRUE; 
2CA2:  MOVLW  01
2CA4:  MOVWF  01
2CA6:  BRA    2CCE
....................    //Si hora1 es mayor, devolvemos FALSE 
....................    if(hora1 > hora2) 
2CA8:  MOVF   xAF,W
2CAA:  SUBWF  xB1,W
2CAC:  BC    2CB4
....................       return FALSE; 
2CAE:  MOVLW  00
2CB0:  MOVWF  01
2CB2:  BRA    2CCE
....................    //Si las horas coinciden habrá que comparar los minutos 
....................    if(hora1==hora2) 
2CB4:  MOVF   xB1,W
2CB6:  SUBWF  xAF,W
2CB8:  BNZ   2CCE
....................    { 
....................       //Se sigue el mismo criterio de antes con la comparación 
....................       //de los minutos. 
....................       if(min1 <= min2) 
2CBA:  MOVF   xB0,W
2CBC:  SUBWF  xB2,W
2CBE:  BNC   2CC8
....................          return TRUE; 
2CC0:  MOVLW  01
2CC2:  MOVWF  01
2CC4:  BRA    2CCE
....................       else 
2CC6:  BRA    2CCE
....................          return FALSE; 
2CC8:  MOVLW  00
2CCA:  MOVWF  01
2CCC:  BRA    2CCE
....................    } 
.................... } 
2CCE:  RETLW  00
....................  
.................... //----------------------------------------------------------------------------------------------------------------------------------------- 
....................  
.................... int comprobar_temperatura() 
.................... { 
....................    //Flags auxiliares 
....................    int1 flag1, flag2; 
....................  
....................    //Leemos la temperatura 
....................    temperatura1 = ds1820_read(dir1); 
*
5D06:  CLRF   xA6
5D08:  MOVLW  6D
5D0A:  MOVWF  xA5
5D0C:  CALL   2280
5D10:  MOVFF  03,2F
5D14:  MOVFF  02,2E
5D18:  MOVFF  01,2D
5D1C:  MOVFF  00,2C
....................    temperatura2 = ds1820_read(dir2); 
5D20:  CLRF   xA6
5D22:  MOVLW  75
5D24:  MOVWF  xA5
5D26:  CALL   2280
5D2A:  MOVFF  03,33
5D2E:  MOVFF  02,32
5D32:  MOVFF  01,31
5D36:  MOVFF  00,30
....................  
....................    //Mostramos la información en la pantalla lcd 
....................    mostrar_temperatura(); 
5D3A:  BRA    5C1C
....................  
....................    //************************************ 
....................    //NOTA: El termostato no lo hemos implementado con la función ALARM SEARCH del ds1820 
....................    //por dos razones: por necesitar un algoritmo bastante complejo en el caso de dos dispositivos 
....................    //y por que se ha llegado a la conclusión de que consume más memoria y tiempo, ya que 
....................    //de todas formas tenemos que leer las temperaturas para mostrarlas por pantalla. Si se 
....................    //quiere ver un ejemplo de utilización de este modo de termostato del ds1820, en el prototipo 
....................    //construido para probar en la EasyPic3 se ha implementado con un único sensor. 
....................    //************************************ 
....................  
....................    //Nos centramos primero en el sensor 1 
....................    if(temperatura1 < termostato1) 
5D3C:  MOVFF  2F,A0
5D40:  MOVFF  2E,9F
5D44:  MOVFF  2D,9E
5D48:  MOVFF  2C,9D
5D4C:  MOVFF  23,A4
5D50:  MOVFF  22,A3
5D54:  MOVFF  21,A2
5D58:  MOVFF  20,A1
5D5C:  CALL   247A
5D60:  BNC   5DA2
....................    { 
....................       //Si la temperatura es menor que la del termostato, devolvemos TRUE 
....................       if(temp_habitacion_superada1) 
5D62:  BTFSS  1F.1
5D64:  BRA    5D9E
....................       { 
....................          //Si la temperatura antes era mayor, indicamos el cambio en el flag 
....................          temp_habitacion_superada1 = FALSE; 
5D66:  BCF    1F.1
....................          //Tenemos en cuenta la histéresis para el nuevo valor del termostato 
....................          termostato1 = termostato1 + histeresis_vivienda; 
5D68:  BCF    FD8.1
5D6A:  MOVFF  23,2AC
5D6E:  MOVFF  22,2AB
5D72:  MOVFF  21,2AA
5D76:  MOVFF  20,2A9
5D7A:  MOVFF  37,2B0
5D7E:  MOVFF  36,2AF
5D82:  MOVFF  35,2AE
5D86:  MOVFF  34,2AD
5D8A:  CALL   24F0
5D8E:  MOVFF  03,23
5D92:  MOVFF  02,22
5D96:  MOVFF  01,21
5D9A:  MOVFF  00,20
....................       } 
....................       flag1 = TRUE; 
5D9E:  BSF    x95.0
....................    } 
....................    else 
5DA0:  BRA    5DE0
....................    { 
....................       //Si la temperatura es mayor que la del termostato, devolvemos FALSE 
....................       if(!temp_habitacion_superada1) 
5DA2:  BTFSC  1F.1
5DA4:  BRA    5DDE
....................       { 
....................          //Si antes era menor, cambiamos el flag 
....................          temp_habitacion_superada1 = TRUE; 
5DA6:  BSF    1F.1
....................          //Guardamos el nuevo valor del termostato teniendo en cuenta la histéresis 
....................          termostato1 = termostato1 - histeresis_vivienda; 
5DA8:  BSF    FD8.1
5DAA:  MOVFF  23,2AC
5DAE:  MOVFF  22,2AB
5DB2:  MOVFF  21,2AA
5DB6:  MOVFF  20,2A9
5DBA:  MOVFF  37,2B0
5DBE:  MOVFF  36,2AF
5DC2:  MOVFF  35,2AE
5DC6:  MOVFF  34,2AD
5DCA:  CALL   24F0
5DCE:  MOVFF  03,23
5DD2:  MOVFF  02,22
5DD6:  MOVFF  01,21
5DDA:  MOVFF  00,20
....................       } 
....................       flag1 = FALSE; 
5DDE:  BCF    x95.0
....................    } 
....................  
....................    //Repetimos las mismas operaciones para el sensor 2 
....................    if(temperatura2 < termostato2) 
5DE0:  MOVFF  33,A0
5DE4:  MOVFF  32,9F
5DE8:  MOVFF  31,9E
5DEC:  MOVFF  30,9D
5DF0:  MOVFF  27,A4
5DF4:  MOVFF  26,A3
5DF8:  MOVFF  25,A2
5DFC:  MOVFF  24,A1
5E00:  CALL   247A
5E04:  BNC   5E46
....................    { 
....................       //Si la temperatura es menor que la del termostato, devolvemos TRUE 
....................       if(temp_habitacion_superada2) 
5E06:  BTFSS  1F.2
5E08:  BRA    5E42
....................       { 
....................          //Si la temperatura antes era mayor, indicamos el cambio en el flag 
....................          temp_habitacion_superada2 = FALSE; 
5E0A:  BCF    1F.2
....................          //Tenemos en cuenta la histéresis para el nuevo valor del termostato 
....................          termostato2 = termostato2 + histeresis_vivienda; 
5E0C:  BCF    FD8.1
5E0E:  MOVFF  27,2AC
5E12:  MOVFF  26,2AB
5E16:  MOVFF  25,2AA
5E1A:  MOVFF  24,2A9
5E1E:  MOVFF  37,2B0
5E22:  MOVFF  36,2AF
5E26:  MOVFF  35,2AE
5E2A:  MOVFF  34,2AD
5E2E:  CALL   24F0
5E32:  MOVFF  03,27
5E36:  MOVFF  02,26
5E3A:  MOVFF  01,25
5E3E:  MOVFF  00,24
....................       } 
....................       flag2 = TRUE; 
5E42:  BSF    x95.1
....................    } 
....................    else 
5E44:  BRA    5E84
....................    { 
....................       //Si la temperatura es mayor que la del termostato, devolvemos FALSE 
....................       if(!temp_habitacion_superada2) 
5E46:  BTFSC  1F.2
5E48:  BRA    5E82
....................       { 
....................          //Si antes era menor, cambiamos el flag 
....................          temp_habitacion_superada2 = TRUE; 
5E4A:  BSF    1F.2
....................          //Guardamos el nuevo valor del termostato teniendo en cuenta la histéresis 
....................          termostato2 = termostato2 - histeresis_vivienda; 
5E4C:  BSF    FD8.1
5E4E:  MOVFF  27,2AC
5E52:  MOVFF  26,2AB
5E56:  MOVFF  25,2AA
5E5A:  MOVFF  24,2A9
5E5E:  MOVFF  37,2B0
5E62:  MOVFF  36,2AF
5E66:  MOVFF  35,2AE
5E6A:  MOVFF  34,2AD
5E6E:  CALL   24F0
5E72:  MOVFF  03,27
5E76:  MOVFF  02,26
5E7A:  MOVFF  01,25
5E7E:  MOVFF  00,24
....................       } 
....................       flag2 = FALSE; 
5E82:  BCF    x95.1
....................    } 
....................  
....................    //Devolvemos el código correspondiente según se explica en la definición de la función 
....................    if(!flag1 && !flag2) 
5E84:  BTFSC  x95.0
5E86:  BRA    5E92
5E88:  BTFSC  x95.1
5E8A:  BRA    5E92
....................       return 0; 
5E8C:  MOVLW  00
5E8E:  MOVWF  01
5E90:  BRA    5EBC
....................    if(flag1 && !flag2) 
5E92:  BTFSS  x95.0
5E94:  BRA    5EA0
5E96:  BTFSC  x95.1
5E98:  BRA    5EA0
....................       return 1; 
5E9A:  MOVLW  01
5E9C:  MOVWF  01
5E9E:  BRA    5EBC
....................    if(!flag1 && flag2) 
5EA0:  BTFSC  x95.0
5EA2:  BRA    5EAE
5EA4:  BTFSS  x95.1
5EA6:  BRA    5EAE
....................       return 2; 
5EA8:  MOVLW  02
5EAA:  MOVWF  01
5EAC:  BRA    5EBC
....................    if(flag1 && flag2) 
5EAE:  BTFSS  x95.0
5EB0:  BRA    5EBC
5EB2:  BTFSS  x95.1
5EB4:  BRA    5EBC
....................       return 3; 
5EB6:  MOVLW  03
5EB8:  MOVWF  01
5EBA:  BRA    5EBC
.................... } 
5EBC:  GOTO   6E26 (RETURN)
....................  
.................... //----------------------------------------------------------------------------------------------------------------------------------------- 
....................  
.................... long diferencia_tiempo(int hora1, int min1, int hora2, int min2) 
.................... { 
....................    long dif; 
....................  
....................    //Si hora1:min1 es menor que hora2:min2, devolvemos simplemente la diferencia en minutos 
....................    if(comprobar_hora(hora1,min1,hora2,min2)) 
*
2CD0:  MOVFF  A5,AF
2CD4:  MOVFF  A6,B0
2CD8:  MOVFF  A7,B1
2CDC:  MOVFF  A8,B2
2CE0:  RCALL  2C9C
2CE2:  MOVF   01,F
2CE4:  BZ    2D4A
....................       dif = ((long)hora2*60 + (long)min2) - ((long)hora1*60 + (long)min1); 
2CE6:  CLRF   xAC
2CE8:  MOVFF  A7,AB
2CEC:  MOVFF  AC,B7
2CF0:  MOVFF  A7,B6
2CF4:  CLRF   xB9
2CF6:  MOVLW  3C
2CF8:  MOVWF  xB8
2CFA:  CALL   18C8
2CFE:  MOVFF  02,AD
2D02:  MOVFF  01,AC
2D06:  CLRF   03
2D08:  MOVF   xA8,W
2D0A:  ADDWF  01,W
2D0C:  MOVWF  xAE
2D0E:  MOVF   03,W
2D10:  ADDWFC 02,W
2D12:  MOVWF  xAF
2D14:  CLRF   xB1
2D16:  MOVFF  A5,B0
2D1A:  MOVFF  B1,B7
2D1E:  MOVFF  A5,B6
2D22:  CLRF   xB9
2D24:  MOVLW  3C
2D26:  MOVWF  xB8
2D28:  CALL   18C8
2D2C:  MOVFF  01,B1
2D30:  CLRF   03
2D32:  MOVF   xA6,W
2D34:  ADDWF  01,W
2D36:  MOVWF  01
2D38:  MOVF   02,W
2D3A:  ADDWFC 03,F
2D3C:  MOVF   01,W
2D3E:  SUBWF  xAE,W
2D40:  MOVWF  xA9
2D42:  MOVF   03,W
2D44:  SUBWFB xAF,W
2D46:  MOVWF  xAA
....................    //Si no es así, habrá que tener en cuenta que hora1:min1 se encuentra en el día anterior 
....................    //al de hora2:min2 
....................    else 
2D48:  BRA    2DBA
....................       dif = (24*60-((long)hora1*60 + (long)min1)) + (long)hora2*60 + (long)min2; 
2D4A:  CLRF   xAC
2D4C:  MOVFF  A5,AB
2D50:  MOVFF  AC,B7
2D54:  MOVFF  A5,B6
2D58:  CLRF   xB9
2D5A:  MOVLW  3C
2D5C:  MOVWF  xB8
2D5E:  CALL   18C8
2D62:  MOVFF  02,AD
2D66:  MOVFF  01,AC
2D6A:  CLRF   03
2D6C:  MOVF   xA6,W
2D6E:  ADDWF  01,W
2D70:  MOVWF  01
2D72:  MOVF   02,W
2D74:  ADDWFC 03,F
2D76:  MOVF   01,W
2D78:  XORLW  FF
2D7A:  ADDLW  A1
2D7C:  MOVWF  xAE
2D7E:  MOVLW  05
2D80:  SUBFWB 03,W
2D82:  MOVWF  xAF
2D84:  CLRF   xB1
2D86:  MOVFF  A7,B0
2D8A:  MOVFF  B1,B7
2D8E:  MOVFF  A7,B6
2D92:  CLRF   xB9
2D94:  MOVLW  3C
2D96:  MOVWF  xB8
2D98:  CALL   18C8
2D9C:  MOVFF  02,03
2DA0:  MOVF   01,W
2DA2:  ADDWF  xAE,W
2DA4:  MOVWF  xB1
2DA6:  MOVF   02,W
2DA8:  ADDWFC xAF,W
2DAA:  MOVWF  xB2
2DAC:  CLRF   03
2DAE:  MOVF   xA8,W
2DB0:  ADDWF  xB1,W
2DB2:  MOVWF  xA9
2DB4:  MOVF   03,W
2DB6:  ADDWFC xB2,W
2DB8:  MOVWF  xAA
....................  
....................    //Devolvemos el resultado 
....................    return dif; 
2DBA:  MOVFF  A9,01
2DBE:  MOVFF  AA,02
.................... } 
2DC2:  RETLW  00
....................  
.................... //----------------------------------------------------------------------------------------------------------------------------------------- 
....................  
.................... long diferencia_tiempo_sec(int hora1, int min1, int sec1, int hora2, int min2, int sec2) 
.................... { 
....................    unsigned long dif; 
....................    unsigned long dif2; 
....................  
....................    //Si hora1:min1 es menor que hora2:min2, ambas horas están en el mismo día 
....................    if(comprobar_hora(hora1,min1,hora2,min2)) 
2DC4:  MOVFF  A5,AF
2DC8:  MOVFF  A6,B0
2DCC:  MOVFF  A8,B1
2DD0:  MOVFF  A9,B2
2DD4:  RCALL  2C9C
2DD6:  MOVF   01,F
2DD8:  BZ    2E7E
....................    { 
....................       //Si la hora y los minutos son iguales, devolvemos simplemente la diferencia en segundos 
....................       if(hora1==hora2 && min1==min2) 
2DDA:  MOVF   xA8,W
2DDC:  SUBWF  xA5,W
2DDE:  BNZ   2DF0
2DE0:  MOVF   xA9,W
2DE2:  SUBWF  xA6,W
2DE4:  BNZ   2DF0
....................          dif = abs(sec2-sec1); 
2DE6:  MOVF   xA7,W
2DE8:  SUBWF  xAA,W
2DEA:  CLRF   xAC
2DEC:  MOVWF  xAB
....................       else 
2DEE:  BRA    2E7C
....................       { 
....................          //Si no habrá que tener en cuenta también la diferencia entre horas y minutos 
....................          dif2 = ((long)hora2*60 + (long)min2) - ((long)hora1*60 + (long)min1); 
2DF0:  CLRF   xB0
2DF2:  MOVFF  A8,AF
2DF6:  MOVFF  B0,B7
2DFA:  MOVFF  A8,B6
2DFE:  CLRF   xB9
2E00:  MOVLW  3C
2E02:  MOVWF  xB8
2E04:  CALL   18C8
2E08:  MOVFF  02,B1
2E0C:  MOVFF  01,B0
2E10:  CLRF   03
2E12:  MOVF   xA9,W
2E14:  ADDWF  01,W
2E16:  MOVWF  xB2
2E18:  MOVF   03,W
2E1A:  ADDWFC 02,W
2E1C:  MOVWF  xB3
2E1E:  CLRF   xB5
2E20:  MOVFF  A5,B4
2E24:  MOVFF  B5,B7
2E28:  MOVFF  A5,B6
2E2C:  CLRF   xB9
2E2E:  MOVLW  3C
2E30:  MOVWF  xB8
2E32:  CALL   18C8
2E36:  MOVFF  01,B5
2E3A:  CLRF   03
2E3C:  MOVF   xA6,W
2E3E:  ADDWF  01,W
2E40:  MOVWF  01
2E42:  MOVF   02,W
2E44:  ADDWFC 03,F
2E46:  MOVF   01,W
2E48:  SUBWF  xB2,W
2E4A:  MOVWF  xAD
2E4C:  MOVF   03,W
2E4E:  SUBWFB xB3,W
2E50:  MOVWF  xAE
....................          //No hacemos la diferencia en segundos directamente porque el long no da de sí 
....................          dif = dif2*60 + sec2 - sec1; 
2E52:  MOVFF  AE,B7
2E56:  MOVFF  AD,B6
2E5A:  CLRF   xB9
2E5C:  MOVLW  3C
2E5E:  MOVWF  xB8
2E60:  CALL   18C8
2E64:  MOVF   xAA,W
2E66:  ADDWF  01,W
2E68:  MOVWF  xB1
2E6A:  MOVLW  00
2E6C:  ADDWFC 02,W
2E6E:  MOVWF  xB2
2E70:  MOVF   xA7,W
2E72:  SUBWF  xB1,W
2E74:  MOVWF  xAB
2E76:  MOVLW  00
2E78:  SUBWFB xB2,W
2E7A:  MOVWF  xAC
....................       } 
....................    } 
....................    else{ 
2E7C:  BRA    2F18
....................       //Si no, simplemente tenemos en cuenta que están en días diferentes y luego le añadimos la 
....................       //diferencia en segundos 
....................       dif2 = (24*60-((long)hora1*60 + (long)min1)) + (long)hora2*60 + (long)min2; 
2E7E:  CLRF   xB0
2E80:  MOVFF  A5,AF
2E84:  MOVFF  B0,B7
2E88:  MOVFF  A5,B6
2E8C:  CLRF   xB9
2E8E:  MOVLW  3C
2E90:  MOVWF  xB8
2E92:  CALL   18C8
2E96:  MOVFF  02,B1
2E9A:  MOVFF  01,B0
2E9E:  CLRF   03
2EA0:  MOVF   xA6,W
2EA2:  ADDWF  01,W
2EA4:  MOVWF  01
2EA6:  MOVF   02,W
2EA8:  ADDWFC 03,F
2EAA:  MOVF   01,W
2EAC:  XORLW  FF
2EAE:  ADDLW  A1
2EB0:  MOVWF  xB2
2EB2:  MOVLW  05
2EB4:  SUBFWB 03,W
2EB6:  MOVWF  xB3
2EB8:  CLRF   xB5
2EBA:  MOVFF  A8,B4
2EBE:  MOVFF  B5,B7
2EC2:  MOVFF  A8,B6
2EC6:  CLRF   xB9
2EC8:  MOVLW  3C
2ECA:  MOVWF  xB8
2ECC:  CALL   18C8
2ED0:  MOVFF  02,03
2ED4:  MOVF   01,W
2ED6:  ADDWF  xB2,W
2ED8:  MOVWF  xB5
2EDA:  MOVF   02,W
2EDC:  ADDWFC xB3,W
2EDE:  MOVWF  xB6
2EE0:  CLRF   03
2EE2:  MOVF   xA9,W
2EE4:  ADDWF  xB5,W
2EE6:  MOVWF  xAD
2EE8:  MOVF   03,W
2EEA:  ADDWFC xB6,W
2EEC:  MOVWF  xAE
....................       dif = dif2*60 + sec2 - sec1; 
2EEE:  MOVFF  AE,B7
2EF2:  MOVFF  AD,B6
2EF6:  CLRF   xB9
2EF8:  MOVLW  3C
2EFA:  MOVWF  xB8
2EFC:  CALL   18C8
2F00:  MOVF   xAA,W
2F02:  ADDWF  01,W
2F04:  MOVWF  xB1
2F06:  MOVLW  00
2F08:  ADDWFC 02,W
2F0A:  MOVWF  xB2
2F0C:  MOVF   xA7,W
2F0E:  SUBWF  xB1,W
2F10:  MOVWF  xAB
2F12:  MOVLW  00
2F14:  SUBWFB xB2,W
2F16:  MOVWF  xAC
....................    } 
....................  
....................    //Devolvemos el resultado 
....................    return dif; 
2F18:  MOVFF  AB,01
2F1C:  MOVFF  AC,02
.................... } 
2F20:  RETLW  00
....................  
.................... //----------------------------------------------------------------------------------------------------------------------------------------- 
....................  
.................... void encender_caldera() 
.................... { 
....................    //Leemos el tiempo actual 
....................    PCF8583_read_datetime(&tiempo); 
*
5B4A:  CLRF   xA6
5B4C:  MOVLW  5B
5B4E:  MOVWF  xA5
5B50:  CALL   28AE
....................  
....................    //Guardamos los datos en las variables correspondientes 
....................    hora_caldera = tiempo.hours; 
5B54:  MOVFF  5D,64
....................    minutos_caldera = tiempo.minutes; 
5B58:  MOVFF  5C,65
....................    segundos_caldera = tiempo.seconds; 
5B5C:  MOVFF  5B,66
....................  
....................    //Encendemos la caldera 
....................    caldera_encendida = TRUE; 
5B60:  BSF    F83.5
.................... } 
5B62:  RETLW  00
....................  
.................... //----------------------------------------------------------------------------------------------------------------------------------------- 
....................  
.................... void encender_sistema() 
.................... { 
....................    //Leemos el tiempo actual 
....................    PCF8583_read_datetime(&tiempo); 
*
2A74:  CLRF   xA6
2A76:  MOVLW  5B
2A78:  MOVWF  xA5
2A7A:  RCALL  28AE
....................  
....................    //Registramos la hora y minutos en los que se enciende el sistema 
....................    hora_encendido    = tiempo.hours; 
2A7C:  MOVFF  5D,62
....................    minutos_encendido = tiempo.minutes; 
2A80:  MOVFF  5C,63
....................  
....................    //Inicializamos a 0 el tiempo total que está encendida la caldera 
....................    t_total_caldera = 0; 
2A84:  CLRF   68
2A86:  CLRF   67
....................  
....................    //Si la caldera está encendida, inicializamos el instante de encendido a 
....................    //éste. 
....................    if(caldera_encendida) 
2A88:  BTFSS  F83.5
2A8A:  BRA    2A98
....................    { 
....................       hora_caldera = tiempo.hours; 
2A8C:  MOVFF  5D,64
....................       minutos_caldera = tiempo.minutes; 
2A90:  MOVFF  5C,65
....................       segundos_caldera = tiempo.seconds; 
2A94:  MOVFF  5B,66
....................    } 
....................  
....................    //Encendemos el sistema 
....................    sistema_encendido = TRUE; 
2A98:  BSF    F83.4
.................... } 
2A9A:  RETLW  00
....................  
.................... //----------------------------------------------------------------------------------------------------------------------------------------- 
....................  
.................... void grabar_programaciones() 
.................... { 
....................    int datos[5];   //Vector para contener los datos a grabar 
....................    programacion pr; //Variable temporal de programacion 
....................    int contador;   //Contador para el bucle 
....................  
....................    //Recorremos todo el vector de programaciones (hasta el número de programaciones que tengamos) 
....................    for(contador=0; contador<num_intervalos; contador++) 
*
3978:  CLRF   x9F
397A:  MOVF   59,W
397C:  SUBWF  x9F,W
397E:  BC    39E8
....................    { 
....................       //Seleccionamos la programación 
....................       pr = programaciones[contador]; 
3980:  MOVF   x9F,W
3982:  MULLW  05
3984:  MOVF   FF3,W
3986:  CLRF   03
3988:  ADDLW  3B
398A:  MOVWF  01
398C:  MOVLW  00
398E:  ADDWFC 03,F
3990:  MOVFF  01,A0
3994:  MOVFF  03,A1
3998:  CLRF   FEA
399A:  MOVLW  9A
399C:  MOVWF  FE9
399E:  MOVFF  03,FE2
39A2:  MOVFF  01,FE1
39A6:  MOVLW  05
39A8:  MOVWF  01
39AA:  MOVFF  FE6,FEE
39AE:  DECFSZ 01,F
39B0:  BRA    39AA
....................  
....................       //Almacenamos los datos en el vector 
....................       datos[0] = pr.horas_inicio; 
39B2:  MOVFF  9A,95
....................       datos[1] = pr.minutos_inicio; 
39B6:  MOVFF  9B,96
....................       datos[2] = pr.horas_fin; 
39BA:  MOVFF  9C,97
....................       datos[3] = pr.minutos_fin; 
39BE:  MOVFF  9D,98
....................       datos[4] = pr.termostato; 
39C2:  MOVFF  9E,99
....................  
....................       //Guardamos los datos en la posición de memoria correspondiente de la EEPROM 
....................       graba_ee(eeprom_programaciones + (contador+1)*8, 5, datos); 
39C6:  MOVLW  01
39C8:  ADDWF  x9F,W
39CA:  MULLW  08
39CC:  MOVF   FF3,W
39CE:  ADDLW  18
39D0:  MOVWF  xA1
39D2:  CLRF   xAC
39D4:  MOVWF  xAB
39D6:  MOVLW  05
39D8:  MOVWF  xAD
39DA:  CLRF   xAF
39DC:  MOVLW  95
39DE:  MOVWF  xAE
39E0:  CALL   18E6
....................    } 
39E4:  INCF   x9F,F
39E6:  BRA    397A
....................  
....................    //Guardamos en la EEPROM en el número de intervalos 
....................    graba_ee(eeprom_num_intervalos, 1, &num_intervalos); 
39E8:  CLRF   xAC
39EA:  MOVLW  11
39EC:  MOVWF  xAB
39EE:  MOVLW  01
39F0:  MOVWF  xAD
39F2:  CLRF   xAF
39F4:  MOVLW  59
39F6:  MOVWF  xAE
39F8:  CALL   18E6
....................  
....................    //He optado por escribir de programación en programación porque a pesar de que 
....................    //en el datasheet aseguran que la memoria tiene una paginación de 32 bytes en la 
....................    //simulación parece tener menos, así que de este modo nos evitamos problemas 
.................... } 
39FC:  GOTO   6DE8 (RETURN)
....................  
.................... //----------------------------------------------------------------------------------------------------------------------------------------- 
....................  
.................... void inicializacion() 
.................... { 
....................    //NOTA: todos los pequeños retardos introducidos en esta rutina sirven para que el técnico 
....................    //no se sienta atosigado por los continuos mensajes que le aparecen solicitándole información. 
....................  
....................  
....................    //Variables para introducir los datos de fecha y hora 
....................    int weekday, dia, mes, anno, horas, minutos; 
....................    //Variable para escritura en memoria 
....................    int data[8]; 
....................    char c[2]; //Cadena para la conversión a int 
....................  
....................    //Comenzamos pidiendo la introducción de la fecha 
....................    //Es una lástima que en RS232 no se vean bien las tildes 
....................    e1: 
....................    printf("\rInicializacion del sistema\r"); 
*
1976:  CLRF   xA5
1978:  MOVF   xA5,W
197A:  CALL   04D8
197E:  IORLW  00
1980:  BZ    198C
1982:  INCF   xA5,F
1984:  BTFSS  F9E.4
1986:  BRA    1984
1988:  MOVWF  FAD
198A:  BRA    1978
....................    printf("**************************\r"); 
198C:  CLRF   xA5
198E:  MOVF   xA5,W
1990:  CALL   0510
1994:  IORLW  00
1996:  BZ    19A2
1998:  INCF   xA5,F
199A:  BTFSS  F9E.4
199C:  BRA    199A
199E:  MOVWF  FAD
19A0:  BRA    198E
....................    //Primero solicitamos el día de la semana 
....................    printf("Dia de la semana (1->Lunes, 2->Martes, ...): LUNES    "); 
19A2:  CLRF   xA5
19A4:  MOVF   xA5,W
19A6:  CALL   0546
19AA:  IORLW  00
19AC:  BZ    19B8
19AE:  INCF   xA5,F
19B0:  BTFSS  F9E.4
19B2:  BRA    19B0
19B4:  MOVWF  FAD
19B6:  BRA    19A4
....................  
....................    //En principio se indica que es lunes 
....................    weekday = 0; 
19B8:  CLRF   x95
....................  
....................    //Inicializamos el vector de caracteres a \0 por dos motivos según la posición: 
....................    //c[0] para que no se elija un día indeseado sin intervención del técnico y c[1], 
....................    //para marcar el fin de la cadena. 
....................    c[0]=c[1]='\0'; 
19BA:  CLRF   xA4
19BC:  MOVFF  A4,A3
....................  
....................    //Iteramos en el bucle hasta que no se pulse ENTER 
....................    while(c[0]!=13){ 
19C0:  MOVF   xA3,W
19C2:  SUBLW  0D
19C4:  BTFSC  FD8.2
19C6:  BRA    1A92
....................       //Guardamos el caracter leído 
....................       c[0]=getch(); 
19C8:  BTFSS  F9E.5
19CA:  BRA    19C8
19CC:  MOVFF  FAE,A3
....................  
....................       //Además se asigna un valor numérico a la variable weekday para almacenarla en el reloj. 
....................       weekday=atoi(c)-1; 
19D0:  CLRF   xA9
19D2:  MOVLW  A3
19D4:  MOVWF  xA8
19D6:  RCALL  1450
19D8:  MOVLW  01
19DA:  SUBWF  01,W
19DC:  MOVWF  x95
....................  
....................       //Según el día introducido, imprimimos un resultado u otro por pantalla, borrando el 
....................       //anterior. Para ello, todos los días ocupan el tamaño del mayor (miércoles) gracias a espacios. 
....................       switch(weekday) 
....................       { 
19DE:  MOVF   x95,W
19E0:  ADDLW  F9
19E2:  BC    1A90
19E4:  ADDLW  07
19E6:  GOTO   1E82
....................          case 0: printf("\b\b\b\b\b\b\b\b\bLUNES    "); 
19EA:  CLRF   xA5
19EC:  MOVF   xA5,W
19EE:  CALL   0598
19F2:  IORLW  00
19F4:  BZ    1A00
19F6:  INCF   xA5,F
19F8:  BTFSS  F9E.4
19FA:  BRA    19F8
19FC:  MOVWF  FAD
19FE:  BRA    19EC
....................                  break; 
1A00:  BRA    1A90
....................          case 1: printf("\b\b\b\b\b\b\b\b\bMARTES   "); 
1A02:  CLRF   xA5
1A04:  MOVF   xA5,W
1A06:  CALL   05C6
1A0A:  IORLW  00
1A0C:  BZ    1A18
1A0E:  INCF   xA5,F
1A10:  BTFSS  F9E.4
1A12:  BRA    1A10
1A14:  MOVWF  FAD
1A16:  BRA    1A04
....................                  break; 
1A18:  BRA    1A90
....................          case 2: printf("\b\b\b\b\b\b\b\b\bMIERCOLES"); 
1A1A:  CLRF   xA5
1A1C:  MOVF   xA5,W
1A1E:  CALL   05F4
1A22:  IORLW  00
1A24:  BZ    1A30
1A26:  INCF   xA5,F
1A28:  BTFSS  F9E.4
1A2A:  BRA    1A28
1A2C:  MOVWF  FAD
1A2E:  BRA    1A1C
....................                  break; 
1A30:  BRA    1A90
....................          case 3: printf("\b\b\b\b\b\b\b\b\bJUEVES   "); 
1A32:  CLRF   xA5
1A34:  MOVF   xA5,W
1A36:  CALL   0622
1A3A:  IORLW  00
1A3C:  BZ    1A48
1A3E:  INCF   xA5,F
1A40:  BTFSS  F9E.4
1A42:  BRA    1A40
1A44:  MOVWF  FAD
1A46:  BRA    1A34
....................                  break; 
1A48:  BRA    1A90
....................          case 4: printf("\b\b\b\b\b\b\b\b\bVIERNES  "); 
1A4A:  CLRF   xA5
1A4C:  MOVF   xA5,W
1A4E:  CALL   0650
1A52:  IORLW  00
1A54:  BZ    1A60
1A56:  INCF   xA5,F
1A58:  BTFSS  F9E.4
1A5A:  BRA    1A58
1A5C:  MOVWF  FAD
1A5E:  BRA    1A4C
....................                  break; 
1A60:  BRA    1A90
....................          case 5: printf("\b\b\b\b\b\b\b\b\bSABADO   "); 
1A62:  CLRF   xA5
1A64:  MOVF   xA5,W
1A66:  CALL   067E
1A6A:  IORLW  00
1A6C:  BZ    1A78
1A6E:  INCF   xA5,F
1A70:  BTFSS  F9E.4
1A72:  BRA    1A70
1A74:  MOVWF  FAD
1A76:  BRA    1A64
....................                  break; 
1A78:  BRA    1A90
....................          case 6: printf("\b\b\b\b\b\b\b\b\bDOMINGO  "); 
1A7A:  CLRF   xA5
1A7C:  MOVF   xA5,W
1A7E:  CALL   06AC
1A82:  IORLW  00
1A84:  BZ    1A90
1A86:  INCF   xA5,F
1A88:  BTFSS  F9E.4
1A8A:  BRA    1A88
1A8C:  MOVWF  FAD
1A8E:  BRA    1A7C
....................       } 
....................    } 
1A90:  BRA    19C0
....................  
....................    //Pedimos la introducción de la fecha 
....................    printf("\rFECHA: "); 
1A92:  CLRF   xA5
1A94:  MOVF   xA5,W
1A96:  CALL   06DA
1A9A:  IORLW  00
1A9C:  BZ    1AA8
1A9E:  INCF   xA5,F
1AA0:  BTFSS  F9E.4
1AA2:  BRA    1AA0
1AA4:  MOVWF  FAD
1AA6:  BRA    1A94
....................  
....................    //Leemos el día del mes 
....................    dia = buscar_numero_rs232(); 
1AA8:  RCALL  15EA
1AAA:  MOVFF  01,96
....................    //Si pulsamos "backspace", se resetea la inicialización 
....................    if(dia==NO) 
1AAE:  MOVF   x96,W
1AB0:  SUBLW  64
1AB2:  BNZ   1ACC
....................    { 
....................       printf("\rReseteando inicializacion...\r"); 
1AB4:  CLRF   xA5
1AB6:  MOVF   xA5,W
1AB8:  CALL   06FE
1ABC:  IORLW  00
1ABE:  BZ    1ACA
1AC0:  INCF   xA5,F
1AC2:  BTFSS  F9E.4
1AC4:  BRA    1AC2
1AC6:  MOVWF  FAD
1AC8:  BRA    1AB6
....................       goto e1; 
1ACA:  BRA    1976
....................    } 
....................    //Si el día introducido no es válido, también reseteamos la inicialización 
....................    if(dia>31 || dia==0) 
1ACC:  MOVF   x96,W
1ACE:  SUBLW  1F
1AD0:  BNC   1AD6
1AD2:  MOVF   x96,F
1AD4:  BNZ   1AFE
....................    { 
....................       printf("\rDia incorrecto. Reseteando inicializacion...\r"); 
1AD6:  CLRF   xA5
1AD8:  MOVF   xA5,W
1ADA:  CALL   0738
1ADE:  IORLW  00
1AE0:  BZ    1AEC
1AE2:  INCF   xA5,F
1AE4:  BTFSS  F9E.4
1AE6:  BRA    1AE4
1AE8:  MOVWF  FAD
1AEA:  BRA    1AD8
....................       delay_ms(LCD_T_RETARDO); 
1AEC:  MOVLW  02
1AEE:  MOVWF  xA5
1AF0:  MOVLW  FA
1AF2:  MOVWF  xB0
1AF4:  CALL   12A8
1AF8:  DECFSZ xA5,F
1AFA:  BRA    1AF0
....................       goto e1; 
1AFC:  BRA    1976
....................    } 
....................  
....................    //Leemos el mes 
....................    printf("/"); 
1AFE:  CLRF   xA5
1B00:  MOVF   xA5,W
1B02:  CALL   0782
1B06:  IORLW  00
1B08:  BZ    1B14
1B0A:  INCF   xA5,F
1B0C:  BTFSS  F9E.4
1B0E:  BRA    1B0C
1B10:  MOVWF  FAD
1B12:  BRA    1B00
....................    mes = buscar_numero_rs232(); 
1B14:  RCALL  15EA
1B16:  MOVFF  01,97
....................    //Si pulsamos "backspace", se resetea la inicialización 
....................    if(mes==NO) 
1B1A:  MOVF   x97,W
1B1C:  SUBLW  64
1B1E:  BNZ   1B38
....................    { 
....................       printf("\rReseteando inicializacion...\r"); 
1B20:  CLRF   xA5
1B22:  MOVF   xA5,W
1B24:  CALL   06FE
1B28:  IORLW  00
1B2A:  BZ    1B36
1B2C:  INCF   xA5,F
1B2E:  BTFSS  F9E.4
1B30:  BRA    1B2E
1B32:  MOVWF  FAD
1B34:  BRA    1B22
....................       goto e1; 
1B36:  BRA    1976
....................    } 
....................    //Si el mes introducido no es válido, reseteamos la inicialización de igual modo 
....................    if(mes>12 || mes==0) 
1B38:  MOVF   x97,W
1B3A:  SUBLW  0C
1B3C:  BNC   1B42
1B3E:  MOVF   x97,F
1B40:  BNZ   1B6A
....................    { 
....................       printf("\rMes incorrecto. Reseteando inicializacion...\r"); 
1B42:  CLRF   xA5
1B44:  MOVF   xA5,W
1B46:  CALL   079E
1B4A:  IORLW  00
1B4C:  BZ    1B58
1B4E:  INCF   xA5,F
1B50:  BTFSS  F9E.4
1B52:  BRA    1B50
1B54:  MOVWF  FAD
1B56:  BRA    1B44
....................       delay_ms(LCD_T_RETARDO); 
1B58:  MOVLW  02
1B5A:  MOVWF  xA5
1B5C:  MOVLW  FA
1B5E:  MOVWF  xB0
1B60:  CALL   12A8
1B64:  DECFSZ xA5,F
1B66:  BRA    1B5C
....................       goto e1; 
1B68:  BRA    1976
....................    } 
....................  
....................    //Si el día introducido no se encuentra en el mes seleccionado, mostramos un mensaje 
....................    //de error y reseteamos la operación 
....................    if((dia>29 && mes==2)||(dia==31 && (mes==4 || mes==6 || mes==9 || mes==11))) 
1B6A:  MOVF   x96,W
1B6C:  SUBLW  1D
1B6E:  BC    1B76
1B70:  MOVF   x97,W
1B72:  SUBLW  02
1B74:  BZ    1B94
1B76:  MOVF   x96,W
1B78:  SUBLW  1F
1B7A:  BNZ   1BBC
1B7C:  MOVF   x97,W
1B7E:  SUBLW  04
1B80:  BZ    1B94
1B82:  MOVF   x97,W
1B84:  SUBLW  06
1B86:  BZ    1B94
1B88:  MOVF   x97,W
1B8A:  SUBLW  09
1B8C:  BZ    1B94
1B8E:  MOVF   x97,W
1B90:  SUBLW  0B
1B92:  BNZ   1BBC
....................    { 
....................       printf("\rError en la fecha. Reseteando inicializacion...\r"); 
1B94:  CLRF   xA5
1B96:  MOVF   xA5,W
1B98:  CALL   07E8
1B9C:  IORLW  00
1B9E:  BZ    1BAA
1BA0:  INCF   xA5,F
1BA2:  BTFSS  F9E.4
1BA4:  BRA    1BA2
1BA6:  MOVWF  FAD
1BA8:  BRA    1B96
....................       delay_ms(LCD_T_RETARDO); 
1BAA:  MOVLW  02
1BAC:  MOVWF  xA5
1BAE:  MOVLW  FA
1BB0:  MOVWF  xB0
1BB2:  CALL   12A8
1BB6:  DECFSZ xA5,F
1BB8:  BRA    1BAE
....................       goto e1; 
1BBA:  BRA    1976
....................    } 
....................  
....................    //Leemos el año 
....................    printf("/"); 
1BBC:  CLRF   xA5
1BBE:  MOVF   xA5,W
1BC0:  CALL   0782
1BC4:  IORLW  00
1BC6:  BZ    1BD2
1BC8:  INCF   xA5,F
1BCA:  BTFSS  F9E.4
1BCC:  BRA    1BCA
1BCE:  MOVWF  FAD
1BD0:  BRA    1BBE
....................    anno = buscar_numero_rs232(); 
1BD2:  RCALL  15EA
1BD4:  MOVFF  01,98
....................    //Si pulsamos "backspace", se resetea la inicialización 
....................    if(anno==NO) 
1BD8:  MOVF   x98,W
1BDA:  SUBLW  64
1BDC:  BNZ   1C06
....................    { 
....................       printf("\rReseteando inicializacion...\r"); 
1BDE:  CLRF   xA5
1BE0:  MOVF   xA5,W
1BE2:  CALL   06FE
1BE6:  IORLW  00
1BE8:  BZ    1BF4
1BEA:  INCF   xA5,F
1BEC:  BTFSS  F9E.4
1BEE:  BRA    1BEC
1BF0:  MOVWF  FAD
1BF2:  BRA    1BE0
....................       delay_ms(LCD_T_RETARDO); 
1BF4:  MOVLW  02
1BF6:  MOVWF  xA5
1BF8:  MOVLW  FA
1BFA:  MOVWF  xB0
1BFC:  CALL   12A8
1C00:  DECFSZ xA5,F
1C02:  BRA    1BF8
....................       goto e1; 
1C04:  BRA    1976
....................    } 
....................    //Si el valor del año es incorrecto, reseteamos también la inicialización. 
....................    //Tampoco se permite un año menor que 2009 (año de fabricación del sistema de control) 
....................    if(anno>99 || anno<9) 
1C06:  MOVF   x98,W
1C08:  SUBLW  63
1C0A:  BNC   1C12
1C0C:  MOVF   x98,W
1C0E:  SUBLW  08
1C10:  BNC   1C3A
....................    { 
....................       printf("\rAnno incorrecto. Reseteando inicializacion...\r"); 
1C12:  CLRF   xA5
1C14:  MOVF   xA5,W
1C16:  CALL   0834
1C1A:  IORLW  00
1C1C:  BZ    1C28
1C1E:  INCF   xA5,F
1C20:  BTFSS  F9E.4
1C22:  BRA    1C20
1C24:  MOVWF  FAD
1C26:  BRA    1C14
....................       delay_ms(LCD_T_RETARDO); 
1C28:  MOVLW  02
1C2A:  MOVWF  xA5
1C2C:  MOVLW  FA
1C2E:  MOVWF  xB0
1C30:  CALL   12A8
1C34:  DECFSZ xA5,F
1C36:  BRA    1C2C
....................       goto e1; 
1C38:  BRA    1976
....................    } 
....................  
....................  
....................    //Si el año no es bisiesto y hemos seleccionado el 29 de febrero, 
....................    //mostramos un mensaje y reseteamos la operación. 
....................    if(anno%4!=0 && mes==2 && dia==29) 
1C3A:  MOVF   x98,W
1C3C:  ANDLW  03
1C3E:  BZ    1C74
1C40:  MOVF   x97,W
1C42:  SUBLW  02
1C44:  BNZ   1C74
1C46:  MOVF   x96,W
1C48:  SUBLW  1D
1C4A:  BNZ   1C74
....................    { 
....................       printf("\rEl anno no es bisiesto. Reseteando inicializacion...\r"); 
1C4C:  CLRF   xA5
1C4E:  MOVF   xA5,W
1C50:  CALL   087E
1C54:  IORLW  00
1C56:  BZ    1C62
1C58:  INCF   xA5,F
1C5A:  BTFSS  F9E.4
1C5C:  BRA    1C5A
1C5E:  MOVWF  FAD
1C60:  BRA    1C4E
....................       delay_ms(LCD_T_RETARDO); 
1C62:  MOVLW  02
1C64:  MOVWF  xA5
1C66:  MOVLW  FA
1C68:  MOVWF  xB0
1C6A:  CALL   12A8
1C6E:  DECFSZ xA5,F
1C70:  BRA    1C66
....................       goto e1; 
1C72:  BRA    1976
....................    } 
....................  
....................    //Introducimos un pequeño retardo para que el técnico vea los valores introducidos 
....................    delay_ms(LCD_T_RETARDO); 
1C74:  MOVLW  02
1C76:  MOVWF  xA5
1C78:  MOVLW  FA
1C7A:  MOVWF  xB0
1C7C:  CALL   12A8
1C80:  DECFSZ xA5,F
1C82:  BRA    1C78
....................  
....................    //Calculamos el año en el intervalo de 0 a 3 según sean bisiesto este año 
....................    //o los anteriores. 
....................    if(anno%4==0) 
1C84:  MOVF   x98,W
1C86:  ANDLW  03
1C88:  BNZ   1C8E
....................       anno_actual_0_to_3 = 0; 
1C8A:  CLRF   6C
....................    else if((anno-1)%4==0) 
1C8C:  BRA    1CB6
1C8E:  MOVLW  01
1C90:  SUBWF  x98,W
1C92:  ANDLW  03
1C94:  BNZ   1C9C
....................       anno_actual_0_to_3 = 1; 
1C96:  MOVLW  01
1C98:  MOVWF  6C
....................    else if((anno-2)%4==0) 
1C9A:  BRA    1CB6
1C9C:  MOVLW  02
1C9E:  SUBWF  x98,W
1CA0:  ANDLW  03
1CA2:  BNZ   1CAA
....................       anno_actual_0_to_3 = 2; 
1CA4:  MOVLW  02
1CA6:  MOVWF  6C
....................    else if((anno-3)%4==0) 
1CA8:  BRA    1CB6
1CAA:  MOVLW  03
1CAC:  SUBWF  x98,W
1CAE:  ANDLW  03
1CB0:  BNZ   1CB6
....................       anno_actual_0_to_3 = 3; 
1CB2:  MOVLW  03
1CB4:  MOVWF  6C
....................  
....................    e2: 
....................    //Se pide la introducción de la hora 
....................    printf("\rHORA: "); 
1CB6:  CLRF   xA5
1CB8:  MOVF   xA5,W
1CBA:  CALL   08D0
1CBE:  IORLW  00
1CC0:  BZ    1CCC
1CC2:  INCF   xA5,F
1CC4:  BTFSS  F9E.4
1CC6:  BRA    1CC4
1CC8:  MOVWF  FAD
1CCA:  BRA    1CB8
....................  
....................    //Leemos la hora 
....................    horas = buscar_numero_rs232(); 
1CCC:  RCALL  15EA
1CCE:  MOVFF  01,99
....................    //Si se pulsa "backspace", se resetea todo el proceso 
....................    if(horas==NO) 
1CD2:  MOVF   x99,W
1CD4:  SUBLW  64
1CD6:  BNZ   1D00
....................    { 
....................       printf("\rReseteando la inicializacion...\r"); 
1CD8:  CLRF   xA5
1CDA:  MOVF   xA5,W
1CDC:  CALL   08F2
1CE0:  IORLW  00
1CE2:  BZ    1CEE
1CE4:  INCF   xA5,F
1CE6:  BTFSS  F9E.4
1CE8:  BRA    1CE6
1CEA:  MOVWF  FAD
1CEC:  BRA    1CDA
....................       delay_ms(LCD_T_RETARDO); 
1CEE:  MOVLW  02
1CF0:  MOVWF  xA5
1CF2:  MOVLW  FA
1CF4:  MOVWF  xB0
1CF6:  CALL   12A8
1CFA:  DECFSZ xA5,F
1CFC:  BRA    1CF2
....................       goto e1; 
1CFE:  BRA    1976
....................    } 
....................    //Si las horas son incorrectas, mostramos un mensaje de error por pantalla y 
....................    //reseteamos la introducción de la misma. 
....................    if(horas>23) 
1D00:  MOVF   x99,W
1D02:  SUBLW  17
1D04:  BC    1D2E
....................    { 
....................       printf("  Hora incorrecta!"); 
1D06:  CLRF   xA5
1D08:  MOVF   xA5,W
1D0A:  CALL   092E
1D0E:  IORLW  00
1D10:  BZ    1D1C
1D12:  INCF   xA5,F
1D14:  BTFSS  F9E.4
1D16:  BRA    1D14
1D18:  MOVWF  FAD
1D1A:  BRA    1D08
....................       delay_ms(LCD_T_RETARDO); 
1D1C:  MOVLW  02
1D1E:  MOVWF  xA5
1D20:  MOVLW  FA
1D22:  MOVWF  xB0
1D24:  CALL   12A8
1D28:  DECFSZ xA5,F
1D2A:  BRA    1D20
....................       goto e2; 
1D2C:  BRA    1CB6
....................    } 
....................  
....................  
....................    //Leemos los minutos 
....................    printf(":"); 
1D2E:  CLRF   xA5
1D30:  MOVF   xA5,W
1D32:  CALL   095C
1D36:  IORLW  00
1D38:  BZ    1D44
1D3A:  INCF   xA5,F
1D3C:  BTFSS  F9E.4
1D3E:  BRA    1D3C
1D40:  MOVWF  FAD
1D42:  BRA    1D30
....................    minutos = buscar_numero_rs232(); 
1D44:  RCALL  15EA
1D46:  MOVFF  01,9A
....................  
....................    //Si se pulsa "backspace", reseteamos la inicialización completa 
....................    if(minutos==NO) 
1D4A:  MOVF   x9A,W
1D4C:  SUBLW  64
1D4E:  BNZ   1D78
....................    { 
....................       printf("\rReseteando la inicializacion...\r"); 
1D50:  CLRF   xA5
1D52:  MOVF   xA5,W
1D54:  CALL   08F2
1D58:  IORLW  00
1D5A:  BZ    1D66
1D5C:  INCF   xA5,F
1D5E:  BTFSS  F9E.4
1D60:  BRA    1D5E
1D62:  MOVWF  FAD
1D64:  BRA    1D52
....................       delay_ms(LCD_T_RETARDO); 
1D66:  MOVLW  02
1D68:  MOVWF  xA5
1D6A:  MOVLW  FA
1D6C:  MOVWF  xB0
1D6E:  CALL   12A8
1D72:  DECFSZ xA5,F
1D74:  BRA    1D6A
....................       goto e1; 
1D76:  BRA    1976
....................    } 
....................    //Si los minutos no son correctos, mostramos un mensaje de error por pantalla y 
....................    //reseteamos la introducción de los minutos 
....................    if(minutos>59) 
1D78:  MOVF   x9A,W
1D7A:  SUBLW  3B
1D7C:  BC    1DA6
....................    { 
....................       printf("  Minutos incorrectos!"); 
1D7E:  CLRF   xA5
1D80:  MOVF   xA5,W
1D82:  CALL   0978
1D86:  IORLW  00
1D88:  BZ    1D94
1D8A:  INCF   xA5,F
1D8C:  BTFSS  F9E.4
1D8E:  BRA    1D8C
1D90:  MOVWF  FAD
1D92:  BRA    1D80
....................       delay_ms(LCD_T_RETARDO); 
1D94:  MOVLW  02
1D96:  MOVWF  xA5
1D98:  MOVLW  FA
1D9A:  MOVWF  xB0
1D9C:  CALL   12A8
1DA0:  DECFSZ xA5,F
1DA2:  BRA    1D98
....................       goto e2; 
1DA4:  BRA    1CB6
....................    } 
....................  
....................    //Introducimos un pequeño retardo para que el técnico pueda ver la hora introducida 
....................    delay_ms(LCD_T_RETARDO); 
1DA6:  MOVLW  02
1DA8:  MOVWF  xA5
1DAA:  MOVLW  FA
1DAC:  MOVWF  xB0
1DAE:  CALL   12A8
1DB2:  DECFSZ xA5,F
1DB4:  BRA    1DAA
....................  
....................    //Mostramos un mensaje de guardado de configuración 
....................    printf("\rGuardando configuracion..."); 
1DB6:  CLRF   xA5
1DB8:  MOVF   xA5,W
1DBA:  CALL   09AA
1DBE:  IORLW  00
1DC0:  BZ    1DCC
1DC2:  INCF   xA5,F
1DC4:  BTFSS  F9E.4
1DC6:  BRA    1DC4
1DC8:  MOVWF  FAD
1DCA:  BRA    1DB8
....................  
....................    //Almacenamos todo en la estructura que contiene la información del tiempo 
....................    tiempo.month   = mes; 
1DCC:  MOVFF  97,5F
....................    tiempo.day     = dia; 
1DD0:  MOVFF  96,5E
....................    tiempo.year    = anno_actual_0_to_3; 
1DD4:  MOVFF  6C,60
....................    tiempo.hours   = horas; 
1DD8:  MOVFF  99,5D
....................    tiempo.minutes = minutos; 
1DDC:  MOVFF  9A,5C
....................    tiempo.seconds = 0x00; 
1DE0:  CLRF   5B
....................    tiempo.weekday = weekday; 
1DE2:  MOVFF  95,61
....................  
....................    //Fijamos el reloj a esa fecha y hora 
....................    PCF8583_set_datetime(&tiempo); 
1DE6:  CLRF   xA6
1DE8:  MOVLW  5B
1DEA:  MOVWF  xA5
1DEC:  BRA    173C
....................  
....................    //Establecemos los parámetros iniciales del sistema para resetear la memoria 
....................    termostato1 = termostato2 = (float)20; 
1DEE:  CLRF   27
1DF0:  CLRF   26
1DF2:  MOVLW  20
1DF4:  MOVWF  25
1DF6:  MOVLW  83
1DF8:  MOVWF  24
1DFA:  MOVFF  27,23
1DFE:  MOVFF  26,22
1E02:  MOVFF  25,21
1E06:  MOVFF  24,20
....................    num_intervalos = 0; 
1E0A:  CLRF   59
....................    num_registros = 0; 
1E0C:  CLRF   6A
1E0E:  CLRF   69
....................    anno_actual = anno; 
1E10:  MOVFF  98,6B
....................  
....................    //Escribimos los datos en la EEPROM, almacenando antes en un vector para 
....................    //agilizar la escritura por ráfaga 
....................    data[0] = (int)termostato1; 
1E14:  MOVFF  23,AC
1E18:  MOVFF  22,AB
1E1C:  MOVFF  21,AA
1E20:  MOVFF  20,A9
1E24:  RCALL  188E
1E26:  MOVFF  01,9B
....................    data[1] = num_intervalos; 
1E2A:  MOVFF  59,9C
....................    data[2] = (int)(num_registros/256); 
1E2E:  MOVF   6A,W
1E30:  MOVWF  x9D
....................    data[3] = (int)(num_registros - data[0]*256); 
1E32:  CLRF   xB7
1E34:  MOVFF  9B,B6
1E38:  MOVLW  01
1E3A:  MOVWF  xB9
1E3C:  CLRF   xB8
1E3E:  RCALL  18C8
1E40:  MOVF   01,W
1E42:  SUBWF  69,W
1E44:  MOVWF  00
1E46:  MOVF   02,W
1E48:  SUBWFB 6A,W
1E4A:  MOVFF  00,9E
....................    data[4] = anno_actual; 
1E4E:  MOVFF  6B,9F
....................    data[5] = anno_actual_0_to_3; 
1E52:  MOVFF  6C,A0
....................  
....................    graba_ee(eeprom_termostato, 6, data); 
1E56:  CLRF   xAC
1E58:  MOVLW  10
1E5A:  MOVWF  xAB
1E5C:  MOVLW  06
1E5E:  MOVWF  xAD
1E60:  CLRF   xAF
1E62:  MOVLW  9B
1E64:  MOVWF  xAE
1E66:  RCALL  18E6
....................  
....................    //Mostramos un mensaje de inicio del sistema 
....................    printf("\rIniciando sistema...\r"); 
1E68:  CLRF   xA5
1E6A:  MOVF   xA5,W
1E6C:  CALL   09E0
1E70:  IORLW  00
1E72:  BZ    1E7E
1E74:  INCF   xA5,F
1E76:  BTFSS  F9E.4
1E78:  BRA    1E76
1E7A:  MOVWF  FAD
1E7C:  BRA    1E6A
....................  
.................... } 
1E7E:  GOTO   5F46 (RETURN)
....................  
.................... //----------------------------------------------------------------------------------------------------------------------------------------- 
....................  
.................... void leer_programaciones(){ 
....................    int datos[5];    //Vector para almacenar los datos recuperados 
....................    programacion pr;  //Variable temporal para guardar la programación 
....................    int contador;    //Contador del bucle 
....................  
....................    //Se supone que antes ha sido recuperado el número de intervalos 
....................    //Recorremos todas las programaciones guardadas 
....................    for(contador=0; contador<num_intervalos; contador++) 
....................    { 
....................       //Leemos de memoria 
....................       lee_ee(eeprom_programaciones + (contador+1)*8, 5, datos); 
....................  
....................       //Guardamos los datos en la programación 
....................       pr.horas_inicio   = datos[0]; 
....................       pr.minutos_inicio = datos[1]; 
....................       pr.horas_fin      = datos[2]; 
....................       pr.minutos_fin    = datos[3]; 
....................       pr.termostato     = datos[4]; 
....................  
....................       //Guardamos la programación en el vector correspondiente 
....................       programaciones[contador] = pr; 
....................  
....................    } 
....................  
.................... } 
....................  
.................... //----------------------------------------------------------------------------------------------------------------------------------------- 
....................  
.................... void mostrar_temperatura() 
.................... { 
....................    //Leemos el tiempo y lo guardamos en la variable tiempo 
....................    PCF8583_read_datetime(&tiempo); 
*
5C1C:  CLRF   xA6
5C1E:  MOVLW  5B
5C20:  MOVWF  xA5
5C22:  CALL   28AE
....................    //Activamos las interrupciones, que se desactivan dentro del método 
....................    enable_interrupts(GLOBAL); 
5C26:  MOVLW  C0
5C28:  IORWF  FF2,F
....................  
....................    //Mostramos la temperatura registrada 
....................    lcd_send_byte(LCD_ORDEN, LCD_CLEAR); 
5C2A:  CLRF   xAC
5C2C:  MOVLW  01
5C2E:  MOVWF  xAD
5C30:  CALL   1314
....................    printf(lcd_putc, "%3.1f%cC  %3.1f%cC\nHORA - ", temperatura1, 223, temperatura2, 223); 
5C34:  MOVLW  02
5C36:  MOVWF  FE9
5C38:  MOVFF  2F,9D
5C3C:  MOVFF  2E,9C
5C40:  MOVFF  2D,9B
5C44:  MOVFF  2C,9A
5C48:  MOVLW  01
5C4A:  MOVWF  x9E
5C4C:  CALL   3494
5C50:  MOVLW  DF
5C52:  MOVWF  xA7
5C54:  CALL   13C0
5C58:  MOVLW  43
5C5A:  MOVWF  xA7
5C5C:  CALL   13C0
5C60:  MOVLW  20
5C62:  MOVWF  xA7
5C64:  CALL   13C0
5C68:  MOVLW  20
5C6A:  MOVWF  xA7
5C6C:  CALL   13C0
5C70:  MOVLW  02
5C72:  MOVWF  FE9
5C74:  MOVFF  33,9D
5C78:  MOVFF  32,9C
5C7C:  MOVFF  31,9B
5C80:  MOVFF  30,9A
5C84:  MOVLW  01
5C86:  MOVWF  x9E
5C88:  CALL   3494
5C8C:  MOVLW  DF
5C8E:  MOVWF  xA7
5C90:  CALL   13C0
5C94:  MOVLW  11
5C96:  MOVWF  x96
5C98:  MOVF   x96,W
5C9A:  CALL   0A12
5C9E:  INCF   x96,F
5CA0:  MOVWF  00
5CA2:  MOVWF  xA7
5CA4:  CALL   13C0
5CA8:  MOVLW  1A
5CAA:  SUBWF  x96,W
5CAC:  BNZ   5C98
....................  
....................    //Mostramos la hora 
....................    //Comprobamos si los valores son menores que 10 para añadir un cero 
....................    //delante y que queden los valores alineados 
....................    if(tiempo.hours < 10) 
5CAE:  MOVF   5D,W
5CB0:  SUBLW  09
5CB2:  BNC   5CCA
....................       printf(lcd_putc, "0"); 
5CB4:  CLRF   x96
5CB6:  MOVF   x96,W
5CB8:  CALL   0A48
5CBC:  IORLW  00
5CBE:  BZ    5CCA
5CC0:  INCF   x96,F
5CC2:  MOVWF  xA7
5CC4:  CALL   13C0
5CC8:  BRA    5CB6
....................    printf(lcd_putc, "%u:", tiempo.hours); 
5CCA:  MOVFF  5D,96
5CCE:  MOVLW  1B
5CD0:  MOVWF  x97
5CD2:  RCALL  5BA4
5CD4:  MOVLW  3A
5CD6:  MOVWF  xA7
5CD8:  CALL   13C0
....................    if(tiempo.minutes < 10) 
5CDC:  MOVF   5C,W
5CDE:  SUBLW  09
5CE0:  BNC   5CF8
....................       printf(lcd_putc, "0"); 
5CE2:  CLRF   x96
5CE4:  MOVF   x96,W
5CE6:  CALL   0A48
5CEA:  IORLW  00
5CEC:  BZ    5CF8
5CEE:  INCF   x96,F
5CF0:  MOVWF  xA7
5CF2:  CALL   13C0
5CF6:  BRA    5CE4
....................    printf(lcd_putc, "%u", tiempo.minutes); 
5CF8:  MOVFF  5C,96
5CFC:  MOVLW  1B
5CFE:  MOVWF  x97
5D00:  RCALL  5BA4
.................... } 
5D02:  GOTO   5D3C (RETURN)
....................  
.................... //----------------------------------------------------------------------------------------------------------------------------------------- 
....................  
.................... void ordenar_programaciones() 
.................... { 
....................    //Variables temporales y contadores auxiliares 
....................    programacion *pr1; 
....................    programacion *pr2; 
....................    int contador1, contador2; 
....................    int h_inicio_1, min_inicio_1, h_inicio_2, min_inicio_2; 
....................  
....................    //Ambos punteros comienzan apuntando al principio de programaciones 
....................    pr1 = programaciones; 
*
37BE:  CLRF   x96
37C0:  MOVLW  3B
37C2:  MOVWF  x95
....................    pr2 = programaciones; 
37C4:  CLRF   x98
37C6:  MOVWF  x97
....................  
....................  
....................    //Algoritmo de la burbuja 
....................    for(contador1=0; contador1 < num_intervalos; contador1++) 
37C8:  CLRF   x99
37CA:  MOVF   59,W
37CC:  SUBWF  x99,W
37CE:  BTFSC  FD8.0
37D0:  BRA    38F2
....................    { 
....................       //Apuntamos a las dos últimas posiciones del vector 
....................       pr1 = programaciones+num_intervalos-2; 
37D2:  MOVF   59,W
37D4:  MULLW  05
37D6:  MOVF   FF3,W
37D8:  ADDLW  3B
37DA:  MOVWF  xA4
37DC:  CLRF   xA5
37DE:  BTFSC  FD8.0
37E0:  INCF   xA5,F
37E2:  MOVLW  0A
37E4:  SUBWF  xA4,W
37E6:  MOVWF  x95
37E8:  MOVLW  00
37EA:  SUBWFB xA5,W
37EC:  MOVWF  x96
....................       pr2 = programaciones+num_intervalos-1; 
37EE:  MOVF   59,W
37F0:  MULLW  05
37F2:  MOVF   FF3,W
37F4:  ADDLW  3B
37F6:  MOVWF  xA4
37F8:  CLRF   xA5
37FA:  BTFSC  FD8.0
37FC:  INCF   xA5,F
37FE:  MOVLW  05
3800:  SUBWF  xA4,W
3802:  MOVWF  x97
3804:  MOVLW  00
3806:  SUBWFB xA5,W
3808:  MOVWF  x98
....................  
....................       //Iteramos hasta llegar a la zona ordenada del vector 
....................       for(contador2=0; contador2 < num_intervalos-contador1-1; contador2++) 
380A:  CLRF   x9A
380C:  MOVF   x99,W
380E:  SUBWF  59,W
3810:  ADDLW  FF
3812:  SUBWF  x9A,W
3814:  BC    38EE
....................       { 
....................          //Tomamos para la comparación los instantes de inicio 
....................          h_inicio_1   = (*pr1).horas_inicio; 
3816:  MOVFF  95,FE9
381A:  MOVFF  96,FEA
381E:  MOVFF  FEF,9B
....................          min_inicio_1 = (*pr1).minutos_inicio; 
3822:  MOVLW  01
3824:  ADDWF  x95,W
3826:  MOVWF  FE9
3828:  MOVLW  00
382A:  ADDWFC x96,W
382C:  MOVWF  FEA
382E:  MOVFF  FEF,9C
....................          h_inicio_2   = (*pr2).horas_inicio; 
3832:  MOVFF  97,FE9
3836:  MOVFF  98,FEA
383A:  MOVFF  FEF,9D
....................          min_inicio_2 = (*pr2).minutos_inicio; 
383E:  MOVLW  01
3840:  ADDWF  x97,W
3842:  MOVWF  FE9
3844:  MOVLW  00
3846:  ADDWFC x98,W
3848:  MOVWF  FEA
384A:  MOVFF  FEF,9E
....................  
....................          //Si la hora de pr2 es menor que la de pr1, habrá que intercambiar los 
....................          //valores para mover la menor a una posición más baja 
....................          if(comprobar_hora(h_inicio_2, min_inicio_2, h_inicio_1, min_inicio_1)) 
384E:  MOVFF  9D,AF
3852:  MOVFF  9E,B0
3856:  MOVFF  9B,B1
385A:  MOVFF  9C,B2
385E:  CALL   2C9C
3862:  MOVF   01,F
3864:  BZ    38DA
....................          { 
....................             programacion temporal; 
....................             temporal = *pr1; 
3866:  MOVFF  96,03
386A:  MOVFF  95,A4
386E:  MOVFF  96,A5
3872:  CLRF   FEA
3874:  MOVLW  9F
3876:  MOVWF  FE9
3878:  MOVFF  96,FE2
387C:  MOVFF  95,FE1
3880:  MOVLW  05
3882:  MOVWF  01
3884:  MOVFF  FE6,FEE
3888:  DECFSZ 01,F
388A:  BRA    3884
....................             *pr1 = *pr2; 
388C:  MOVFF  95,A6
3890:  MOVFF  96,A7
3894:  MOVFF  98,03
3898:  MOVFF  97,A8
389C:  MOVFF  98,A9
38A0:  MOVFF  96,FEA
38A4:  MOVFF  95,FE9
38A8:  MOVFF  98,FE2
38AC:  MOVFF  97,FE1
38B0:  MOVLW  05
38B2:  MOVWF  01
38B4:  MOVFF  FE6,FEE
38B8:  DECFSZ 01,F
38BA:  BRA    38B4
....................             *pr2 = temporal; 
38BC:  MOVFF  98,03
38C0:  MOVFF  97,FE9
38C4:  MOVFF  03,FEA
38C8:  CLRF   FE2
38CA:  MOVLW  9F
38CC:  MOVWF  FE1
38CE:  MOVLW  05
38D0:  MOVWF  01
38D2:  MOVFF  FE6,FEE
38D6:  DECFSZ 01,F
38D8:  BRA    38D2
....................          } 
....................  
....................          //Pasamos a la siguiente posición y repetimos el proceso 
....................          pr1--; 
38DA:  MOVLW  FB
38DC:  ADDWF  x95,F
38DE:  BTFSS  FD8.0
38E0:  DECF   x96,F
....................          pr2--; 
38E2:  MOVLW  FB
38E4:  ADDWF  x97,F
38E6:  BTFSS  FD8.0
38E8:  DECF   x98,F
....................       } 
38EA:  INCF   x9A,F
38EC:  BRA    380C
....................    } 
38EE:  INCF   x99,F
38F0:  BRA    37CA
.................... } 
38F2:  GOTO   6BF4 (RETURN)
....................  
.................... //----------------------------------------------------------------------------------------------------------------------------------------- 
....................  
.................... void programar_proxima_alarma() 
.................... { 
....................    //Variables auxiliares 
....................    int hora, minutos; 
....................  
....................    //Recuperamos los datos de inicio de la alarma actual 
....................    prg=programaciones[posicion_alarmas]; 
*
2B5C:  MOVF   5A,W
2B5E:  MULLW  05
2B60:  MOVF   FF3,W
2B62:  CLRF   03
2B64:  ADDLW  3B
2B66:  MOVWF  01
2B68:  MOVLW  00
2B6A:  ADDWFC 03,F
2B6C:  MOVFF  01,97
2B70:  MOVFF  03,98
2B74:  CLRF   FEA
2B76:  MOVLW  54
2B78:  MOVWF  FE9
2B7A:  MOVFF  03,FE2
2B7E:  MOVFF  01,FE1
2B82:  MOVLW  05
2B84:  MOVWF  01
2B86:  MOVFF  FE6,FEE
2B8A:  DECFSZ 01,F
2B8C:  BRA    2B86
....................    hora = prg.horas_inicio; 
2B8E:  MOVFF  54,95
....................    minutos = prg.minutos_inicio; 
2B92:  MOVFF  55,96
....................  
....................    //Establecemos la alarma a ese tiempo 
....................    PCF8583_establecer_alarma(hora, minutos, 0); 
2B96:  MOVFF  95,97
2B9A:  MOVFF  96,98
2B9E:  CLRF   x99
2BA0:  RCALL  2A9C
.................... } 
2BA2:  RETLW  00
....................  
.................... //----------------------------------------------------------------------------------------------------------------------------------------- 
....................  
.................... void representar_registros() 
.................... { 
....................    //Contadores y variables auxiliares 
....................    int contador, contador2; 
....................    unsigned int data[8], data2[4]; 
....................  
....................    float media_dia_mes[12];         //Tiempos medios en minutos que se enciende el sistema en cada mes 
....................    int dias_meses[12];              //Número de dias que tiene cada mes 
....................    float media_dia_caldera;         //Tiempo medio que se enciende la caldera cada día 
....................    float valor;                     //Tiempo medio en minutos que se enciende el sistema por día 
....................    float media_dia_mes_caldera[12]; //Tiempo medio que se enciende la caldera en cada mes 
....................  
....................    unsigned long valor_total;  //Tiempo total de encendido de la caldera 
....................    unsigned long valor_total_caldera; //Tiempo total de encendido del sistema 
....................  
....................    //Capacidad para 4 años de datos 
....................    //Vectores de almacenamiento de los datos anuales 
....................    float media_annos[4][12]; 
....................    float media_annos_caldera[4][12]; 
....................    //Número de años de los que se tienen datos 
....................    int num_annos; 
....................    //Años correspondientes 
....................    int annos[4]; 
....................  
....................    //Variables para almacenar valores provisionales 
....................    long tiempo_x_dia;         //Tiempo que se enciende cada día el sistema (minutos) 
....................    long tiempo_x_dia_caldera; //Tiempo que se enciende cada día la caldera (minutos) 
....................    int dia[3];               //Día con el que estamos trabajando (día/mes/año) 
....................    long num_dias;             //Número de días que llevamos analizados 
....................  
....................    //dias_meses = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}; 
....................    dias_meses[0] = dias_meses[2] = dias_meses[4] = dias_meses[6] = dias_meses[7] = dias_meses[9] = dias_meses[11] = 31; 
*
3DC0:  MOVLW  1F
3DC2:  MOVWF  xDE
3DC4:  MOVFF  DE,DC
3DC8:  MOVFF  DC,DA
3DCC:  MOVFF  DA,D9
3DD0:  MOVFF  D9,D7
3DD4:  MOVFF  D7,D5
3DD8:  MOVFF  D5,D3
....................    dias_meses[1] = 28; 
3DDC:  MOVLW  1C
3DDE:  MOVWF  xD4
....................    dias_meses[3] = dias_meses[5] = dias_meses[8] = dias_meses[10] = 30; 
3DE0:  MOVLW  1E
3DE2:  MOVWF  xDD
3DE4:  MOVFF  DD,DB
3DE8:  MOVFF  DB,D8
3DEC:  MOVFF  D8,D6
....................  
....................    //Inicializamos los vectores a 0 
....................    for(contador=0; contador<12;contador++) 
3DF0:  CLRF   x95
3DF2:  MOVF   x95,W
3DF4:  SUBLW  0B
3DF6:  BNC   3E16
....................    { 
....................       media_dia_mes[contador]=0; 
3DF8:  MOVF   x95,W
3DFA:  MULLW  04
3DFC:  MOVF   FF3,W
3DFE:  CLRF   03
3E00:  ADDLW  A3
3E02:  MOVWF  FE9
3E04:  MOVLW  00
3E06:  ADDWFC 03,W
3E08:  MOVWF  FEA
3E0A:  CLRF   FEF
3E0C:  CLRF   FEC
3E0E:  CLRF   FEC
3E10:  CLRF   FEC
....................    } 
3E12:  INCF   x95,F
3E14:  BRA    3DF2
....................  
....................    for(contador=0; contador<12;contador++) 
3E16:  CLRF   x95
3E18:  MOVF   x95,W
3E1A:  SUBLW  0B
3E1C:  BNC   3E3C
....................    { 
....................       media_dia_mes_caldera[contador]=0; 
3E1E:  MOVF   x95,W
3E20:  MULLW  04
3E22:  MOVF   FF3,W
3E24:  CLRF   03
3E26:  ADDLW  E7
3E28:  MOVWF  FE9
3E2A:  MOVLW  00
3E2C:  ADDWFC 03,W
3E2E:  MOVWF  FEA
3E30:  CLRF   FEF
3E32:  CLRF   FEC
3E34:  CLRF   FEC
3E36:  CLRF   FEC
....................    } 
3E38:  INCF   x95,F
3E3A:  BRA    3E18
....................  
....................    for(contador=0; contador<4 ;contador++) 
3E3C:  CLRF   x95
3E3E:  MOVF   x95,W
3E40:  SUBLW  03
3E42:  BNC   3E8A
....................    { 
....................       for(contador2=0; contador2<12 ;contador2++) 
3E44:  CLRF   x96
3E46:  MOVF   x96,W
3E48:  SUBLW  0B
3E4A:  BNC   3E86
....................       { 
....................          media_annos[contador][contador2]=0; 
3E4C:  MOVF   x95,W
3E4E:  MULLW  30
3E50:  MOVF   FF3,W
3E52:  MOVLB  2
3E54:  CLRF   xAA
3E56:  MOVWF  xA9
3E58:  MOVLB  0
3E5A:  MOVF   x96,W
3E5C:  MULLW  04
3E5E:  MOVF   FF3,W
3E60:  CLRF   03
3E62:  MOVLB  2
3E64:  ADDWF  xA9,W
3E66:  MOVWF  01
3E68:  MOVF   xAA,W
3E6A:  ADDWFC 03,F
3E6C:  MOVF   01,W
3E6E:  ADDLW  1B
3E70:  MOVWF  FE9
3E72:  MOVLW  01
3E74:  ADDWFC 03,W
3E76:  MOVWF  FEA
3E78:  CLRF   FEF
3E7A:  CLRF   FEC
3E7C:  CLRF   FEC
3E7E:  CLRF   FEC
....................       } 
3E80:  MOVLB  0
3E82:  INCF   x96,F
3E84:  BRA    3E46
....................    } 
3E86:  INCF   x95,F
3E88:  BRA    3E3E
....................  
....................    for(contador=0; contador<4 ;contador++) 
3E8A:  CLRF   x95
3E8C:  MOVF   x95,W
3E8E:  SUBLW  03
3E90:  BNC   3ED8
....................    { 
....................       for(contador2=0; contador2<12 ;contador2++) 
3E92:  CLRF   x96
3E94:  MOVF   x96,W
3E96:  SUBLW  0B
3E98:  BNC   3ED4
....................       { 
....................          media_annos_caldera[contador][contador2]=0; 
3E9A:  MOVF   x95,W
3E9C:  MULLW  30
3E9E:  MOVF   FF3,W
3EA0:  MOVLB  2
3EA2:  CLRF   xAA
3EA4:  MOVWF  xA9
3EA6:  MOVLB  0
3EA8:  MOVF   x96,W
3EAA:  MULLW  04
3EAC:  MOVF   FF3,W
3EAE:  CLRF   03
3EB0:  MOVLB  2
3EB2:  ADDWF  xA9,W
3EB4:  MOVWF  01
3EB6:  MOVF   xAA,W
3EB8:  ADDWFC 03,F
3EBA:  MOVF   01,W
3EBC:  ADDLW  DB
3EBE:  MOVWF  FE9
3EC0:  MOVLW  01
3EC2:  ADDWFC 03,W
3EC4:  MOVWF  FEA
3EC6:  CLRF   FEF
3EC8:  CLRF   FEC
3ECA:  CLRF   FEC
3ECC:  CLRF   FEC
....................       } 
3ECE:  MOVLB  0
3ED0:  INCF   x96,F
3ED2:  BRA    3E94
....................    } 
3ED4:  INCF   x95,F
3ED6:  BRA    3E8C
....................  
....................    //Iniciamos a cero las otras variables 
....................    dia[0] = dia[1] = dia[2] = 0; 
3ED8:  MOVLB  2
3EDA:  CLRF   xA6
3EDC:  MOVFF  2A6,2A5
3EE0:  MOVFF  2A5,2A4
....................    num_dias = 0; 
3EE4:  CLRF   xA8
3EE6:  CLRF   xA7
....................    num_annos = 0; 
3EE8:  CLRF   x9B
....................  
....................    media_dia_caldera = 0; 
3EEA:  MOVLB  0
3EEC:  CLRF   xE2
3EEE:  CLRF   xE1
3EF0:  CLRF   xE0
3EF2:  CLRF   xDF
....................    valor = 0; 
3EF4:  CLRF   xE6
3EF6:  CLRF   xE5
3EF8:  CLRF   xE4
3EFA:  CLRF   xE3
....................    valor_total = 0; 
3EFC:  MOVLB  1
3EFE:  CLRF   x18
3F00:  CLRF   x17
....................    valor_total_caldera = 0; 
3F02:  CLRF   x1A
3F04:  CLRF   x19
....................  
....................    //Imprimimos el encabezamiento 
....................    printf("\rREGISTRO DE EVENTOS\r"); 
3F06:  MOVLB  2
3F08:  CLRF   xA9
3F0A:  MOVF   xA9,W
3F0C:  MOVLB  0
3F0E:  CALL   0A64
3F12:  IORLW  00
3F14:  BZ    3F24
3F16:  MOVLB  2
3F18:  INCF   xA9,F
3F1A:  BTFSS  F9E.4
3F1C:  BRA    3F1A
3F1E:  MOVWF  FAD
3F20:  BRA    3F0A
3F22:  MOVLB  0
....................    printf("*******************\r"); 
3F24:  MOVLB  2
3F26:  CLRF   xA9
3F28:  MOVF   xA9,W
3F2A:  MOVLB  0
3F2C:  CALL   0A94
3F30:  IORLW  00
3F32:  BZ    3F42
3F34:  MOVLB  2
3F36:  INCF   xA9,F
3F38:  BTFSS  F9E.4
3F3A:  BRA    3F38
3F3C:  MOVWF  FAD
3F3E:  BRA    3F28
3F40:  MOVLB  0
....................    printf("Momento de apagado     Temperatura1       Temperatura2         Termostato        Minutos encendido       Minutos caldera\r"); 
3F42:  MOVLB  2
3F44:  CLRF   xA9
3F46:  MOVF   xA9,W
3F48:  MOVLB  0
3F4A:  CALL   0AC4
3F4E:  IORLW  00
3F50:  BZ    3F60
3F52:  MOVLB  2
3F54:  INCF   xA9,F
3F56:  BTFSS  F9E.4
3F58:  BRA    3F56
3F5A:  MOVWF  FAD
3F5C:  BRA    3F46
3F5E:  MOVLB  0
....................    printf("===========================================================================================================================\r"); 
3F60:  MOVLB  2
3F62:  CLRF   xA9
3F64:  MOVF   xA9,W
3F66:  MOVLB  0
3F68:  CALL   0B58
3F6C:  IORLW  00
3F6E:  BZ    3F7E
3F70:  MOVLB  2
3F72:  INCF   xA9,F
3F74:  BTFSS  F9E.4
3F76:  BRA    3F74
3F78:  MOVWF  FAD
3F7A:  BRA    3F64
3F7C:  MOVLB  0
....................  
....................    //Recorremos todos los registros almacenados 
....................    for(contador=0; contador<num_registros; contador++) 
3F7E:  CLRF   x95
3F80:  MOVF   6A,F
3F82:  BNZ   3F8E
3F84:  MOVF   69,W
3F86:  SUBWF  x95,W
3F88:  BTFSC  FD8.0
3F8A:  GOTO   4754
....................    { 
....................       //Comenzamos leyendo los datos de memoria 
....................       lee_ee((unsigned long)eeprom_registros + (unsigned long)contador*(unsigned long)2*(unsigned long)8, 8, data); 
3F8E:  MOVLB  2
3F90:  CLRF   xAA
3F92:  MOVFF  95,2A9
3F96:  BCF    FD8.0
3F98:  RLCF   xA9,W
3F9A:  MOVWF  xAB
3F9C:  RLCF   xAA,W
3F9E:  MOVWF  xAC
3FA0:  RLCF   xAB,W
3FA2:  MOVWF  02
3FA4:  RLCF   xAC,W
3FA6:  MOVWF  03
3FA8:  RLCF   02,F
3FAA:  RLCF   03,F
3FAC:  RLCF   02,F
3FAE:  RLCF   03,F
3FB0:  MOVLW  F8
3FB2:  ANDWF  02,F
3FB4:  MOVF   02,W
3FB6:  ADDLW  50
3FB8:  MOVWF  xAD
3FBA:  MOVLW  00
3FBC:  ADDWFC 03,W
3FBE:  MOVWF  xAE
3FC0:  MOVWF  xB2
3FC2:  MOVFF  2AD,2B1
3FC6:  MOVLW  08
3FC8:  MOVWF  xB3
3FCA:  CLRF   xB5
3FCC:  MOVLW  97
3FCE:  MOVWF  xB4
3FD0:  MOVLB  0
3FD2:  RCALL  3A00
....................       lee_ee((unsigned long)eeprom_registros + (unsigned long)contador*(unsigned long)2*(unsigned long)8 + (unsigned long)8, 4, data2); 
3FD4:  MOVLB  2
3FD6:  CLRF   xAA
3FD8:  MOVFF  95,2A9
3FDC:  BCF    FD8.0
3FDE:  RLCF   xA9,W
3FE0:  MOVWF  xAB
3FE2:  RLCF   xAA,W
3FE4:  MOVWF  xAC
3FE6:  RLCF   xAB,W
3FE8:  MOVWF  02
3FEA:  RLCF   xAC,W
3FEC:  MOVWF  03
3FEE:  RLCF   02,F
3FF0:  RLCF   03,F
3FF2:  RLCF   02,F
3FF4:  RLCF   03,F
3FF6:  MOVLW  F8
3FF8:  ANDWF  02,F
3FFA:  MOVF   02,W
3FFC:  ADDLW  50
3FFE:  MOVWF  xAD
4000:  MOVLW  00
4002:  ADDWFC 03,W
4004:  MOVWF  xAE
4006:  MOVLW  08
4008:  ADDWF  xAD,W
400A:  MOVWF  xAF
400C:  MOVLW  00
400E:  ADDWFC xAE,W
4010:  MOVWF  xB0
4012:  MOVWF  xB2
4014:  MOVFF  2AF,2B1
4018:  MOVLW  04
401A:  MOVWF  xB3
401C:  CLRF   xB5
401E:  MOVLW  9F
4020:  MOVWF  xB4
4022:  MOVLB  0
4024:  RCALL  3A00
....................  
....................       //Si cambiamos de día debemos gestionar los datos del nuevo día y almacenar los del anterior 
....................       if(dia[0]!=data[0] || dia[1]!=data[1] || dia[2]!=data2[0]) 
4026:  MOVF   x97,W
4028:  MOVLB  2
402A:  SUBWF  xA4,W
402C:  BNZ   4044
402E:  MOVLB  0
4030:  MOVF   x98,W
4032:  MOVLB  2
4034:  SUBWF  xA5,W
4036:  BNZ   4044
4038:  MOVLB  0
403A:  MOVF   x9F,W
403C:  MOVLB  2
403E:  SUBWF  xA6,W
4040:  BTFSC  FD8.2
4042:  BRA    43BA
....................       { 
....................          //Lógicamente, no tenemos en cuenta para la media los días en los que no se enciende: 
....................          //días de verano, calurosos, etc. Esta información puede visualizarse en la media 
....................          //por meses. 
....................          //Guardamos los datos del día anterior si el día no es el primero 
....................          if(dia[0]!=0) 
4044:  MOVF   xA4,F
4046:  BZ    411C
....................          { 
....................             //En la media de tiempo por día, acumulamos el tiempo que ha estado encendido el último día 
....................             valor = valor + (float)tiempo_x_dia; 
4048:  MOVFF  2A1,2B0
404C:  MOVFF  2A0,2AF
4050:  MOVLB  0
4052:  CALL   276A
4056:  BCF    FD8.1
4058:  MOVFF  E6,2AC
405C:  MOVFF  E5,2AB
4060:  MOVFF  E4,2AA
4064:  MOVFF  E3,2A9
4068:  MOVFF  03,2B0
406C:  MOVFF  02,2AF
4070:  MOVFF  01,2AE
4074:  MOVFF  00,2AD
4078:  CALL   24F0
407C:  MOVFF  03,E6
4080:  MOVFF  02,E5
4084:  MOVFF  01,E4
4088:  MOVFF  00,E3
....................             //Guardamos también este valor en el registro del año 
....................             media_dia_mes[dia[1]-1] = valor; 
408C:  MOVLW  01
408E:  MOVLB  2
4090:  SUBWF  xA5,W
4092:  MULLW  04
4094:  MOVF   FF3,W
4096:  CLRF   03
4098:  ADDLW  A3
409A:  MOVWF  FE9
409C:  MOVLW  00
409E:  ADDWFC 03,W
40A0:  MOVWF  FEA
40A2:  MOVFF  E3,FEF
40A6:  MOVFF  E4,FEC
40AA:  MOVFF  E5,FEC
40AE:  MOVFF  E6,FEC
....................             //Realizamos la misma operación con la media de encendido de la caldera 
....................             media_dia_caldera = media_dia_caldera + (float)tiempo_x_dia_caldera; 
40B2:  MOVFF  2A3,2B0
40B6:  MOVFF  2A2,2AF
40BA:  MOVLB  0
40BC:  CALL   276A
40C0:  BCF    FD8.1
40C2:  MOVFF  E2,2AC
40C6:  MOVFF  E1,2AB
40CA:  MOVFF  E0,2AA
40CE:  MOVFF  DF,2A9
40D2:  MOVFF  03,2B0
40D6:  MOVFF  02,2AF
40DA:  MOVFF  01,2AE
40DE:  MOVFF  00,2AD
40E2:  CALL   24F0
40E6:  MOVFF  03,E2
40EA:  MOVFF  02,E1
40EE:  MOVFF  01,E0
40F2:  MOVFF  00,DF
....................             media_dia_mes_caldera[dia[1]-1] = media_dia_caldera; 
40F6:  MOVLW  01
40F8:  MOVLB  2
40FA:  SUBWF  xA5,W
40FC:  MULLW  04
40FE:  MOVF   FF3,W
4100:  CLRF   03
4102:  ADDLW  E7
4104:  MOVWF  FE9
4106:  MOVLW  00
4108:  ADDWFC 03,W
410A:  MOVWF  FEA
410C:  MOVFF  DF,FEF
4110:  MOVFF  E0,FEC
4114:  MOVFF  E1,FEC
4118:  MOVFF  E2,FEC
....................          } 
....................          //La sumatoria podría alcanzar un valor muy alto. El sistema no está preparado para estas eventualidades 
....................          //y debería ser reseteado cada cierto tiempo. Si el sistema va a utilizarse mucho (zonas muy frías o mal 
....................          //aisladas), el usuario debería informar al fabricante para aumentar la memoria de almacenamiento y el 
....................          //tamaño de las variables 
....................  
....................          //Si cambiamos de año, habrá que guardar los datos anuales 
....................          if(dia[2]!=data2[0]) 
411C:  MOVLB  0
411E:  MOVF   x9F,W
4120:  MOVLB  2
4122:  SUBWF  xA6,W
4124:  BTFSC  FD8.2
4126:  BRA    43A0
....................          { 
....................             //Comprobamos que no nos encontrabamos en el año introducido por defecto 
....................             if(dia[2]!=0) 
4128:  MOVF   xA6,F
412A:  BTFSC  FD8.2
412C:  BRA    438C
....................             { 
....................                //En ese caso, guardamos los datos de todo el año 
....................                for(contador2=0; contador2<12; contador2++) 
412E:  MOVLB  0
4130:  CLRF   x96
4132:  MOVF   x96,W
4134:  SUBLW  0B
4136:  BTFSS  FD8.0
4138:  BRA    4376
....................                { 
....................                   media_dia_mes[contador2] = media_dia_mes[contador2]/(float)dias_meses[contador2]; 
413A:  MOVF   x96,W
413C:  MULLW  04
413E:  MOVF   FF3,W
4140:  CLRF   03
4142:  ADDLW  A3
4144:  MOVWF  01
4146:  MOVLW  00
4148:  ADDWFC 03,F
414A:  MOVFF  01,2A9
414E:  MOVFF  03,2AA
4152:  MOVLB  0
4154:  MOVF   x96,W
4156:  MULLW  04
4158:  MOVF   FF3,W
415A:  CLRF   03
415C:  ADDLW  A3
415E:  MOVWF  FE9
4160:  MOVLW  00
4162:  ADDWFC 03,W
4164:  MOVWF  FEA
4166:  MOVFF  FEF,2AB
416A:  MOVFF  FEC,2AC
416E:  MOVFF  FEC,2AD
4172:  MOVFF  FEC,2AE
4176:  CLRF   03
4178:  MOVF   x96,W
417A:  ADDLW  D3
417C:  MOVWF  FE9
417E:  MOVLW  00
4180:  ADDWFC 03,W
4182:  MOVWF  FEA
4184:  MOVF   FEF,W
4186:  MOVLB  2
4188:  CLRF   xB0
418A:  MOVWF  xAF
418C:  MOVLB  0
418E:  CALL   276A
4192:  MOVFF  2AE,2B2
4196:  MOVFF  2AD,2B1
419A:  MOVFF  2AC,2B0
419E:  MOVFF  2AB,2AF
41A2:  MOVFF  03,2B6
41A6:  MOVFF  02,2B5
41AA:  MOVFF  01,2B4
41AE:  MOVFF  00,2B3
41B2:  CALL   2120
41B6:  MOVFF  2AA,FEA
41BA:  MOVFF  2A9,FE9
41BE:  MOVFF  00,FEF
41C2:  MOVFF  01,FEC
41C6:  MOVFF  02,FEC
41CA:  MOVFF  03,FEC
....................                   media_dia_mes_caldera[contador2] = media_dia_mes_caldera[contador2]/(float)dias_meses[contador2]; 
41CE:  MOVF   x96,W
41D0:  MULLW  04
41D2:  MOVF   FF3,W
41D4:  CLRF   03
41D6:  ADDLW  E7
41D8:  MOVWF  01
41DA:  MOVLW  00
41DC:  ADDWFC 03,F
41DE:  MOVFF  01,2A9
41E2:  MOVFF  03,2AA
41E6:  MOVLB  0
41E8:  MOVF   x96,W
41EA:  MULLW  04
41EC:  MOVF   FF3,W
41EE:  CLRF   03
41F0:  ADDLW  E7
41F2:  MOVWF  FE9
41F4:  MOVLW  00
41F6:  ADDWFC 03,W
41F8:  MOVWF  FEA
41FA:  MOVFF  FEF,2AB
41FE:  MOVFF  FEC,2AC
4202:  MOVFF  FEC,2AD
4206:  MOVFF  FEC,2AE
420A:  CLRF   03
420C:  MOVF   x96,W
420E:  ADDLW  D3
4210:  MOVWF  FE9
4212:  MOVLW  00
4214:  ADDWFC 03,W
4216:  MOVWF  FEA
4218:  MOVF   FEF,W
421A:  MOVLB  2
421C:  CLRF   xB0
421E:  MOVWF  xAF
4220:  MOVLB  0
4222:  CALL   276A
4226:  MOVFF  2AE,2B2
422A:  MOVFF  2AD,2B1
422E:  MOVFF  2AC,2B0
4232:  MOVFF  2AB,2AF
4236:  MOVFF  03,2B6
423A:  MOVFF  02,2B5
423E:  MOVFF  01,2B4
4242:  MOVFF  00,2B3
4246:  CALL   2120
424A:  MOVFF  2AA,FEA
424E:  MOVFF  2A9,FE9
4252:  MOVFF  00,FEF
4256:  MOVFF  01,FEC
425A:  MOVFF  02,FEC
425E:  MOVFF  03,FEC
....................                   media_annos[num_annos][contador2] = media_dia_mes[contador2]; 
4262:  MOVLB  2
4264:  MOVF   x9B,W
4266:  MULLW  30
4268:  MOVF   FF3,W
426A:  CLRF   xAA
426C:  MOVWF  xA9
426E:  MOVLB  0
4270:  MOVF   x96,W
4272:  MULLW  04
4274:  MOVF   FF3,W
4276:  CLRF   03
4278:  MOVLB  2
427A:  ADDWF  xA9,W
427C:  MOVWF  01
427E:  MOVF   xAA,W
4280:  ADDWFC 03,F
4282:  MOVF   01,W
4284:  ADDLW  1B
4286:  MOVWF  01
4288:  MOVLW  01
428A:  ADDWFC 03,F
428C:  MOVFF  01,2AB
4290:  MOVFF  03,2AC
4294:  MOVLB  0
4296:  MOVF   x96,W
4298:  MULLW  04
429A:  MOVF   FF3,W
429C:  CLRF   03
429E:  ADDLW  A3
42A0:  MOVWF  FE9
42A2:  MOVLW  00
42A4:  ADDWFC 03,W
42A6:  MOVWF  FEA
42A8:  MOVFF  FEF,00
42AC:  MOVFF  FEC,01
42B0:  MOVFF  FEC,02
42B4:  MOVFF  FEC,03
42B8:  MOVFF  2AC,FEA
42BC:  MOVFF  2AB,FE9
42C0:  MOVFF  00,FEF
42C4:  MOVFF  01,FEC
42C8:  MOVFF  02,FEC
42CC:  MOVFF  03,FEC
....................                   media_annos_caldera[num_annos][contador2] = media_dia_mes_caldera[contador2]; 
42D0:  MOVLB  2
42D2:  MOVF   x9B,W
42D4:  MULLW  30
42D6:  MOVF   FF3,W
42D8:  CLRF   xAA
42DA:  MOVWF  xA9
42DC:  MOVLB  0
42DE:  MOVF   x96,W
42E0:  MULLW  04
42E2:  MOVF   FF3,W
42E4:  CLRF   03
42E6:  MOVLB  2
42E8:  ADDWF  xA9,W
42EA:  MOVWF  01
42EC:  MOVF   xAA,W
42EE:  ADDWFC 03,F
42F0:  MOVF   01,W
42F2:  ADDLW  DB
42F4:  MOVWF  01
42F6:  MOVLW  01
42F8:  ADDWFC 03,F
42FA:  MOVFF  01,2AB
42FE:  MOVFF  03,2AC
4302:  MOVLB  0
4304:  MOVF   x96,W
4306:  MULLW  04
4308:  MOVF   FF3,W
430A:  CLRF   03
430C:  ADDLW  E7
430E:  MOVWF  FE9
4310:  MOVLW  00
4312:  ADDWFC 03,W
4314:  MOVWF  FEA
4316:  MOVFF  FEF,00
431A:  MOVFF  FEC,01
431E:  MOVFF  FEC,02
4322:  MOVFF  FEC,03
4326:  MOVFF  2AC,FEA
432A:  MOVFF  2AB,FE9
432E:  MOVFF  00,FEF
4332:  MOVFF  01,FEC
4336:  MOVFF  02,FEC
433A:  MOVFF  03,FEC
....................                   //Volvemos a inicializar los contenedores de información anual 
....................                   media_dia_mes[contador2]=0; 
433E:  MOVF   x96,W
4340:  MULLW  04
4342:  MOVF   FF3,W
4344:  CLRF   03
4346:  ADDLW  A3
4348:  MOVWF  FE9
434A:  MOVLW  00
434C:  ADDWFC 03,W
434E:  MOVWF  FEA
4350:  CLRF   FEF
4352:  CLRF   FEC
4354:  CLRF   FEC
4356:  CLRF   FEC
....................                   media_dia_mes_caldera[contador2]=0; 
4358:  MOVF   x96,W
435A:  MULLW  04
435C:  MOVF   FF3,W
435E:  CLRF   03
4360:  ADDLW  E7
4362:  MOVWF  FE9
4364:  MOVLW  00
4366:  ADDWFC 03,W
4368:  MOVWF  FEA
436A:  CLRF   FEF
436C:  CLRF   FEC
436E:  CLRF   FEC
4370:  CLRF   FEC
....................                } 
4372:  INCF   x96,F
4374:  BRA    4132
....................  
....................                //Guardamos el año del que se trata 
....................                annos[num_annos]=dia[2]; 
4376:  CLRF   03
4378:  MOVLB  2
437A:  MOVF   x9B,W
437C:  ADDLW  9C
437E:  MOVWF  FE9
4380:  MOVLW  02
4382:  ADDWFC 03,W
4384:  MOVWF  FEA
4386:  MOVFF  2A6,FEF
....................  
....................                //Aumentamos en 1 el número de años 
....................                num_annos++; 
438A:  INCF   x9B,F
....................             } 
....................  
....................             //COMPROBAR BISIESTO 
....................             //En realidad, un año será bisiesto si es divisible por 4 y no lo es por 100, 
....................             //excepto si este último lo es por 400. Sin embargo, dado que trabajamos con las 
....................             //dos últimas cifras y que el próximo año divisible por 4 que no lo es por 100 
....................             //es el 2100, mejor nos limitaremos a la divisibilidad por 4. 
....................             //Dependiendo si el año es bisiesto o no, le damos a febrero 29 o 28 días. 
....................             if(data2[0]%4 == 0) 
438C:  MOVLB  0
438E:  MOVF   x9F,W
4390:  ANDLW  03
4392:  BNZ   439A
....................                dias_meses[1] = 29; 
4394:  MOVLW  1D
4396:  MOVWF  xD4
....................             else 
4398:  BRA    439E
....................                dias_meses[1] = 28; 
439A:  MOVLW  1C
439C:  MOVWF  xD4
439E:  MOVLB  2
....................          } 
....................  
....................          //Modificamos la información del día 
....................          dia[0] = data[0]; 
43A0:  MOVFF  97,2A4
....................          dia[1] = data[1]; 
43A4:  MOVFF  98,2A5
....................          dia[2] = data2[0]; 
43A8:  MOVFF  9F,2A6
....................  
....................          //Aumentamos en 1 el número de días 
....................          num_dias++; 
43AC:  INCF   xA7,F
43AE:  BTFSC  FD8.2
43B0:  INCF   xA8,F
....................  
....................          //Reseteamos las variables acumulativas de tiempo por día 
....................          tiempo_x_dia = 0; 
43B2:  CLRF   xA1
43B4:  CLRF   xA0
....................          tiempo_x_dia_caldera = 0; 
43B6:  CLRF   xA3
43B8:  CLRF   xA2
....................       } 
....................  
....................       //Le sumamos al tiempo de encendido de sistema y caldera el correspondiente de este registro 
....................       tiempo_x_dia = tiempo_x_dia + data2[1]; 
43BA:  MOVLB  0
43BC:  MOVF   xA0,W
43BE:  MOVLB  2
43C0:  ADDWF  xA0,F
43C2:  MOVLW  00
43C4:  ADDWFC xA1,F
....................       tiempo_x_dia_caldera = tiempo_x_dia_caldera + data2[2]; 
43C6:  MOVLB  0
43C8:  MOVF   xA1,W
43CA:  MOVLB  2
43CC:  ADDWF  xA2,F
43CE:  MOVLW  00
43D0:  ADDWFC xA3,F
....................       //También incrementamos los tiempos totales 
....................       valor_total = valor_total + data2[1]; 
43D2:  MOVLB  0
43D4:  MOVF   xA0,W
43D6:  MOVLB  1
43D8:  ADDWF  x17,F
43DA:  MOVLW  00
43DC:  ADDWFC x18,F
....................       valor_total_caldera = valor_total_caldera + data2[2]; 
43DE:  MOVLB  0
43E0:  MOVF   xA1,W
43E2:  MOVLB  1
43E4:  ADDWF  x19,F
43E6:  MOVLW  00
43E8:  ADDWFC x1A,F
....................  
....................       //Representamos todos los datos, teniendo en cuenta algunos requisitos representativos 
....................       //para que los datos queden alineados (número menores que 10, que 100, etc). 
....................       if(data[0]<10) 
43EA:  MOVLB  0
43EC:  MOVF   x97,W
43EE:  SUBLW  09
43F0:  BNC   4410
....................          printf(" "); 
43F2:  MOVLB  2
43F4:  CLRF   xA9
43F6:  MOVF   xA9,W
43F8:  MOVLB  0
43FA:  CALL   0BF0
43FE:  IORLW  00
4400:  BZ    4410
4402:  MOVLB  2
4404:  INCF   xA9,F
4406:  BTFSS  F9E.4
4408:  BRA    4406
440A:  MOVWF  FAD
440C:  BRA    43F6
440E:  MOVLB  0
....................  
....................       printf("%u/", data[0]); 
4410:  MOVFF  97,2AA
4414:  MOVLW  1B
4416:  MOVLB  2
4418:  MOVWF  xAB
441A:  MOVLB  0
441C:  CALL   3AF0
4420:  MOVLW  2F
4422:  BTFSS  F9E.4
4424:  BRA    4422
4426:  MOVWF  FAD
....................  
....................       if(data[1]<10) 
4428:  MOVF   x98,W
442A:  SUBLW  09
442C:  BNC   444C
....................          printf("0"); 
442E:  MOVLB  2
4430:  CLRF   xA9
4432:  MOVF   xA9,W
4434:  MOVLB  0
4436:  CALL   0A48
443A:  IORLW  00
443C:  BZ    444C
443E:  MOVLB  2
4440:  INCF   xA9,F
4442:  BTFSS  F9E.4
4444:  BRA    4442
4446:  MOVWF  FAD
4448:  BRA    4432
444A:  MOVLB  0
....................  
....................       printf("%u/", data[1]); 
444C:  MOVFF  98,2AA
4450:  MOVLW  1B
4452:  MOVLB  2
4454:  MOVWF  xAB
4456:  MOVLB  0
4458:  CALL   3AF0
445C:  MOVLW  2F
445E:  BTFSS  F9E.4
4460:  BRA    445E
4462:  MOVWF  FAD
....................  
....................       if(data2[0]<10) 
4464:  MOVF   x9F,W
4466:  SUBLW  09
4468:  BNC   4488
....................          printf("0"); 
446A:  MOVLB  2
446C:  CLRF   xA9
446E:  MOVF   xA9,W
4470:  MOVLB  0
4472:  CALL   0A48
4476:  IORLW  00
4478:  BZ    4488
447A:  MOVLB  2
447C:  INCF   xA9,F
447E:  BTFSS  F9E.4
4480:  BRA    447E
4482:  MOVWF  FAD
4484:  BRA    446E
4486:  MOVLB  0
....................  
....................       printf("%u  ", data2[0]); 
4488:  MOVFF  9F,2AA
448C:  MOVLW  1B
448E:  MOVLB  2
4490:  MOVWF  xAB
4492:  MOVLB  0
4494:  CALL   3AF0
4498:  MOVLW  20
449A:  BTFSS  F9E.4
449C:  BRA    449A
449E:  MOVWF  FAD
44A0:  MOVLW  20
44A2:  BTFSS  F9E.4
44A4:  BRA    44A2
44A6:  MOVWF  FAD
....................  
....................       if(data[2]<10) 
44A8:  MOVF   x99,W
44AA:  SUBLW  09
44AC:  BNC   44CC
....................          printf("0"); 
44AE:  MOVLB  2
44B0:  CLRF   xA9
44B2:  MOVF   xA9,W
44B4:  MOVLB  0
44B6:  CALL   0A48
44BA:  IORLW  00
44BC:  BZ    44CC
44BE:  MOVLB  2
44C0:  INCF   xA9,F
44C2:  BTFSS  F9E.4
44C4:  BRA    44C2
44C6:  MOVWF  FAD
44C8:  BRA    44B2
44CA:  MOVLB  0
....................  
....................       printf("%u:", data[2]); 
44CC:  MOVFF  99,2AA
44D0:  MOVLW  1B
44D2:  MOVLB  2
44D4:  MOVWF  xAB
44D6:  MOVLB  0
44D8:  CALL   3AF0
44DC:  MOVLW  3A
44DE:  BTFSS  F9E.4
44E0:  BRA    44DE
44E2:  MOVWF  FAD
....................  
....................       if(data[3]<10) 
44E4:  MOVF   x9A,W
44E6:  SUBLW  09
44E8:  BNC   4508
....................          printf("0"); 
44EA:  MOVLB  2
44EC:  CLRF   xA9
44EE:  MOVF   xA9,W
44F0:  MOVLB  0
44F2:  CALL   0A48
44F6:  IORLW  00
44F8:  BZ    4508
44FA:  MOVLB  2
44FC:  INCF   xA9,F
44FE:  BTFSS  F9E.4
4500:  BRA    44FE
4502:  MOVWF  FAD
4504:  BRA    44EE
4506:  MOVLB  0
....................  
....................       printf("%u          ", data[3]); 
4508:  MOVFF  9A,2AA
450C:  MOVLW  1B
450E:  MOVLB  2
4510:  MOVWF  xAB
4512:  MOVLB  0
4514:  CALL   3AF0
4518:  MOVLW  0A
451A:  MOVLB  2
451C:  MOVWF  xA9
451E:  MOVLW  20
4520:  BTFSS  F9E.4
4522:  BRA    4520
4524:  MOVWF  FAD
4526:  DECFSZ xA9,F
4528:  BRA    451E
....................  
....................       if(data[4]<10) 
452A:  MOVLB  0
452C:  MOVF   x9B,W
452E:  SUBLW  09
4530:  BNC   4550
....................          printf(" "); 
4532:  MOVLB  2
4534:  CLRF   xA9
4536:  MOVF   xA9,W
4538:  MOVLB  0
453A:  CALL   0BF0
453E:  IORLW  00
4540:  BZ    4550
4542:  MOVLB  2
4544:  INCF   xA9,F
4546:  BTFSS  F9E.4
4548:  BRA    4546
454A:  MOVWF  FAD
454C:  BRA    4536
454E:  MOVLB  0
....................  
....................       printf("%u.", data[4]); 
4550:  MOVFF  9B,2AA
4554:  MOVLW  1B
4556:  MOVLB  2
4558:  MOVWF  xAB
455A:  MOVLB  0
455C:  CALL   3AF0
4560:  MOVLW  2E
4562:  BTFSS  F9E.4
4564:  BRA    4562
4566:  MOVWF  FAD
....................  
....................       if(data[5]<10) 
4568:  MOVF   x9C,W
456A:  SUBLW  09
456C:  BNC   458C
....................          printf("0"); 
456E:  MOVLB  2
4570:  CLRF   xA9
4572:  MOVF   xA9,W
4574:  MOVLB  0
4576:  CALL   0A48
457A:  IORLW  00
457C:  BZ    458C
457E:  MOVLB  2
4580:  INCF   xA9,F
4582:  BTFSS  F9E.4
4584:  BRA    4582
4586:  MOVWF  FAD
4588:  BRA    4572
458A:  MOVLB  0
....................  
....................       printf("%u%cC             ", data[5], 223); 
458C:  MOVFF  9C,2AA
4590:  MOVLW  1B
4592:  MOVLB  2
4594:  MOVWF  xAB
4596:  MOVLB  0
4598:  CALL   3AF0
459C:  MOVLW  DF
459E:  BTFSS  F9E.4
45A0:  BRA    459E
45A2:  MOVWF  FAD
45A4:  MOVLW  43
45A6:  BTFSS  F9E.4
45A8:  BRA    45A6
45AA:  MOVWF  FAD
45AC:  MOVLW  0D
45AE:  MOVLB  2
45B0:  MOVWF  xA9
45B2:  MOVLW  20
45B4:  BTFSS  F9E.4
45B6:  BRA    45B4
45B8:  MOVWF  FAD
45BA:  DECFSZ xA9,F
45BC:  BRA    45B2
....................  
....................       if(data[6]<10) 
45BE:  MOVLB  0
45C0:  MOVF   x9D,W
45C2:  SUBLW  09
45C4:  BNC   45E4
....................          printf(" "); 
45C6:  MOVLB  2
45C8:  CLRF   xA9
45CA:  MOVF   xA9,W
45CC:  MOVLB  0
45CE:  CALL   0BF0
45D2:  IORLW  00
45D4:  BZ    45E4
45D6:  MOVLB  2
45D8:  INCF   xA9,F
45DA:  BTFSS  F9E.4
45DC:  BRA    45DA
45DE:  MOVWF  FAD
45E0:  BRA    45CA
45E2:  MOVLB  0
....................  
....................       printf("%u.", data[6]); 
45E4:  MOVFF  9D,2AA
45E8:  MOVLW  1B
45EA:  MOVLB  2
45EC:  MOVWF  xAB
45EE:  MOVLB  0
45F0:  CALL   3AF0
45F4:  MOVLW  2E
45F6:  BTFSS  F9E.4
45F8:  BRA    45F6
45FA:  MOVWF  FAD
....................  
....................       if(data[7]<10) 
45FC:  MOVF   x9E,W
45FE:  SUBLW  09
4600:  BNC   4620
....................          printf("0"); 
4602:  MOVLB  2
4604:  CLRF   xA9
4606:  MOVF   xA9,W
4608:  MOVLB  0
460A:  CALL   0A48
460E:  IORLW  00
4610:  BZ    4620
4612:  MOVLB  2
4614:  INCF   xA9,F
4616:  BTFSS  F9E.4
4618:  BRA    4616
461A:  MOVWF  FAD
461C:  BRA    4606
461E:  MOVLB  0
....................  
....................       printf("%u%cC              %u%cC                  ", data[7], 223, data2[3], 223); 
4620:  MOVFF  9E,2AA
4624:  MOVLW  1B
4626:  MOVLB  2
4628:  MOVWF  xAB
462A:  MOVLB  0
462C:  CALL   3AF0
4630:  MOVLW  DF
4632:  BTFSS  F9E.4
4634:  BRA    4632
4636:  MOVWF  FAD
4638:  MOVLW  43
463A:  BTFSS  F9E.4
463C:  BRA    463A
463E:  MOVWF  FAD
4640:  MOVLW  0E
4642:  MOVLB  2
4644:  MOVWF  xA9
4646:  MOVLW  20
4648:  BTFSS  F9E.4
464A:  BRA    4648
464C:  MOVWF  FAD
464E:  DECFSZ xA9,F
4650:  BRA    4646
4652:  MOVFF  A2,2AA
4656:  MOVLW  1B
4658:  MOVWF  xAB
465A:  MOVLB  0
465C:  CALL   3AF0
4660:  MOVLW  DF
4662:  BTFSS  F9E.4
4664:  BRA    4662
4666:  MOVWF  FAD
4668:  MOVLW  43
466A:  BTFSS  F9E.4
466C:  BRA    466A
466E:  MOVWF  FAD
4670:  MOVLW  12
4672:  MOVLB  2
4674:  MOVWF  xAA
4676:  MOVLW  20
4678:  BTFSS  F9E.4
467A:  BRA    4678
467C:  MOVWF  FAD
467E:  DECFSZ xAA,F
4680:  BRA    4676
....................  
....................       if(data2[1]<100) 
4682:  MOVLB  0
4684:  MOVF   xA0,W
4686:  SUBLW  63
4688:  BNC   46A8
....................          printf(" "); 
468A:  MOVLB  2
468C:  CLRF   xA9
468E:  MOVF   xA9,W
4690:  MOVLB  0
4692:  CALL   0BF0
4696:  IORLW  00
4698:  BZ    46A8
469A:  MOVLB  2
469C:  INCF   xA9,F
469E:  BTFSS  F9E.4
46A0:  BRA    469E
46A2:  MOVWF  FAD
46A4:  BRA    468E
46A6:  MOVLB  0
....................       if(data2[1]<10) 
46A8:  MOVF   xA0,W
46AA:  SUBLW  09
46AC:  BNC   46CC
....................          printf(" "); 
46AE:  MOVLB  2
46B0:  CLRF   xA9
46B2:  MOVF   xA9,W
46B4:  MOVLB  0
46B6:  CALL   0BF0
46BA:  IORLW  00
46BC:  BZ    46CC
46BE:  MOVLB  2
46C0:  INCF   xA9,F
46C2:  BTFSS  F9E.4
46C4:  BRA    46C2
46C6:  MOVWF  FAD
46C8:  BRA    46B2
46CA:  MOVLB  0
....................  
....................       printf("%u                    ", data2[1]); 
46CC:  MOVFF  A0,2AA
46D0:  MOVLW  1B
46D2:  MOVLB  2
46D4:  MOVWF  xAB
46D6:  MOVLB  0
46D8:  CALL   3AF0
46DC:  MOVLW  14
46DE:  MOVLB  2
46E0:  MOVWF  xA9
46E2:  MOVLW  20
46E4:  BTFSS  F9E.4
46E6:  BRA    46E4
46E8:  MOVWF  FAD
46EA:  DECFSZ xA9,F
46EC:  BRA    46E2
....................  
....................       if(data2[2]<100) 
46EE:  MOVLB  0
46F0:  MOVF   xA1,W
46F2:  SUBLW  63
46F4:  BNC   4714
....................          printf(" "); 
46F6:  MOVLB  2
46F8:  CLRF   xA9
46FA:  MOVF   xA9,W
46FC:  MOVLB  0
46FE:  CALL   0BF0
4702:  IORLW  00
4704:  BZ    4714
4706:  MOVLB  2
4708:  INCF   xA9,F
470A:  BTFSS  F9E.4
470C:  BRA    470A
470E:  MOVWF  FAD
4710:  BRA    46FA
4712:  MOVLB  0
....................       if(data2[2]<10) 
4714:  MOVF   xA1,W
4716:  SUBLW  09
4718:  BNC   4738
....................          printf(" "); 
471A:  MOVLB  2
471C:  CLRF   xA9
471E:  MOVF   xA9,W
4720:  MOVLB  0
4722:  CALL   0BF0
4726:  IORLW  00
4728:  BZ    4738
472A:  MOVLB  2
472C:  INCF   xA9,F
472E:  BTFSS  F9E.4
4730:  BRA    472E
4732:  MOVWF  FAD
4734:  BRA    471E
4736:  MOVLB  0
....................  
....................       printf("%u\r", data2[2]); 
4738:  MOVFF  A1,2AA
473C:  MOVLW  1B
473E:  MOVLB  2
4740:  MOVWF  xAB
4742:  MOVLB  0
4744:  CALL   3AF0
4748:  MOVLW  0D
474A:  BTFSS  F9E.4
474C:  BRA    474A
474E:  MOVWF  FAD
....................  
....................    } 
4750:  INCF   x95,F
4752:  BRA    3F80
....................  
....................    //Debemos realizar la operación de guardado para el último día. El proceso es el mismo 
....................    //que hemos seguido arriba. 
....................    if(dia[0]!=0) 
4754:  MOVLB  2
4756:  MOVF   xA4,F
4758:  BZ    482E
....................    { 
....................       valor = valor + (float)tiempo_x_dia; 
475A:  MOVFF  2A1,2B0
475E:  MOVFF  2A0,2AF
4762:  MOVLB  0
4764:  CALL   276A
4768:  BCF    FD8.1
476A:  MOVFF  E6,2AC
476E:  MOVFF  E5,2AB
4772:  MOVFF  E4,2AA
4776:  MOVFF  E3,2A9
477A:  MOVFF  03,2B0
477E:  MOVFF  02,2AF
4782:  MOVFF  01,2AE
4786:  MOVFF  00,2AD
478A:  CALL   24F0
478E:  MOVFF  03,E6
4792:  MOVFF  02,E5
4796:  MOVFF  01,E4
479A:  MOVFF  00,E3
....................       media_dia_mes[dia[1]-1] = valor; 
479E:  MOVLW  01
47A0:  MOVLB  2
47A2:  SUBWF  xA5,W
47A4:  MULLW  04
47A6:  MOVF   FF3,W
47A8:  CLRF   03
47AA:  ADDLW  A3
47AC:  MOVWF  FE9
47AE:  MOVLW  00
47B0:  ADDWFC 03,W
47B2:  MOVWF  FEA
47B4:  MOVFF  E3,FEF
47B8:  MOVFF  E4,FEC
47BC:  MOVFF  E5,FEC
47C0:  MOVFF  E6,FEC
....................       media_dia_caldera = media_dia_caldera + (float)tiempo_x_dia_caldera; 
47C4:  MOVFF  2A3,2B0
47C8:  MOVFF  2A2,2AF
47CC:  MOVLB  0
47CE:  CALL   276A
47D2:  BCF    FD8.1
47D4:  MOVFF  E2,2AC
47D8:  MOVFF  E1,2AB
47DC:  MOVFF  E0,2AA
47E0:  MOVFF  DF,2A9
47E4:  MOVFF  03,2B0
47E8:  MOVFF  02,2AF
47EC:  MOVFF  01,2AE
47F0:  MOVFF  00,2AD
47F4:  CALL   24F0
47F8:  MOVFF  03,E2
47FC:  MOVFF  02,E1
4800:  MOVFF  01,E0
4804:  MOVFF  00,DF
....................       media_dia_mes_caldera[dia[1]-1] = media_dia_caldera; 
4808:  MOVLW  01
480A:  MOVLB  2
480C:  SUBWF  xA5,W
480E:  MULLW  04
4810:  MOVF   FF3,W
4812:  CLRF   03
4814:  ADDLW  E7
4816:  MOVWF  FE9
4818:  MOVLW  00
481A:  ADDWFC 03,W
481C:  MOVWF  FEA
481E:  MOVFF  DF,FEF
4822:  MOVFF  E0,FEC
4826:  MOVFF  E1,FEC
482A:  MOVFF  E2,FEC
....................    } 
....................  
....................    //Comprobamos que no nos encontrabamos en el año introducido por defecto 
....................    if(dia[2]!=0) 
482E:  MOVF   xA6,F
4830:  BTFSC  FD8.2
4832:  BRA    4A5E
....................    { 
....................       for(contador2=0; contador2<12; contador2++) 
4834:  MOVLB  0
4836:  CLRF   x96
4838:  MOVF   x96,W
483A:  SUBLW  0B
483C:  BTFSS  FD8.0
483E:  BRA    4A48
....................       { 
....................          media_dia_mes[contador2] = media_dia_mes[contador2]/(float)dias_meses[contador2]; 
4840:  MOVF   x96,W
4842:  MULLW  04
4844:  MOVF   FF3,W
4846:  CLRF   03
4848:  ADDLW  A3
484A:  MOVWF  01
484C:  MOVLW  00
484E:  ADDWFC 03,F
4850:  MOVFF  01,2A9
4854:  MOVFF  03,2AA
4858:  MOVLB  0
485A:  MOVF   x96,W
485C:  MULLW  04
485E:  MOVF   FF3,W
4860:  CLRF   03
4862:  ADDLW  A3
4864:  MOVWF  FE9
4866:  MOVLW  00
4868:  ADDWFC 03,W
486A:  MOVWF  FEA
486C:  MOVFF  FEF,2AB
4870:  MOVFF  FEC,2AC
4874:  MOVFF  FEC,2AD
4878:  MOVFF  FEC,2AE
487C:  CLRF   03
487E:  MOVF   x96,W
4880:  ADDLW  D3
4882:  MOVWF  FE9
4884:  MOVLW  00
4886:  ADDWFC 03,W
4888:  MOVWF  FEA
488A:  MOVF   FEF,W
488C:  MOVLB  2
488E:  CLRF   xB0
4890:  MOVWF  xAF
4892:  MOVLB  0
4894:  CALL   276A
4898:  MOVFF  2AE,2B2
489C:  MOVFF  2AD,2B1
48A0:  MOVFF  2AC,2B0
48A4:  MOVFF  2AB,2AF
48A8:  MOVFF  03,2B6
48AC:  MOVFF  02,2B5
48B0:  MOVFF  01,2B4
48B4:  MOVFF  00,2B3
48B8:  CALL   2120
48BC:  MOVFF  2AA,FEA
48C0:  MOVFF  2A9,FE9
48C4:  MOVFF  00,FEF
48C8:  MOVFF  01,FEC
48CC:  MOVFF  02,FEC
48D0:  MOVFF  03,FEC
....................          media_dia_mes_caldera[contador2] = media_dia_mes_caldera[contador2]/(float)dias_meses[contador2]; 
48D4:  MOVF   x96,W
48D6:  MULLW  04
48D8:  MOVF   FF3,W
48DA:  CLRF   03
48DC:  ADDLW  E7
48DE:  MOVWF  01
48E0:  MOVLW  00
48E2:  ADDWFC 03,F
48E4:  MOVFF  01,2A9
48E8:  MOVFF  03,2AA
48EC:  MOVLB  0
48EE:  MOVF   x96,W
48F0:  MULLW  04
48F2:  MOVF   FF3,W
48F4:  CLRF   03
48F6:  ADDLW  E7
48F8:  MOVWF  FE9
48FA:  MOVLW  00
48FC:  ADDWFC 03,W
48FE:  MOVWF  FEA
4900:  MOVFF  FEF,2AB
4904:  MOVFF  FEC,2AC
4908:  MOVFF  FEC,2AD
490C:  MOVFF  FEC,2AE
4910:  CLRF   03
4912:  MOVF   x96,W
4914:  ADDLW  D3
4916:  MOVWF  FE9
4918:  MOVLW  00
491A:  ADDWFC 03,W
491C:  MOVWF  FEA
491E:  MOVF   FEF,W
4920:  MOVLB  2
4922:  CLRF   xB0
4924:  MOVWF  xAF
4926:  MOVLB  0
4928:  CALL   276A
492C:  MOVFF  2AE,2B2
4930:  MOVFF  2AD,2B1
4934:  MOVFF  2AC,2B0
4938:  MOVFF  2AB,2AF
493C:  MOVFF  03,2B6
4940:  MOVFF  02,2B5
4944:  MOVFF  01,2B4
4948:  MOVFF  00,2B3
494C:  CALL   2120
4950:  MOVFF  2AA,FEA
4954:  MOVFF  2A9,FE9
4958:  MOVFF  00,FEF
495C:  MOVFF  01,FEC
4960:  MOVFF  02,FEC
4964:  MOVFF  03,FEC
....................          media_annos[num_annos][contador2] = media_dia_mes[contador2]; 
4968:  MOVLB  2
496A:  MOVF   x9B,W
496C:  MULLW  30
496E:  MOVF   FF3,W
4970:  CLRF   xAA
4972:  MOVWF  xA9
4974:  MOVLB  0
4976:  MOVF   x96,W
4978:  MULLW  04
497A:  MOVF   FF3,W
497C:  CLRF   03
497E:  MOVLB  2
4980:  ADDWF  xA9,W
4982:  MOVWF  01
4984:  MOVF   xAA,W
4986:  ADDWFC 03,F
4988:  MOVF   01,W
498A:  ADDLW  1B
498C:  MOVWF  01
498E:  MOVLW  01
4990:  ADDWFC 03,F
4992:  MOVFF  01,2AB
4996:  MOVFF  03,2AC
499A:  MOVLB  0
499C:  MOVF   x96,W
499E:  MULLW  04
49A0:  MOVF   FF3,W
49A2:  CLRF   03
49A4:  ADDLW  A3
49A6:  MOVWF  FE9
49A8:  MOVLW  00
49AA:  ADDWFC 03,W
49AC:  MOVWF  FEA
49AE:  MOVFF  FEF,00
49B2:  MOVFF  FEC,01
49B6:  MOVFF  FEC,02
49BA:  MOVFF  FEC,03
49BE:  MOVFF  2AC,FEA
49C2:  MOVFF  2AB,FE9
49C6:  MOVFF  00,FEF
49CA:  MOVFF  01,FEC
49CE:  MOVFF  02,FEC
49D2:  MOVFF  03,FEC
....................          media_annos_caldera[num_annos][contador2] = media_dia_mes_caldera[contador2]; 
49D6:  MOVLB  2
49D8:  MOVF   x9B,W
49DA:  MULLW  30
49DC:  MOVF   FF3,W
49DE:  CLRF   xAA
49E0:  MOVWF  xA9
49E2:  MOVLB  0
49E4:  MOVF   x96,W
49E6:  MULLW  04
49E8:  MOVF   FF3,W
49EA:  CLRF   03
49EC:  MOVLB  2
49EE:  ADDWF  xA9,W
49F0:  MOVWF  01
49F2:  MOVF   xAA,W
49F4:  ADDWFC 03,F
49F6:  MOVF   01,W
49F8:  ADDLW  DB
49FA:  MOVWF  01
49FC:  MOVLW  01
49FE:  ADDWFC 03,F
4A00:  MOVFF  01,2AB
4A04:  MOVFF  03,2AC
4A08:  MOVLB  0
4A0A:  MOVF   x96,W
4A0C:  MULLW  04
4A0E:  MOVF   FF3,W
4A10:  CLRF   03
4A12:  ADDLW  E7
4A14:  MOVWF  FE9
4A16:  MOVLW  00
4A18:  ADDWFC 03,W
4A1A:  MOVWF  FEA
4A1C:  MOVFF  FEF,00
4A20:  MOVFF  FEC,01
4A24:  MOVFF  FEC,02
4A28:  MOVFF  FEC,03
4A2C:  MOVFF  2AC,FEA
4A30:  MOVFF  2AB,FE9
4A34:  MOVFF  00,FEF
4A38:  MOVFF  01,FEC
4A3C:  MOVFF  02,FEC
4A40:  MOVFF  03,FEC
....................       } 
4A44:  INCF   x96,F
4A46:  BRA    4838
....................  
....................       annos[num_annos]=dia[2]; 
4A48:  CLRF   03
4A4A:  MOVLB  2
4A4C:  MOVF   x9B,W
4A4E:  ADDLW  9C
4A50:  MOVWF  FE9
4A52:  MOVLW  02
4A54:  ADDWFC 03,W
4A56:  MOVWF  FEA
4A58:  MOVFF  2A6,FEF
....................  
....................       num_annos++; 
4A5C:  INCF   x9B,F
....................    } 
....................  
....................    //Calculamos la media como el cociente entre los valore de tiempo calculados y el número de 
....................    //días en los que se ha encendido la caldera 
....................    valor = valor/(float)num_dias; 
4A5E:  MOVFF  2A8,2B0
4A62:  MOVFF  2A7,2AF
4A66:  MOVLB  0
4A68:  CALL   276A
4A6C:  MOVFF  E6,2B2
4A70:  MOVFF  E5,2B1
4A74:  MOVFF  E4,2B0
4A78:  MOVFF  E3,2AF
4A7C:  MOVFF  03,2B6
4A80:  MOVFF  02,2B5
4A84:  MOVFF  01,2B4
4A88:  MOVFF  00,2B3
4A8C:  CALL   2120
4A90:  MOVFF  03,E6
4A94:  MOVFF  02,E5
4A98:  MOVFF  01,E4
4A9C:  MOVFF  00,E3
....................    media_dia_caldera = media_dia_caldera/(float)num_dias; 
4AA0:  MOVFF  2A8,2B0
4AA4:  MOVFF  2A7,2AF
4AA8:  CALL   276A
4AAC:  MOVFF  E2,2B2
4AB0:  MOVFF  E1,2B1
4AB4:  MOVFF  E0,2B0
4AB8:  MOVFF  DF,2AF
4ABC:  MOVFF  03,2B6
4AC0:  MOVFF  02,2B5
4AC4:  MOVFF  01,2B4
4AC8:  MOVFF  00,2B3
4ACC:  CALL   2120
4AD0:  MOVFF  03,E2
4AD4:  MOVFF  02,E1
4AD8:  MOVFF  01,E0
4ADC:  MOVFF  00,DF
....................  
....................    repetir: 
....................    //Menú para mostrar los datos 
....................    printf("\r===========================================================================================================================\r"); 
4AE0:  MOVLB  2
4AE2:  CLRF   xA9
4AE4:  MOVF   xA9,W
4AE6:  MOVLB  0
4AE8:  CALL   0C0C
4AEC:  IORLW  00
4AEE:  BZ    4AFE
4AF0:  MOVLB  2
4AF2:  INCF   xA9,F
4AF4:  BTFSS  F9E.4
4AF6:  BRA    4AF4
4AF8:  MOVWF  FAD
4AFA:  BRA    4AE4
4AFC:  MOVLB  0
....................    printf("¿Que operacion desea realizar?\r"); 
4AFE:  MOVLB  2
4B00:  CLRF   xA9
4B02:  MOVF   xA9,W
4B04:  MOVLB  0
4B06:  CALL   0CA4
4B0A:  IORLW  00
4B0C:  BZ    4B1C
4B0E:  MOVLB  2
4B10:  INCF   xA9,F
4B12:  BTFSS  F9E.4
4B14:  BRA    4B12
4B16:  MOVWF  FAD
4B18:  BRA    4B02
4B1A:  MOVLB  0
....................    printf("0. Salir\r"); 
4B1C:  MOVLB  2
4B1E:  CLRF   xA9
4B20:  MOVF   xA9,W
4B22:  MOVLB  0
4B24:  CALL   0CDE
4B28:  IORLW  00
4B2A:  BZ    4B3A
4B2C:  MOVLB  2
4B2E:  INCF   xA9,F
4B30:  BTFSS  F9E.4
4B32:  BRA    4B30
4B34:  MOVWF  FAD
4B36:  BRA    4B20
4B38:  MOVLB  0
....................    printf("1. Extraer tiempos medios por dia\r"); 
4B3A:  MOVLB  2
4B3C:  CLRF   xA9
4B3E:  MOVF   xA9,W
4B40:  MOVLB  0
4B42:  CALL   0D02
4B46:  IORLW  00
4B48:  BZ    4B58
4B4A:  MOVLB  2
4B4C:  INCF   xA9,F
4B4E:  BTFSS  F9E.4
4B50:  BRA    4B4E
4B52:  MOVWF  FAD
4B54:  BRA    4B3E
4B56:  MOVLB  0
....................    printf("2. Extraer tiempos totales\r"); 
4B58:  MOVLB  2
4B5A:  CLRF   xA9
4B5C:  MOVF   xA9,W
4B5E:  MOVLB  0
4B60:  CALL   0D40
4B64:  IORLW  00
4B66:  BZ    4B76
4B68:  MOVLB  2
4B6A:  INCF   xA9,F
4B6C:  BTFSS  F9E.4
4B6E:  BRA    4B6C
4B70:  MOVWF  FAD
4B72:  BRA    4B5C
4B74:  MOVLB  0
....................    printf("3. Extraer datos mensuales\r"); 
4B76:  MOVLB  2
4B78:  CLRF   xA9
4B7A:  MOVF   xA9,W
4B7C:  MOVLB  0
4B7E:  CALL   0D76
4B82:  IORLW  00
4B84:  BZ    4B94
4B86:  MOVLB  2
4B88:  INCF   xA9,F
4B8A:  BTFSS  F9E.4
4B8C:  BRA    4B8A
4B8E:  MOVWF  FAD
4B90:  BRA    4B7A
4B92:  MOVLB  0
....................    printf("===========================================================================================================================\r"); 
4B94:  MOVLB  2
4B96:  CLRF   xA9
4B98:  MOVF   xA9,W
4B9A:  MOVLB  0
4B9C:  CALL   0B58
4BA0:  IORLW  00
4BA2:  BZ    4BB2
4BA4:  MOVLB  2
4BA6:  INCF   xA9,F
4BA8:  BTFSS  F9E.4
4BAA:  BRA    4BA8
4BAC:  MOVWF  FAD
4BAE:  BRA    4B98
4BB0:  MOVLB  0
....................  
....................    //Esperamos la introducción de una de las opciones por parte del técnico 
....................    while(key!='1' && key!='2' && key!='3' && key!='0'){ 
4BB2:  MOVF   38,W
4BB4:  SUBLW  31
4BB6:  BZ    4BD4
4BB8:  MOVF   38,W
4BBA:  SUBLW  32
4BBC:  BZ    4BD4
4BBE:  MOVF   38,W
4BC0:  SUBLW  33
4BC2:  BZ    4BD4
4BC4:  MOVF   38,W
4BC6:  SUBLW  30
4BC8:  BZ    4BD4
....................       key=getch(); 
4BCA:  BTFSS  F9E.5
4BCC:  BRA    4BCA
4BCE:  MOVFF  FAE,38
....................    } 
4BD2:  BRA    4BB2
....................  
....................    switch(key) 
....................    { 
4BD4:  MOVLW  30
4BD6:  SUBWF  38,W
4BD8:  ADDLW  FC
4BDA:  BTFSC  FD8.0
4BDC:  GOTO   5954
4BE0:  ADDLW  04
4BE2:  GOTO   5958
....................       //En el caso 0, se sale del sistema 
....................       case '0': 
....................                //Se indica la salida mediante un mensaje 
....................                printf("\rSaliendo...\r"); 
4BE6:  MOVLB  2
4BE8:  CLRF   xA9
4BEA:  MOVF   xA9,W
4BEC:  MOVLB  0
4BEE:  CALL   0DAC
4BF2:  IORLW  00
4BF4:  BZ    4C04
4BF6:  MOVLB  2
4BF8:  INCF   xA9,F
4BFA:  BTFSS  F9E.4
4BFC:  BRA    4BFA
4BFE:  MOVWF  FAD
4C00:  BRA    4BEA
4C02:  MOVLB  0
....................                break; 
4C04:  GOTO   5954
....................  
....................       //En el caso 1, se muestran los valores medios 
....................       case '1': 
....................                key = 'J';  //Utilizamos este carácter para evitar la elección errónea de la misma acción 
4C08:  MOVLW  4A
4C0A:  MOVWF  38
....................                printf("\rTiempo medio de encendido del sistema por dia: %3.2f minutos\r\r", valor); 
4C0C:  MOVLB  2
4C0E:  CLRF   xA9
4C10:  MOVF   xA9,W
4C12:  MOVLB  0
4C14:  CALL   0DD4
4C18:  MOVLB  2
4C1A:  INCF   xA9,F
4C1C:  MOVWF  00
4C1E:  MOVF   00,W
4C20:  BTFSS  F9E.4
4C22:  BRA    4C20
4C24:  MOVWF  FAD
4C26:  MOVLW  30
4C28:  SUBWF  xA9,W
4C2A:  BNZ   4C10
4C2C:  MOVLW  02
4C2E:  MOVWF  FE9
4C30:  MOVFF  E6,2BB
4C34:  MOVFF  E5,2BA
4C38:  MOVFF  E4,2B9
4C3C:  MOVFF  E3,2B8
4C40:  MOVWF  xBC
4C42:  MOVLB  0
4C44:  CALL   3B6E
4C48:  MOVLW  35
4C4A:  MOVLB  2
4C4C:  MOVWF  xAA
4C4E:  MOVF   xAA,W
4C50:  MOVLB  0
4C52:  CALL   0DD4
4C56:  MOVLB  2
4C58:  INCF   xAA,F
4C5A:  MOVWF  00
4C5C:  MOVF   00,W
4C5E:  BTFSS  F9E.4
4C60:  BRA    4C5E
4C62:  MOVWF  FAD
4C64:  MOVLW  3F
4C66:  SUBWF  xAA,W
4C68:  BNZ   4C4E
....................                printf("Tiempo medio de encendido de la caldera por dia: %3.2f minutos\r\r", media_dia_caldera); 
4C6A:  CLRF   xA9
4C6C:  MOVF   xA9,W
4C6E:  MOVLB  0
4C70:  CALL   0E2E
4C74:  MOVLB  2
4C76:  INCF   xA9,F
4C78:  MOVWF  00
4C7A:  MOVF   00,W
4C7C:  BTFSS  F9E.4
4C7E:  BRA    4C7C
4C80:  MOVWF  FAD
4C82:  MOVLW  31
4C84:  SUBWF  xA9,W
4C86:  BNZ   4C6C
4C88:  MOVLW  02
4C8A:  MOVWF  FE9
4C8C:  MOVFF  E2,2BB
4C90:  MOVFF  E1,2BA
4C94:  MOVFF  E0,2B9
4C98:  MOVFF  DF,2B8
4C9C:  MOVWF  xBC
4C9E:  MOVLB  0
4CA0:  CALL   3B6E
4CA4:  MOVLW  36
4CA6:  MOVLB  2
4CA8:  MOVWF  xAA
4CAA:  MOVF   xAA,W
4CAC:  MOVLB  0
4CAE:  CALL   0E2E
4CB2:  MOVLB  2
4CB4:  INCF   xAA,F
4CB6:  MOVWF  00
4CB8:  MOVF   00,W
4CBA:  BTFSS  F9E.4
4CBC:  BRA    4CBA
4CBE:  MOVWF  FAD
4CC0:  MOVLW  40
4CC2:  SUBWF  xAA,W
4CC4:  BNZ   4CAA
....................                goto repetir; 
4CC6:  MOVLB  0
4CC8:  BRA    4AE0
....................                break; 
4CCA:  GOTO   5954
....................  
....................       //En el caso 2, se muestran los valores totales 
....................       case '2': 
....................                key = 'J'; //Ídem 
4CCE:  MOVLW  4A
4CD0:  MOVWF  38
....................                printf("\rTiempo total de encendido del sistema: %lu minutos\r\r", valor_total); 
4CD2:  MOVLB  2
4CD4:  CLRF   xA9
4CD6:  MOVF   xA9,W
4CD8:  MOVLB  0
4CDA:  CALL   0E8A
4CDE:  MOVLB  2
4CE0:  INCF   xA9,F
4CE2:  MOVWF  00
4CE4:  MOVF   00,W
4CE6:  BTFSS  F9E.4
4CE8:  BRA    4CE6
4CEA:  MOVWF  FAD
4CEC:  MOVLW  28
4CEE:  SUBWF  xA9,W
4CF0:  BNZ   4CD6
4CF2:  MOVLW  10
4CF4:  MOVWF  FE9
4CF6:  MOVFF  118,2AB
4CFA:  MOVFF  117,2AA
4CFE:  MOVLB  0
4D00:  CALL   3D16
4D04:  MOVLW  2B
4D06:  MOVLB  2
4D08:  MOVWF  xAA
4D0A:  MOVF   xAA,W
4D0C:  MOVLB  0
4D0E:  CALL   0E8A
4D12:  MOVLB  2
4D14:  INCF   xAA,F
4D16:  MOVWF  00
4D18:  MOVF   00,W
4D1A:  BTFSS  F9E.4
4D1C:  BRA    4D1A
4D1E:  MOVWF  FAD
4D20:  MOVLW  35
4D22:  SUBWF  xAA,W
4D24:  BNZ   4D0A
....................                printf("Tiempo total de encendido de la caldera: %lu minutos\r\r", valor_total_caldera); 
4D26:  CLRF   xA9
4D28:  MOVF   xA9,W
4D2A:  MOVLB  0
4D2C:  CALL   0EDA
4D30:  MOVLB  2
4D32:  INCF   xA9,F
4D34:  MOVWF  00
4D36:  MOVF   00,W
4D38:  BTFSS  F9E.4
4D3A:  BRA    4D38
4D3C:  MOVWF  FAD
4D3E:  MOVLW  29
4D40:  SUBWF  xA9,W
4D42:  BNZ   4D28
4D44:  MOVLW  10
4D46:  MOVWF  FE9
4D48:  MOVFF  11A,2AB
4D4C:  MOVFF  119,2AA
4D50:  MOVLB  0
4D52:  CALL   3D16
4D56:  MOVLW  2C
4D58:  MOVLB  2
4D5A:  MOVWF  xAA
4D5C:  MOVF   xAA,W
4D5E:  MOVLB  0
4D60:  CALL   0EDA
4D64:  MOVLB  2
4D66:  INCF   xAA,F
4D68:  MOVWF  00
4D6A:  MOVF   00,W
4D6C:  BTFSS  F9E.4
4D6E:  BRA    4D6C
4D70:  MOVWF  FAD
4D72:  MOVLW  36
4D74:  SUBWF  xAA,W
4D76:  BNZ   4D5C
....................                goto repetir; 
4D78:  MOVLB  0
4D7A:  BRA    4AE0
....................                break; 
4D7C:  GOTO   5954
....................  
....................       //En el caso 3, se muestran todos los valores medios por meses y años 
....................       case '3': 
....................                key = 'J'; //Ídem 
4D80:  MOVLW  4A
4D82:  MOVWF  38
....................                //Se representan todos los años de los que se tiene registro 
....................                for(contador=0; contador<num_annos; contador++) 
4D84:  CLRF   x95
4D86:  MOVLB  2
4D88:  MOVF   x9B,W
4D8A:  MOVLB  0
4D8C:  SUBWF  x95,W
4D8E:  BTFSC  FD8.0
4D90:  GOTO   594E
....................                { 
....................                   //Imprimimos el año en el que nos encontramos 
....................                   printf("\r20"); 
4D94:  MOVLB  2
4D96:  CLRF   xA9
4D98:  MOVF   xA9,W
4D9A:  MOVLB  0
4D9C:  CALL   0F2C
4DA0:  IORLW  00
4DA2:  BZ    4DB2
4DA4:  MOVLB  2
4DA6:  INCF   xA9,F
4DA8:  BTFSS  F9E.4
4DAA:  BRA    4DA8
4DAC:  MOVWF  FAD
4DAE:  BRA    4D98
4DB0:  MOVLB  0
....................                   if(annos[contador]<10) 
4DB2:  CLRF   03
4DB4:  MOVF   x95,W
4DB6:  ADDLW  9C
4DB8:  MOVWF  FE9
4DBA:  MOVLW  02
4DBC:  ADDWFC 03,W
4DBE:  MOVWF  FEA
4DC0:  MOVF   FEF,W
4DC2:  SUBLW  09
4DC4:  BNC   4DE4
....................                      printf("0"); 
4DC6:  MOVLB  2
4DC8:  CLRF   xA9
4DCA:  MOVF   xA9,W
4DCC:  MOVLB  0
4DCE:  CALL   0A48
4DD2:  IORLW  00
4DD4:  BZ    4DE4
4DD6:  MOVLB  2
4DD8:  INCF   xA9,F
4DDA:  BTFSS  F9E.4
4DDC:  BRA    4DDA
4DDE:  MOVWF  FAD
4DE0:  BRA    4DCA
4DE2:  MOVLB  0
....................                   printf("%u\r", annos[contador]); 
4DE4:  CLRF   03
4DE6:  MOVF   x95,W
4DE8:  ADDLW  9C
4DEA:  MOVWF  FE9
4DEC:  MOVLW  02
4DEE:  ADDWFC 03,W
4DF0:  MOVWF  FEA
4DF2:  MOVFF  FEF,2A9
4DF6:  MOVFF  2A9,2AA
4DFA:  MOVLW  1B
4DFC:  MOVLB  2
4DFE:  MOVWF  xAB
4E00:  MOVLB  0
4E02:  CALL   3AF0
4E06:  MOVLW  0D
4E08:  BTFSS  F9E.4
4E0A:  BRA    4E08
4E0C:  MOVWF  FAD
....................                   printf("--------------------------------------------------------------------------------------------------------------------\r"); 
4E0E:  MOVLB  2
4E10:  CLRF   xA9
4E12:  MOVF   xA9,W
4E14:  MOVLB  0
4E16:  CALL   0F4A
4E1A:  IORLW  00
4E1C:  BZ    4E2C
4E1E:  MOVLB  2
4E20:  INCF   xA9,F
4E22:  BTFSS  F9E.4
4E24:  BRA    4E22
4E26:  MOVWF  FAD
4E28:  BRA    4E12
4E2A:  MOVLB  0
....................                   printf("              Tiempo medio de encendido del sistema (min/dia)      Tiempo medio de encendido de la caldera (min/dia)\r"); 
4E2C:  MOVLB  2
4E2E:  CLRF   xA9
4E30:  MOVF   xA9,W
4E32:  MOVLB  0
4E34:  CALL   0FDA
4E38:  IORLW  00
4E3A:  BZ    4E4A
4E3C:  MOVLB  2
4E3E:  INCF   xA9,F
4E40:  BTFSS  F9E.4
4E42:  BRA    4E40
4E44:  MOVWF  FAD
4E46:  BRA    4E30
4E48:  MOVLB  0
....................                   printf("ENERO                              %3.2f                                                     %3.2f\r", media_annos[contador][0], media_annos_caldera[contador][0]); 
4E4A:  MOVF   x95,W
4E4C:  MULLW  30
4E4E:  MOVF   FF3,W
4E50:  MOVLB  2
4E52:  CLRF   xAA
4E54:  MOVWF  xA9
4E56:  MOVLW  1B
4E58:  ADDWF  xA9,W
4E5A:  MOVWF  FE9
4E5C:  MOVLW  01
4E5E:  ADDWFC xAA,W
4E60:  MOVWF  FEA
4E62:  MOVFF  FEF,2AB
4E66:  MOVFF  FEC,2AC
4E6A:  MOVFF  FEC,2AD
4E6E:  MOVFF  FEC,2AE
4E72:  MOVLB  0
4E74:  MOVF   x95,W
4E76:  MULLW  30
4E78:  MOVF   FF3,W
4E7A:  MOVLB  2
4E7C:  CLRF   xB0
4E7E:  MOVWF  xAF
4E80:  MOVLW  DB
4E82:  ADDWF  xAF,W
4E84:  MOVWF  FE9
4E86:  MOVLW  01
4E88:  ADDWFC xB0,W
4E8A:  MOVWF  FEA
4E8C:  MOVFF  FEF,2B1
4E90:  MOVFF  FEC,2B2
4E94:  MOVFF  FEC,2B3
4E98:  MOVFF  FEC,2B4
4E9C:  CLRF   xB5
4E9E:  MOVF   xB5,W
4EA0:  MOVLB  0
4EA2:  CALL   106A
4EA6:  MOVLB  2
4EA8:  INCF   xB5,F
4EAA:  MOVWF  00
4EAC:  MOVF   00,W
4EAE:  BTFSS  F9E.4
4EB0:  BRA    4EAE
4EB2:  MOVWF  FAD
4EB4:  MOVLW  05
4EB6:  SUBWF  xB5,W
4EB8:  BNZ   4E9E
4EBA:  MOVLW  1E
4EBC:  MOVWF  xB6
4EBE:  MOVLW  20
4EC0:  BTFSS  F9E.4
4EC2:  BRA    4EC0
4EC4:  MOVWF  FAD
4EC6:  DECFSZ xB6,F
4EC8:  BRA    4EBE
4ECA:  MOVLW  02
4ECC:  MOVWF  FE9
4ECE:  MOVFF  2AE,2BB
4ED2:  MOVFF  2AD,2BA
4ED6:  MOVFF  2AC,2B9
4EDA:  MOVFF  2AB,2B8
4EDE:  MOVWF  xBC
4EE0:  MOVLB  0
4EE2:  CALL   3B6E
4EE6:  MOVLW  35
4EE8:  MOVLB  2
4EEA:  MOVWF  xB7
4EEC:  MOVLW  20
4EEE:  BTFSS  F9E.4
4EF0:  BRA    4EEE
4EF2:  MOVWF  FAD
4EF4:  DECFSZ xB7,F
4EF6:  BRA    4EEC
4EF8:  MOVLW  02
4EFA:  MOVWF  FE9
4EFC:  MOVFF  2B4,2BB
4F00:  MOVFF  2B3,2BA
4F04:  MOVFF  2B2,2B9
4F08:  MOVFF  2B1,2B8
4F0C:  MOVWF  xBC
4F0E:  MOVLB  0
4F10:  CALL   3B6E
4F14:  MOVLW  0D
4F16:  BTFSS  F9E.4
4F18:  BRA    4F16
4F1A:  MOVWF  FAD
....................                   printf("FEBRERO                            %3.2f                                                     %3.2f\r", media_annos[contador][1], media_annos_caldera[contador][1]); 
4F1C:  MOVF   x95,W
4F1E:  MULLW  30
4F20:  MOVF   FF3,W
4F22:  MOVLB  2
4F24:  CLRF   xAA
4F26:  MOVWF  xA9
4F28:  MOVLW  04
4F2A:  ADDWF  xA9,W
4F2C:  MOVWF  01
4F2E:  MOVLW  00
4F30:  ADDWFC xAA,W
4F32:  MOVWF  03
4F34:  MOVF   01,W
4F36:  ADDLW  1B
4F38:  MOVWF  FE9
4F3A:  MOVLW  01
4F3C:  ADDWFC 03,W
4F3E:  MOVWF  FEA
4F40:  MOVFF  FEF,2AB
4F44:  MOVFF  FEC,2AC
4F48:  MOVFF  FEC,2AD
4F4C:  MOVFF  FEC,2AE
4F50:  MOVLB  0
4F52:  MOVF   x95,W
4F54:  MULLW  30
4F56:  MOVF   FF3,W
4F58:  MOVLB  2
4F5A:  CLRF   xB0
4F5C:  MOVWF  xAF
4F5E:  MOVLW  04
4F60:  ADDWF  xAF,W
4F62:  MOVWF  01
4F64:  MOVLW  00
4F66:  ADDWFC xB0,W
4F68:  MOVWF  03
4F6A:  MOVF   01,W
4F6C:  ADDLW  DB
4F6E:  MOVWF  FE9
4F70:  MOVLW  01
4F72:  ADDWFC 03,W
4F74:  MOVWF  FEA
4F76:  MOVFF  FEF,2B1
4F7A:  MOVFF  FEC,2B2
4F7E:  MOVFF  FEC,2B3
4F82:  MOVFF  FEC,2B4
4F86:  CLRF   xB5
4F88:  MOVF   xB5,W
4F8A:  MOVLB  0
4F8C:  CALL   1096
4F90:  MOVLB  2
4F92:  INCF   xB5,F
4F94:  MOVWF  00
4F96:  MOVF   00,W
4F98:  BTFSS  F9E.4
4F9A:  BRA    4F98
4F9C:  MOVWF  FAD
4F9E:  MOVLW  07
4FA0:  SUBWF  xB5,W
4FA2:  BNZ   4F88
4FA4:  MOVLW  1C
4FA6:  MOVWF  xB6
4FA8:  MOVLW  20
4FAA:  BTFSS  F9E.4
4FAC:  BRA    4FAA
4FAE:  MOVWF  FAD
4FB0:  DECFSZ xB6,F
4FB2:  BRA    4FA8
4FB4:  MOVLW  02
4FB6:  MOVWF  FE9
4FB8:  MOVFF  2AE,2BB
4FBC:  MOVFF  2AD,2BA
4FC0:  MOVFF  2AC,2B9
4FC4:  MOVFF  2AB,2B8
4FC8:  MOVWF  xBC
4FCA:  MOVLB  0
4FCC:  CALL   3B6E
4FD0:  MOVLW  35
4FD2:  MOVLB  2
4FD4:  MOVWF  xB7
4FD6:  MOVLW  20
4FD8:  BTFSS  F9E.4
4FDA:  BRA    4FD8
4FDC:  MOVWF  FAD
4FDE:  DECFSZ xB7,F
4FE0:  BRA    4FD6
4FE2:  MOVLW  02
4FE4:  MOVWF  FE9
4FE6:  MOVFF  2B4,2BB
4FEA:  MOVFF  2B3,2BA
4FEE:  MOVFF  2B2,2B9
4FF2:  MOVFF  2B1,2B8
4FF6:  MOVWF  xBC
4FF8:  MOVLB  0
4FFA:  CALL   3B6E
4FFE:  MOVLW  0D
5000:  BTFSS  F9E.4
5002:  BRA    5000
5004:  MOVWF  FAD
....................                   printf("MARZO                              %3.2f                                                     %3.2f\r", media_annos[contador][2], media_annos_caldera[contador][2]); 
5006:  MOVF   x95,W
5008:  MULLW  30
500A:  MOVF   FF3,W
500C:  MOVLB  2
500E:  CLRF   xAA
5010:  MOVWF  xA9
5012:  MOVLW  08
5014:  ADDWF  xA9,W
5016:  MOVWF  01
5018:  MOVLW  00
501A:  ADDWFC xAA,W
501C:  MOVWF  03
501E:  MOVF   01,W
5020:  ADDLW  1B
5022:  MOVWF  FE9
5024:  MOVLW  01
5026:  ADDWFC 03,W
5028:  MOVWF  FEA
502A:  MOVFF  FEF,2AB
502E:  MOVFF  FEC,2AC
5032:  MOVFF  FEC,2AD
5036:  MOVFF  FEC,2AE
503A:  MOVLB  0
503C:  MOVF   x95,W
503E:  MULLW  30
5040:  MOVF   FF3,W
5042:  MOVLB  2
5044:  CLRF   xB0
5046:  MOVWF  xAF
5048:  MOVLW  08
504A:  ADDWF  xAF,W
504C:  MOVWF  01
504E:  MOVLW  00
5050:  ADDWFC xB0,W
5052:  MOVWF  03
5054:  MOVF   01,W
5056:  ADDLW  DB
5058:  MOVWF  FE9
505A:  MOVLW  01
505C:  ADDWFC 03,W
505E:  MOVWF  FEA
5060:  MOVFF  FEF,2B1
5064:  MOVFF  FEC,2B2
5068:  MOVFF  FEC,2B3
506C:  MOVFF  FEC,2B4
5070:  CLRF   xB5
5072:  MOVF   xB5,W
5074:  MOVLB  0
5076:  CALL   10C4
507A:  MOVLB  2
507C:  INCF   xB5,F
507E:  MOVWF  00
5080:  MOVF   00,W
5082:  BTFSS  F9E.4
5084:  BRA    5082
5086:  MOVWF  FAD
5088:  MOVLW  05
508A:  SUBWF  xB5,W
508C:  BNZ   5072
508E:  MOVLW  1E
5090:  MOVWF  xB6
5092:  MOVLW  20
5094:  BTFSS  F9E.4
5096:  BRA    5094
5098:  MOVWF  FAD
509A:  DECFSZ xB6,F
509C:  BRA    5092
509E:  MOVLW  02
50A0:  MOVWF  FE9
50A2:  MOVFF  2AE,2BB
50A6:  MOVFF  2AD,2BA
50AA:  MOVFF  2AC,2B9
50AE:  MOVFF  2AB,2B8
50B2:  MOVWF  xBC
50B4:  MOVLB  0
50B6:  CALL   3B6E
50BA:  MOVLW  35
50BC:  MOVLB  2
50BE:  MOVWF  xB7
50C0:  MOVLW  20
50C2:  BTFSS  F9E.4
50C4:  BRA    50C2
50C6:  MOVWF  FAD
50C8:  DECFSZ xB7,F
50CA:  BRA    50C0
50CC:  MOVLW  02
50CE:  MOVWF  FE9
50D0:  MOVFF  2B4,2BB
50D4:  MOVFF  2B3,2BA
50D8:  MOVFF  2B2,2B9
50DC:  MOVFF  2B1,2B8
50E0:  MOVWF  xBC
50E2:  MOVLB  0
50E4:  CALL   3B6E
50E8:  MOVLW  0D
50EA:  BTFSS  F9E.4
50EC:  BRA    50EA
50EE:  MOVWF  FAD
....................                   printf("ABRIL                              %3.2f                                                     %3.2f\r", media_annos[contador][3], media_annos_caldera[contador][3]); 
50F0:  MOVF   x95,W
50F2:  MULLW  30
50F4:  MOVF   FF3,W
50F6:  MOVLB  2
50F8:  CLRF   xAA
50FA:  MOVWF  xA9
50FC:  MOVLW  0C
50FE:  ADDWF  xA9,W
5100:  MOVWF  01
5102:  MOVLW  00
5104:  ADDWFC xAA,W
5106:  MOVWF  03
5108:  MOVF   01,W
510A:  ADDLW  1B
510C:  MOVWF  FE9
510E:  MOVLW  01
5110:  ADDWFC 03,W
5112:  MOVWF  FEA
5114:  MOVFF  FEF,2AB
5118:  MOVFF  FEC,2AC
511C:  MOVFF  FEC,2AD
5120:  MOVFF  FEC,2AE
5124:  MOVLB  0
5126:  MOVF   x95,W
5128:  MULLW  30
512A:  MOVF   FF3,W
512C:  MOVLB  2
512E:  CLRF   xB0
5130:  MOVWF  xAF
5132:  MOVLW  0C
5134:  ADDWF  xAF,W
5136:  MOVWF  01
5138:  MOVLW  00
513A:  ADDWFC xB0,W
513C:  MOVWF  03
513E:  MOVF   01,W
5140:  ADDLW  DB
5142:  MOVWF  FE9
5144:  MOVLW  01
5146:  ADDWFC 03,W
5148:  MOVWF  FEA
514A:  MOVFF  FEF,2B1
514E:  MOVFF  FEC,2B2
5152:  MOVFF  FEC,2B3
5156:  MOVFF  FEC,2B4
515A:  CLRF   xB5
515C:  MOVF   xB5,W
515E:  MOVLB  0
5160:  CALL   10F0
5164:  MOVLB  2
5166:  INCF   xB5,F
5168:  MOVWF  00
516A:  MOVF   00,W
516C:  BTFSS  F9E.4
516E:  BRA    516C
5170:  MOVWF  FAD
5172:  MOVLW  05
5174:  SUBWF  xB5,W
5176:  BNZ   515C
5178:  MOVLW  1E
517A:  MOVWF  xB6
517C:  MOVLW  20
517E:  BTFSS  F9E.4
5180:  BRA    517E
5182:  MOVWF  FAD
5184:  DECFSZ xB6,F
5186:  BRA    517C
5188:  MOVLW  02
518A:  MOVWF  FE9
518C:  MOVFF  2AE,2BB
5190:  MOVFF  2AD,2BA
5194:  MOVFF  2AC,2B9
5198:  MOVFF  2AB,2B8
519C:  MOVWF  xBC
519E:  MOVLB  0
51A0:  CALL   3B6E
51A4:  MOVLW  35
51A6:  MOVLB  2
51A8:  MOVWF  xB7
51AA:  MOVLW  20
51AC:  BTFSS  F9E.4
51AE:  BRA    51AC
51B0:  MOVWF  FAD
51B2:  DECFSZ xB7,F
51B4:  BRA    51AA
51B6:  MOVLW  02
51B8:  MOVWF  FE9
51BA:  MOVFF  2B4,2BB
51BE:  MOVFF  2B3,2BA
51C2:  MOVFF  2B2,2B9
51C6:  MOVFF  2B1,2B8
51CA:  MOVWF  xBC
51CC:  MOVLB  0
51CE:  CALL   3B6E
51D2:  MOVLW  0D
51D4:  BTFSS  F9E.4
51D6:  BRA    51D4
51D8:  MOVWF  FAD
....................                   printf("MAYO                               %3.2f                                                     %3.2f\r", media_annos[contador][4], media_annos_caldera[contador][4]); 
51DA:  MOVF   x95,W
51DC:  MULLW  30
51DE:  MOVF   FF3,W
51E0:  MOVLB  2
51E2:  CLRF   xAA
51E4:  MOVWF  xA9
51E6:  MOVLW  10
51E8:  ADDWF  xA9,W
51EA:  MOVWF  01
51EC:  MOVLW  00
51EE:  ADDWFC xAA,W
51F0:  MOVWF  03
51F2:  MOVF   01,W
51F4:  ADDLW  1B
51F6:  MOVWF  FE9
51F8:  MOVLW  01
51FA:  ADDWFC 03,W
51FC:  MOVWF  FEA
51FE:  MOVFF  FEF,2AB
5202:  MOVFF  FEC,2AC
5206:  MOVFF  FEC,2AD
520A:  MOVFF  FEC,2AE
520E:  MOVLB  0
5210:  MOVF   x95,W
5212:  MULLW  30
5214:  MOVF   FF3,W
5216:  MOVLB  2
5218:  CLRF   xB0
521A:  MOVWF  xAF
521C:  MOVLW  10
521E:  ADDWF  xAF,W
5220:  MOVWF  01
5222:  MOVLW  00
5224:  ADDWFC xB0,W
5226:  MOVWF  03
5228:  MOVF   01,W
522A:  ADDLW  DB
522C:  MOVWF  FE9
522E:  MOVLW  01
5230:  ADDWFC 03,W
5232:  MOVWF  FEA
5234:  MOVFF  FEF,2B1
5238:  MOVFF  FEC,2B2
523C:  MOVFF  FEC,2B3
5240:  MOVFF  FEC,2B4
5244:  CLRF   xB5
5246:  MOVF   xB5,W
5248:  MOVLB  0
524A:  CALL   111C
524E:  MOVLB  2
5250:  INCF   xB5,F
5252:  MOVWF  00
5254:  MOVF   00,W
5256:  BTFSS  F9E.4
5258:  BRA    5256
525A:  MOVWF  FAD
525C:  MOVLW  04
525E:  SUBWF  xB5,W
5260:  BNZ   5246
5262:  MOVLW  1F
5264:  MOVWF  xB6
5266:  MOVLW  20
5268:  BTFSS  F9E.4
526A:  BRA    5268
526C:  MOVWF  FAD
526E:  DECFSZ xB6,F
5270:  BRA    5266
5272:  MOVLW  02
5274:  MOVWF  FE9
5276:  MOVFF  2AE,2BB
527A:  MOVFF  2AD,2BA
527E:  MOVFF  2AC,2B9
5282:  MOVFF  2AB,2B8
5286:  MOVWF  xBC
5288:  MOVLB  0
528A:  CALL   3B6E
528E:  MOVLW  35
5290:  MOVLB  2
5292:  MOVWF  xB7
5294:  MOVLW  20
5296:  BTFSS  F9E.4
5298:  BRA    5296
529A:  MOVWF  FAD
529C:  DECFSZ xB7,F
529E:  BRA    5294
52A0:  MOVLW  02
52A2:  MOVWF  FE9
52A4:  MOVFF  2B4,2BB
52A8:  MOVFF  2B3,2BA
52AC:  MOVFF  2B2,2B9
52B0:  MOVFF  2B1,2B8
52B4:  MOVWF  xBC
52B6:  MOVLB  0
52B8:  CALL   3B6E
52BC:  MOVLW  0D
52BE:  BTFSS  F9E.4
52C0:  BRA    52BE
52C2:  MOVWF  FAD
....................                   printf("JUNIO                              %3.2f                                                     %3.2f\r", media_annos[contador][5], media_annos_caldera[contador][5]); 
52C4:  MOVF   x95,W
52C6:  MULLW  30
52C8:  MOVF   FF3,W
52CA:  MOVLB  2
52CC:  CLRF   xAA
52CE:  MOVWF  xA9
52D0:  MOVLW  14
52D2:  ADDWF  xA9,W
52D4:  MOVWF  01
52D6:  MOVLW  00
52D8:  ADDWFC xAA,W
52DA:  MOVWF  03
52DC:  MOVF   01,W
52DE:  ADDLW  1B
52E0:  MOVWF  FE9
52E2:  MOVLW  01
52E4:  ADDWFC 03,W
52E6:  MOVWF  FEA
52E8:  MOVFF  FEF,2AB
52EC:  MOVFF  FEC,2AC
52F0:  MOVFF  FEC,2AD
52F4:  MOVFF  FEC,2AE
52F8:  MOVLB  0
52FA:  MOVF   x95,W
52FC:  MULLW  30
52FE:  MOVF   FF3,W
5300:  MOVLB  2
5302:  CLRF   xB0
5304:  MOVWF  xAF
5306:  MOVLW  14
5308:  ADDWF  xAF,W
530A:  MOVWF  01
530C:  MOVLW  00
530E:  ADDWFC xB0,W
5310:  MOVWF  03
5312:  MOVF   01,W
5314:  ADDLW  DB
5316:  MOVWF  FE9
5318:  MOVLW  01
531A:  ADDWFC 03,W
531C:  MOVWF  FEA
531E:  MOVFF  FEF,2B1
5322:  MOVFF  FEC,2B2
5326:  MOVFF  FEC,2B3
532A:  MOVFF  FEC,2B4
532E:  CLRF   xB5
5330:  MOVF   xB5,W
5332:  MOVLB  0
5334:  CALL   1146
5338:  MOVLB  2
533A:  INCF   xB5,F
533C:  MOVWF  00
533E:  MOVF   00,W
5340:  BTFSS  F9E.4
5342:  BRA    5340
5344:  MOVWF  FAD
5346:  MOVLW  05
5348:  SUBWF  xB5,W
534A:  BNZ   5330
534C:  MOVLW  1E
534E:  MOVWF  xB6
5350:  MOVLW  20
5352:  BTFSS  F9E.4
5354:  BRA    5352
5356:  MOVWF  FAD
5358:  DECFSZ xB6,F
535A:  BRA    5350
535C:  MOVLW  02
535E:  MOVWF  FE9
5360:  MOVFF  2AE,2BB
5364:  MOVFF  2AD,2BA
5368:  MOVFF  2AC,2B9
536C:  MOVFF  2AB,2B8
5370:  MOVWF  xBC
5372:  MOVLB  0
5374:  CALL   3B6E
5378:  MOVLW  35
537A:  MOVLB  2
537C:  MOVWF  xB7
537E:  MOVLW  20
5380:  BTFSS  F9E.4
5382:  BRA    5380
5384:  MOVWF  FAD
5386:  DECFSZ xB7,F
5388:  BRA    537E
538A:  MOVLW  02
538C:  MOVWF  FE9
538E:  MOVFF  2B4,2BB
5392:  MOVFF  2B3,2BA
5396:  MOVFF  2B2,2B9
539A:  MOVFF  2B1,2B8
539E:  MOVWF  xBC
53A0:  MOVLB  0
53A2:  CALL   3B6E
53A6:  MOVLW  0D
53A8:  BTFSS  F9E.4
53AA:  BRA    53A8
53AC:  MOVWF  FAD
....................                   printf("JULIO                              %3.2f                                                     %3.2f\r", media_annos[contador][6], media_annos_caldera[contador][6]); 
53AE:  MOVF   x95,W
53B0:  MULLW  30
53B2:  MOVF   FF3,W
53B4:  MOVLB  2
53B6:  CLRF   xAA
53B8:  MOVWF  xA9
53BA:  MOVLW  18
53BC:  ADDWF  xA9,W
53BE:  MOVWF  01
53C0:  MOVLW  00
53C2:  ADDWFC xAA,W
53C4:  MOVWF  03
53C6:  MOVF   01,W
53C8:  ADDLW  1B
53CA:  MOVWF  FE9
53CC:  MOVLW  01
53CE:  ADDWFC 03,W
53D0:  MOVWF  FEA
53D2:  MOVFF  FEF,2AB
53D6:  MOVFF  FEC,2AC
53DA:  MOVFF  FEC,2AD
53DE:  MOVFF  FEC,2AE
53E2:  MOVLB  0
53E4:  MOVF   x95,W
53E6:  MULLW  30
53E8:  MOVF   FF3,W
53EA:  MOVLB  2
53EC:  CLRF   xB0
53EE:  MOVWF  xAF
53F0:  MOVLW  18
53F2:  ADDWF  xAF,W
53F4:  MOVWF  01
53F6:  MOVLW  00
53F8:  ADDWFC xB0,W
53FA:  MOVWF  03
53FC:  MOVF   01,W
53FE:  ADDLW  DB
5400:  MOVWF  FE9
5402:  MOVLW  01
5404:  ADDWFC 03,W
5406:  MOVWF  FEA
5408:  MOVFF  FEF,2B1
540C:  MOVFF  FEC,2B2
5410:  MOVFF  FEC,2B3
5414:  MOVFF  FEC,2B4
5418:  CLRF   xB5
541A:  MOVF   xB5,W
541C:  MOVLB  0
541E:  CALL   1172
5422:  MOVLB  2
5424:  INCF   xB5,F
5426:  MOVWF  00
5428:  MOVF   00,W
542A:  BTFSS  F9E.4
542C:  BRA    542A
542E:  MOVWF  FAD
5430:  MOVLW  05
5432:  SUBWF  xB5,W
5434:  BNZ   541A
5436:  MOVLW  1E
5438:  MOVWF  xB6
543A:  MOVLW  20
543C:  BTFSS  F9E.4
543E:  BRA    543C
5440:  MOVWF  FAD
5442:  DECFSZ xB6,F
5444:  BRA    543A
5446:  MOVLW  02
5448:  MOVWF  FE9
544A:  MOVFF  2AE,2BB
544E:  MOVFF  2AD,2BA
5452:  MOVFF  2AC,2B9
5456:  MOVFF  2AB,2B8
545A:  MOVWF  xBC
545C:  MOVLB  0
545E:  CALL   3B6E
5462:  MOVLW  35
5464:  MOVLB  2
5466:  MOVWF  xB7
5468:  MOVLW  20
546A:  BTFSS  F9E.4
546C:  BRA    546A
546E:  MOVWF  FAD
5470:  DECFSZ xB7,F
5472:  BRA    5468
5474:  MOVLW  02
5476:  MOVWF  FE9
5478:  MOVFF  2B4,2BB
547C:  MOVFF  2B3,2BA
5480:  MOVFF  2B2,2B9
5484:  MOVFF  2B1,2B8
5488:  MOVWF  xBC
548A:  MOVLB  0
548C:  CALL   3B6E
5490:  MOVLW  0D
5492:  BTFSS  F9E.4
5494:  BRA    5492
5496:  MOVWF  FAD
....................                   printf("AGOSTO                             %3.2f                                                     %3.2f\r", media_annos[contador][7], media_annos_caldera[contador][7]); 
5498:  MOVF   x95,W
549A:  MULLW  30
549C:  MOVF   FF3,W
549E:  MOVLB  2
54A0:  CLRF   xAA
54A2:  MOVWF  xA9
54A4:  MOVLW  1C
54A6:  ADDWF  xA9,W
54A8:  MOVWF  01
54AA:  MOVLW  00
54AC:  ADDWFC xAA,W
54AE:  MOVWF  03
54B0:  MOVF   01,W
54B2:  ADDLW  1B
54B4:  MOVWF  FE9
54B6:  MOVLW  01
54B8:  ADDWFC 03,W
54BA:  MOVWF  FEA
54BC:  MOVFF  FEF,2AB
54C0:  MOVFF  FEC,2AC
54C4:  MOVFF  FEC,2AD
54C8:  MOVFF  FEC,2AE
54CC:  MOVLB  0
54CE:  MOVF   x95,W
54D0:  MULLW  30
54D2:  MOVF   FF3,W
54D4:  MOVLB  2
54D6:  CLRF   xB0
54D8:  MOVWF  xAF
54DA:  MOVLW  1C
54DC:  ADDWF  xAF,W
54DE:  MOVWF  01
54E0:  MOVLW  00
54E2:  ADDWFC xB0,W
54E4:  MOVWF  03
54E6:  MOVF   01,W
54E8:  ADDLW  DB
54EA:  MOVWF  FE9
54EC:  MOVLW  01
54EE:  ADDWFC 03,W
54F0:  MOVWF  FEA
54F2:  MOVFF  FEF,2B1
54F6:  MOVFF  FEC,2B2
54FA:  MOVFF  FEC,2B3
54FE:  MOVFF  FEC,2B4
5502:  CLRF   xB5
5504:  MOVF   xB5,W
5506:  MOVLB  0
5508:  CALL   119E
550C:  MOVLB  2
550E:  INCF   xB5,F
5510:  MOVWF  00
5512:  MOVF   00,W
5514:  BTFSS  F9E.4
5516:  BRA    5514
5518:  MOVWF  FAD
551A:  MOVLW  06
551C:  SUBWF  xB5,W
551E:  BNZ   5504
5520:  MOVLW  1D
5522:  MOVWF  xB6
5524:  MOVLW  20
5526:  BTFSS  F9E.4
5528:  BRA    5526
552A:  MOVWF  FAD
552C:  DECFSZ xB6,F
552E:  BRA    5524
5530:  MOVLW  02
5532:  MOVWF  FE9
5534:  MOVFF  2AE,2BB
5538:  MOVFF  2AD,2BA
553C:  MOVFF  2AC,2B9
5540:  MOVFF  2AB,2B8
5544:  MOVWF  xBC
5546:  MOVLB  0
5548:  CALL   3B6E
554C:  MOVLW  35
554E:  MOVLB  2
5550:  MOVWF  xB7
5552:  MOVLW  20
5554:  BTFSS  F9E.4
5556:  BRA    5554
5558:  MOVWF  FAD
555A:  DECFSZ xB7,F
555C:  BRA    5552
555E:  MOVLW  02
5560:  MOVWF  FE9
5562:  MOVFF  2B4,2BB
5566:  MOVFF  2B3,2BA
556A:  MOVFF  2B2,2B9
556E:  MOVFF  2B1,2B8
5572:  MOVWF  xBC
5574:  MOVLB  0
5576:  CALL   3B6E
557A:  MOVLW  0D
557C:  BTFSS  F9E.4
557E:  BRA    557C
5580:  MOVWF  FAD
....................                   printf("SEPTIEMBRE                         %3.2f                                                     %3.2f\r", media_annos[contador][8], media_annos_caldera[contador][8]); 
5582:  MOVF   x95,W
5584:  MULLW  30
5586:  MOVF   FF3,W
5588:  MOVLB  2
558A:  CLRF   xAA
558C:  MOVWF  xA9
558E:  MOVLW  20
5590:  ADDWF  xA9,W
5592:  MOVWF  01
5594:  MOVLW  00
5596:  ADDWFC xAA,W
5598:  MOVWF  03
559A:  MOVF   01,W
559C:  ADDLW  1B
559E:  MOVWF  FE9
55A0:  MOVLW  01
55A2:  ADDWFC 03,W
55A4:  MOVWF  FEA
55A6:  MOVFF  FEF,2AB
55AA:  MOVFF  FEC,2AC
55AE:  MOVFF  FEC,2AD
55B2:  MOVFF  FEC,2AE
55B6:  MOVLB  0
55B8:  MOVF   x95,W
55BA:  MULLW  30
55BC:  MOVF   FF3,W
55BE:  MOVLB  2
55C0:  CLRF   xB0
55C2:  MOVWF  xAF
55C4:  MOVLW  20
55C6:  ADDWF  xAF,W
55C8:  MOVWF  01
55CA:  MOVLW  00
55CC:  ADDWFC xB0,W
55CE:  MOVWF  03
55D0:  MOVF   01,W
55D2:  ADDLW  DB
55D4:  MOVWF  FE9
55D6:  MOVLW  01
55D8:  ADDWFC 03,W
55DA:  MOVWF  FEA
55DC:  MOVFF  FEF,2B1
55E0:  MOVFF  FEC,2B2
55E4:  MOVFF  FEC,2B3
55E8:  MOVFF  FEC,2B4
55EC:  CLRF   xB5
55EE:  MOVF   xB5,W
55F0:  MOVLB  0
55F2:  CALL   11CA
55F6:  MOVLB  2
55F8:  INCF   xB5,F
55FA:  MOVWF  00
55FC:  MOVF   00,W
55FE:  BTFSS  F9E.4
5600:  BRA    55FE
5602:  MOVWF  FAD
5604:  MOVLW  0A
5606:  SUBWF  xB5,W
5608:  BNZ   55EE
560A:  MOVLW  19
560C:  MOVWF  xB6
560E:  MOVLW  20
5610:  BTFSS  F9E.4
5612:  BRA    5610
5614:  MOVWF  FAD
5616:  DECFSZ xB6,F
5618:  BRA    560E
561A:  MOVLW  02
561C:  MOVWF  FE9
561E:  MOVFF  2AE,2BB
5622:  MOVFF  2AD,2BA
5626:  MOVFF  2AC,2B9
562A:  MOVFF  2AB,2B8
562E:  MOVWF  xBC
5630:  MOVLB  0
5632:  CALL   3B6E
5636:  MOVLW  35
5638:  MOVLB  2
563A:  MOVWF  xB7
563C:  MOVLW  20
563E:  BTFSS  F9E.4
5640:  BRA    563E
5642:  MOVWF  FAD
5644:  DECFSZ xB7,F
5646:  BRA    563C
5648:  MOVLW  02
564A:  MOVWF  FE9
564C:  MOVFF  2B4,2BB
5650:  MOVFF  2B3,2BA
5654:  MOVFF  2B2,2B9
5658:  MOVFF  2B1,2B8
565C:  MOVWF  xBC
565E:  MOVLB  0
5660:  CALL   3B6E
5664:  MOVLW  0D
5666:  BTFSS  F9E.4
5668:  BRA    5666
566A:  MOVWF  FAD
....................                   printf("OCTUBRE                            %3.2f                                                     %3.2f\r", media_annos[contador][9], media_annos_caldera[contador][9]); 
566C:  MOVF   x95,W
566E:  MULLW  30
5670:  MOVF   FF3,W
5672:  MOVLB  2
5674:  CLRF   xAA
5676:  MOVWF  xA9
5678:  MOVLW  24
567A:  ADDWF  xA9,W
567C:  MOVWF  01
567E:  MOVLW  00
5680:  ADDWFC xAA,W
5682:  MOVWF  03
5684:  MOVF   01,W
5686:  ADDLW  1B
5688:  MOVWF  FE9
568A:  MOVLW  01
568C:  ADDWFC 03,W
568E:  MOVWF  FEA
5690:  MOVFF  FEF,2AB
5694:  MOVFF  FEC,2AC
5698:  MOVFF  FEC,2AD
569C:  MOVFF  FEC,2AE
56A0:  MOVLB  0
56A2:  MOVF   x95,W
56A4:  MULLW  30
56A6:  MOVF   FF3,W
56A8:  MOVLB  2
56AA:  CLRF   xB0
56AC:  MOVWF  xAF
56AE:  MOVLW  24
56B0:  ADDWF  xAF,W
56B2:  MOVWF  01
56B4:  MOVLW  00
56B6:  ADDWFC xB0,W
56B8:  MOVWF  03
56BA:  MOVF   01,W
56BC:  ADDLW  DB
56BE:  MOVWF  FE9
56C0:  MOVLW  01
56C2:  ADDWFC 03,W
56C4:  MOVWF  FEA
56C6:  MOVFF  FEF,2B1
56CA:  MOVFF  FEC,2B2
56CE:  MOVFF  FEC,2B3
56D2:  MOVFF  FEC,2B4
56D6:  CLRF   xB5
56D8:  MOVF   xB5,W
56DA:  MOVLB  0
56DC:  CALL   11FA
56E0:  MOVLB  2
56E2:  INCF   xB5,F
56E4:  MOVWF  00
56E6:  MOVF   00,W
56E8:  BTFSS  F9E.4
56EA:  BRA    56E8
56EC:  MOVWF  FAD
56EE:  MOVLW  07
56F0:  SUBWF  xB5,W
56F2:  BNZ   56D8
56F4:  MOVLW  1C
56F6:  MOVWF  xB6
56F8:  MOVLW  20
56FA:  BTFSS  F9E.4
56FC:  BRA    56FA
56FE:  MOVWF  FAD
5700:  DECFSZ xB6,F
5702:  BRA    56F8
5704:  MOVLW  02
5706:  MOVWF  FE9
5708:  MOVFF  2AE,2BB
570C:  MOVFF  2AD,2BA
5710:  MOVFF  2AC,2B9
5714:  MOVFF  2AB,2B8
5718:  MOVWF  xBC
571A:  MOVLB  0
571C:  CALL   3B6E
5720:  MOVLW  35
5722:  MOVLB  2
5724:  MOVWF  xB7
5726:  MOVLW  20
5728:  BTFSS  F9E.4
572A:  BRA    5728
572C:  MOVWF  FAD
572E:  DECFSZ xB7,F
5730:  BRA    5726
5732:  MOVLW  02
5734:  MOVWF  FE9
5736:  MOVFF  2B4,2BB
573A:  MOVFF  2B3,2BA
573E:  MOVFF  2B2,2B9
5742:  MOVFF  2B1,2B8
5746:  MOVWF  xBC
5748:  MOVLB  0
574A:  CALL   3B6E
574E:  MOVLW  0D
5750:  BTFSS  F9E.4
5752:  BRA    5750
5754:  MOVWF  FAD
....................                   printf("NOVIEMBRE                          %3.2f                                                     %3.2f\r", media_annos[contador][10], media_annos_caldera[contador][10]); 
5756:  MOVF   x95,W
5758:  MULLW  30
575A:  MOVF   FF3,W
575C:  MOVLB  2
575E:  CLRF   xAA
5760:  MOVWF  xA9
5762:  MOVLW  28
5764:  ADDWF  xA9,W
5766:  MOVWF  01
5768:  MOVLW  00
576A:  ADDWFC xAA,W
576C:  MOVWF  03
576E:  MOVF   01,W
5770:  ADDLW  1B
5772:  MOVWF  FE9
5774:  MOVLW  01
5776:  ADDWFC 03,W
5778:  MOVWF  FEA
577A:  MOVFF  FEF,2AB
577E:  MOVFF  FEC,2AC
5782:  MOVFF  FEC,2AD
5786:  MOVFF  FEC,2AE
578A:  MOVLB  0
578C:  MOVF   x95,W
578E:  MULLW  30
5790:  MOVF   FF3,W
5792:  MOVLB  2
5794:  CLRF   xB0
5796:  MOVWF  xAF
5798:  MOVLW  28
579A:  ADDWF  xAF,W
579C:  MOVWF  01
579E:  MOVLW  00
57A0:  ADDWFC xB0,W
57A2:  MOVWF  03
57A4:  MOVF   01,W
57A6:  ADDLW  DB
57A8:  MOVWF  FE9
57AA:  MOVLW  01
57AC:  ADDWFC 03,W
57AE:  MOVWF  FEA
57B0:  MOVFF  FEF,2B1
57B4:  MOVFF  FEC,2B2
57B8:  MOVFF  FEC,2B3
57BC:  MOVFF  FEC,2B4
57C0:  CLRF   xB5
57C2:  MOVF   xB5,W
57C4:  MOVLB  0
57C6:  CALL   1228
57CA:  MOVLB  2
57CC:  INCF   xB5,F
57CE:  MOVWF  00
57D0:  MOVF   00,W
57D2:  BTFSS  F9E.4
57D4:  BRA    57D2
57D6:  MOVWF  FAD
57D8:  MOVLW  09
57DA:  SUBWF  xB5,W
57DC:  BNZ   57C2
57DE:  MOVLW  1A
57E0:  MOVWF  xB6
57E2:  MOVLW  20
57E4:  BTFSS  F9E.4
57E6:  BRA    57E4
57E8:  MOVWF  FAD
57EA:  DECFSZ xB6,F
57EC:  BRA    57E2
57EE:  MOVLW  02
57F0:  MOVWF  FE9
57F2:  MOVFF  2AE,2BB
57F6:  MOVFF  2AD,2BA
57FA:  MOVFF  2AC,2B9
57FE:  MOVFF  2AB,2B8
5802:  MOVWF  xBC
5804:  MOVLB  0
5806:  CALL   3B6E
580A:  MOVLW  35
580C:  MOVLB  2
580E:  MOVWF  xB7
5810:  MOVLW  20
5812:  BTFSS  F9E.4
5814:  BRA    5812
5816:  MOVWF  FAD
5818:  DECFSZ xB7,F
581A:  BRA    5810
581C:  MOVLW  02
581E:  MOVWF  FE9
5820:  MOVFF  2B4,2BB
5824:  MOVFF  2B3,2BA
5828:  MOVFF  2B2,2B9
582C:  MOVFF  2B1,2B8
5830:  MOVWF  xBC
5832:  MOVLB  0
5834:  CALL   3B6E
5838:  MOVLW  0D
583A:  BTFSS  F9E.4
583C:  BRA    583A
583E:  MOVWF  FAD
....................                   printf("DICIEMBRE                          %3.2f                                                     %3.2f\r", media_annos[contador][11], media_annos_caldera[contador][11]); 
5840:  MOVF   x95,W
5842:  MULLW  30
5844:  MOVF   FF3,W
5846:  MOVLB  2
5848:  CLRF   xAA
584A:  MOVWF  xA9
584C:  MOVLW  2C
584E:  ADDWF  xA9,W
5850:  MOVWF  01
5852:  MOVLW  00
5854:  ADDWFC xAA,W
5856:  MOVWF  03
5858:  MOVF   01,W
585A:  ADDLW  1B
585C:  MOVWF  FE9
585E:  MOVLW  01
5860:  ADDWFC 03,W
5862:  MOVWF  FEA
5864:  MOVFF  FEF,2AB
5868:  MOVFF  FEC,2AC
586C:  MOVFF  FEC,2AD
5870:  MOVFF  FEC,2AE
5874:  MOVLB  0
5876:  MOVF   x95,W
5878:  MULLW  30
587A:  MOVF   FF3,W
587C:  MOVLB  2
587E:  CLRF   xB0
5880:  MOVWF  xAF
5882:  MOVLW  2C
5884:  ADDWF  xAF,W
5886:  MOVWF  01
5888:  MOVLW  00
588A:  ADDWFC xB0,W
588C:  MOVWF  03
588E:  MOVF   01,W
5890:  ADDLW  DB
5892:  MOVWF  FE9
5894:  MOVLW  01
5896:  ADDWFC 03,W
5898:  MOVWF  FEA
589A:  MOVFF  FEF,2B1
589E:  MOVFF  FEC,2B2
58A2:  MOVFF  FEC,2B3
58A6:  MOVFF  FEC,2B4
58AA:  CLRF   xB5
58AC:  MOVF   xB5,W
58AE:  MOVLB  0
58B0:  CALL   1258
58B4:  MOVLB  2
58B6:  INCF   xB5,F
58B8:  MOVWF  00
58BA:  MOVF   00,W
58BC:  BTFSS  F9E.4
58BE:  BRA    58BC
58C0:  MOVWF  FAD
58C2:  MOVLW  09
58C4:  SUBWF  xB5,W
58C6:  BNZ   58AC
58C8:  MOVLW  1A
58CA:  MOVWF  xB6
58CC:  MOVLW  20
58CE:  BTFSS  F9E.4
58D0:  BRA    58CE
58D2:  MOVWF  FAD
58D4:  DECFSZ xB6,F
58D6:  BRA    58CC
58D8:  MOVLW  02
58DA:  MOVWF  FE9
58DC:  MOVFF  2AE,2BB
58E0:  MOVFF  2AD,2BA
58E4:  MOVFF  2AC,2B9
58E8:  MOVFF  2AB,2B8
58EC:  MOVWF  xBC
58EE:  MOVLB  0
58F0:  CALL   3B6E
58F4:  MOVLW  35
58F6:  MOVLB  2
58F8:  MOVWF  xB7
58FA:  MOVLW  20
58FC:  BTFSS  F9E.4
58FE:  BRA    58FC
5900:  MOVWF  FAD
5902:  DECFSZ xB7,F
5904:  BRA    58FA
5906:  MOVLW  02
5908:  MOVWF  FE9
590A:  MOVFF  2B4,2BB
590E:  MOVFF  2B3,2BA
5912:  MOVFF  2B2,2B9
5916:  MOVFF  2B1,2B8
591A:  MOVWF  xBC
591C:  MOVLB  0
591E:  CALL   3B6E
5922:  MOVLW  0D
5924:  BTFSS  F9E.4
5926:  BRA    5924
5928:  MOVWF  FAD
....................                   printf("--------------------------------------------------------------------------------------------------------------------\r"); 
592A:  MOVLB  2
592C:  CLRF   xA9
592E:  MOVF   xA9,W
5930:  MOVLB  0
5932:  CALL   0F4A
5936:  IORLW  00
5938:  BZ    5948
593A:  MOVLB  2
593C:  INCF   xA9,F
593E:  BTFSS  F9E.4
5940:  BRA    593E
5942:  MOVWF  FAD
5944:  BRA    592E
5946:  MOVLB  0
....................                } 
5948:  INCF   x95,F
594A:  GOTO   4D86
....................  
....................                goto repetir; 
594E:  GOTO   4AE0
....................                break; 
5952:  BRA    5954
....................  
....................       //En los tres casos, vuelve a mostrarse el menú tras imprimir las estadísticas 
....................    } 
.................... } 
5954:  GOTO   6D6C (RETURN)
....................  
.................... //----------------------------------------------------------------------------------------------------------------------------------------- 
....................  
.................... void seleccionar_alarma() 
.................... { 
....................    //Contador y variables auxiliares 
....................    int contador; 
....................    int hora, minutos, hora_p, min_p; 
....................  
....................    //Ponemos la posición en el vector de alarmas incialmente a 0 
....................    posicion_alarmas = 0; 
*
38F6:  CLRF   5A
....................  
....................    //Leemos el tiempo actual 
....................    PCF8583_read_datetime(&tiempo); 
38F8:  CLRF   xA6
38FA:  MOVLW  5B
38FC:  MOVWF  xA5
38FE:  CALL   28AE
....................    hora = tiempo.hours; 
3902:  MOVFF  5D,96
....................    minutos = tiempo.minutes; 
3906:  MOVFF  5C,97
....................  
....................    //Recorremos todas las programaciones 
....................    for(contador=0; contador<num_intervalos; contador++) 
390A:  CLRF   x95
390C:  MOVF   59,W
390E:  SUBWF  x95,W
3910:  BC    3974
....................    { 
....................        hora_p = programaciones[contador].horas_inicio; 
3912:  MOVF   x95,W
3914:  MULLW  05
3916:  MOVF   FF3,W
3918:  CLRF   x9B
391A:  MOVWF  x9A
391C:  MOVLW  3B
391E:  ADDWF  x9A,W
3920:  MOVWF  FE9
3922:  MOVLW  00
3924:  ADDWFC x9B,W
3926:  MOVWF  FEA
3928:  MOVFF  FEF,98
....................        min_p  = programaciones[contador].minutos_inicio; 
392C:  MOVF   x95,W
392E:  MULLW  05
3930:  MOVF   FF3,W
3932:  CLRF   x9B
3934:  MOVWF  x9A
3936:  MOVLW  01
3938:  ADDWF  x9A,W
393A:  MOVWF  01
393C:  MOVLW  00
393E:  ADDWFC x9B,W
3940:  MOVWF  03
3942:  MOVF   01,W
3944:  ADDLW  3B
3946:  MOVWF  FE9
3948:  MOVLW  00
394A:  ADDWFC 03,W
394C:  MOVWF  FEA
394E:  MOVFF  FEF,99
....................  
....................        //Comprobamos las horas y tomamos la primera programación que tenga una 
....................        //hora mayor que la actual 
....................        if(!comprobar_hora(hora_p, min_p, hora, minutos)) 
3952:  MOVFF  98,AF
3956:  MOVFF  99,B0
395A:  MOVFF  96,B1
395E:  MOVFF  97,B2
3962:  CALL   2C9C
3966:  MOVF   01,F
3968:  BNZ   3970
....................        { 
....................            //Guardamos la posición de esta programación y salimos 
....................            posicion_alarmas = contador; 
396A:  MOVFF  95,5A
....................            break; 
396E:  BRA    3974
....................        } 
....................    } 
3970:  INCF   x95,F
3972:  BRA    390C
.................... } 
3974:  GOTO   6BF8 (RETURN)

Configuration Fuses:
   Word  1: 0200   HS NOIESO NOFCMEN RESERVED
   Word  2: 181E   BROWNOUT NOWDT BORV25 PUT WDT4096
   Word  3: 8300   PBADEN CCP2C1 NOLPT1OSC MCLR RESERVED
   Word  4: 0081   STVREN NODEBUG NOLVP NOXINST RESERVED
   Word  5: C00F   NOPROTECT NOCPD NOCPB
   Word  6: E00F   NOWRT NOWRTD NOWRTC NOWRTB
   Word  7: 400F   NOEBTR NOEBTRB
