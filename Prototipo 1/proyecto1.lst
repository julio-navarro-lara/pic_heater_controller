CCS PCH C Compiler, Version 3.249, 28193               16-ene-10 18:04

               Filename: E:\programming\sed\Proyecto 1\Prototipo 1\proyecto1.lst

               ROM used: 23196 bytes (71%)
                         Largest free fragment is 9568
               RAM used: 117 (8%) at main() level
                         699 (46%) worst case
               Stack:    8 worst case (7 in main + 1 for interrupts)

*
0000:  GOTO   4BC2
*
0008:  MOVWF  05
000A:  MOVFF  FD8,06
000E:  MOVFF  FE0,07
0012:  MOVLB  0
0014:  MOVFF  FE9,0D
0018:  MOVFF  FEA,08
001C:  MOVFF  FE1,09
0020:  MOVFF  FE2,0A
0024:  MOVFF  FD9,0B
0028:  MOVFF  FDA,0C
002C:  MOVFF  FF3,14
0030:  MOVFF  FF4,15
0034:  MOVFF  FFA,16
0038:  MOVFF  00,0F
003C:  MOVFF  01,10
0040:  MOVFF  02,11
0044:  MOVFF  03,12
0048:  MOVFF  04,13
004C:  BTFSS  FF2.4
004E:  GOTO   0058
0052:  BTFSC  FF2.1
0054:  GOTO   0BD4
0058:  BTFSS  FF0.3
005A:  GOTO   0064
005E:  BTFSC  FF0.0
0060:  GOTO   0BDE
0064:  MOVFF  0F,00
0068:  MOVFF  10,01
006C:  MOVFF  11,02
0070:  MOVFF  12,03
0074:  MOVFF  13,04
0078:  MOVFF  0D,FE9
007C:  MOVFF  08,FEA
0080:  MOVFF  09,FE1
0084:  MOVFF  0A,FE2
0088:  MOVFF  0B,FD9
008C:  MOVFF  0C,FDA
0090:  MOVFF  14,FF3
0094:  MOVFF  15,FF4
0098:  MOVFF  16,FFA
009C:  MOVF   05,W
009E:  MOVFF  07,FE0
00A2:  MOVFF  06,FD8
00A6:  RETFIE 0
.................... //***************************************************************** 
.................... //***   PROYECTO 1: Control de un sistema de calefacción de una *** 
.................... //***   vivienda utilizando un microcontrolador PIC18F4520      *** 
.................... //***************************************************************** 
.................... //Author: Julio Navarro Lara        2010 
....................  
....................  
....................  
.................... #include "18F4520.H" 
.................... //////// Standard Header file for the PIC18F4520 device //////////////// 
.................... #DEVICE PIC18F4520 //Aunque el convertidor A/D es de 10 bits, con esta directiva 
00A8:  MOVFF  FF2,0E
00AC:  BCF    FF2.7
00AE:  CLRF   FF7
00B0:  ADDLW  C2
00B2:  MOVWF  FF6
00B4:  MOVLW  00
00B6:  ADDWFC FF7,F
00B8:  TBLRD*+
00BA:  MOVF   FF5,W
00BC:  BTFSC  0E.7
00BE:  BSF    FF2.7
00C0:  RETURN 0
00C2:  DATA 2C,0F
00C4:  DATA 01,06
00C6:  MOVFF  FF2,0E
00CA:  BCF    FF2.7
00CC:  CLRF   FF7
00CE:  ADDLW  E0
00D0:  MOVWF  FF6
00D2:  MOVLW  00
00D4:  ADDWFC FF7,F
00D6:  TBLRD*+
00D8:  MOVF   FF5,W
00DA:  BTFSC  0E.7
00DC:  BSF    FF2.7
00DE:  RETURN 0
00E0:  DATA 31,32
00E2:  DATA 33,34
00E4:  DATA 35,36
00E6:  DATA 37,38
00E8:  DATA 39,53
00EA:  DATA 30,4E
00EC:  MOVFF  FF2,0E
00F0:  BCF    FF2.7
00F2:  CLRF   FF7
00F4:  ADDLW  06
00F6:  MOVWF  FF6
00F8:  MOVLW  01
00FA:  ADDWFC FF7,F
00FC:  TBLRD*+
00FE:  MOVF   FF5,W
0100:  BTFSC  0E.7
0102:  BSF    FF2.7
0104:  RETURN 0
0106:  DATA 49,6E
0108:  DATA 69,63
010A:  DATA 69,61
010C:  DATA 6C,69
010E:  DATA 7A,61
0110:  DATA 6E,64
0112:  DATA 6F,2E
0114:  DATA 2E,2E
0116:  DATA 00,00
0118:  MOVFF  FF2,0E
011C:  BCF    FF2.7
011E:  CLRF   FF7
0120:  ADDLW  32
0122:  MOVWF  FF6
0124:  MOVLW  01
0126:  ADDWFC FF7,F
0128:  TBLRD*+
012A:  MOVF   FF5,W
012C:  BTFSC  0E.7
012E:  BSF    FF2.7
0130:  RETURN 0
0132:  DATA 20,20
0134:  DATA 49,6E
0136:  DATA 64,69
0138:  DATA 71,75
013A:  DATA 65,20
013C:  DATA 6C,61
013E:  DATA 20,0A
0140:  DATA 20,20
0142:  DATA 6F,70
0144:  DATA 65,72
0146:  DATA 61,63
0148:  DATA 69,6F
014A:  DATA 6E,00
014C:  MOVFF  FF2,0E
0150:  BCF    FF2.7
0152:  CLRF   FF7
0154:  ADDLW  66
0156:  MOVWF  FF6
0158:  MOVLW  01
015A:  ADDWFC FF7,F
015C:  TBLRD*+
015E:  MOVF   FF5,W
0160:  BTFSC  0E.7
0162:  BSF    FF2.7
0164:  RETURN 0
0166:  DATA 20,20
0168:  DATA 45,6E
016A:  DATA 63,65
016C:  DATA 6E,64
016E:  DATA 69,65
0170:  DATA 6E,64
0172:  DATA 6F,0A
0174:  DATA 20,20
0176:  DATA 73,69
0178:  DATA 73,74
017A:  DATA 65,6D
017C:  DATA 61,2E
017E:  DATA 2E,2E
0180:  DATA 00,00
0182:  MOVFF  FF2,0E
0186:  BCF    FF2.7
0188:  CLRF   FF7
018A:  ADDLW  9C
018C:  MOVWF  FF6
018E:  MOVLW  01
0190:  ADDWFC FF7,F
0192:  TBLRD*+
0194:  MOVF   FF5,W
0196:  BTFSC  0E.7
0198:  BSF    FF2.7
019A:  RETURN 0
019C:  DATA 20,20
019E:  DATA 41,70
01A0:  DATA 61,67
01A2:  DATA 61,6E
01A4:  DATA 64,6F
01A6:  DATA 0A,20
01A8:  DATA 20,73
01AA:  DATA 69,73
01AC:  DATA 74,65
01AE:  DATA 6D,61
01B0:  DATA 2E,2E
01B2:  DATA 2E,00
01B4:  MOVFF  FF2,0E
01B8:  BCF    FF2.7
01BA:  CLRF   FF7
01BC:  ADDLW  CE
01BE:  MOVWF  FF6
01C0:  MOVLW  01
01C2:  ADDWFC FF7,F
01C4:  TBLRD*+
01C6:  MOVF   FF5,W
01C8:  BTFSC  0E.7
01CA:  BSF    FF2.7
01CC:  RETURN 0
01CE:  DATA 4D,6F
01D0:  DATA 64,69
01D2:  DATA 66,69
01D4:  DATA 63,61
01D6:  DATA 72,0A
01D8:  DATA 74,65
01DA:  DATA 72,6D
01DC:  DATA 6F,73
01DE:  DATA 74,61
01E0:  DATA 74,6F
01E2:  DATA 20,25
01E4:  DATA 2E,30
01E6:  DATA 66,25
01E8:  DATA 63,43
01EA:  DATA 00,00
01EC:  MOVFF  FF2,0E
01F0:  BCF    FF2.7
01F2:  CLRF   FF7
01F4:  ADDLW  06
01F6:  MOVWF  FF6
01F8:  MOVLW  02
01FA:  ADDWFC FF7,F
01FC:  TBLRD*+
01FE:  MOVF   FF5,W
0200:  BTFSC  0E.7
0202:  BSF    FF2.7
0204:  RETURN 0
0206:  DATA 4E,75
0208:  DATA 65,76
020A:  DATA 6F,20
020C:  DATA 76,61
020E:  DATA 6C,6F
0210:  DATA 72,3A
0212:  DATA 0A,25
0214:  DATA 63,43
0216:  DATA 00,00
0218:  MOVFF  FF2,0E
021C:  BCF    FF2.7
021E:  CLRF   FF7
0220:  ADDLW  32
0222:  MOVWF  FF6
0224:  MOVLW  02
0226:  ADDWFC FF7,F
0228:  TBLRD*+
022A:  MOVF   FF5,W
022C:  BTFSC  0E.7
022E:  BSF    FF2.7
0230:  RETURN 0
0232:  DATA 20,20
0234:  DATA 41,70
0236:  DATA 6C,69
0238:  DATA 63,61
023A:  DATA 6E,64
023C:  DATA 6F,0A
023E:  DATA 20,20
0240:  DATA 63,61
0242:  DATA 6D,62
0244:  DATA 69,6F
0246:  DATA 73,2E
0248:  DATA 2E,2E
024A:  DATA 00,00
024C:  MOVFF  FF2,0E
0250:  BCF    FF2.7
0252:  CLRF   FF7
0254:  ADDLW  66
0256:  MOVWF  FF6
0258:  MOVLW  02
025A:  ADDWFC FF7,F
025C:  TBLRD*+
025E:  MOVF   FF5,W
0260:  BTFSC  0E.7
0262:  BSF    FF2.7
0264:  RETURN 0
0266:  DATA 20,20
0268:  DATA 20,56
026A:  DATA 61,6C
026C:  DATA 6F,72
026E:  DATA 0A,20
0270:  DATA 20,20
0272:  DATA 69,6E
0274:  DATA 63,6F
0276:  DATA 72,72
0278:  DATA 65,63
027A:  DATA 74,6F
027C:  DATA 00,00
027E:  MOVFF  FF2,0E
0282:  BCF    FF2.7
0284:  CLRF   FF7
0286:  ADDLW  98
0288:  MOVWF  FF6
028A:  MOVLW  02
028C:  ADDWFC FF7,F
028E:  TBLRD*+
0290:  MOVF   FF5,W
0292:  BTFSC  0E.7
0294:  BSF    FF2.7
0296:  RETURN 0
0298:  DATA 20,50
029A:  DATA 72,6F
029C:  DATA 67,72
029E:  DATA 61,6D
02A0:  DATA 61,72
02A2:  DATA 0A,20
02A4:  DATA 73,69
02A6:  DATA 73,74
02A8:  DATA 65,6D
02AA:  DATA 61,00
02AC:  MOVFF  FF2,0E
02B0:  BCF    FF2.7
02B2:  CLRF   FF7
02B4:  ADDLW  C6
02B6:  MOVWF  FF6
02B8:  MOVLW  02
02BA:  ADDWFC FF7,F
02BC:  TBLRD*+
02BE:  MOVF   FF5,W
02C0:  BTFSC  0E.7
02C2:  BSF    FF2.7
02C4:  RETURN 0
02C6:  DATA 20,49
02C8:  DATA 4E,54
02CA:  DATA 45,52
02CC:  DATA 56,41
02CE:  DATA 4C,4F
02D0:  DATA 20,25
02D2:  DATA 69,0A
02D4:  DATA 3A,3A
02D6:  DATA 00,00
02D8:  MOVFF  FF2,0E
02DC:  BCF    FF2.7
02DE:  CLRF   FF7
02E0:  ADDLW  F2
02E2:  MOVWF  FF6
02E4:  MOVLW  02
02E6:  ADDWFC FF7,F
02E8:  TBLRD*+
02EA:  MOVF   FF5,W
02EC:  BTFSC  0E.7
02EE:  BSF    FF2.7
02F0:  RETURN 0
02F2:  DATA 20,20
02F4:  DATA 20,56
02F6:  DATA 61,6C
02F8:  DATA 6F,72
02FA:  DATA 65,73
02FC:  DATA 0A,20
02FE:  DATA 20,20
0300:  DATA 69,6E
0302:  DATA 63,6F
0304:  DATA 72,72
0306:  DATA 65,63
0308:  DATA 74,6F
030A:  DATA 73,00
030C:  MOVFF  FF2,0E
0310:  BCF    FF2.7
0312:  CLRF   FF7
0314:  ADDLW  26
0316:  MOVWF  FF6
0318:  MOVLW  03
031A:  ADDWFC FF7,F
031C:  TBLRD*+
031E:  MOVF   FF5,W
0320:  BTFSC  0E.7
0322:  BSF    FF2.7
0324:  RETURN 0
0326:  DATA 49,6E
0328:  DATA 74,65
032A:  DATA 72,76
032C:  DATA 61,6C
032E:  DATA 6F,20
0330:  DATA 6C,69
0332:  DATA 6D,69
0334:  DATA 74,65
0336:  DATA 0A,64
0338:  DATA 65,20
033A:  DATA 34,20
033C:  DATA 68,6F
033E:  DATA 72,61
0340:  DATA 73,00
0342:  MOVFF  FF2,0E
0346:  BCF    FF2.7
0348:  CLRF   FF7
034A:  ADDLW  5C
034C:  MOVWF  FF6
034E:  MOVLW  03
0350:  ADDWFC FF7,F
0352:  TBLRD*+
0354:  MOVF   FF5,W
0356:  BTFSC  0E.7
0358:  BSF    FF2.7
035A:  RETURN 0
035C:  DATA 54,65
035E:  DATA 72,6D
0360:  DATA 6F,73
0362:  DATA 74,61
0364:  DATA 74,6F
0366:  DATA 20,25
0368:  DATA 69,0A
036A:  DATA 25,63
036C:  DATA 43,00
036E:  MOVFF  FF2,0E
0372:  BCF    FF2.7
0374:  CLRF   FF7
0376:  ADDLW  88
0378:  MOVWF  FF6
037A:  MOVLW  03
037C:  ADDWFC FF7,F
037E:  TBLRD*+
0380:  MOVF   FF5,W
0382:  BTFSC  0E.7
0384:  BSF    FF2.7
0386:  RETURN 0
0388:  DATA 53,6F
038A:  DATA 6C,61
038C:  DATA 70,61
038E:  DATA 6D,69
0390:  DATA 65,6E
0392:  DATA 74,6F
0394:  DATA 0A,64
0396:  DATA 65,20
0398:  DATA 69,6E
039A:  DATA 74,65
039C:  DATA 72,76
039E:  DATA 61,6C
03A0:  DATA 6F,73
03A2:  DATA 21,00
03A4:  MOVFF  FF2,0E
03A8:  BCF    FF2.7
03AA:  CLRF   FF7
03AC:  ADDLW  BE
03AE:  MOVWF  FF6
03B0:  MOVLW  03
03B2:  ADDWFC FF7,F
03B4:  TBLRD*+
03B6:  MOVF   FF5,W
03B8:  BTFSC  0E.7
03BA:  BSF    FF2.7
03BC:  RETURN 0
03BE:  DATA 20,20
03C0:  DATA 43,4C
03C2:  DATA 41,56
03C4:  DATA 45,3A
03C6:  DATA 0A,20
03C8:  DATA 20,00
03CA:  MOVFF  FF2,0E
03CE:  BCF    FF2.7
03D0:  CLRF   FF7
03D2:  ADDLW  E4
03D4:  MOVWF  FF6
03D6:  MOVLW  03
03D8:  ADDWFC FF7,F
03DA:  TBLRD*+
03DC:  MOVF   FF5,W
03DE:  BTFSC  0E.7
03E0:  BSF    FF2.7
03E2:  RETURN 0
03E4:  DATA 20,20
03E6:  DATA 4D,6F
03E8:  DATA 64,6F
03EA:  DATA 0A,20
03EC:  DATA 20,72
03EE:  DATA 65,76
03F0:  DATA 69,73
03F2:  DATA 69,6F
03F4:  DATA 6E,00
03F6:  MOVFF  FF2,0E
03FA:  BCF    FF2.7
03FC:  CLRF   FF7
03FE:  ADDLW  10
0400:  MOVWF  FF6
0402:  MOVLW  04
0404:  ADDWFC FF7,F
0406:  TBLRD*+
0408:  MOVF   FF5,W
040A:  BTFSC  0E.7
040C:  BSF    FF2.7
040E:  RETURN 0
0410:  DATA 20,20
0412:  DATA 43,6C
0414:  DATA 61,76
0416:  DATA 65,0A
0418:  DATA 20,20
041A:  DATA 69,6E
041C:  DATA 63,6F
041E:  DATA 72,72
0420:  DATA 65,63
0422:  DATA 74,61
0424:  DATA 00,00
0426:  MOVFF  FF2,0E
042A:  BCF    FF2.7
042C:  CLRF   FF7
042E:  ADDLW  40
0430:  MOVWF  FF6
0432:  MOVLW  04
0434:  ADDWFC FF7,F
0436:  TBLRD*+
0438:  MOVF   FF5,W
043A:  BTFSC  0E.7
043C:  BSF    FF2.7
043E:  RETURN 0
0440:  DATA 20,20
0442:  DATA 41,6E
0444:  DATA 75,6C
0446:  DATA 61,6E
0448:  DATA 64,6F
044A:  DATA 0A,20
044C:  DATA 20,6F
044E:  DATA 70,65
0450:  DATA 72,61
0452:  DATA 63,69
0454:  DATA 6F,6E
0456:  DATA 2E,2E
0458:  DATA 2E,00
045A:  MOVFF  FF2,0E
045E:  BCF    FF2.7
0460:  CLRF   FF7
0462:  ADDLW  74
0464:  MOVWF  FF6
0466:  MOVLW  04
0468:  ADDWFC FF7,F
046A:  TBLRD*+
046C:  MOVF   FF5,W
046E:  BTFSC  0E.7
0470:  BSF    FF2.7
0472:  RETURN 0
0474:  DATA 44,65
0476:  DATA 6D,61
0478:  DATA 73,69
047A:  DATA 61,64
047C:  DATA 6F,20
047E:  DATA 74,69
0480:  DATA 65,6D
0482:  DATA 70,6F
0484:  DATA 0A,65
0486:  DATA 6E,63
0488:  DATA 65,6E
048A:  DATA 64,69
048C:  DATA 64,6F
048E:  DATA 21,00
0490:  MOVFF  FF2,0E
0494:  BCF    FF2.7
0496:  CLRF   FF7
0498:  ADDLW  AA
049A:  MOVWF  FF6
049C:  MOVLW  04
049E:  ADDWFC FF7,F
04A0:  TBLRD*+
04A2:  MOVF   FF5,W
04A4:  BTFSC  0E.7
04A6:  BSF    FF2.7
04A8:  RETURN 0
04AA:  DATA 54,45
04AC:  DATA 4D,50
04AE:  DATA 20,2D
04B0:  DATA 20,25
04B2:  DATA 33,2E
04B4:  DATA 31,66
04B6:  DATA 20,25
04B8:  DATA 63,43
04BA:  DATA 0A,48
04BC:  DATA 4F,52
04BE:  DATA 41,20
04C0:  DATA 2D,20
04C2:  DATA 00,00
04C4:  MOVFF  FF2,0E
04C8:  BCF    FF2.7
04CA:  CLRF   FF7
04CC:  ADDLW  DE
04CE:  MOVWF  FF6
04D0:  MOVLW  04
04D2:  ADDWFC FF7,F
04D4:  TBLRD*+
04D6:  MOVF   FF5,W
04D8:  BTFSC  0E.7
04DA:  BSF    FF2.7
04DC:  RETURN 0
04DE:  DATA 30,00
04E0:  MOVFF  FF2,0E
04E4:  BCF    FF2.7
04E6:  CLRF   FF7
04E8:  ADDLW  FA
04EA:  MOVWF  FF6
04EC:  MOVLW  04
04EE:  ADDWFC FF7,F
04F0:  TBLRD*+
04F2:  MOVF   FF5,W
04F4:  BTFSC  0E.7
04F6:  BSF    FF2.7
04F8:  RETURN 0
04FA:  DATA 52,45
04FC:  DATA 47,49
04FE:  DATA 53,54
0500:  DATA 52,4F
0502:  DATA 20,44
0504:  DATA 45,20
0506:  DATA 45,56
0508:  DATA 45,4E
050A:  DATA 54,4F
050C:  DATA 53,0D
050E:  DATA 00,00
0510:  MOVFF  FF2,0E
0514:  BCF    FF2.7
0516:  CLRF   FF7
0518:  ADDLW  2A
051A:  MOVWF  FF6
051C:  MOVLW  05
051E:  ADDWFC FF7,F
0520:  TBLRD*+
0522:  MOVF   FF5,W
0524:  BTFSC  0E.7
0526:  BSF    FF2.7
0528:  RETURN 0
052A:  DATA 2A,2A
052C:  DATA 2A,2A
052E:  DATA 2A,2A
0530:  DATA 2A,2A
0532:  DATA 2A,2A
0534:  DATA 2A,2A
0536:  DATA 2A,2A
0538:  DATA 2A,2A
053A:  DATA 2A,2A
053C:  DATA 2A,0D
053E:  DATA 00,00
0540:  MOVFF  FF2,0E
0544:  BCF    FF2.7
0546:  CLRF   FF7
0548:  ADDLW  5A
054A:  MOVWF  FF6
054C:  MOVLW  05
054E:  ADDWFC FF7,F
0550:  TBLRD*+
0552:  MOVF   FF5,W
0554:  BTFSC  0E.7
0556:  BSF    FF2.7
0558:  RETURN 0
055A:  DATA 4D,6F
055C:  DATA 6D,65
055E:  DATA 6E,74
0560:  DATA 6F,20
0562:  DATA 64,65
0564:  DATA 20,61
0566:  DATA 70,61
0568:  DATA 67,61
056A:  DATA 64,6F
056C:  DATA 20,20
056E:  DATA 20,20
0570:  DATA 20,54
0572:  DATA 65,6D
0574:  DATA 70,65
0576:  DATA 72,61
0578:  DATA 74,75
057A:  DATA 72,61
057C:  DATA 20,20
057E:  DATA 20,20
0580:  DATA 20,20
0582:  DATA 20,20
0584:  DATA 4D,69
0586:  DATA 6E,75
0588:  DATA 74,6F
058A:  DATA 73,20
058C:  DATA 65,6E
058E:  DATA 63,65
0590:  DATA 6E,64
0592:  DATA 69,64
0594:  DATA 6F,20
0596:  DATA 20,20
0598:  DATA 20,20
059A:  DATA 20,20
059C:  DATA 4D,69
059E:  DATA 6E,75
05A0:  DATA 74,6F
05A2:  DATA 73,20
05A4:  DATA 63,61
05A6:  DATA 6C,64
05A8:  DATA 65,72
05AA:  DATA 61,0D
05AC:  DATA 00,00
05AE:  MOVFF  FF2,0E
05B2:  BCF    FF2.7
05B4:  CLRF   FF7
05B6:  ADDLW  C8
05B8:  MOVWF  FF6
05BA:  MOVLW  05
05BC:  ADDWFC FF7,F
05BE:  TBLRD*+
05C0:  MOVF   FF5,W
05C2:  BTFSC  0E.7
05C4:  BSF    FF2.7
05C6:  RETURN 0
05C8:  DATA 3D,3D
05CA:  DATA 3D,3D
05CC:  DATA 3D,3D
05CE:  DATA 3D,3D
05D0:  DATA 3D,3D
05D2:  DATA 3D,3D
05D4:  DATA 3D,3D
05D6:  DATA 3D,3D
05D8:  DATA 3D,3D
05DA:  DATA 3D,3D
05DC:  DATA 3D,3D
05DE:  DATA 3D,3D
05E0:  DATA 3D,3D
05E2:  DATA 3D,3D
05E4:  DATA 3D,3D
05E6:  DATA 3D,3D
05E8:  DATA 3D,3D
05EA:  DATA 3D,3D
05EC:  DATA 3D,3D
05EE:  DATA 3D,3D
05F0:  DATA 3D,3D
05F2:  DATA 3D,3D
05F4:  DATA 3D,3D
05F6:  DATA 3D,3D
05F8:  DATA 3D,3D
05FA:  DATA 3D,3D
05FC:  DATA 3D,3D
05FE:  DATA 3D,3D
0600:  DATA 3D,3D
0602:  DATA 3D,3D
0604:  DATA 3D,3D
0606:  DATA 3D,3D
0608:  DATA 3D,3D
060A:  DATA 3D,3D
060C:  DATA 3D,3D
060E:  DATA 3D,3D
0610:  DATA 3D,3D
0612:  DATA 3D,3D
0614:  DATA 3D,3D
0616:  DATA 3D,3D
0618:  DATA 3D,0D
061A:  DATA 00,00
061C:  MOVFF  FF2,0E
0620:  BCF    FF2.7
0622:  CLRF   FF7
0624:  ADDLW  36
0626:  MOVWF  FF6
0628:  MOVLW  06
062A:  ADDWFC FF7,F
062C:  TBLRD*+
062E:  MOVF   FF5,W
0630:  BTFSC  0E.7
0632:  BSF    FF2.7
0634:  RETURN 0
0636:  DATA 20,00
0638:  MOVFF  FF2,0E
063C:  BCF    FF2.7
063E:  CLRF   FF7
0640:  ADDLW  52
0642:  MOVWF  FF6
0644:  MOVLW  06
0646:  ADDWFC FF7,F
0648:  TBLRD*+
064A:  MOVF   FF5,W
064C:  BTFSC  0E.7
064E:  BSF    FF2.7
0650:  RETURN 0
0652:  DATA BF,51
0654:  DATA 75,65
0656:  DATA 20,6F
0658:  DATA 70,65
065A:  DATA 72,61
065C:  DATA 63,69
065E:  DATA 6F,6E
0660:  DATA 20,64
0662:  DATA 65,73
0664:  DATA 65,61
0666:  DATA 20,72
0668:  DATA 65,61
066A:  DATA 6C,69
066C:  DATA 7A,61
066E:  DATA 72,3F
0670:  DATA 0D,00
0672:  MOVFF  FF2,0E
0676:  BCF    FF2.7
0678:  CLRF   FF7
067A:  ADDLW  8C
067C:  MOVWF  FF6
067E:  MOVLW  06
0680:  ADDWFC FF7,F
0682:  TBLRD*+
0684:  MOVF   FF5,W
0686:  BTFSC  0E.7
0688:  BSF    FF2.7
068A:  RETURN 0
068C:  DATA 30,2E
068E:  DATA 20,53
0690:  DATA 61,6C
0692:  DATA 69,72
0694:  DATA 0D,00
0696:  MOVFF  FF2,0E
069A:  BCF    FF2.7
069C:  CLRF   FF7
069E:  ADDLW  B0
06A0:  MOVWF  FF6
06A2:  MOVLW  06
06A4:  ADDWFC FF7,F
06A6:  TBLRD*+
06A8:  MOVF   FF5,W
06AA:  BTFSC  0E.7
06AC:  BSF    FF2.7
06AE:  RETURN 0
06B0:  DATA 31,2E
06B2:  DATA 20,45
06B4:  DATA 78,74
06B6:  DATA 72,61
06B8:  DATA 65,72
06BA:  DATA 20,74
06BC:  DATA 69,65
06BE:  DATA 6D,70
06C0:  DATA 6F,73
06C2:  DATA 20,6D
06C4:  DATA 65,64
06C6:  DATA 69,6F
06C8:  DATA 73,20
06CA:  DATA 70,6F
06CC:  DATA 72,20
06CE:  DATA 64,69
06D0:  DATA 61,0D
06D2:  DATA 00,00
06D4:  MOVFF  FF2,0E
06D8:  BCF    FF2.7
06DA:  CLRF   FF7
06DC:  ADDLW  EE
06DE:  MOVWF  FF6
06E0:  MOVLW  06
06E2:  ADDWFC FF7,F
06E4:  TBLRD*+
06E6:  MOVF   FF5,W
06E8:  BTFSC  0E.7
06EA:  BSF    FF2.7
06EC:  RETURN 0
06EE:  DATA 32,2E
06F0:  DATA 20,45
06F2:  DATA 78,74
06F4:  DATA 72,61
06F6:  DATA 65,72
06F8:  DATA 20,74
06FA:  DATA 69,65
06FC:  DATA 6D,70
06FE:  DATA 6F,73
0700:  DATA 20,74
0702:  DATA 6F,74
0704:  DATA 61,6C
0706:  DATA 65,73
0708:  DATA 0D,00
070A:  MOVFF  FF2,0E
070E:  BCF    FF2.7
0710:  CLRF   FF7
0712:  ADDLW  24
0714:  MOVWF  FF6
0716:  MOVLW  07
0718:  ADDWFC FF7,F
071A:  TBLRD*+
071C:  MOVF   FF5,W
071E:  BTFSC  0E.7
0720:  BSF    FF2.7
0722:  RETURN 0
0724:  DATA 33,2E
0726:  DATA 20,45
0728:  DATA 78,74
072A:  DATA 72,61
072C:  DATA 65,72
072E:  DATA 20,64
0730:  DATA 61,74
0732:  DATA 6F,73
0734:  DATA 20,6D
0736:  DATA 65,6E
0738:  DATA 73,75
073A:  DATA 61,6C
073C:  DATA 65,73
073E:  DATA 0D,00
0740:  MOVFF  FF2,0E
0744:  BCF    FF2.7
0746:  CLRF   FF7
0748:  ADDLW  5A
074A:  MOVWF  FF6
074C:  MOVLW  07
074E:  ADDWFC FF7,F
0750:  TBLRD*+
0752:  MOVF   FF5,W
0754:  BTFSC  0E.7
0756:  BSF    FF2.7
0758:  RETURN 0
075A:  DATA 20,20
075C:  DATA 53,61
075E:  DATA 6C,69
0760:  DATA 65,6E
0762:  DATA 64,6F
0764:  DATA 2E,2E
0766:  DATA 2E,00
0768:  MOVFF  FF2,0E
076C:  BCF    FF2.7
076E:  CLRF   FF7
0770:  ADDLW  82
0772:  MOVWF  FF6
0774:  MOVLW  07
0776:  ADDWFC FF7,F
0778:  TBLRD*+
077A:  MOVF   FF5,W
077C:  BTFSC  0E.7
077E:  BSF    FF2.7
0780:  RETURN 0
0782:  DATA 0D,54
0784:  DATA 69,65
0786:  DATA 6D,70
0788:  DATA 6F,20
078A:  DATA 6D,65
078C:  DATA 64,69
078E:  DATA 6F,20
0790:  DATA 64,65
0792:  DATA 20,65
0794:  DATA 6E,63
0796:  DATA 65,6E
0798:  DATA 64,69
079A:  DATA 64,6F
079C:  DATA 20,64
079E:  DATA 65,6C
07A0:  DATA 20,73
07A2:  DATA 69,73
07A4:  DATA 74,65
07A6:  DATA 6D,61
07A8:  DATA 20,70
07AA:  DATA 6F,72
07AC:  DATA 20,64
07AE:  DATA 69,61
07B0:  DATA 3A,20
07B2:  DATA 25,33
07B4:  DATA 2E,32
07B6:  DATA 66,20
07B8:  DATA 6D,69
07BA:  DATA 6E,75
07BC:  DATA 74,6F
07BE:  DATA 73,0D
07C0:  DATA 0D,00
07C2:  MOVFF  FF2,0E
07C6:  BCF    FF2.7
07C8:  CLRF   FF7
07CA:  ADDLW  DC
07CC:  MOVWF  FF6
07CE:  MOVLW  07
07D0:  ADDWFC FF7,F
07D2:  TBLRD*+
07D4:  MOVF   FF5,W
07D6:  BTFSC  0E.7
07D8:  BSF    FF2.7
07DA:  RETURN 0
07DC:  DATA 54,69
07DE:  DATA 65,6D
07E0:  DATA 70,6F
07E2:  DATA 20,6D
07E4:  DATA 65,64
07E6:  DATA 69,6F
07E8:  DATA 20,64
07EA:  DATA 65,20
07EC:  DATA 65,6E
07EE:  DATA 63,65
07F0:  DATA 6E,64
07F2:  DATA 69,64
07F4:  DATA 6F,20
07F6:  DATA 64,65
07F8:  DATA 20,6C
07FA:  DATA 61,20
07FC:  DATA 63,61
07FE:  DATA 6C,64
0800:  DATA 65,72
0802:  DATA 61,20
0804:  DATA 70,6F
0806:  DATA 72,20
0808:  DATA 64,69
080A:  DATA 61,3A
080C:  DATA 20,25
080E:  DATA 33,2E
0810:  DATA 32,66
0812:  DATA 20,6D
0814:  DATA 69,6E
0816:  DATA 75,74
0818:  DATA 6F,73
081A:  DATA 0D,0D
081C:  DATA 00,00
081E:  MOVFF  FF2,0E
0822:  BCF    FF2.7
0824:  CLRF   FF7
0826:  ADDLW  38
0828:  MOVWF  FF6
082A:  MOVLW  08
082C:  ADDWFC FF7,F
082E:  TBLRD*+
0830:  MOVF   FF5,W
0832:  BTFSC  0E.7
0834:  BSF    FF2.7
0836:  RETURN 0
0838:  DATA 0D,54
083A:  DATA 69,65
083C:  DATA 6D,70
083E:  DATA 6F,20
0840:  DATA 74,6F
0842:  DATA 74,61
0844:  DATA 6C,20
0846:  DATA 64,65
0848:  DATA 20,65
084A:  DATA 6E,63
084C:  DATA 65,6E
084E:  DATA 64,69
0850:  DATA 64,6F
0852:  DATA 20,64
0854:  DATA 65,6C
0856:  DATA 20,73
0858:  DATA 69,73
085A:  DATA 74,65
085C:  DATA 6D,61
085E:  DATA 3A,20
0860:  DATA 25,6C
0862:  DATA 75,20
0864:  DATA 6D,69
0866:  DATA 6E,75
0868:  DATA 74,6F
086A:  DATA 73,0D
086C:  DATA 0D,00
086E:  MOVFF  FF2,0E
0872:  BCF    FF2.7
0874:  CLRF   FF7
0876:  ADDLW  88
0878:  MOVWF  FF6
087A:  MOVLW  08
087C:  ADDWFC FF7,F
087E:  TBLRD*+
0880:  MOVF   FF5,W
0882:  BTFSC  0E.7
0884:  BSF    FF2.7
0886:  RETURN 0
0888:  DATA 54,69
088A:  DATA 65,6D
088C:  DATA 70,6F
088E:  DATA 20,74
0890:  DATA 6F,74
0892:  DATA 61,6C
0894:  DATA 20,64
0896:  DATA 65,20
0898:  DATA 65,6E
089A:  DATA 63,65
089C:  DATA 6E,64
089E:  DATA 69,64
08A0:  DATA 6F,20
08A2:  DATA 64,65
08A4:  DATA 20,6C
08A6:  DATA 61,20
08A8:  DATA 63,61
08AA:  DATA 6C,64
08AC:  DATA 65,72
08AE:  DATA 61,3A
08B0:  DATA 20,25
08B2:  DATA 6C,75
08B4:  DATA 20,6D
08B6:  DATA 69,6E
08B8:  DATA 75,74
08BA:  DATA 6F,73
08BC:  DATA 0D,0D
08BE:  DATA 00,00
08C0:  MOVFF  FF2,0E
08C4:  BCF    FF2.7
08C6:  CLRF   FF7
08C8:  ADDLW  DA
08CA:  MOVWF  FF6
08CC:  MOVLW  08
08CE:  ADDWFC FF7,F
08D0:  TBLRD*+
08D2:  MOVF   FF5,W
08D4:  BTFSC  0E.7
08D6:  BSF    FF2.7
08D8:  RETURN 0
08DA:  DATA 0D,32
08DC:  DATA 30,00
08DE:  MOVFF  FF2,0E
08E2:  BCF    FF2.7
08E4:  CLRF   FF7
08E6:  ADDLW  F8
08E8:  MOVWF  FF6
08EA:  MOVLW  08
08EC:  ADDWFC FF7,F
08EE:  TBLRD*+
08F0:  MOVF   FF5,W
08F2:  BTFSC  0E.7
08F4:  BSF    FF2.7
08F6:  RETURN 0
08F8:  DATA 2D,2D
08FA:  DATA 2D,2D
08FC:  DATA 2D,2D
08FE:  DATA 2D,2D
0900:  DATA 2D,2D
0902:  DATA 2D,2D
0904:  DATA 2D,2D
0906:  DATA 2D,2D
0908:  DATA 2D,2D
090A:  DATA 2D,2D
090C:  DATA 2D,2D
090E:  DATA 2D,2D
0910:  DATA 2D,2D
0912:  DATA 2D,2D
0914:  DATA 2D,2D
0916:  DATA 2D,2D
0918:  DATA 2D,2D
091A:  DATA 2D,2D
091C:  DATA 2D,2D
091E:  DATA 2D,2D
0920:  DATA 2D,2D
0922:  DATA 2D,2D
0924:  DATA 2D,2D
0926:  DATA 2D,2D
0928:  DATA 2D,2D
092A:  DATA 2D,2D
092C:  DATA 2D,2D
092E:  DATA 2D,2D
0930:  DATA 2D,2D
0932:  DATA 2D,2D
0934:  DATA 2D,2D
0936:  DATA 2D,2D
0938:  DATA 2D,2D
093A:  DATA 2D,2D
093C:  DATA 2D,2D
093E:  DATA 2D,2D
0940:  DATA 2D,2D
0942:  DATA 2D,2D
0944:  DATA 2D,2D
0946:  DATA 2D,2D
0948:  DATA 2D,2D
094A:  DATA 2D,2D
094C:  DATA 2D,2D
094E:  DATA 2D,2D
0950:  DATA 2D,2D
0952:  DATA 2D,2D
0954:  DATA 2D,2D
0956:  DATA 2D,2D
0958:  DATA 2D,2D
095A:  DATA 2D,2D
095C:  DATA 2D,2D
095E:  DATA 2D,2D
0960:  DATA 2D,2D
0962:  DATA 2D,2D
0964:  DATA 2D,2D
0966:  DATA 2D,2D
0968:  DATA 2D,2D
096A:  DATA 2D,2D
096C:  DATA 0D,00
096E:  MOVFF  FF2,0E
0972:  BCF    FF2.7
0974:  CLRF   FF7
0976:  ADDLW  88
0978:  MOVWF  FF6
097A:  MOVLW  09
097C:  ADDWFC FF7,F
097E:  TBLRD*+
0980:  MOVF   FF5,W
0982:  BTFSC  0E.7
0984:  BSF    FF2.7
0986:  RETURN 0
0988:  DATA 20,20
098A:  DATA 20,20
098C:  DATA 20,20
098E:  DATA 20,20
0990:  DATA 20,20
0992:  DATA 20,20
0994:  DATA 20,20
0996:  DATA 54,69
0998:  DATA 65,6D
099A:  DATA 70,6F
099C:  DATA 20,6D
099E:  DATA 65,64
09A0:  DATA 69,6F
09A2:  DATA 20,64
09A4:  DATA 65,20
09A6:  DATA 65,6E
09A8:  DATA 63,65
09AA:  DATA 6E,64
09AC:  DATA 69,64
09AE:  DATA 6F,20
09B0:  DATA 64,65
09B2:  DATA 6C,20
09B4:  DATA 73,69
09B6:  DATA 73,74
09B8:  DATA 65,6D
09BA:  DATA 61,20
09BC:  DATA 28,6D
09BE:  DATA 69,6E
09C0:  DATA 2F,64
09C2:  DATA 69,61
09C4:  DATA 29,20
09C6:  DATA 20,20
09C8:  DATA 20,20
09CA:  DATA 20,54
09CC:  DATA 69,65
09CE:  DATA 6D,70
09D0:  DATA 6F,20
09D2:  DATA 6D,65
09D4:  DATA 64,69
09D6:  DATA 6F,20
09D8:  DATA 64,65
09DA:  DATA 20,65
09DC:  DATA 6E,63
09DE:  DATA 65,6E
09E0:  DATA 64,69
09E2:  DATA 64,6F
09E4:  DATA 20,64
09E6:  DATA 65,20
09E8:  DATA 6C,61
09EA:  DATA 20,63
09EC:  DATA 61,6C
09EE:  DATA 64,65
09F0:  DATA 72,61
09F2:  DATA 20,28
09F4:  DATA 6D,69
09F6:  DATA 6E,2F
09F8:  DATA 64,69
09FA:  DATA 61,29
09FC:  DATA 0D,00
09FE:  MOVFF  FF2,0E
0A02:  BCF    FF2.7
0A04:  CLRF   FF7
0A06:  ADDLW  18
0A08:  MOVWF  FF6
0A0A:  MOVLW  0A
0A0C:  ADDWFC FF7,F
0A0E:  TBLRD*+
0A10:  MOVF   FF5,W
0A12:  BTFSC  0E.7
0A14:  BSF    FF2.7
0A16:  RETURN 0
0A18:  DATA 45,4E
0A1A:  DATA 45,52
0A1C:  DATA 4F,25
0A1E:  DATA 66,25
0A20:  DATA 66,0D
0A22:  DATA 00,00
0A24:  MOVFF  FF2,0E
0A28:  BCF    FF2.7
0A2A:  CLRF   FF7
0A2C:  ADDLW  3E
0A2E:  MOVWF  FF6
0A30:  MOVLW  0A
0A32:  ADDWFC FF7,F
0A34:  TBLRD*+
0A36:  MOVF   FF5,W
0A38:  BTFSC  0E.7
0A3A:  BSF    FF2.7
0A3C:  RETURN 0
0A3E:  DATA 46,45
0A40:  DATA 42,52
0A42:  DATA 45,52
0A44:  DATA 4F,25
0A46:  DATA 66,25
0A48:  DATA 66,0D
0A4A:  DATA 00,00
0A4C:  MOVFF  FF2,0E
0A50:  BCF    FF2.7
0A52:  CLRF   FF7
0A54:  ADDLW  66
0A56:  MOVWF  FF6
0A58:  MOVLW  0A
0A5A:  ADDWFC FF7,F
0A5C:  TBLRD*+
0A5E:  MOVF   FF5,W
0A60:  BTFSC  0E.7
0A62:  BSF    FF2.7
0A64:  RETURN 0
0A66:  DATA 4D,41
0A68:  DATA 52,5A
0A6A:  DATA 4F,25
0A6C:  DATA 66,25
0A6E:  DATA 66,0D
0A70:  DATA 00,00
0A72:  MOVFF  FF2,0E
0A76:  BCF    FF2.7
0A78:  CLRF   FF7
0A7A:  ADDLW  8C
0A7C:  MOVWF  FF6
0A7E:  MOVLW  0A
0A80:  ADDWFC FF7,F
0A82:  TBLRD*+
0A84:  MOVF   FF5,W
0A86:  BTFSC  0E.7
0A88:  BSF    FF2.7
0A8A:  RETURN 0
0A8C:  DATA 41,42
0A8E:  DATA 52,49
0A90:  DATA 4C,25
0A92:  DATA 66,25
0A94:  DATA 66,0D
0A96:  DATA 00,00
0A98:  MOVFF  FF2,0E
0A9C:  BCF    FF2.7
0A9E:  CLRF   FF7
0AA0:  ADDLW  B2
0AA2:  MOVWF  FF6
0AA4:  MOVLW  0A
0AA6:  ADDWFC FF7,F
0AA8:  TBLRD*+
0AAA:  MOVF   FF5,W
0AAC:  BTFSC  0E.7
0AAE:  BSF    FF2.7
0AB0:  RETURN 0
0AB2:  DATA 4D,41
0AB4:  DATA 59,4F
0AB6:  DATA 25,66
0AB8:  DATA 25,66
0ABA:  DATA 0D,00
0ABC:  MOVFF  FF2,0E
0AC0:  BCF    FF2.7
0AC2:  CLRF   FF7
0AC4:  ADDLW  D6
0AC6:  MOVWF  FF6
0AC8:  MOVLW  0A
0ACA:  ADDWFC FF7,F
0ACC:  TBLRD*+
0ACE:  MOVF   FF5,W
0AD0:  BTFSC  0E.7
0AD2:  BSF    FF2.7
0AD4:  RETURN 0
0AD6:  DATA 4A,55
0AD8:  DATA 4E,49
0ADA:  DATA 4F,25
0ADC:  DATA 66,25
0ADE:  DATA 66,0D
0AE0:  DATA 00,00
0AE2:  MOVFF  FF2,0E
0AE6:  BCF    FF2.7
0AE8:  CLRF   FF7
0AEA:  ADDLW  FC
0AEC:  MOVWF  FF6
0AEE:  MOVLW  0A
0AF0:  ADDWFC FF7,F
0AF2:  TBLRD*+
0AF4:  MOVF   FF5,W
0AF6:  BTFSC  0E.7
0AF8:  BSF    FF2.7
0AFA:  RETURN 0
0AFC:  DATA 4A,55
0AFE:  DATA 4C,49
0B00:  DATA 4F,25
0B02:  DATA 66,25
0B04:  DATA 66,0D
0B06:  DATA 00,00
0B08:  MOVFF  FF2,0E
0B0C:  BCF    FF2.7
0B0E:  CLRF   FF7
0B10:  ADDLW  22
0B12:  MOVWF  FF6
0B14:  MOVLW  0B
0B16:  ADDWFC FF7,F
0B18:  TBLRD*+
0B1A:  MOVF   FF5,W
0B1C:  BTFSC  0E.7
0B1E:  BSF    FF2.7
0B20:  RETURN 0
0B22:  DATA 41,47
0B24:  DATA 4F,53
0B26:  DATA 54,4F
0B28:  DATA 25,66
0B2A:  DATA 25,66
0B2C:  DATA 0D,00
0B2E:  MOVFF  FF2,0E
0B32:  BCF    FF2.7
0B34:  CLRF   FF7
0B36:  ADDLW  48
0B38:  MOVWF  FF6
0B3A:  MOVLW  0B
0B3C:  ADDWFC FF7,F
0B3E:  TBLRD*+
0B40:  MOVF   FF5,W
0B42:  BTFSC  0E.7
0B44:  BSF    FF2.7
0B46:  RETURN 0
0B48:  DATA 53,45
0B4A:  DATA 50,54
0B4C:  DATA 49,45
0B4E:  DATA 4D,42
0B50:  DATA 52,45
0B52:  DATA 25,66
0B54:  DATA 25,66
0B56:  DATA 0D,00
0B58:  MOVFF  FF2,0E
0B5C:  BCF    FF2.7
0B5E:  CLRF   FF7
0B60:  ADDLW  72
0B62:  MOVWF  FF6
0B64:  MOVLW  0B
0B66:  ADDWFC FF7,F
0B68:  TBLRD*+
0B6A:  MOVF   FF5,W
0B6C:  BTFSC  0E.7
0B6E:  BSF    FF2.7
0B70:  RETURN 0
0B72:  DATA 4F,43
0B74:  DATA 54,55
0B76:  DATA 42,52
0B78:  DATA 45,25
0B7A:  DATA 66,25
0B7C:  DATA 66,0D
0B7E:  DATA 00,00
0B80:  MOVFF  FF2,0E
0B84:  BCF    FF2.7
0B86:  CLRF   FF7
0B88:  ADDLW  9A
0B8A:  MOVWF  FF6
0B8C:  MOVLW  0B
0B8E:  ADDWFC FF7,F
0B90:  TBLRD*+
0B92:  MOVF   FF5,W
0B94:  BTFSC  0E.7
0B96:  BSF    FF2.7
0B98:  RETURN 0
0B9A:  DATA 4E,4F
0B9C:  DATA 56,49
0B9E:  DATA 45,4D
0BA0:  DATA 42,52
0BA2:  DATA 45,25
0BA4:  DATA 66,25
0BA6:  DATA 66,0D
0BA8:  DATA 00,00
0BAA:  MOVFF  FF2,0E
0BAE:  BCF    FF2.7
0BB0:  CLRF   FF7
0BB2:  ADDLW  C4
0BB4:  MOVWF  FF6
0BB6:  MOVLW  0B
0BB8:  ADDWFC FF7,F
0BBA:  TBLRD*+
0BBC:  MOVF   FF5,W
0BBE:  BTFSC  0E.7
0BC0:  BSF    FF2.7
0BC2:  RETURN 0
0BC4:  DATA 44,49
0BC6:  DATA 43,49
0BC8:  DATA 45,4D
0BCA:  DATA 42,52
0BCC:  DATA 45,25
0BCE:  DATA 66,25
0BD0:  DATA 66,0D
0BD2:  DATA 00,00
*
0F38:  MOVLW  8E
0F3A:  MOVWF  00
0F3C:  MOVFF  299,01
0F40:  MOVFF  298,02
0F44:  CLRF   03
0F46:  MOVF   01,F
0F48:  BNZ   0F5C
0F4A:  MOVFF  02,01
0F4E:  CLRF   02
0F50:  MOVLW  08
0F52:  SUBWF  00,F
0F54:  MOVF   01,F
0F56:  BNZ   0F5C
0F58:  CLRF   00
0F5A:  BRA    0F6C
0F5C:  BCF    FD8.0
0F5E:  BTFSC  01.7
0F60:  BRA    0F6A
0F62:  RLCF   02,F
0F64:  RLCF   01,F
0F66:  DECF   00,F
0F68:  BRA    0F5C
0F6A:  BCF    01.7
0F6C:  NOP   
0F6E:  RETLW  00
*
1510:  MOVLW  8E
1512:  MOVWF  00
1514:  MOVFF  9B,01
1518:  MOVFF  9A,02
151C:  CLRF   03
151E:  BTFSS  x9B.7
1520:  BRA    152C
1522:  COMF   01,F
1524:  COMF   02,F
1526:  INCF   02,F
1528:  BNZ   152C
152A:  INCF   01,F
152C:  MOVF   01,F
152E:  BNZ   1542
1530:  MOVFF  02,01
1534:  CLRF   02
1536:  MOVLW  08
1538:  SUBWF  00,F
153A:  MOVF   01,F
153C:  BNZ   1542
153E:  CLRF   00
1540:  BRA    1556
1542:  BCF    FD8.0
1544:  BTFSC  01.7
1546:  BRA    1550
1548:  RLCF   02,F
154A:  RLCF   01,F
154C:  DECF   00,F
154E:  BRA    1542
1550:  BTFSC  x9B.7
1552:  BRA    1556
1554:  BCF    01.7
1556:  NOP   
1558:  GOTO   1704 (RETURN)
155C:  MOVLB  2
155E:  MOVF   x98,W
1560:  BTFSC  FD8.2
1562:  BRA    16AE
1564:  MOVWF  xA4
1566:  MOVF   x9C,W
1568:  BTFSC  FD8.2
156A:  BRA    16AE
156C:  SUBWF  xA4,F
156E:  BNC   157A
1570:  MOVLW  7F
1572:  ADDWF  xA4,F
1574:  BTFSC  FD8.0
1576:  BRA    16AE
1578:  BRA    1586
157A:  MOVLW  81
157C:  SUBWF  xA4,F
157E:  BTFSS  FD8.0
1580:  BRA    16AE
1582:  BTFSC  FD8.2
1584:  BRA    16AE
1586:  MOVFF  2A4,00
158A:  CLRF   01
158C:  CLRF   02
158E:  CLRF   03
1590:  CLRF   xA3
1592:  MOVFF  299,2A2
1596:  BSF    xA2.7
1598:  MOVFF  29A,2A1
159C:  MOVFF  29B,2A0
15A0:  MOVLW  19
15A2:  MOVWF  xA4
15A4:  MOVF   x9F,W
15A6:  SUBWF  xA0,F
15A8:  BC    15C4
15AA:  MOVLW  01
15AC:  SUBWF  xA1,F
15AE:  BC    15C4
15B0:  SUBWF  xA2,F
15B2:  BC    15C4
15B4:  SUBWF  xA3,F
15B6:  BC    15C4
15B8:  INCF   xA3,F
15BA:  INCF   xA2,F
15BC:  INCF   xA1,F
15BE:  MOVF   x9F,W
15C0:  ADDWF  xA0,F
15C2:  BRA    1614
15C4:  MOVF   x9E,W
15C6:  SUBWF  xA1,F
15C8:  BC    15EE
15CA:  MOVLW  01
15CC:  SUBWF  xA2,F
15CE:  BC    15EE
15D0:  SUBWF  xA3,F
15D2:  BC    15EE
15D4:  INCF   xA3,F
15D6:  INCF   xA2,F
15D8:  MOVF   x9E,W
15DA:  ADDWF  xA1,F
15DC:  MOVF   x9F,W
15DE:  ADDWF  xA0,F
15E0:  BNC   1614
15E2:  INCF   xA1,F
15E4:  BNZ   1614
15E6:  INCF   xA2,F
15E8:  BNZ   1614
15EA:  INCF   xA3,F
15EC:  BRA    1614
15EE:  MOVF   x9D,W
15F0:  IORLW  80
15F2:  SUBWF  xA2,F
15F4:  BC    1612
15F6:  MOVLW  01
15F8:  SUBWF  xA3,F
15FA:  BC    1612
15FC:  INCF   xA3,F
15FE:  MOVF   x9D,W
1600:  IORLW  80
1602:  ADDWF  xA2,F
1604:  MOVF   x9E,W
1606:  ADDWF  xA1,F
1608:  BNC   15DC
160A:  INCF   xA2,F
160C:  BNZ   15DC
160E:  INCF   xA3,F
1610:  BRA    15DC
1612:  BSF    03.0
1614:  DECFSZ xA4,F
1616:  BRA    161A
1618:  BRA    1630
161A:  BCF    FD8.0
161C:  RLCF   xA0,F
161E:  RLCF   xA1,F
1620:  RLCF   xA2,F
1622:  RLCF   xA3,F
1624:  BCF    FD8.0
1626:  RLCF   03,F
1628:  RLCF   02,F
162A:  RLCF   01,F
162C:  RLCF   xA5,F
162E:  BRA    15A4
1630:  BTFSS  xA5.0
1632:  BRA    1640
1634:  BCF    FD8.0
1636:  RRCF   01,F
1638:  RRCF   02,F
163A:  RRCF   03,F
163C:  RRCF   xA5,F
163E:  BRA    1644
1640:  DECF   00,F
1642:  BZ    16AE
1644:  BTFSC  xA5.7
1646:  BRA    1684
1648:  BCF    FD8.0
164A:  RLCF   xA0,F
164C:  RLCF   xA1,F
164E:  RLCF   xA2,F
1650:  RLCF   xA3,F
1652:  MOVF   x9F,W
1654:  SUBWF  xA0,F
1656:  BC    1666
1658:  MOVLW  01
165A:  SUBWF  xA1,F
165C:  BC    1666
165E:  SUBWF  xA2,F
1660:  BC    1666
1662:  SUBWF  xA3,F
1664:  BNC   169A
1666:  MOVF   x9E,W
1668:  SUBWF  xA1,F
166A:  BC    1676
166C:  MOVLW  01
166E:  SUBWF  xA2,F
1670:  BC    1676
1672:  SUBWF  xA3,F
1674:  BNC   169A
1676:  MOVF   x9D,W
1678:  IORLW  80
167A:  SUBWF  xA2,F
167C:  BC    1684
167E:  MOVLW  01
1680:  SUBWF  xA3,F
1682:  BNC   169A
1684:  INCF   03,F
1686:  BNZ   169A
1688:  INCF   02,F
168A:  BNZ   169A
168C:  INCF   01,F
168E:  BNZ   169A
1690:  INCF   00,F
1692:  BZ    16AE
1694:  RRCF   01,F
1696:  RRCF   02,F
1698:  RRCF   03,F
169A:  MOVFF  299,2A4
169E:  MOVF   x9D,W
16A0:  XORWF  xA4,F
16A2:  BTFSS  xA4.7
16A4:  BRA    16AA
16A6:  BSF    01.7
16A8:  BRA    16B6
16AA:  BCF    01.7
16AC:  BRA    16B6
16AE:  CLRF   00
16B0:  CLRF   01
16B2:  CLRF   02
16B4:  CLRF   03
16B6:  NOP   
16B8:  MOVLB  0
16BA:  RETLW  00
*
1762:  MOVFF  8A,91
1766:  MOVF   x8E,W
1768:  XORWF  x91,F
176A:  BTFSS  x91.7
176C:  BRA    1778
176E:  BCF    FD8.2
1770:  BCF    FD8.0
1772:  BTFSC  x8A.7
1774:  BSF    FD8.0
1776:  BRA    17D6
1778:  MOVFF  8A,91
177C:  MOVFF  8D,92
1780:  MOVF   x89,W
1782:  SUBWF  x92,F
1784:  BZ    1792
1786:  BTFSS  x91.7
1788:  BRA    17D6
178A:  MOVF   FD8,W
178C:  XORLW  01
178E:  MOVWF  FD8
1790:  BRA    17D6
1792:  MOVFF  8E,92
1796:  MOVF   x8A,W
1798:  SUBWF  x92,F
179A:  BZ    17A8
179C:  BTFSS  x91.7
179E:  BRA    17D6
17A0:  MOVF   FD8,W
17A2:  XORLW  01
17A4:  MOVWF  FD8
17A6:  BRA    17D6
17A8:  MOVFF  8F,92
17AC:  MOVF   x8B,W
17AE:  SUBWF  x92,F
17B0:  BZ    17BE
17B2:  BTFSS  x91.7
17B4:  BRA    17D6
17B6:  MOVF   FD8,W
17B8:  XORLW  01
17BA:  MOVWF  FD8
17BC:  BRA    17D6
17BE:  MOVFF  90,92
17C2:  MOVF   x8C,W
17C4:  SUBWF  x92,F
17C6:  BZ    17D4
17C8:  BTFSS  x91.7
17CA:  BRA    17D6
17CC:  MOVF   FD8,W
17CE:  XORLW  01
17D0:  MOVWF  FD8
17D2:  BRA    17D6
17D4:  BCF    FD8.0
17D6:  RETLW  00
17D8:  MOVLW  80
17DA:  BTFSS  FD8.1
17DC:  BRA    17E2
17DE:  MOVLB  2
17E0:  XORWF  x97,F
17E2:  MOVLB  2
17E4:  CLRF   x9C
17E6:  CLRF   x9D
17E8:  MOVFF  293,29B
17EC:  MOVF   x97,W
17EE:  XORWF  x9B,F
17F0:  MOVF   x92,W
17F2:  BTFSC  FD8.2
17F4:  BRA    19B4
17F6:  MOVWF  x9A
17F8:  MOVWF  00
17FA:  MOVF   x96,W
17FC:  BTFSC  FD8.2
17FE:  BRA    19C6
1800:  SUBWF  x9A,F
1802:  BTFSC  FD8.2
1804:  BRA    190C
1806:  BNC   1884
1808:  MOVFF  297,2A0
180C:  BSF    xA0.7
180E:  MOVFF  298,29F
1812:  MOVFF  299,29E
1816:  CLRF   x9D
1818:  BCF    FD8.0
181A:  RRCF   xA0,F
181C:  RRCF   x9F,F
181E:  RRCF   x9E,F
1820:  RRCF   x9D,F
1822:  DECFSZ x9A,F
1824:  BRA    1816
1826:  BTFSS  x9B.7
1828:  BRA    1830
182A:  BSF    x9C.0
182C:  BRA    19EE
182E:  BCF    x9C.0
1830:  BCF    x9A.0
1832:  BSF    x9C.4
1834:  MOVLW  02
1836:  MOVWF  FEA
1838:  MOVLW  95
183A:  MOVWF  FE9
183C:  BRA    1A14
183E:  BCF    x9C.4
1840:  BTFSC  x9B.7
1842:  BRA    1858
1844:  BTFSS  x9A.0
1846:  BRA    186E
1848:  RRCF   xA0,F
184A:  RRCF   x9F,F
184C:  RRCF   x9E,F
184E:  RRCF   x9D,F
1850:  INCF   00,F
1852:  BTFSC  FD8.2
1854:  BRA    19E4
1856:  BRA    186E
1858:  BTFSC  xA0.7
185A:  BRA    1874
185C:  BCF    FD8.0
185E:  RLCF   x9D,F
1860:  RLCF   x9E,F
1862:  RLCF   x9F,F
1864:  RLCF   xA0,F
1866:  DECF   00,F
1868:  BTFSC  FD8.2
186A:  BRA    19E4
186C:  BRA    1858
186E:  BSF    x9C.6
1870:  BRA    194C
1872:  BCF    x9C.6
1874:  MOVFF  293,29B
1878:  BTFSS  x93.7
187A:  BRA    1880
187C:  BSF    xA0.7
187E:  BRA    19D6
1880:  BCF    xA0.7
1882:  BRA    19D6
1884:  MOVFF  296,29A
1888:  MOVFF  296,00
188C:  MOVF   x92,W
188E:  SUBWF  x9A,F
1890:  MOVFF  293,2A0
1894:  BSF    xA0.7
1896:  MOVFF  294,29F
189A:  MOVFF  295,29E
189E:  CLRF   x9D
18A0:  BCF    FD8.0
18A2:  RRCF   xA0,F
18A4:  RRCF   x9F,F
18A6:  RRCF   x9E,F
18A8:  RRCF   x9D,F
18AA:  DECFSZ x9A,F
18AC:  BRA    189E
18AE:  BTFSS  x9B.7
18B0:  BRA    18B8
18B2:  BSF    x9C.1
18B4:  BRA    19EE
18B6:  BCF    x9C.1
18B8:  BCF    x9A.0
18BA:  BSF    x9C.5
18BC:  MOVLW  02
18BE:  MOVWF  FEA
18C0:  MOVLW  99
18C2:  MOVWF  FE9
18C4:  BRA    1A14
18C6:  BCF    x9C.5
18C8:  BTFSC  x9B.7
18CA:  BRA    18E0
18CC:  BTFSS  x9A.0
18CE:  BRA    18F6
18D0:  RRCF   xA0,F
18D2:  RRCF   x9F,F
18D4:  RRCF   x9E,F
18D6:  RRCF   x9D,F
18D8:  INCF   00,F
18DA:  BTFSC  FD8.2
18DC:  BRA    19E4
18DE:  BRA    18F6
18E0:  BTFSC  xA0.7
18E2:  BRA    18FC
18E4:  BCF    FD8.0
18E6:  RLCF   x9D,F
18E8:  RLCF   x9E,F
18EA:  RLCF   x9F,F
18EC:  RLCF   xA0,F
18EE:  DECF   00,F
18F0:  BTFSC  FD8.2
18F2:  BRA    19E4
18F4:  BRA    18E0
18F6:  BSF    x9C.7
18F8:  BRA    194C
18FA:  BCF    x9C.7
18FC:  MOVFF  297,29B
1900:  BTFSS  x97.7
1902:  BRA    1908
1904:  BSF    xA0.7
1906:  BRA    19D6
1908:  BCF    xA0.7
190A:  BRA    19D6
190C:  MOVFF  297,2A0
1910:  BSF    xA0.7
1912:  MOVFF  298,29F
1916:  MOVFF  299,29E
191A:  BTFSS  x9B.7
191C:  BRA    1926
191E:  BCF    xA0.7
1920:  BSF    x9C.2
1922:  BRA    19EE
1924:  BCF    x9C.2
1926:  CLRF   x9D
1928:  BCF    x9A.0
192A:  MOVLW  02
192C:  MOVWF  FEA
192E:  MOVLW  95
1930:  MOVWF  FE9
1932:  BRA    1A14
1934:  BTFSC  x9B.7
1936:  BRA    1970
1938:  MOVFF  293,29B
193C:  BTFSS  x9A.0
193E:  BRA    194C
1940:  RRCF   xA0,F
1942:  RRCF   x9F,F
1944:  RRCF   x9E,F
1946:  RRCF   x9D,F
1948:  INCF   00,F
194A:  BZ    19E4
194C:  BTFSS  x9D.7
194E:  BRA    1966
1950:  INCF   x9E,F
1952:  BNZ   1966
1954:  INCF   x9F,F
1956:  BNZ   1966
1958:  INCF   xA0,F
195A:  BNZ   1966
195C:  RRCF   xA0,F
195E:  RRCF   x9F,F
1960:  RRCF   x9E,F
1962:  INCF   00,F
1964:  BZ    19E4
1966:  BTFSC  x9C.6
1968:  BRA    1872
196A:  BTFSC  x9C.7
196C:  BRA    18FA
196E:  BRA    19A8
1970:  MOVLW  80
1972:  XORWF  xA0,F
1974:  BTFSS  xA0.7
1976:  BRA    1980
1978:  BRA    19EE
197A:  MOVFF  297,29B
197E:  BRA    1994
1980:  MOVFF  293,29B
1984:  MOVF   xA0,F
1986:  BNZ   1994
1988:  MOVF   x9F,F
198A:  BNZ   1994
198C:  MOVF   x9E,F
198E:  BNZ   1994
1990:  CLRF   00
1992:  BRA    19D6
1994:  BTFSC  xA0.7
1996:  BRA    19A8
1998:  BCF    FD8.0
199A:  RLCF   x9D,F
199C:  RLCF   x9E,F
199E:  RLCF   x9F,F
19A0:  RLCF   xA0,F
19A2:  DECFSZ 00,F
19A4:  BRA    1994
19A6:  BRA    19E4
19A8:  BTFSS  x9B.7
19AA:  BRA    19B0
19AC:  BSF    xA0.7
19AE:  BRA    19D6
19B0:  BCF    xA0.7
19B2:  BRA    19D6
19B4:  MOVFF  296,00
19B8:  MOVFF  297,2A0
19BC:  MOVFF  298,29F
19C0:  MOVFF  299,29E
19C4:  BRA    19D6
19C6:  MOVFF  292,00
19CA:  MOVFF  293,2A0
19CE:  MOVFF  294,29F
19D2:  MOVFF  295,29E
19D6:  MOVFF  2A0,01
19DA:  MOVFF  29F,02
19DE:  MOVFF  29E,03
19E2:  BRA    1A4C
19E4:  CLRF   00
19E6:  CLRF   01
19E8:  CLRF   02
19EA:  CLRF   03
19EC:  BRA    1A4C
19EE:  CLRF   x9D
19F0:  COMF   x9E,F
19F2:  COMF   x9F,F
19F4:  COMF   xA0,F
19F6:  COMF   x9D,F
19F8:  INCF   x9D,F
19FA:  BNZ   1A06
19FC:  INCF   x9E,F
19FE:  BNZ   1A06
1A00:  INCF   x9F,F
1A02:  BNZ   1A06
1A04:  INCF   xA0,F
1A06:  BTFSC  x9C.0
1A08:  BRA    182E
1A0A:  BTFSC  x9C.1
1A0C:  BRA    18B6
1A0E:  BTFSC  x9C.2
1A10:  BRA    1924
1A12:  BRA    197A
1A14:  MOVF   FEF,W
1A16:  ADDWF  x9E,F
1A18:  BNC   1A24
1A1A:  INCF   x9F,F
1A1C:  BNZ   1A24
1A1E:  INCF   xA0,F
1A20:  BTFSC  FD8.2
1A22:  BSF    x9A.0
1A24:  MOVF   FED,F
1A26:  MOVF   FEF,W
1A28:  ADDWF  x9F,F
1A2A:  BNC   1A32
1A2C:  INCF   xA0,F
1A2E:  BTFSC  FD8.2
1A30:  BSF    x9A.0
1A32:  MOVF   FED,F
1A34:  MOVF   FEF,W
1A36:  BTFSC  FEF.7
1A38:  BRA    1A3C
1A3A:  XORLW  80
1A3C:  ADDWF  xA0,F
1A3E:  BTFSC  FD8.0
1A40:  BSF    x9A.0
1A42:  BTFSC  x9C.4
1A44:  BRA    183E
1A46:  BTFSC  x9C.5
1A48:  BRA    18C6
1A4A:  BRA    1934
1A4C:  NOP   
1A4E:  MOVLB  0
1A50:  RETLW  00
*
1A7C:  MOVF   xA2,W
1A7E:  MULWF  xA4
1A80:  MOVFF  FF3,01
1A84:  MOVFF  FF4,00
1A88:  MULWF  xA5
1A8A:  MOVF   FF3,W
1A8C:  ADDWF  00,F
1A8E:  MOVF   xA3,W
1A90:  MULWF  xA4
1A92:  MOVF   FF3,W
1A94:  ADDWFC 00,W
1A96:  MOVWF  02
1A98:  RETLW  00
*
1B88:  MOVLW  8E
1B8A:  MOVWF  00
1B8C:  MOVF   x95,W
1B8E:  SUBWF  00,F
1B90:  MOVFF  96,02
1B94:  MOVFF  97,01
1B98:  BSF    02.7
1B9A:  MOVF   00,F
1B9C:  BZ    1BB0
1B9E:  BCF    FD8.0
1BA0:  MOVF   02,F
1BA2:  BNZ   1BA8
1BA4:  MOVF   01,F
1BA6:  BZ    1BB0
1BA8:  RRCF   02,F
1BAA:  RRCF   01,F
1BAC:  DECFSZ 00,F
1BAE:  BRA    1B9E
1BB0:  BTFSS  x96.7
1BB2:  BRA    1BBE
1BB4:  COMF   01,F
1BB6:  COMF   02,F
1BB8:  INCF   01,F
1BBA:  BTFSC  FD8.2
1BBC:  INCF   02,F
1BBE:  NOP   
1BC0:  RETLW  00
1BC2:  MOVLB  2
1BC4:  MOVF   xAE,W
1BC6:  BTFSC  FD8.2
1BC8:  BRA    1CAC
1BCA:  MOVWF  00
1BCC:  MOVF   xB2,W
1BCE:  BTFSC  FD8.2
1BD0:  BRA    1CAC
1BD2:  ADDWF  00,F
1BD4:  BNC   1BDE
1BD6:  MOVLW  81
1BD8:  ADDWF  00,F
1BDA:  BC    1CAC
1BDC:  BRA    1BE6
1BDE:  MOVLW  7F
1BE0:  SUBWF  00,F
1BE2:  BNC   1CAC
1BE4:  BZ    1CAC
1BE6:  MOVFF  2AF,2B6
1BEA:  MOVF   xB3,W
1BEC:  XORWF  xB6,F
1BEE:  BSF    xAF.7
1BF0:  BSF    xB3.7
1BF2:  MOVF   xB1,W
1BF4:  MULWF  xB5
1BF6:  MOVFF  FF4,2B8
1BFA:  MOVF   xB0,W
1BFC:  MULWF  xB4
1BFE:  MOVFF  FF4,03
1C02:  MOVFF  FF3,2B7
1C06:  MULWF  xB5
1C08:  MOVF   FF3,W
1C0A:  ADDWF  xB8,F
1C0C:  MOVF   FF4,W
1C0E:  ADDWFC xB7,F
1C10:  MOVLW  00
1C12:  ADDWFC 03,F
1C14:  MOVF   xB1,W
1C16:  MULWF  xB4
1C18:  MOVF   FF3,W
1C1A:  ADDWF  xB8,F
1C1C:  MOVF   FF4,W
1C1E:  ADDWFC xB7,F
1C20:  MOVLW  00
1C22:  CLRF   02
1C24:  ADDWFC 03,F
1C26:  ADDWFC 02,F
1C28:  MOVF   xAF,W
1C2A:  MULWF  xB5
1C2C:  MOVF   FF3,W
1C2E:  ADDWF  xB7,F
1C30:  MOVF   FF4,W
1C32:  ADDWFC 03,F
1C34:  MOVLW  00
1C36:  ADDWFC 02,F
1C38:  MOVF   xAF,W
1C3A:  MULWF  xB4
1C3C:  MOVF   FF3,W
1C3E:  ADDWF  03,F
1C40:  MOVF   FF4,W
1C42:  ADDWFC 02,F
1C44:  MOVLW  00
1C46:  CLRF   01
1C48:  ADDWFC 01,F
1C4A:  MOVF   xB1,W
1C4C:  MULWF  xB3
1C4E:  MOVF   FF3,W
1C50:  ADDWF  xB7,F
1C52:  MOVF   FF4,W
1C54:  ADDWFC 03,F
1C56:  MOVLW  00
1C58:  ADDWFC 02,F
1C5A:  ADDWFC 01,F
1C5C:  MOVF   xB0,W
1C5E:  MULWF  xB3
1C60:  MOVF   FF3,W
1C62:  ADDWF  03,F
1C64:  MOVF   FF4,W
1C66:  ADDWFC 02,F
1C68:  MOVLW  00
1C6A:  ADDWFC 01,F
1C6C:  MOVF   xAF,W
1C6E:  MULWF  xB3
1C70:  MOVF   FF3,W
1C72:  ADDWF  02,F
1C74:  MOVF   FF4,W
1C76:  ADDWFC 01,F
1C78:  INCF   00,F
1C7A:  BTFSC  01.7
1C7C:  BRA    1C88
1C7E:  RLCF   xB7,F
1C80:  RLCF   03,F
1C82:  RLCF   02,F
1C84:  RLCF   01,F
1C86:  DECF   00,F
1C88:  MOVLW  00
1C8A:  BTFSS  xB7.7
1C8C:  BRA    1CA2
1C8E:  INCF   03,F
1C90:  ADDWFC 02,F
1C92:  ADDWFC 01,F
1C94:  MOVF   01,W
1C96:  BNZ   1CA2
1C98:  MOVF   02,W
1C9A:  BNZ   1CA2
1C9C:  MOVF   03,W
1C9E:  BNZ   1CA2
1CA0:  INCF   00,F
1CA2:  BTFSC  xB6.7
1CA4:  BSF    01.7
1CA6:  BTFSS  xB6.7
1CA8:  BCF    01.7
1CAA:  BRA    1CB4
1CAC:  CLRF   00
1CAE:  CLRF   01
1CB0:  CLRF   02
1CB2:  CLRF   03
1CB4:  NOP   
1CB6:  MOVLB  0
1CB8:  RETLW  00
*
1E0E:  CLRF   01
1E10:  CLRF   02
1E12:  CLRF   00
1E14:  CLRF   03
1E16:  MOVF   x94,W
1E18:  BNZ   1E1E
1E1A:  MOVF   x93,W
1E1C:  BZ    1E4E
1E1E:  MOVLW  10
1E20:  MOVWF  x95
1E22:  BCF    FD8.0
1E24:  RLCF   x91,F
1E26:  RLCF   x92,F
1E28:  RLCF   00,F
1E2A:  RLCF   03,F
1E2C:  MOVF   x94,W
1E2E:  SUBWF  03,W
1E30:  BNZ   1E36
1E32:  MOVF   x93,W
1E34:  SUBWF  00,W
1E36:  BNC   1E46
1E38:  MOVF   x93,W
1E3A:  SUBWF  00,F
1E3C:  BTFSS  FD8.0
1E3E:  DECF   03,F
1E40:  MOVF   x94,W
1E42:  SUBWF  03,F
1E44:  BSF    FD8.0
1E46:  RLCF   01,F
1E48:  RLCF   02,F
1E4A:  DECFSZ x95,F
1E4C:  BRA    1E22
1E4E:  NOP   
1E50:  GOTO   2038 (RETURN)
*
223A:  MOVLB  2
223C:  MOVF   xAE,W
223E:  SUBLW  B6
2240:  MOVWF  xAE
2242:  CLRF   03
2244:  MOVFF  2AF,2B2
2248:  BSF    xAF.7
224A:  BCF    FD8.0
224C:  RRCF   xAF,F
224E:  RRCF   xB0,F
2250:  RRCF   xB1,F
2252:  RRCF   03,F
2254:  RRCF   02,F
2256:  RRCF   01,F
2258:  RRCF   00,F
225A:  DECFSZ xAE,F
225C:  BRA    224A
225E:  BTFSS  xB2.7
2260:  BRA    2278
2262:  COMF   00,F
2264:  COMF   01,F
2266:  COMF   02,F
2268:  COMF   03,F
226A:  INCF   00,F
226C:  BTFSC  FD8.2
226E:  INCF   01,F
2270:  BTFSC  FD8.2
2272:  INCF   02,F
2274:  BTFSC  FD8.2
2276:  INCF   03,F
2278:  MOVLB  0
227A:  RETLW  00
227C:  CLRF   00
227E:  CLRF   01
2280:  CLRF   02
2282:  CLRF   03
2284:  MOVLB  2
2286:  CLRF   xB6
2288:  CLRF   xB7
228A:  CLRF   xB8
228C:  CLRF   xB9
228E:  MOVF   xB5,W
2290:  IORWF  xB4,W
2292:  IORWF  xB3,W
2294:  IORWF  xB2,W
2296:  BZ    22F0
2298:  MOVLW  20
229A:  MOVWF  xBA
229C:  BCF    FD8.0
229E:  RLCF   xAE,F
22A0:  RLCF   xAF,F
22A2:  RLCF   xB0,F
22A4:  RLCF   xB1,F
22A6:  RLCF   xB6,F
22A8:  RLCF   xB7,F
22AA:  RLCF   xB8,F
22AC:  RLCF   xB9,F
22AE:  MOVF   xB5,W
22B0:  SUBWF  xB9,W
22B2:  BNZ   22C4
22B4:  MOVF   xB4,W
22B6:  SUBWF  xB8,W
22B8:  BNZ   22C4
22BA:  MOVF   xB3,W
22BC:  SUBWF  xB7,W
22BE:  BNZ   22C4
22C0:  MOVF   xB2,W
22C2:  SUBWF  xB6,W
22C4:  BNC   22E4
22C6:  MOVF   xB2,W
22C8:  SUBWF  xB6,F
22CA:  MOVF   xB3,W
22CC:  BTFSS  FD8.0
22CE:  INCFSZ xB3,W
22D0:  SUBWF  xB7,F
22D2:  MOVF   xB4,W
22D4:  BTFSS  FD8.0
22D6:  INCFSZ xB4,W
22D8:  SUBWF  xB8,F
22DA:  MOVF   xB5,W
22DC:  BTFSS  FD8.0
22DE:  INCFSZ xB5,W
22E0:  SUBWF  xB9,F
22E2:  BSF    FD8.0
22E4:  RLCF   00,F
22E6:  RLCF   01,F
22E8:  RLCF   02,F
22EA:  RLCF   03,F
22EC:  DECFSZ xBA,F
22EE:  BRA    229C
22F0:  NOP   
22F2:  MOVLW  02
22F4:  MOVWF  FEA
22F6:  MOVLW  B6
22F8:  MOVWF  FE9
22FA:  MOVLB  0
22FC:  RETLW  00
22FE:  MOVF   FE9,W
2300:  MOVWF  x8B
2302:  MOVF   x8A,W
2304:  MOVWF  x8D
2306:  BZ    233E
2308:  MOVFF  89,2B1
230C:  MOVFF  88,2B0
2310:  MOVFF  87,2AF
2314:  MOVFF  86,2AE
2318:  MOVLB  2
231A:  CLRF   xB5
231C:  CLRF   xB4
231E:  MOVLW  20
2320:  MOVWF  xB3
2322:  MOVLW  82
2324:  MOVWF  xB2
2326:  MOVLB  0
2328:  RCALL  1BC2
232A:  MOVFF  03,89
232E:  MOVFF  02,88
2332:  MOVFF  01,87
2336:  MOVFF  00,86
233A:  DECFSZ x8D,F
233C:  BRA    2308
233E:  MOVFF  89,2B1
2342:  MOVFF  88,2B0
2346:  MOVFF  87,2AF
234A:  MOVFF  86,2AE
234E:  RCALL  223A
2350:  MOVFF  03,89
2354:  MOVFF  02,88
2358:  MOVFF  01,87
235C:  MOVFF  00,86
2360:  BTFSS  x89.7
2362:  BRA    237E
2364:  DECF   x8B,F
2366:  BSF    x8B.5
2368:  COMF   x86,F
236A:  COMF   x87,F
236C:  COMF   x88,F
236E:  COMF   x89,F
2370:  INCF   x86,F
2372:  BTFSC  FD8.2
2374:  INCF   x87,F
2376:  BTFSC  FD8.2
2378:  INCF   x88,F
237A:  BTFSC  FD8.2
237C:  INCF   x89,F
237E:  MOVLW  3B
2380:  MOVWF  x92
2382:  MOVLW  9A
2384:  MOVWF  x91
2386:  MOVLW  CA
2388:  MOVWF  x90
238A:  CLRF   x8F
238C:  MOVLW  0A
238E:  MOVWF  x8D
2390:  MOVF   x8A,W
2392:  BTFSC  FD8.2
2394:  INCF   x8B,F
2396:  MOVFF  89,2B1
239A:  MOVFF  88,2B0
239E:  MOVFF  87,2AF
23A2:  MOVFF  86,2AE
23A6:  MOVFF  92,2B5
23AA:  MOVFF  91,2B4
23AE:  MOVFF  90,2B3
23B2:  MOVFF  8F,2B2
23B6:  RCALL  227C
23B8:  MOVF   01,W
23BA:  MOVFF  FEF,86
23BE:  MOVFF  FEC,87
23C2:  MOVFF  FEC,88
23C6:  MOVFF  FEC,89
23CA:  MOVF   00,F
23CC:  BNZ   23EC
23CE:  INCF   x8A,W
23D0:  SUBWF  x8D,W
23D2:  BZ    23EC
23D4:  MOVF   x8B,W
23D6:  BZ    23F0
23D8:  ANDLW  0F
23DA:  SUBWF  x8D,W
23DC:  BZ    23E0
23DE:  BC    2462
23E0:  BTFSC  x8B.7
23E2:  BRA    2462
23E4:  BTFSC  x8B.6
23E6:  BRA    23F0
23E8:  MOVLW  20
23EA:  BRA    2458
23EC:  MOVLW  20
23EE:  ANDWF  x8B,F
23F0:  BTFSS  x8B.5
23F2:  BRA    2412
23F4:  BCF    x8B.5
23F6:  MOVF   x8A,W
23F8:  BTFSS  FD8.2
23FA:  DECF   x8B,F
23FC:  MOVF   00,W
23FE:  MOVWF  x8B
2400:  MOVLW  2D
2402:  MOVLB  2
2404:  MOVWF  x93
2406:  MOVLB  0
2408:  CALL   0D34
240C:  MOVF   x8B,W
240E:  MOVWF  00
2410:  CLRF   x8B
2412:  MOVF   x8A,W
2414:  SUBWF  x8D,W
2416:  BNZ   2432
2418:  MOVF   00,W
241A:  MOVWF  x8B
241C:  MOVLW  2E
241E:  MOVLB  2
2420:  MOVWF  x93
2422:  MOVLB  0
2424:  CALL   0D34
2428:  MOVF   x8B,W
242A:  MOVWF  00
242C:  MOVLW  20
242E:  ANDWF  x8B,F
2430:  MOVLW  00
2432:  MOVLW  30
2434:  BTFSS  x8B.5
2436:  BRA    2458
2438:  BCF    x8B.5
243A:  MOVF   x8A,W
243C:  BTFSS  FD8.2
243E:  DECF   x8B,F
2440:  MOVF   00,W
2442:  MOVWF  x8B
2444:  MOVLW  2D
2446:  MOVLB  2
2448:  MOVWF  x93
244A:  MOVLB  0
244C:  CALL   0D34
2450:  MOVF   x8B,W
2452:  MOVWF  00
2454:  CLRF   x8B
2456:  MOVLW  30
2458:  ADDWF  00,F
245A:  MOVFF  00,293
245E:  CALL   0D34
2462:  MOVFF  92,2B1
2466:  MOVFF  91,2B0
246A:  MOVFF  90,2AF
246E:  MOVFF  8F,2AE
2472:  MOVLB  2
2474:  CLRF   xB5
2476:  CLRF   xB4
2478:  CLRF   xB3
247A:  MOVLW  0A
247C:  MOVWF  xB2
247E:  MOVLB  0
2480:  RCALL  227C
2482:  MOVFF  03,92
2486:  MOVFF  02,91
248A:  MOVFF  01,90
248E:  MOVFF  00,8F
2492:  DECFSZ x8D,F
2494:  BRA    2396
2496:  RETLW  00
2498:  CLRF   00
249A:  CLRF   01
249C:  MOVF   x8A,W
249E:  BCF    FD8.0
24A0:  BTFSC  x8B.0
24A2:  ADDWF  00,F
24A4:  RRCF   00,F
24A6:  RRCF   01,F
24A8:  BTFSC  x8B.1
24AA:  ADDWF  00,F
24AC:  RRCF   00,F
24AE:  RRCF   01,F
24B0:  BTFSC  x8B.2
24B2:  ADDWF  00,F
24B4:  RRCF   00,F
24B6:  RRCF   01,F
24B8:  BTFSC  x8B.3
24BA:  ADDWF  00,F
24BC:  RRCF   00,F
24BE:  RRCF   01,F
24C0:  BTFSC  x8B.4
24C2:  ADDWF  00,F
24C4:  RRCF   00,F
24C6:  RRCF   01,F
24C8:  BTFSC  x8B.5
24CA:  ADDWF  00,F
24CC:  RRCF   00,F
24CE:  RRCF   01,F
24D0:  BTFSC  x8B.6
24D2:  ADDWF  00,F
24D4:  RRCF   00,F
24D6:  RRCF   01,F
24D8:  BTFSC  x8B.7
24DA:  ADDWF  00,F
24DC:  RRCF   00,F
24DE:  RRCF   01,F
24E0:  GOTO   25BC (RETURN)
*
26F0:  MOVLB  2
26F2:  MOVF   x96,W
26F4:  CLRF   01
26F6:  SUBWF  x95,W
26F8:  BC    2700
26FA:  MOVFF  295,00
26FE:  BRA    2718
2700:  CLRF   00
2702:  MOVLW  08
2704:  MOVWF  x97
2706:  RLCF   x95,F
2708:  RLCF   00,F
270A:  MOVF   x96,W
270C:  SUBWF  00,W
270E:  BTFSC  FD8.0
2710:  MOVWF  00
2712:  RLCF   01,F
2714:  DECFSZ x97,F
2716:  BRA    2706
2718:  MOVLB  0
271A:  RETLW  00
271C:  MOVLW  20
271E:  BTFSS  x84.4
2720:  MOVLW  30
2722:  MOVWF  x85
2724:  MOVFF  83,00
2728:  BTFSS  x83.7
272A:  BRA    273A
272C:  COMF   00,F
272E:  INCF   00,F
2730:  MOVFF  00,83
2734:  MOVLW  2D
2736:  MOVWF  x85
2738:  BSF    x84.7
273A:  MOVF   01,W
273C:  MOVFF  83,295
2740:  MOVLW  64
2742:  MOVLB  2
2744:  MOVWF  x96
2746:  MOVLB  0
2748:  RCALL  26F0
274A:  MOVFF  00,83
274E:  MOVLW  30
2750:  ADDWF  01,W
2752:  MOVWF  x86
2754:  MOVFF  83,295
2758:  MOVLW  0A
275A:  MOVLB  2
275C:  MOVWF  x96
275E:  MOVLB  0
2760:  RCALL  26F0
2762:  MOVLW  30
2764:  ADDWF  00,W
2766:  MOVWF  x88
2768:  MOVLW  30
276A:  ADDWF  01,W
276C:  MOVWF  x87
276E:  MOVFF  85,00
2772:  BTFSS  x84.3
2774:  BRA    277A
2776:  BTFSS  x84.7
2778:  BCF    x84.2
277A:  BTFSC  x84.4
277C:  BRA    2794
277E:  BTFSS  x84.7
2780:  BRA    27C6
2782:  BTFSC  x84.2
2784:  BRA    27C6
2786:  MOVFF  00,86
278A:  BTFSC  x84.1
278C:  BRA    27C6
278E:  MOVFF  00,87
2792:  BRA    27C6
2794:  MOVLW  30
2796:  SUBWF  x86,W
2798:  BNZ   27C6
279A:  MOVFF  00,86
279E:  MOVLW  20
27A0:  MOVWF  x85
27A2:  BTFSS  x84.3
27A4:  BRA    27AE
27A6:  BCF    x84.2
27A8:  BSF    x84.1
27AA:  BTFSS  x84.7
27AC:  BCF    x84.1
27AE:  MOVLW  30
27B0:  SUBWF  x87,W
27B2:  BNZ   27C6
27B4:  MOVFF  00,87
27B8:  MOVLW  20
27BA:  MOVWF  x86
27BC:  BTFSS  x84.3
27BE:  BRA    27AE
27C0:  BCF    x84.1
27C2:  BTFSS  x84.7
27C4:  BCF    x84.0
27C6:  BTFSS  x84.2
27C8:  BRA    27D2
27CA:  MOVFF  85,293
27CE:  CALL   0D34
27D2:  BTFSS  x84.1
27D4:  BRA    27DE
27D6:  MOVFF  86,293
27DA:  CALL   0D34
27DE:  BTFSS  x84.0
27E0:  BRA    27EA
27E2:  MOVFF  87,293
27E6:  CALL   0D34
27EA:  MOVFF  88,293
27EE:  CALL   0D34
27F2:  RETLW  00
*
29B4:  MOVF   01,W
29B6:  MOVFF  293,295
29BA:  MOVLW  64
29BC:  MOVLB  2
29BE:  MOVWF  x96
29C0:  MOVLB  0
29C2:  RCALL  26F0
29C4:  MOVFF  00,293
29C8:  MOVF   01,W
29CA:  MOVLW  30
29CC:  BNZ   29DE
29CE:  MOVLB  2
29D0:  BTFSS  x94.1
29D2:  BRA    29F0
29D4:  BTFSC  x94.3
29D6:  BRA    29F0
29D8:  BTFSC  x94.4
29DA:  MOVLW  20
29DC:  BRA    29E6
29DE:  MOVLB  2
29E0:  BCF    x94.3
29E2:  BCF    x94.4
29E4:  BSF    x94.0
29E6:  ADDWF  01,F
29E8:  MOVF   01,W
29EA:  BTFSS  F9E.4
29EC:  BRA    29EA
29EE:  MOVWF  FAD
29F0:  MOVFF  293,295
29F4:  MOVLW  0A
29F6:  MOVWF  x96
29F8:  MOVLB  0
29FA:  RCALL  26F0
29FC:  MOVFF  00,293
2A00:  MOVF   01,W
2A02:  MOVLW  30
2A04:  BNZ   2A16
2A06:  MOVLB  2
2A08:  BTFSC  x94.3
2A0A:  BRA    2A22
2A0C:  BTFSS  x94.0
2A0E:  BRA    2A22
2A10:  BTFSC  x94.4
2A12:  MOVLW  20
2A14:  MOVLB  0
2A16:  ADDWF  01,F
2A18:  MOVF   01,W
2A1A:  BTFSS  F9E.4
2A1C:  BRA    2A1A
2A1E:  MOVWF  FAD
2A20:  MOVLB  2
2A22:  MOVLW  30
2A24:  ADDWF  x93,F
2A26:  MOVF   x93,W
2A28:  BTFSS  F9E.4
2A2A:  BRA    2A28
2A2C:  MOVWF  FAD
2A2E:  MOVLB  0
2A30:  RETLW  00
2A32:  MOVF   FE9,W
2A34:  MOVLB  2
2A36:  MOVWF  xA6
2A38:  MOVF   xA5,W
2A3A:  MOVWF  xA8
2A3C:  BZ    2A76
2A3E:  MOVFF  2A4,2B1
2A42:  MOVFF  2A3,2B0
2A46:  MOVFF  2A2,2AF
2A4A:  MOVFF  2A1,2AE
2A4E:  CLRF   xB5
2A50:  CLRF   xB4
2A52:  MOVLW  20
2A54:  MOVWF  xB3
2A56:  MOVLW  82
2A58:  MOVWF  xB2
2A5A:  MOVLB  0
2A5C:  CALL   1BC2
2A60:  MOVFF  03,2A4
2A64:  MOVFF  02,2A3
2A68:  MOVFF  01,2A2
2A6C:  MOVFF  00,2A1
2A70:  MOVLB  2
2A72:  DECFSZ xA8,F
2A74:  BRA    2A3E
2A76:  MOVFF  2A4,2B1
2A7A:  MOVFF  2A3,2B0
2A7E:  MOVFF  2A2,2AF
2A82:  MOVFF  2A1,2AE
2A86:  MOVLB  0
2A88:  CALL   223A
2A8C:  MOVFF  03,2A4
2A90:  MOVFF  02,2A3
2A94:  MOVFF  01,2A2
2A98:  MOVFF  00,2A1
2A9C:  MOVLB  2
2A9E:  BTFSS  xA4.7
2AA0:  BRA    2ABC
2AA2:  DECF   xA6,F
2AA4:  BSF    xA6.5
2AA6:  COMF   xA1,F
2AA8:  COMF   xA2,F
2AAA:  COMF   xA3,F
2AAC:  COMF   xA4,F
2AAE:  INCF   xA1,F
2AB0:  BTFSC  FD8.2
2AB2:  INCF   xA2,F
2AB4:  BTFSC  FD8.2
2AB6:  INCF   xA3,F
2AB8:  BTFSC  FD8.2
2ABA:  INCF   xA4,F
2ABC:  MOVLW  3B
2ABE:  MOVWF  xAD
2AC0:  MOVLW  9A
2AC2:  MOVWF  xAC
2AC4:  MOVLW  CA
2AC6:  MOVWF  xAB
2AC8:  CLRF   xAA
2ACA:  MOVLW  0A
2ACC:  MOVWF  xA8
2ACE:  MOVF   xA5,W
2AD0:  BTFSC  FD8.2
2AD2:  INCF   xA6,F
2AD4:  MOVFF  2A4,2B1
2AD8:  MOVFF  2A3,2B0
2ADC:  MOVFF  2A2,2AF
2AE0:  MOVFF  2A1,2AE
2AE4:  MOVFF  2AD,2B5
2AE8:  MOVFF  2AC,2B4
2AEC:  MOVFF  2AB,2B3
2AF0:  MOVFF  2AA,2B2
2AF4:  MOVLB  0
2AF6:  CALL   227C
2AFA:  MOVF   01,W
2AFC:  MOVFF  FEF,2A1
2B00:  MOVFF  FEC,2A2
2B04:  MOVFF  FEC,2A3
2B08:  MOVFF  FEC,2A4
2B0C:  MOVF   00,F
2B0E:  BNZ   2B36
2B10:  MOVLB  2
2B12:  INCF   xA5,W
2B14:  SUBWF  xA8,W
2B16:  BTFSS  FD8.2
2B18:  BRA    2B1E
2B1A:  MOVLB  0
2B1C:  BRA    2B36
2B1E:  MOVF   xA6,W
2B20:  BZ    2B3C
2B22:  ANDLW  0F
2B24:  SUBWF  xA8,W
2B26:  BZ    2B2A
2B28:  BC    2BA2
2B2A:  BTFSC  xA6.7
2B2C:  BRA    2BA2
2B2E:  BTFSC  xA6.6
2B30:  BRA    2B3C
2B32:  MOVLW  20
2B34:  BRA    2B98
2B36:  MOVLW  20
2B38:  MOVLB  2
2B3A:  ANDWF  xA6,F
2B3C:  BTFSS  xA6.5
2B3E:  BRA    2B5A
2B40:  BCF    xA6.5
2B42:  MOVF   xA5,W
2B44:  BTFSS  FD8.2
2B46:  DECF   xA6,F
2B48:  MOVF   00,W
2B4A:  MOVWF  xA6
2B4C:  MOVLW  2D
2B4E:  BTFSS  F9E.4
2B50:  BRA    2B4E
2B52:  MOVWF  FAD
2B54:  MOVF   xA6,W
2B56:  MOVWF  00
2B58:  CLRF   xA6
2B5A:  MOVF   xA5,W
2B5C:  SUBWF  xA8,W
2B5E:  BNZ   2B76
2B60:  MOVF   00,W
2B62:  MOVWF  xA6
2B64:  MOVLW  2E
2B66:  BTFSS  F9E.4
2B68:  BRA    2B66
2B6A:  MOVWF  FAD
2B6C:  MOVF   xA6,W
2B6E:  MOVWF  00
2B70:  MOVLW  20
2B72:  ANDWF  xA6,F
2B74:  MOVLW  00
2B76:  MOVLW  30
2B78:  BTFSS  xA6.5
2B7A:  BRA    2B98
2B7C:  BCF    xA6.5
2B7E:  MOVF   xA5,W
2B80:  BTFSS  FD8.2
2B82:  DECF   xA6,F
2B84:  MOVF   00,W
2B86:  MOVWF  xA6
2B88:  MOVLW  2D
2B8A:  BTFSS  F9E.4
2B8C:  BRA    2B8A
2B8E:  MOVWF  FAD
2B90:  MOVF   xA6,W
2B92:  MOVWF  00
2B94:  CLRF   xA6
2B96:  MOVLW  30
2B98:  ADDWF  00,F
2B9A:  MOVF   00,W
2B9C:  BTFSS  F9E.4
2B9E:  BRA    2B9C
2BA0:  MOVWF  FAD
2BA2:  MOVFF  2AD,2B1
2BA6:  MOVFF  2AC,2B0
2BAA:  MOVFF  2AB,2AF
2BAE:  MOVFF  2AA,2AE
2BB2:  CLRF   xB5
2BB4:  CLRF   xB4
2BB6:  CLRF   xB3
2BB8:  MOVLW  0A
2BBA:  MOVWF  xB2
2BBC:  MOVLB  0
2BBE:  CALL   227C
2BC2:  MOVFF  03,2AD
2BC6:  MOVFF  02,2AC
2BCA:  MOVFF  01,2AB
2BCE:  MOVFF  00,2AA
2BD2:  MOVLB  2
2BD4:  DECFSZ xA8,F
2BD6:  BRA    2AD4
2BD8:  MOVLB  0
2BDA:  RETLW  00
2BDC:  MOVFF  FEA,29B
2BE0:  MOVFF  FE9,29A
2BE4:  MOVLB  2
2BE6:  SWAPF  x94,W
2BE8:  IORLW  F0
2BEA:  MOVWF  x96
2BEC:  ADDWF  x96,F
2BEE:  ADDLW  E2
2BF0:  MOVWF  x97
2BF2:  ADDLW  32
2BF4:  MOVWF  x99
2BF6:  MOVF   x94,W
2BF8:  ANDLW  0F
2BFA:  ADDWF  x97,F
2BFC:  ADDWF  x97,F
2BFE:  ADDWF  x99,F
2C00:  ADDLW  E9
2C02:  MOVWF  x98
2C04:  ADDWF  x98,F
2C06:  ADDWF  x98,F
2C08:  SWAPF  x93,W
2C0A:  ANDLW  0F
2C0C:  ADDWF  x98,F
2C0E:  ADDWF  x99,F
2C10:  RLCF   x98,F
2C12:  RLCF   x99,F
2C14:  COMF   x99,F
2C16:  RLCF   x99,F
2C18:  MOVF   x93,W
2C1A:  ANDLW  0F
2C1C:  ADDWF  x99,F
2C1E:  RLCF   x96,F
2C20:  MOVLW  07
2C22:  MOVWF  x95
2C24:  MOVLW  0A
2C26:  DECF   x98,F
2C28:  ADDWF  x99,F
2C2A:  BNC   2C26
2C2C:  DECF   x97,F
2C2E:  ADDWF  x98,F
2C30:  BNC   2C2C
2C32:  DECF   x96,F
2C34:  ADDWF  x97,F
2C36:  BNC   2C32
2C38:  DECF   x95,F
2C3A:  ADDWF  x96,F
2C3C:  BNC   2C38
2C3E:  MOVLW  02
2C40:  MOVWF  FEA
2C42:  MOVLW  95
2C44:  MOVWF  FE9
2C46:  MOVLW  07
2C48:  ANDWF  x9A,W
2C4A:  BCF    x9A.6
2C4C:  ADDWF  FE9,F
2C4E:  MOVLW  99
2C50:  SUBWF  FE9,W
2C52:  BTFSC  FD8.2
2C54:  BSF    x9A.6
2C56:  MOVF   FEF,W
2C58:  MOVWF  00
2C5A:  BNZ   2C6C
2C5C:  BTFSC  x9A.6
2C5E:  BRA    2C6C
2C60:  BTFSC  x9A.4
2C62:  BRA    2C7C
2C64:  BTFSC  x9A.3
2C66:  BRA    2C6C
2C68:  MOVLW  20
2C6A:  BRA    2C72
2C6C:  BSF    x9A.3
2C6E:  BCF    x9A.4
2C70:  MOVLW  30
2C72:  ADDWF  00,F
2C74:  MOVF   00,W
2C76:  BTFSS  F9E.4
2C78:  BRA    2C76
2C7A:  MOVWF  FAD
2C7C:  MOVF   FEE,W
2C7E:  BTFSS  x9A.6
2C80:  BRA    2C4E
2C82:  MOVLB  0
2C84:  RETLW  00
*
4748:  MOVFF  FF2,0E
474C:  BCF    FF2.7
474E:  ADDWF  FE8,W
4750:  ADDLW  6D
4752:  MOVWF  FF6
4754:  MOVLW  47
4756:  MOVWF  FF7
4758:  BTFSC  FD8.0
475A:  INCF   FF7,F
475C:  TBLRD*-
475E:  MOVF   FF5,W
4760:  MOVWF  FFA
4762:  TBLRD*
4764:  MOVF   FF5,W
4766:  BTFSC  0E.7
4768:  BSF    FF2.7
476A:  MOVWF  FF9
476C:  DATA 94,39
476E:  DATA C8,39
4770:  DATA 8E,3A
4772:  DATA 40,3B
*
499C:  MOVF   01,W
499E:  MOVFF  81,295
49A2:  MOVLW  64
49A4:  MOVLB  2
49A6:  MOVWF  x96
49A8:  MOVLB  0
49AA:  CALL   26F0
49AE:  MOVFF  00,81
49B2:  MOVF   01,W
49B4:  MOVLW  30
49B6:  BNZ   49C6
49B8:  BTFSS  x82.1
49BA:  BRA    49D6
49BC:  BTFSC  x82.3
49BE:  BRA    49D6
49C0:  BTFSC  x82.4
49C2:  MOVLW  20
49C4:  BRA    49CC
49C6:  BCF    x82.3
49C8:  BCF    x82.4
49CA:  BSF    x82.0
49CC:  ADDWF  01,F
49CE:  MOVFF  01,293
49D2:  CALL   0D34
49D6:  MOVFF  81,295
49DA:  MOVLW  0A
49DC:  MOVLB  2
49DE:  MOVWF  x96
49E0:  MOVLB  0
49E2:  CALL   26F0
49E6:  MOVFF  00,81
49EA:  MOVF   01,W
49EC:  MOVLW  30
49EE:  BNZ   49FC
49F0:  BTFSC  x82.3
49F2:  BRA    4A06
49F4:  BTFSS  x82.0
49F6:  BRA    4A06
49F8:  BTFSC  x82.4
49FA:  MOVLW  20
49FC:  ADDWF  01,F
49FE:  MOVFF  01,293
4A02:  CALL   0D34
4A06:  MOVLW  30
4A08:  ADDWF  x81,F
4A0A:  MOVFF  81,293
4A0E:  CALL   0D34
4A12:  RETLW  00
....................                   //fijamos que el valor leído esté representado con 8 bits 
....................                   //(es decir de 00 a FF). 
....................                   //Para cambiar el rango de salida usamos: ADC=10 (000 a 3FF) 
....................                   //                                      ó ADC=16 (0000 a FFC0) 
.................... #list 
....................  
.................... #include "proyecto1.h" 
.................... //****************************************** 
.................... //Archivo de cabecera del Proyecto 1 
.................... //****************************************** 
.................... //Author: Julio Navarro Lara         2010 
....................  
.................... //Definimos los puertos del microcontrolador 
.................... #byte port_a = 0xF80 
.................... #byte port_b = 0xF81 
.................... #byte port_c = 0xF82 
.................... #byte port_d = 0xF83 
.................... #byte port_e = 0xF84 
....................  
.................... #bit sistema_encendido = 0xF83.5    //Pin que indica el encendido del sistema con un valor alto 
.................... #bit motor = 0xF83.6                //Pin que indica el encendido del motor de circulación del agua con un valor alto 
.................... #bit caldera_encendida = 0xF83.7    //Pin que indica el encendido de la caldera con un valor alto 
.................... #bit teclado1 = 0xF81.4             //Pines para gestionar la entrada del teclado 
.................... #bit teclado2 = 0xF81.5             //'' 
.................... #bit teclado3 = 0xF81.6             //'' 
.................... #bit teclado4 = 0xF81.7             //'' 
.................... #bit lcd_rs   = 0xF81.2             //Pin que controla la entrada RS de la pantalla LCD 
....................  
.................... //Parámetros de la pantalla LCD 
.................... #define LCD_ORDEN       0    //Código para enviar un orden 
.................... #define LCD_DATO        1    //Código para enviar un dato 
....................  
.................... #define LCD_CLEAR       0x01  //Orden para borrar la pantalla 
.................... #define LCD_NO_CURSOR   0x0C  //Orden para eliminar el cursor de la pantalla 
.................... #define LCD_CURSOR      0x0E  //Orden para visualizar el cursor en la pantalla 
.................... #define LCD_APAGAR      0x08  //Orden para apagar la pantalla 
....................  
.................... //Tiempo que se mantienen los mensajes temporales en pantalla (ms) 
.................... #define LCD_T_RETARDO   500 
....................  
.................... //Clave de acceso 
.................... #define clave           2401 
....................  
....................  
.................... //Parámetros del teclado 
.................... #define NUM_COLUMNAS 3     //Número de columnas del teclado matricial 
.................... #define NUM_FILAS    4     //Número de filas del teclado matricial 
.................... #define NO           100  //Codificación del NO en el método buscar_numero() 
.................... #define SI           101  //Codificación del SI en el método buscar_numero() 
....................  
.................... //Parámetros del conversor AD 
.................... #define termostato_caldera   3   //Entrada AD que se refiere a la temperatura de referencia de la caldera 
.................... #define temperatura_caldera  0   //Entrada AD que se refiere a la temperatura del agua en la caldera 
.................... #define histeresis_caldera   5   //Diferencia de histéresis para el agua de la caldera 
.................... #define t_max_caldera        70  //Temperatura máxima a la que puede regularse la caldera 
.................... #define t_min_caldera        25  //Temperatura mínima a la que puede regularse la caldera 
.................... #define AD_num_valores       255 //Número de valores de escala del conversor (sensibilidad de los potenciómetros) 
....................  
.................... //Parámetros de control de temperatura 
.................... //Datos suministrados por el aparato de aire acondicionado (con bomba de calor) de mi casa 
.................... #define temp_max          32  //Temperatura máxima de regulación del termostato 
.................... #define temp_min          16  //Temperatura mínima de regulación del termostato 
....................  
....................  
.................... //Direcciones para la EEPROM 
.................... #define eeprom_termostato        0x10  //Valor del termostato 
.................... #define eeprom_num_intervalos    0x11  //Número de intervalos de programación de los que disponemos 
.................... #define eeprom_num_registros     0x12  //Número de registros de desconexión de los que se disponen 
.................... #define eeprom_anno_actual       0x14  //Año en el que nos encontramos 
.................... #define eeprom_anno_1_to_3       0x15  //Año en el que nos encontramos medido de 0 a 3 (llamado 1_to_3 por razones "históricas") 
.................... #define eeprom_programaciones    0x18  //Posición a partir de la cual se almacenan las programaciones de alarmas 
.................... #define eeprom_registros         0x50  //Posición a partir de la cual se almacenan los registros 
....................  
.................... #fuses HS, NOPROTECT, BROWNOUT, PUT, NOLVP, NOXINST, WDT2048, NOWDT 
.................... //El watchdog-timer salta cada 8.192 segundos, aproximadamente 
.................... #use delay(clock=8000000, restart_wdt) 
*
0BE8:  MOVLW  02
0BEA:  MOVWF  FEA
0BEC:  MOVLW  9A
0BEE:  MOVWF  FE9
0BF0:  MOVF   FEF,W
0BF2:  BZ    0C18
0BF4:  MOVLW  02
0BF6:  MOVWF  01
0BF8:  MOVLW  BF
0BFA:  MOVWF  00
0BFC:  CLRWDT
0BFE:  DECFSZ 00,F
0C00:  BRA    0BFC
0C02:  DECFSZ 01,F
0C04:  BRA    0BF8
0C06:  MOVLW  96
0C08:  MOVWF  00
0C0A:  DECFSZ 00,F
0C0C:  BRA    0C0A
0C0E:  NOP   
0C10:  NOP   
0C12:  CLRWDT
0C14:  DECFSZ FEF,F
0C16:  BRA    0BF4
0C18:  RETLW  00
*
0C3C:  MOVLW  09
0C3E:  MOVLB  2
0C40:  SUBWF  x9B,F
0C42:  BNC   0C5C
0C44:  MOVLW  02
0C46:  MOVWF  FEA
0C48:  MOVLW  9B
0C4A:  MOVWF  FE9
0C4C:  BCF    FD8.0
0C4E:  RRCF   FEF,F
0C50:  MOVF   FEF,W
0C52:  BZ    0C5C
0C54:  BRA    0C58
0C56:  CLRWDT
0C58:  DECFSZ FEF,F
0C5A:  BRA    0C56
0C5C:  MOVLB  0
0C5E:  RETLW  00
.................... #use rs232(baud=4800, xmit=PIN_C6,rcv=PIN_C7) 
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  (x==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  (x<' ') 
.................... #define isprint(x)  (x>=' ') 
.................... #define isgraph(x)  (x>' ') 
.................... #define ispunct(x)  ((x>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(int *)==1 
.................... #define ptrdiff_t int 
.................... #else 
.................... #define ptrdiff_t long 
.................... #endif 
....................  
.................... #define size_t int 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: float atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... float atof(char * s); 
....................  
.................... /* Standard template: float atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... float atoe(char * s); 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int32 atoi32(char *s); 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, int8 base, char * s); 
....................  
.................... /* Standard template: signed long  atol(char * s) 
....................  * converts the initial portion of the string s to a signed long 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: float strtol(char * s,char *endptr) 
....................  * converts the initial portion of the string s to a float 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... float strtod(char *s,char *endptr); 
....................  
.................... /* Standard template: long strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr,signed int base); 
....................  
.................... /* Standard template: long strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... long strtoul(char *s,char *endptr,signed int base); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... long rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer,signed int denom); 
.................... ldiv_t ldiv(signed long numer,signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(int *)==1 
.................... #define ptrdiff_t int 
.................... #else 
.................... #define ptrdiff_t long 
.................... #endif 
....................  
.................... #define size_t int 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(int *)==1 
.................... #define ptrdiff_t int 
.................... #else 
.................... #define ptrdiff_t long 
.................... #endif 
....................  
.................... #define size_t int 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  (x==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  (x<' ') 
.................... #define isprint(x)  (x>=' ') 
.................... #define isgraph(x)  (x>' ') 
.................... #define ispunct(x)  ((x>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* compiler ignored the name 'strcpy()'; perhaps, it's reserved? 
....................    Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1*/ 
....................  
.................... char *strcopy(char *s1, char *s2) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; *s2 != 0; s++, s2++) { 
.................... 	  *s = *s2; 
....................   } 
....................   *s = *s2; 
....................   return(s1); 
.................... } 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   int n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,int c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, int c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... int *strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, int c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... int *strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
.................... 	 if (*sc2 == '\0') 
.................... 	    return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
.................... 	char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
.................... 	while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && *s == *t; ++s, ++t); 
....................  
.................... 		if (*t == '\0') 
.................... 			return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
.................... 	} 
.................... 	return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(int errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... int *strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer,signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer,signed long denom) 
.................... { 
....................    ldiv_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... float atof(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int sign = 0; 
....................    char c; 
....................    int ptr = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
....................  
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int sign = 0; 
....................    int expsign = 0; 
....................    char c; 
....................    int ptr = 0; 
....................    int i; 
....................    float exp = 1.0; 
....................    int expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
24E4:  CLRF   x88
....................    sign = 0; 
24E6:  CLRF   x86
....................    base = 10; 
24E8:  MOVLW  0A
24EA:  MOVWF  x87
....................    result = 0; 
24EC:  CLRF   x85
....................  
....................    if (!s) 
24EE:  MOVF   x83,W
24F0:  IORWF  x84,W
24F2:  BNZ   24FA
....................       return 0; 
24F4:  MOVLW  00
24F6:  MOVWF  01
24F8:  BRA    267C
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
24FA:  MOVF   x88,W
24FC:  INCF   x88,F
24FE:  CLRF   03
2500:  ADDWF  x83,W
2502:  MOVWF  FE9
2504:  MOVF   x84,W
2506:  ADDWFC 03,W
2508:  MOVWF  FEA
250A:  MOVFF  FEF,89
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
250E:  MOVF   x89,W
2510:  SUBLW  2D
2512:  BNZ   252E
....................    { 
....................       sign = 1;         // Set the sign to negative 
2514:  MOVLW  01
2516:  MOVWF  x86
....................       c = s[index++]; 
2518:  MOVF   x88,W
251A:  INCF   x88,F
251C:  CLRF   03
251E:  ADDWF  x83,W
2520:  MOVWF  FE9
2522:  MOVF   x84,W
2524:  ADDWFC 03,W
2526:  MOVWF  FEA
2528:  MOVFF  FEF,89
....................    } 
....................    else if (c == '+') 
252C:  BRA    2548
252E:  MOVF   x89,W
2530:  SUBLW  2B
2532:  BNZ   2548
....................    { 
....................       c = s[index++]; 
2534:  MOVF   x88,W
2536:  INCF   x88,F
2538:  CLRF   03
253A:  ADDWF  x83,W
253C:  MOVWF  FE9
253E:  MOVF   x84,W
2540:  ADDWFC 03,W
2542:  MOVWF  FEA
2544:  MOVFF  FEF,89
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
2548:  MOVF   x89,W
254A:  SUBLW  2F
254C:  BTFSC  FD8.0
254E:  BRA    266C
2550:  MOVF   x89,W
2552:  SUBLW  39
2554:  BTFSS  FD8.0
2556:  BRA    266C
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
2558:  MOVF   x89,W
255A:  SUBLW  30
255C:  BNZ   25A0
255E:  CLRF   03
2560:  MOVF   x88,W
2562:  ADDWF  x83,W
2564:  MOVWF  FE9
2566:  MOVF   x84,W
2568:  ADDWFC 03,W
256A:  MOVWF  FEA
256C:  MOVF   FEF,W
256E:  SUBLW  78
2570:  BZ    2586
2572:  CLRF   03
2574:  MOVF   x88,W
2576:  ADDWF  x83,W
2578:  MOVWF  FE9
257A:  MOVF   x84,W
257C:  ADDWFC 03,W
257E:  MOVWF  FEA
2580:  MOVF   FEF,W
2582:  SUBLW  58
2584:  BNZ   25A0
....................       { 
....................          base = 16; 
2586:  MOVLW  10
2588:  MOVWF  x87
....................          index++; 
258A:  INCF   x88,F
....................          c = s[index++]; 
258C:  MOVF   x88,W
258E:  INCF   x88,F
2590:  CLRF   03
2592:  ADDWF  x83,W
2594:  MOVWF  FE9
2596:  MOVF   x84,W
2598:  ADDWFC 03,W
259A:  MOVWF  FEA
259C:  MOVFF  FEF,89
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
25A0:  MOVF   x87,W
25A2:  SUBLW  0A
25A4:  BNZ   25DC
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
25A6:  MOVF   x89,W
25A8:  SUBLW  2F
25AA:  BC    25DA
25AC:  MOVF   x89,W
25AE:  SUBLW  39
25B0:  BNC   25DA
....................             result = 10*result + (c - '0'); 
25B2:  MOVLW  0A
25B4:  MOVWF  x8A
25B6:  MOVFF  85,8B
25BA:  BRA    2498
25BC:  MOVLW  30
25BE:  SUBWF  x89,W
25C0:  ADDWF  01,W
25C2:  MOVWF  x85
....................             c = s[index++]; 
25C4:  MOVF   x88,W
25C6:  INCF   x88,F
25C8:  CLRF   03
25CA:  ADDWF  x83,W
25CC:  MOVWF  FE9
25CE:  MOVF   x84,W
25D0:  ADDWFC 03,W
25D2:  MOVWF  FEA
25D4:  MOVFF  FEF,89
....................          } 
25D8:  BRA    25A6
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
25DA:  BRA    266C
25DC:  MOVF   x87,W
25DE:  SUBLW  10
25E0:  BNZ   266C
....................       { 
....................          c = toupper(c); 
25E2:  MOVF   x89,W
25E4:  SUBLW  60
25E6:  BC    25F4
25E8:  MOVF   x89,W
25EA:  SUBLW  7A
25EC:  BNC   25F4
25EE:  MOVF   x89,W
25F0:  ANDLW  DF
25F2:  BRA    25F6
25F4:  MOVF   x89,W
25F6:  MOVWF  x89
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
25F8:  MOVF   x89,W
25FA:  SUBLW  2F
25FC:  BC    2604
25FE:  MOVF   x89,W
2600:  SUBLW  39
2602:  BC    2610
2604:  MOVF   x89,W
2606:  SUBLW  40
2608:  BC    266C
260A:  MOVF   x89,W
260C:  SUBLW  46
260E:  BNC   266C
....................             if (c >= '0' && c <= '9') 
2610:  MOVF   x89,W
2612:  SUBLW  2F
2614:  BC    262E
2616:  MOVF   x89,W
2618:  SUBLW  39
261A:  BNC   262E
....................                result = (result << 4) + (c - '0'); 
261C:  SWAPF  x85,W
261E:  MOVWF  x8A
2620:  MOVLW  F0
2622:  ANDWF  x8A,F
2624:  MOVLW  30
2626:  SUBWF  x89,W
2628:  ADDWF  x8A,W
262A:  MOVWF  x85
....................             else 
262C:  BRA    2640
....................                result = (result << 4) + (c - 'A' + 10); 
262E:  SWAPF  x85,W
2630:  MOVWF  x8A
2632:  MOVLW  F0
2634:  ANDWF  x8A,F
2636:  MOVLW  41
2638:  SUBWF  x89,W
263A:  ADDLW  0A
263C:  ADDWF  x8A,W
263E:  MOVWF  x85
....................  
....................             c = s[index++]; 
2640:  MOVF   x88,W
2642:  INCF   x88,F
2644:  CLRF   03
2646:  ADDWF  x83,W
2648:  MOVWF  FE9
264A:  MOVF   x84,W
264C:  ADDWFC 03,W
264E:  MOVWF  FEA
2650:  MOVFF  FEF,89
....................             c = toupper(c); 
2654:  MOVF   x89,W
2656:  SUBLW  60
2658:  BC    2666
265A:  MOVF   x89,W
265C:  SUBLW  7A
265E:  BNC   2666
2660:  MOVF   x89,W
2662:  ANDLW  DF
2664:  BRA    2668
2666:  MOVF   x89,W
2668:  MOVWF  x89
....................          } 
266A:  BRA    25F8
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
266C:  DECFSZ x86,W
266E:  BRA    2678
2670:  MOVF   x87,W
2672:  SUBLW  0A
2674:  BNZ   2678
....................        result = -result; 
2676:  NEGF   x85
....................  
....................    return(result); 
2678:  MOVFF  85,01
.................... } 
267C:  RETLW  00
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... char * itoa(signed int32 num, int8 base, char *s) 
.................... { 
....................      int32 temp=1; 
....................      int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... float strtod(char *s,char *endptr) { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int sign = 0, point = 0; 
....................    char c; 
....................    int ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c=s[ptr++]; 
....................  
....................  
....................    while((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 0) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          point = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 1) { 
....................          pow10 = pow10*10; 
....................          result += (c - '0')/pow10; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '+') { 
....................          c = s[ptr++]; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................          *((char *)endptr)=s+ptr; 
....................       } 
....................       else 
....................          *((char *)endptr)=s; 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... long strtoul(char *s,char *endptr,signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-') 
....................    { 
....................       if (endptr) 
....................       { 
....................         *((char *)endptr)=s; 
....................       } 
....................       return 0; 
....................    } 
....................  
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    { 
....................       if (endptr) 
....................       { 
....................         *((char *)endptr)=s; 
....................       } 
....................       return 0; 
....................    } 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................       if (endptr) 
....................       { 
....................         *((char *)endptr)=s; 
....................       } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................         *((char *)endptr)=sc; 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr,signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    { 
....................       if (endptr) 
....................       { 
....................         *((char *)endptr)=s; 
....................       } 
....................       return 0; 
....................    } 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................       if (endptr) 
....................       { 
....................         *((char *)endptr)=s; 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................         *((char *)endptr)=sc; 
....................    return x; 
.................... } 
....................  
.................... signed int system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed = 1; 
....................  
.................... long rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned long)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... typedef signed int (*_Cmpfun)(char * p1,char * p2); 
....................  
.................... void qsort(char * qdata, int qitems, int qsize, _Cmpfun cmp) { 
....................    int m,j,i,l; 
....................    short done; 
....................    BYTE t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=TRUE; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = FALSE; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include "PCF8583.c" 
.................... // Funciones para el RTC I2c: PCF8583 
.................... // Este código no procede de CCS (no está totalmente verificado) 
.................... // Inluye funciones de conversión BCD-Binario 
.................... // y de lectura/escritura a través de I2C. 
....................  
.................... //Vamos a eliminar todos los casos en los que se habiliten las interrupciones globales 
.................... //Estas sentencias nos impedían utilizar estos métodos en las interrupciones 
....................  
.................... #ifndef PCF8583_SDA 
.................... #define PCF8583_SDA  PIN_C4 
.................... #define PCF8583_SCL  PIN_C3 
.................... #endif 
....................  
.................... #use i2c(master, sda=PCF8583_SDA, scl=PCF8583_SCL) 
*
0D90:  MOVLW  08
0D92:  MOVWF  01
0D94:  NOP   
0D96:  NOP   
0D98:  NOP   
0D9A:  BCF    F8B.3
0D9C:  BCF    F94.3
0D9E:  NOP   
0DA0:  NOP   
0DA2:  NOP   
0DA4:  MOVLB  2
0DA6:  RLCF   x9E,F
0DA8:  BCF    F8B.4
0DAA:  BTFSC  FD8.0
0DAC:  BSF    F94.4
0DAE:  BTFSS  FD8.0
0DB0:  BCF    F94.4
0DB2:  BSF    F94.3
0DB4:  BTFSS  F82.3
0DB6:  BRA    0DB4
0DB8:  DECFSZ 01,F
0DBA:  BRA    0DBE
0DBC:  BRA    0DC2
0DBE:  MOVLB  0
0DC0:  BRA    0D94
0DC2:  NOP   
0DC4:  NOP   
0DC6:  BCF    F8B.3
0DC8:  BCF    F94.3
0DCA:  NOP   
0DCC:  BSF    F94.4
0DCE:  NOP   
0DD0:  NOP   
0DD2:  NOP   
0DD4:  NOP   
0DD6:  NOP   
0DD8:  NOP   
0DDA:  BSF    F94.3
0DDC:  BTFSS  F82.3
0DDE:  BRA    0DDC
0DE0:  CLRF   01
0DE2:  NOP   
0DE4:  NOP   
0DE6:  NOP   
0DE8:  BTFSC  F82.4
0DEA:  BSF    01.0
0DEC:  BCF    F8B.3
0DEE:  BCF    F94.3
0DF0:  BCF    F8B.4
0DF2:  BCF    F94.4
0DF4:  MOVLB  0
0DF6:  RETLW  00
0DF8:  MOVLW  08
0DFA:  MOVLB  2
0DFC:  MOVWF  x9F
0DFE:  MOVFF  00,2A0
0E02:  BSF    F94.4
0E04:  NOP   
0E06:  NOP   
0E08:  NOP   
0E0A:  BSF    F94.3
0E0C:  BTFSS  F82.3
0E0E:  BRA    0E0C
0E10:  BTFSC  F82.4
0E12:  BSF    FD8.0
0E14:  BTFSS  F82.4
0E16:  BCF    FD8.0
0E18:  RLCF   01,F
0E1A:  NOP   
0E1C:  NOP   
0E1E:  BCF    F94.3
0E20:  BCF    F8B.3
0E22:  DECFSZ x9F,F
0E24:  BRA    0E02
0E26:  BSF    F94.4
0E28:  NOP   
0E2A:  NOP   
0E2C:  NOP   
0E2E:  BCF    F8B.4
0E30:  MOVF   xA0,W
0E32:  BTFSS  FD8.2
0E34:  BCF    F94.4
0E36:  NOP   
0E38:  BSF    F94.3
0E3A:  BTFSS  F82.3
0E3C:  BRA    0E3A
0E3E:  NOP   
0E40:  NOP   
0E42:  BCF    F8B.3
0E44:  BCF    F94.3
0E46:  NOP   
0E48:  NOP   
0E4A:  NOP   
0E4C:  BCF    F8B.4
0E4E:  BCF    F94.4
0E50:  MOVLB  0
0E52:  RETLW  00
....................  
.................... #ifndef PCF8583_WRITE_ADDRESS 
.................... #define PCF8583_WRITE_ADDRESS 0xA0 
.................... #define PCF8583_READ_ADDRESS  0xA1 
.................... #endif 
....................  
.................... // Register addresses 
.................... #define PCF8583_CTRL_STATUS_REG    0x00 
.................... #define PCF8583_100S_REG           0x01 
.................... #define PCF8583_SECONDS_REG        0x02 
.................... #define PCF8583_MINUTES_REG        0x03 
.................... #define PCF8583_HOURS_REG          0x04 
.................... #define PCF8583_DATE_REG           0x05 
.................... #define PCF8583_MONTHS_REG         0x06 
.................... #define PCF8583_TIMER_REG          0x07 
....................  
.................... #define PCF8583_ALARM_CONTROL_REG  0x08 
.................... #define PCF8583_ALARM_100S_REG     0x09 
.................... #define PCF8583_ALARM_SECS_REG     0x0A 
.................... #define PCF8583_ALARM_MINS_REG     0x0B 
.................... #define PCF8583_ALARM_HOURS_REG    0x0C 
.................... #define PCF8583_ALARM_DATE_REG     0x0D 
.................... #define PCF8583_ALARM_MONTHS_REG   0x0E 
.................... #define PCF8583_ALARM_TIMER_REG    0x0F 
....................  
.................... // Use the first NVRAM address for the year byte. 
.................... #define PCF8583_YEAR_REG           0x10 
....................  
....................  
.................... // Commands for the Control/Status register. 
.................... #define PCF8583_START_COUNTING     0x00 
.................... #define PCF8583_STOP_COUNTING      0x80 
.................... #define PCF8583_ACTIVAR_ALARMA     0b00000100  //Palabra de activación de la alarma 
.................... #define PCF8583_DEFINIR_ALARMA     0b10010000  //Palabra para definir el comportamiento 
....................                                                //de la alarma en su registro 
....................  
.................... #define PCF8583_DESACTIVAR_INT     0b00010000 
....................  
....................  
.................... int8 alarma_activada=0; 
....................  
....................  
.................... char const weekday_names[7][10] = 
.................... { 
.................... {"DOM"}, 
.................... {"LUN"}, 
.................... {"MAR"}, 
.................... {"MIE"}, 
.................... {"JUE"}, 
.................... {"VIE"}, 
.................... {"SAB"} 
.................... }; 
....................  
.................... // This structure defines the user's date and time data. 
.................... // The values are stored as unsigned integers.  The user 
.................... // should declare a structure of this type in the application 
.................... // program. Then the address of the structure should be 
.................... // passed to the PCF8583 read/write functions in this 
.................... // driver, whenever you want to talk to the chip. 
.................... typedef struct 
.................... { 
.................... int8 seconds;    // 0 to 59 
.................... int8 minutes;    // 0 to 59 
.................... int8 hours;      // 0 to 23  (24-hour time) 
.................... int8 day;        // 1 to 31 
.................... int8 month;      // 1 to 12 
.................... int8 year;       // 00 to 99 
.................... int8 weekday;    // 0 = Sunday, 1 = Monday, etc. 
.................... }date_time_t; 
....................  
....................  
.................... //---------------------------------------------- 
.................... void PCF8583_write_byte(int8 address, int8 data) 
.................... { 
.................... disable_interrupts(GLOBAL); 
*
1082:  BCF    FF2.6
1084:  BCF    FF2.7
1086:  BTFSC  FF2.7
1088:  BRA    1084
.................... i2c_start(); 
108A:  BSF    F94.4
108C:  NOP   
108E:  NOP   
1090:  BSF    F94.3
1092:  NOP   
1094:  NOP   
1096:  NOP   
1098:  BCF    F8B.4
109A:  BCF    F94.4
109C:  NOP   
109E:  NOP   
10A0:  BCF    F8B.3
10A2:  BCF    F94.3
.................... i2c_write(PCF8583_WRITE_ADDRESS); 
10A4:  MOVLW  A0
10A6:  MOVLB  2
10A8:  MOVWF  x9E
10AA:  MOVLB  0
10AC:  RCALL  0D90
.................... i2c_write(address); 
10AE:  MOVFF  9A,29E
10B2:  RCALL  0D90
.................... i2c_write(data); 
10B4:  MOVFF  9B,29E
10B8:  RCALL  0D90
.................... i2c_stop(); 
10BA:  BCF    F94.4
10BC:  NOP   
10BE:  BSF    F94.3
10C0:  BTFSS  F82.3
10C2:  BRA    10C0
10C4:  NOP   
10C6:  NOP   
10C8:  NOP   
10CA:  NOP   
10CC:  NOP   
10CE:  BSF    F94.4
10D0:  NOP   
10D2:  NOP   
.................... } 
10D4:  RETLW  00
....................  
.................... //---------------------------------------------- 
.................... int8 PCF8583_read_byte(int8 address) 
.................... { 
.................... int8 retval; 
....................  
.................... disable_interrupts(GLOBAL); 
*
0FFE:  BCF    FF2.6
1000:  BCF    FF2.7
1002:  BTFSC  FF2.7
1004:  BRA    1000
.................... i2c_start(); 
1006:  BSF    F94.4
1008:  NOP   
100A:  NOP   
100C:  BSF    F94.3
100E:  NOP   
1010:  NOP   
1012:  NOP   
1014:  BCF    F8B.4
1016:  BCF    F94.4
1018:  NOP   
101A:  NOP   
101C:  BCF    F8B.3
101E:  BCF    F94.3
.................... i2c_write(PCF8583_WRITE_ADDRESS); 
1020:  MOVLW  A0
1022:  MOVLB  2
1024:  MOVWF  x9E
1026:  MOVLB  0
1028:  RCALL  0D90
.................... i2c_write(address); 
102A:  MOVFF  9A,29E
102E:  RCALL  0D90
.................... i2c_start(); 
1030:  BSF    F94.4
1032:  NOP   
1034:  NOP   
1036:  BSF    F94.3
1038:  NOP   
103A:  NOP   
103C:  NOP   
103E:  BTFSS  F82.3
1040:  BRA    103E
1042:  BCF    F8B.4
1044:  BCF    F94.4
1046:  NOP   
1048:  NOP   
104A:  BCF    F8B.3
104C:  BCF    F94.3
.................... i2c_write(PCF8583_READ_ADDRESS); 
104E:  MOVLW  A1
1050:  MOVLB  2
1052:  MOVWF  x9E
1054:  MOVLB  0
1056:  RCALL  0D90
.................... retval = i2c_read(0); 
1058:  CLRF   00
105A:  RCALL  0DF8
105C:  MOVFF  01,9B
.................... i2c_stop(); 
1060:  BCF    F94.4
1062:  NOP   
1064:  BSF    F94.3
1066:  BTFSS  F82.3
1068:  BRA    1066
106A:  NOP   
106C:  NOP   
106E:  NOP   
1070:  NOP   
1072:  NOP   
1074:  BSF    F94.4
1076:  NOP   
1078:  NOP   
....................  
.................... return(retval); 
107A:  MOVFF  9B,01
.................... } 
107E:  GOTO   1268 (RETURN)
....................  
....................  
.................... void PCF8583_init(void) 
.................... { 
.................... PCF8583_write_byte(PCF8583_CTRL_STATUS_REG, 
....................                               PCF8583_START_COUNTING); 
.................... } 
....................  
.................... //---------------------------------------------- 
.................... // This function converts an 8 bit binary value 
.................... // to an 8 bit BCD value. 
.................... // The input range must be from 0 to 99. 
....................  
.................... int8 bin2bcd(int8 value) 
.................... { 
.................... char retval; 
....................  
.................... retval = 0; 
*
1344:  CLRF   x8A
....................  
.................... while(1) 
....................   { 
....................    // Get the tens digit by doing multiple subtraction 
....................    // of 10 from the binary value. 
....................    if(value >= 10) 
1346:  MOVF   x89,W
1348:  SUBLW  09
134A:  BC    1356
....................      { 
....................       value -= 10; 
134C:  MOVLW  0A
134E:  SUBWF  x89,F
....................       retval += 0x10; 
1350:  MOVLW  10
1352:  ADDWF  x8A,F
....................      } 
....................    else // Get the ones digit by adding the remainder. 
1354:  BRA    135C
....................      { 
....................       retval += value; 
1356:  MOVF   x89,W
1358:  ADDWF  x8A,F
....................       break; 
135A:  BRA    135E
....................      } 
....................    } 
135C:  BRA    1346
....................  
.................... return(retval); 
135E:  MOVFF  8A,01
.................... } 
1362:  RETLW  00
....................  
.................... //---------------------------------------------- 
.................... // This function converts an 8 bit BCD value to 
.................... // an 8 bit binary value. 
.................... // The input range must be from 00 to 99. 
....................  
.................... char bcd2bin(char bcd_value) 
.................... { 
.................... char temp; 
....................  
.................... temp = bcd_value; 
*
0FD8:  MOVFF  9D,9E
....................  
.................... // Shifting the upper digit right by 1 is 
.................... // the same as multiplying it by 8. 
.................... temp >>= 1; 
0FDC:  BCF    FD8.0
0FDE:  RRCF   x9E,F
....................  
.................... // Isolate the bits for the upper digit. 
.................... temp &= 0x78; 
0FE0:  MOVLW  78
0FE2:  ANDWF  x9E,F
....................  
.................... // Now return: (Tens * 8) + (Tens * 2) + Ones 
.................... return(temp + (temp >> 2) + (bcd_value & 0x0f)); 
0FE4:  RRCF   x9E,W
0FE6:  MOVWF  00
0FE8:  RRCF   00,F
0FEA:  MOVLW  3F
0FEC:  ANDWF  00,F
0FEE:  MOVF   00,W
0FF0:  ADDWF  x9E,W
0FF2:  MOVWF  x9F
0FF4:  MOVF   x9D,W
0FF6:  ANDLW  0F
0FF8:  ADDWF  x9F,W
0FFA:  MOVWF  01
....................  
.................... } 
0FFC:  RETLW  00
....................  
.................... //---------------------------------------------- 
.................... void PCF8583_set_datetime(date_time_t *dt) 
.................... { 
.................... int8 bcd_sec; 
.................... int8 bcd_min; 
.................... int8 bcd_hrs; 
.................... int8 bcd_day; 
.................... int8 bcd_mon; 
....................  
.................... // Convert the input date/time into BCD values 
.................... // that are formatted for the PCF8583 registers. 
.................... bcd_sec = bin2bcd(dt->seconds); 
.................... bcd_min = bin2bcd(dt->minutes); 
.................... bcd_hrs = bin2bcd(dt->hours); 
.................... bcd_day = bin2bcd(dt->day) | (dt->year << 6); 
.................... bcd_mon = bin2bcd(dt->month) | (dt->weekday << 5); 
....................  
.................... // Stop the RTC from counting, before we write to 
.................... // the date and time registers. 
.................... PCF8583_write_byte(PCF8583_CTRL_STATUS_REG, 
....................                               PCF8583_STOP_COUNTING); 
....................  
.................... // Write to the date and time registers.  Disable interrupts 
.................... // so they can't disrupt the i2c operations. 
.................... disable_interrupts(GLOBAL); 
.................... i2c_start(); 
.................... i2c_write(PCF8583_WRITE_ADDRESS); 
.................... i2c_write(PCF8583_100S_REG);   // Start at 100's reg. 
.................... i2c_write(0x00);               // Set 100's reg = 0 
.................... i2c_write(bcd_sec); 
.................... i2c_write(bcd_min); 
.................... i2c_write(bcd_hrs); 
.................... i2c_write(bcd_day); 
.................... i2c_write(bcd_mon); 
.................... i2c_stop(); 
....................  
.................... // Write the year byte to the first NVRAM location. 
.................... // Leave it in binary format. 
.................... PCF8583_write_byte(PCF8583_YEAR_REG, dt->year); 
....................  
.................... // Now allow the PCF8583 to start counting again. 
.................... PCF8583_write_byte(PCF8583_CTRL_STATUS_REG, 
....................                               PCF8583_START_COUNTING); 
.................... } 
....................  
.................... //---------------------------------------------- 
.................... // Read the Date and Time from the hardware registers 
.................... // in the PCF8583.   We don't have to disable counting 
.................... // during read operations, because according to the data 
.................... // sheet, if any of the lower registers (1 to 7) is read, 
.................... // all of them are loaded into "capture" registers. 
.................... // All further reading within that cycle is done from 
.................... // those registers. 
....................  
.................... void PCF8583_read_datetime(date_time_t *dt) 
.................... { 
.................... int8 year_bits; 
.................... int8 year; 
....................  
.................... int8 bcd_sec; 
.................... int8 bcd_min; 
.................... int8 bcd_hrs; 
.................... int8 bcd_day; 
.................... int8 bcd_mon; 
....................  
.................... // Disable interrupts so the i2c process is not disrupted. 
.................... disable_interrupts(GLOBAL); 
*
10D6:  BCF    FF2.6
10D8:  BCF    FF2.7
10DA:  BTFSC  FF2.7
10DC:  BRA    10D8
....................  
.................... // Read the date/time registers inside the PCF8583. 
.................... i2c_start(); 
10DE:  BSF    F94.4
10E0:  NOP   
10E2:  NOP   
10E4:  BSF    F94.3
10E6:  NOP   
10E8:  NOP   
10EA:  NOP   
10EC:  BCF    F8B.4
10EE:  BCF    F94.4
10F0:  NOP   
10F2:  NOP   
10F4:  BCF    F8B.3
10F6:  BCF    F94.3
.................... i2c_write(PCF8583_WRITE_ADDRESS); 
10F8:  MOVLW  A0
10FA:  MOVLB  2
10FC:  MOVWF  x9E
10FE:  MOVLB  0
1100:  RCALL  0D90
.................... i2c_write(PCF8583_SECONDS_REG);   // Start at seconds reg. 
1102:  MOVLW  02
1104:  MOVLB  2
1106:  MOVWF  x9E
1108:  MOVLB  0
110A:  RCALL  0D90
.................... i2c_start(); 
110C:  BSF    F94.4
110E:  NOP   
1110:  NOP   
1112:  BSF    F94.3
1114:  NOP   
1116:  NOP   
1118:  NOP   
111A:  BTFSS  F82.3
111C:  BRA    111A
111E:  BCF    F8B.4
1120:  BCF    F94.4
1122:  NOP   
1124:  NOP   
1126:  BCF    F8B.3
1128:  BCF    F94.3
.................... i2c_write(PCF8583_READ_ADDRESS); 
112A:  MOVLW  A1
112C:  MOVLB  2
112E:  MOVWF  x9E
1130:  MOVLB  0
1132:  RCALL  0D90
....................  
.................... bcd_sec = i2c_read(); 
1134:  MOVLW  01
1136:  MOVWF  00
1138:  RCALL  0DF8
113A:  MOVFF  01,95
.................... bcd_min = i2c_read(); 
113E:  MOVLW  01
1140:  MOVWF  00
1142:  RCALL  0DF8
1144:  MOVFF  01,96
.................... bcd_hrs = i2c_read(); 
1148:  MOVLW  01
114A:  MOVWF  00
114C:  RCALL  0DF8
114E:  MOVFF  01,97
.................... bcd_day = i2c_read(); 
1152:  MOVLW  01
1154:  MOVWF  00
1156:  RCALL  0DF8
1158:  MOVFF  01,98
.................... bcd_mon = i2c_read(0); 
115C:  CLRF   00
115E:  RCALL  0DF8
1160:  MOVFF  01,99
.................... i2c_stop(); 
1164:  BCF    F94.4
1166:  NOP   
1168:  BSF    F94.3
116A:  BTFSS  F82.3
116C:  BRA    116A
116E:  NOP   
1170:  NOP   
1172:  NOP   
1174:  NOP   
1176:  NOP   
1178:  BSF    F94.4
117A:  NOP   
117C:  NOP   
....................  
....................  
.................... // Convert the date/time values from BCD to 
.................... // unsigned 8-bit integers.  Unpack the bits 
.................... // in the PCF8583 registers where required. 
.................... dt->seconds = bcd2bin(bcd_sec); 
117E:  MOVFF  91,01
1182:  MOVFF  92,03
1186:  MOVFF  91,9A
118A:  MOVFF  92,9B
118E:  MOVFF  95,9D
1192:  RCALL  0FD8
1194:  MOVFF  9B,FEA
1198:  MOVFF  9A,FE9
119C:  MOVFF  01,FEF
.................... dt->minutes = bcd2bin(bcd_min); 
11A0:  MOVLW  01
11A2:  ADDWF  x91,W
11A4:  MOVWF  01
11A6:  MOVLW  00
11A8:  ADDWFC x92,W
11AA:  MOVWF  03
11AC:  MOVFF  01,9A
11B0:  MOVWF  x9B
11B2:  MOVFF  96,9D
11B6:  RCALL  0FD8
11B8:  MOVFF  9B,FEA
11BC:  MOVFF  9A,FE9
11C0:  MOVFF  01,FEF
.................... dt->hours   = bcd2bin(bcd_hrs & 0x3F); 
11C4:  MOVLW  02
11C6:  ADDWF  x91,W
11C8:  MOVWF  01
11CA:  MOVLW  00
11CC:  ADDWFC x92,W
11CE:  MOVWF  03
11D0:  MOVFF  01,9A
11D4:  MOVWF  x9B
11D6:  MOVF   x97,W
11D8:  ANDLW  3F
11DA:  MOVWF  x9C
11DC:  MOVWF  x9D
11DE:  RCALL  0FD8
11E0:  MOVFF  9B,FEA
11E4:  MOVFF  9A,FE9
11E8:  MOVFF  01,FEF
.................... dt->day     = bcd2bin(bcd_day & 0x3F); 
11EC:  MOVLW  03
11EE:  ADDWF  x91,W
11F0:  MOVWF  01
11F2:  MOVLW  00
11F4:  ADDWFC x92,W
11F6:  MOVWF  03
11F8:  MOVFF  01,9A
11FC:  MOVWF  x9B
11FE:  MOVF   x98,W
1200:  ANDLW  3F
1202:  MOVWF  x9C
1204:  MOVWF  x9D
1206:  RCALL  0FD8
1208:  MOVFF  9B,FEA
120C:  MOVFF  9A,FE9
1210:  MOVFF  01,FEF
.................... dt->month   = bcd2bin(bcd_mon & 0x1F); 
1214:  MOVLW  04
1216:  ADDWF  x91,W
1218:  MOVWF  01
121A:  MOVLW  00
121C:  ADDWFC x92,W
121E:  MOVWF  03
1220:  MOVFF  01,9A
1224:  MOVWF  x9B
1226:  MOVF   x99,W
1228:  ANDLW  1F
122A:  MOVWF  x9C
122C:  MOVWF  x9D
122E:  RCALL  0FD8
1230:  MOVFF  9B,FEA
1234:  MOVFF  9A,FE9
1238:  MOVFF  01,FEF
.................... dt->weekday = bcd_mon >> 5; 
123C:  MOVLW  06
123E:  ADDWF  x91,W
1240:  MOVWF  FE9
1242:  MOVLW  00
1244:  ADDWFC x92,W
1246:  MOVWF  FEA
1248:  SWAPF  x99,W
124A:  MOVWF  00
124C:  RRCF   00,F
124E:  MOVLW  07
1250:  ANDWF  00,F
1252:  MOVFF  00,FEF
.................... year_bits   = bcd_day >> 6; 
1256:  SWAPF  x98,W
1258:  MOVWF  x93
125A:  RRCF   x93,F
125C:  RRCF   x93,F
125E:  MOVLW  03
1260:  ANDWF  x93,F
....................  
.................... // Read the year byte from NVRAM. 
.................... // This is an added feature of this driver. 
.................... year = PCF8583_read_byte(PCF8583_YEAR_REG); 
1262:  MOVLW  10
1264:  MOVWF  x9A
1266:  BRA    0FFE
1268:  MOVFF  01,94
....................  
.................... // Check if the two "year bits" were incremented by 
.................... // the PCF8583.  If so, increment the 8-bit year 
.................... // byte (read from NVRAM) by the same amount. 
.................... while(year_bits != (year & 3)) 
....................       year++; 
126C:  MOVF   x94,W
126E:  ANDLW  03
1270:  SUBWF  x93,W
1272:  BZ    1278
1274:  INCF   x94,F
1276:  BRA    126C
....................  
.................... dt->year = year; 
1278:  MOVLW  05
127A:  ADDWF  x91,W
127C:  MOVWF  FE9
127E:  MOVLW  00
1280:  ADDWFC x92,W
1282:  MOVWF  FEA
1284:  MOVFF  94,FEF
....................  
.................... // Now update the year byte in the NVRAM 
.................... // inside the PCF8583. 
.................... PCF8583_write_byte(PCF8583_YEAR_REG, year); 
1288:  MOVLW  10
128A:  MOVWF  x9A
128C:  MOVFF  94,9B
1290:  RCALL  1082
....................  
.................... } 
1292:  RETLW  00
....................  
.................... //Método que permite establecer una alarma, dados horas, minutos y segundos 
.................... //Author: Julio Navarro Lara 
.................... void PCF8583_establecer_alarma(int8 horas, int8 minutos, int8 segundos){ 
....................    int8 bcd_horas; 
....................    int8 bcd_minutos; 
....................    int8 bcd_segundos; 
....................  
....................    //Transformamos a BCD las horas y los minutos introducidos 
....................    bcd_horas = bin2bcd(horas); 
*
1364:  MOVFF  83,89
1368:  RCALL  1344
136A:  MOVFF  01,86
....................    bcd_minutos = bin2bcd(minutos); 
136E:  MOVFF  84,89
1372:  RCALL  1344
1374:  MOVFF  01,87
....................    bcd_segundos = bin2bcd(segundos); 
1378:  MOVFF  85,89
137C:  RCALL  1344
137E:  MOVFF  01,88
....................  
....................    //Paramos de contar el tiempo para escribir los datos 
....................    PCF8583_write_byte(PCF8583_CTRL_STATUS_REG, 
....................                               PCF8583_STOP_COUNTING); 
1382:  CLRF   x9A
1384:  MOVLW  80
1386:  MOVWF  x9B
1388:  RCALL  1082
....................  
....................    //Definimos las condiciones de la alarma 
....................    PCF8583_write_byte(PCF8583_ALARM_CONTROL_REG, 
....................                               PCF8583_DEFINIR_ALARMA); 
138A:  MOVLW  08
138C:  MOVWF  x9A
138E:  MOVLW  90
1390:  MOVWF  x9B
1392:  RCALL  1082
....................  
....................    //Desactivamos las interrupciones para que no interfieran en la escritura i2c 
....................    disable_interrupts(GLOBAL); 
1394:  BCF    FF2.6
1396:  BCF    FF2.7
1398:  BTFSC  FF2.7
139A:  BRA    1396
....................    i2c_start(); 
139C:  BSF    F94.4
139E:  NOP   
13A0:  NOP   
13A2:  BSF    F94.3
13A4:  NOP   
13A6:  NOP   
13A8:  NOP   
13AA:  BCF    F8B.4
13AC:  BCF    F94.4
13AE:  NOP   
13B0:  NOP   
13B2:  BCF    F8B.3
13B4:  BCF    F94.3
....................    i2c_write(PCF8583_WRITE_ADDRESS); 
13B6:  MOVLW  A0
13B8:  MOVLB  2
13BA:  MOVWF  x9E
13BC:  MOVLB  0
13BE:  RCALL  0D90
....................    //Escribimos en los registros de hora y minutos 
....................    i2c_write(PCF8583_ALARM_100S_REG); 
13C0:  MOVLW  09
13C2:  MOVLB  2
13C4:  MOVWF  x9E
13C6:  MOVLB  0
13C8:  RCALL  0D90
....................    i2c_write(0x00); 
13CA:  MOVLB  2
13CC:  CLRF   x9E
13CE:  MOVLB  0
13D0:  RCALL  0D90
....................    i2c_write(bcd_segundos); 
13D2:  MOVFF  88,29E
13D6:  RCALL  0D90
....................    i2c_write(bcd_minutos); 
13D8:  MOVFF  87,29E
13DC:  RCALL  0D90
....................    i2c_write(bcd_horas); 
13DE:  MOVFF  86,29E
13E2:  RCALL  0D90
....................    i2c_stop(); 
13E4:  BCF    F94.4
13E6:  NOP   
13E8:  BSF    F94.3
13EA:  BTFSS  F82.3
13EC:  BRA    13EA
13EE:  NOP   
13F0:  NOP   
13F2:  NOP   
13F4:  NOP   
13F6:  NOP   
13F8:  BSF    F94.4
13FA:  NOP   
13FC:  NOP   
....................  
....................    //OJO! No volvemos a activar las interrupciones por si llamamos al método 
....................    //dentro de una rutina de interrupción 
....................  
....................    //Activamos la alarma 
....................    PCF8583_write_byte(PCF8583_CTRL_STATUS_REG, 
....................                               PCF8583_ACTIVAR_ALARMA); 
13FE:  CLRF   x9A
1400:  MOVLW  04
1402:  MOVWF  x9B
1404:  RCALL  1082
....................  
....................  
....................  
....................    //Activamos el flag indicador de alarma 
....................    alarma_activada = TRUE; 
1406:  MOVLW  01
1408:  MOVWF  1E
....................  
.................... } 
140A:  RETLW  00
....................  
.................... #include "LCDeasy.c" 
.................... ////----------------------------------------------------------------------------//// 
.................... // 	Funciones para la gestion del display LCD de la EasyPIC3 
.................... //	con el compilador de CCS. 
.................... //	Es una adaptación del archivo LCD.c de CCS para las prácticas de la 
.................... //	asignatura, y por tanto no distribuible a usuarios no autorizados. 
.................... //------------------------------------------------------------------------------//// 
....................  
.................... //  lcd_init()   Inicializa el LCD: debe ser llamada antes que las otras funciones. 
.................... // 
.................... //  lcd_putc(c)  Visualiza c en la siguiente posición del display. 
.................... //               Caracteres especiales de control: 
.................... //                      \f  Borrar display 
.................... //                      \n  Saltar a la segunda linea 
.................... //                      \b  Retroceder una posición. 
.................... // 
.................... //  lcd_gotoxy(x,y) Selecciona la nueva posicion de escritura en el display. 
.................... //                  (la esquina superior izquierda es 1,1) 
.................... // 
.................... //  lcd_getc(x,y)   Devuelve el caracter de la posicion x,y del display. 
.................... //			(esta función no va en la EASYPIC3, pues R/W=0) 
.................... // 
.................... //  lcd_send_byte(rs,byte)	escribe byte en el registro de datos(con rs=1) o de 
.................... //				instrucciones (con rs=0). 
.................... //------------------------------------------------------------------------------// 
.................... // Conexion del LCD con el PIC: 
.................... //     RB0 -- 
.................... //     RB1 -- 
.................... //     RB2  rs 
.................... //     RB3  Enable 
.................... //     RB4  D4 
.................... //     RB5  D5 
.................... //     RB6  D6 
.................... //     RB7  D7 
.................... // 
.................... // Los pines D0-D3 del LCD no se usan 
.................... // El pin RB0 del PIC no se usa 
.................... // El pin RB1 no está conectado en la tarjeta, 
.................... // podría ser para r/w 
....................  
.................... // Un-comment the following define to use port B 
.................... #define use_portb_lcd TRUE 		//LINEA DES-COMENTADA---------------- 
....................  
....................  
.................... struct lcd_pin_map {                 // This structure is overlayed 
....................            int unused : 2 ;	//MODIFICADA PARA EASYPIC-------------------- 
.................... 	   //BOOLEAN rw;		//MODIFICADA PARA EASYPIC-------------------- 
.................... 	   BOOLEAN rs;           // on to an I/O port to gain 
....................            BOOLEAN ENABLE;            // access to the LCD pins. 
....................            		           	// The bits are allocated from 
....................            			          // low order up.  ENABLE will 
....................            int     data : 4;         	// be pin B3------------------------- 
....................         } lcd; 
....................  
....................  
.................... #if defined(__PCH__) 
.................... #if defined use_portb_lcd 
....................    #byte lcd = 0xF81                   // This puts the entire structure 
.................... #else 
....................    #byte lcd = 0xF83                   // This puts the entire structure 
.................... #endif 
.................... #else 
.................... #if defined use_portb_lcd 
....................    #byte lcd = 6                  // on to port B (at address 6) 
.................... #else 
....................    #byte lcd = 8                 // on to port D (at address 8) 
.................... #endif 
.................... #endif 
....................  
.................... #if defined use_portb_lcd 
....................    #define set_tris_lcd(x) set_tris_b(x) 
.................... #else 
....................    #define set_tris_lcd(x) set_tris_d(x) 
.................... #endif 
....................  
....................  
.................... #define lcd_type 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #define lcd_line_two 0x40    // LCD RAM address for the second line 
....................  
....................  
.................... BYTE const LCD_INIT_STRING[4] = {0x24 | (lcd_type << 2), 0xF, 1, 6}; 
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................  
....................  
....................                              // The following are used for setting 
....................                              // the I/O port direction register. 
....................  
.................... struct lcd_pin_map const LCD_WRITE = {3,0,0,0}; // For write mode all pins are out 
.................... struct lcd_pin_map const LCD_READ = {3,0,0,15}; // For read mode data pins are in 
....................  
....................  
....................  
.................... BYTE lcd_read_byte() { 
....................       BYTE low,high; 
....................       set_tris_lcd(LCD_READ); 
....................       //////lcd.rw = 1; 
....................       delay_cycles(1); 
....................       lcd.enable = 1; 
....................       delay_cycles(1); 
....................       high = lcd.data; 
....................       lcd.enable = 0; 
....................       delay_cycles(1); 
....................       lcd.enable = 1; 
....................       delay_us(1); 
....................       low = lcd.data; 
....................       lcd.enable = 0; 
....................       set_tris_lcd(LCD_WRITE); 
....................       return( (high<<4) | low); 
.................... } 
....................  
....................  
.................... void lcd_send_nibble( BYTE n ) { 
....................       lcd.data = n; 
*
0C1A:  MOVLB  2
0C1C:  SWAPF  x9B,W
0C1E:  ANDLW  F0
0C20:  MOVWF  00
0C22:  MOVLW  0F
0C24:  ANDWF  F81,W
0C26:  IORWF  00,W
0C28:  MOVWF  F81
....................       delay_cycles(1); 
0C2A:  NOP   
....................       lcd.enable = 1; 
0C2C:  BSF    F81.3
....................       delay_us(2); 
0C2E:  CLRWDT
0C30:  NOP   
0C32:  NOP   
0C34:  NOP   
....................       lcd.enable = 0; 
0C36:  BCF    F81.3
.................... } 
0C38:  MOVLB  0
0C3A:  RETLW  00
....................  
....................  
.................... void lcd_send_byte( BYTE address, BYTE n ) { 
....................  
....................       lcd.rs = 0; 
*
0C60:  BCF    F81.2
....................       delay_us(3000); 
0C62:  CLRWDT
0C64:  MOVLW  02
0C66:  MOVLB  2
0C68:  MOVWF  x9A
0C6A:  MOVLB  0
0C6C:  RCALL  0BE8
0C6E:  MOVLW  09
0C70:  MOVLB  2
0C72:  MOVWF  x9A
0C74:  MOVLW  6D
0C76:  MOVWF  x9B
0C78:  MOVLB  0
0C7A:  RCALL  0C3C
0C7C:  MOVLB  2
0C7E:  DECFSZ x9A,F
0C80:  BRA    0C74
.................... //      while ( bit_test(lcd_read_byte(),7) ) ; 
....................       lcd.rs = address; 
0C82:  BTFSS  x98.0
0C84:  BCF    F81.2
0C86:  BTFSC  x98.0
0C88:  BSF    F81.2
....................       delay_cycles(1); 
0C8A:  NOP   
....................       //////////lcd.rw = 0; 
....................       delay_cycles(1); 
0C8C:  NOP   
....................       lcd.enable = 0; 
0C8E:  BCF    F81.3
....................       lcd_send_nibble(n >> 4); 
0C90:  SWAPF  x99,W
0C92:  MOVWF  x9A
0C94:  MOVLW  0F
0C96:  ANDWF  x9A,F
0C98:  MOVFF  29A,29B
0C9C:  MOVLB  0
0C9E:  RCALL  0C1A
....................       lcd_send_nibble(n & 0xf); 
0CA0:  MOVLB  2
0CA2:  MOVF   x99,W
0CA4:  ANDLW  0F
0CA6:  MOVWF  x9A
0CA8:  MOVWF  x9B
0CAA:  MOVLB  0
0CAC:  RCALL  0C1A
.................... } 
0CAE:  RETLW  00
....................  
....................  
.................... void lcd_init() { 
....................     BYTE i; 
....................     set_tris_lcd(LCD_WRITE); 
0CB0:  MOVLW  03
0CB2:  MOVWF  F93
....................     lcd.rs = 0; 
0CB4:  BCF    F81.2
....................     /////lcd.rw = 0; 
....................     lcd.enable = 0; 
0CB6:  BCF    F81.3
....................     delay_ms(50); 
0CB8:  MOVLW  32
0CBA:  MOVLB  2
0CBC:  MOVWF  x9A
0CBE:  MOVLB  0
0CC0:  RCALL  0BE8
....................     //for(i=1;i<=3;++i) { 
....................     //   lcd_send_nibble(3); 
....................     //  delay_ms(5); 
....................     //} 
....................     lcd_send_nibble(2); 
0CC2:  MOVLW  02
0CC4:  MOVLB  2
0CC6:  MOVWF  x9B
0CC8:  MOVLB  0
0CCA:  RCALL  0C1A
....................     delay_ms(5); 
0CCC:  MOVLW  05
0CCE:  MOVLB  2
0CD0:  MOVWF  x9A
0CD2:  MOVLB  0
0CD4:  RCALL  0BE8
....................     for(i=0;i<=3;++i) 
0CD6:  CLRF   x81
0CD8:  MOVF   x81,W
0CDA:  SUBLW  03
0CDC:  BNC   0D0A
....................        { lcd_send_byte(0,LCD_INIT_STRING[i]); 
0CDE:  CLRF   03
0CE0:  MOVF   x81,W
0CE2:  MOVFF  FF2,82
0CE6:  BCF    FF2.7
0CE8:  CALL   00A8
0CEC:  BTFSC  x82.7
0CEE:  BSF    FF2.7
0CF0:  MOVWF  x83
0CF2:  MOVLB  2
0CF4:  CLRF   x98
0CF6:  MOVWF  x99
0CF8:  MOVLB  0
0CFA:  RCALL  0C60
....................         delay_ms(5); } 
0CFC:  MOVLW  05
0CFE:  MOVLB  2
0D00:  MOVWF  x9A
0D02:  MOVLB  0
0D04:  RCALL  0BE8
0D06:  INCF   x81,F
0D08:  BRA    0CD8
.................... } 
0D0A:  GOTO   4C0C (RETURN)
....................  
....................  
.................... void lcd_gotoxy( BYTE x, BYTE y) { 
....................    BYTE address; 
....................  
....................    if(y!=1) 
0D0E:  MOVLB  2
0D10:  DECFSZ x95,W
0D12:  BRA    0D16
0D14:  BRA    0D1C
....................      address=lcd_line_two; 
0D16:  MOVLW  40
0D18:  MOVWF  x96
....................    else 
0D1A:  BRA    0D1E
....................      address=0; 
0D1C:  CLRF   x96
....................    address+=x-1; 
0D1E:  MOVLW  01
0D20:  SUBWF  x94,W
0D22:  ADDWF  x96,F
....................    lcd_send_byte(0,0x80|address); 
0D24:  MOVF   x96,W
0D26:  IORLW  80
0D28:  MOVWF  x97
0D2A:  CLRF   x98
0D2C:  MOVWF  x99
0D2E:  MOVLB  0
0D30:  RCALL  0C60
.................... } 
0D32:  RETLW  00
....................  
.................... void lcd_putc( char c) { 
....................    switch (c) { 
0D34:  MOVLB  2
0D36:  MOVF   x93,W
0D38:  XORLW  0C
0D3A:  MOVLB  0
0D3C:  BZ    0D48
0D3E:  XORLW  06
0D40:  BZ    0D60
0D42:  XORLW  02
0D44:  BZ    0D70
0D46:  BRA    0D7E
....................      case '\f'   : lcd_send_byte(0,1); 
0D48:  MOVLB  2
0D4A:  CLRF   x98
0D4C:  MOVLW  01
0D4E:  MOVWF  x99
0D50:  MOVLB  0
0D52:  RCALL  0C60
....................                    delay_ms(2); 
0D54:  MOVLW  02
0D56:  MOVLB  2
0D58:  MOVWF  x9A
0D5A:  MOVLB  0
0D5C:  RCALL  0BE8
....................                                            break; 
0D5E:  BRA    0D8E
....................      case '\n'   : lcd_gotoxy(1,2);        break; 
0D60:  MOVLW  01
0D62:  MOVLB  2
0D64:  MOVWF  x94
0D66:  MOVLW  02
0D68:  MOVWF  x95
0D6A:  MOVLB  0
0D6C:  RCALL  0D0E
0D6E:  BRA    0D8E
....................      case '\b'   : lcd_send_byte(0,0x10);  break; 
0D70:  MOVLB  2
0D72:  CLRF   x98
0D74:  MOVLW  10
0D76:  MOVWF  x99
0D78:  MOVLB  0
0D7A:  RCALL  0C60
0D7C:  BRA    0D8E
....................      default     : lcd_send_byte(1,c);     break; 
0D7E:  MOVLW  01
0D80:  MOVLB  2
0D82:  MOVWF  x98
0D84:  MOVFF  293,299
0D88:  MOVLB  0
0D8A:  RCALL  0C60
0D8C:  BRA    0D8E
....................    } 
.................... } 
0D8E:  RETLW  00
....................  
.................... char lcd_getc( BYTE x, BYTE y) { 
....................    char value; 
....................  
....................     lcd_gotoxy(x,y); 
....................     while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................     lcd.rs=1; 
....................     value = lcd_read_byte(); 
....................     lcd.rs=0; 
....................     return(value); 
.................... } 
....................  
.................... #include "1wire.c" 
.................... /***********************1Wire Class***********************/ 
.................... /*Funciones básicas para comunicación con un solo sensor 1wire */ 
.................... /*********************************************************/ 
.................... /*-------1-wire definitions-------*/ 
....................  
.................... #define ONE_WIRE_PIN PIN_A5 //modificar de acuerdo con la tarjeta 
....................  
....................  
.................... /************onewire_reset*************************************************/ 
.................... void onewire_reset()  // OK if just using a single permanently connected device 
.................... { 
....................  output_low(ONE_WIRE_PIN); 
*
1454:  BCF    F92.5
1456:  BCF    F89.5
....................  delay_us( 500 ); // pull 1-wire low for reset pulse 
1458:  CLRWDT
145A:  MOVLW  02
145C:  MOVWF  x9A
145E:  MOVLW  F7
1460:  MOVLB  2
1462:  MOVWF  x9B
1464:  MOVLB  0
1466:  CALL   0C3C
146A:  DECFSZ x9A,F
146C:  BRA    145E
....................  output_float(ONE_WIRE_PIN); // float 1-wire high 
146E:  BSF    F92.5
....................  delay_us( 500 ); // wait-out remaining initialisation window. 
1470:  CLRWDT
1472:  MOVLW  02
1474:  MOVWF  x9A
1476:  MOVLW  F7
1478:  MOVLB  2
147A:  MOVWF  x9B
147C:  MOVLB  0
147E:  CALL   0C3C
1482:  DECFSZ x9A,F
1484:  BRA    1476
....................  output_float(ONE_WIRE_PIN); 
1486:  BSF    F92.5
.................... } 
1488:  RETLW  00
....................  
.................... /*********************** onewire_write() ********************************/ 
.................... /*Esta función escribe un byte en el sensor.*/ 
.................... /* */ 
.................... /*Parametros: byte - el byte a escribir en el 1wire */ 
....................  
.................... void onewire_write(int data) 
.................... { 
....................  int count; 
....................  
....................  for (count=0; count<8; ++count) 
148A:  CLRF   x9B
148C:  MOVF   x9B,W
148E:  SUBLW  07
1490:  BNC   14C6
....................  { 
....................   output_low(ONE_WIRE_PIN); 
1492:  BCF    F92.5
1494:  BCF    F89.5
....................   delay_us( 2 ); // pull 1-wire low to initiate write time-slot. 
1496:  CLRWDT
1498:  NOP   
149A:  NOP   
149C:  NOP   
....................   output_bit(ONE_WIRE_PIN, shift_right(&data,1,0)); // set output bit on 1-wire 
149E:  BCF    FD8.0
14A0:  RRCF   x9A,F
14A2:  BC    14A8
14A4:  BCF    F89.5
14A6:  BRA    14AA
14A8:  BSF    F89.5
14AA:  BCF    F92.5
....................   delay_us( 60 ); // wait until end of write slot. 
14AC:  CLRWDT
14AE:  MOVLW  27
14B0:  MOVWF  00
14B2:  DECFSZ 00,F
14B4:  BRA    14B2
14B6:  NOP   
....................   output_float(ONE_WIRE_PIN); // set 1-wire high again, 
14B8:  BSF    F92.5
....................   delay_us( 2 ); // for more than 1us minimum. 
14BA:  CLRWDT
14BC:  NOP   
14BE:  NOP   
14C0:  NOP   
....................  } 
14C2:  INCF   x9B,F
14C4:  BRA    148C
.................... } 
14C6:  RETLW  00
....................  
.................... /*********************** read1wire() *********************************/ 
.................... /*Esta función lee un dato de 8 bits del sensor.*/ 
.................... /*Devuelve: dato de 8-bit (1-byte)*/ 
....................  
.................... int onewire_read() 
.................... { 
....................  int count, data; 
....................  
....................  for (count=0; count<8; ++count) 
14C8:  CLRF   x9A
14CA:  MOVF   x9A,W
14CC:  SUBLW  07
14CE:  BNC   150A
....................  { 
....................   output_low(ONE_WIRE_PIN); 
14D0:  BCF    F92.5
14D2:  BCF    F89.5
....................   delay_us( 2 ); // pull 1-wire low to initiate read time-slot. 
14D4:  CLRWDT
14D6:  NOP   
14D8:  NOP   
14DA:  NOP   
....................   output_float(ONE_WIRE_PIN); // now let 1-wire float high, 
14DC:  BSF    F92.5
....................   delay_us( 8 ); // let device state stabilise, 
14DE:  CLRWDT
14E0:  MOVLW  04
14E2:  MOVWF  00
14E4:  DECFSZ 00,F
14E6:  BRA    14E4
14E8:  NOP   
14EA:  NOP   
....................   shift_right(&data,1,input(ONE_WIRE_PIN)); // and load result. 
14EC:  BSF    F92.5
14EE:  BTFSC  F80.5
14F0:  BRA    14F6
14F2:  BCF    FD8.0
14F4:  BRA    14F8
14F6:  BSF    FD8.0
14F8:  RRCF   x9B,F
....................   delay_us( 120 ); // wait until end of read slot. 
14FA:  CLRWDT
14FC:  MOVLW  4F
14FE:  MOVWF  00
1500:  DECFSZ 00,F
1502:  BRA    1500
1504:  NOP   
....................  } 
1506:  INCF   x9A,F
1508:  BRA    14CA
....................  
....................  return( data ); 
150A:  MOVFF  9B,01
.................... } 
150E:  RETLW  00
....................  
.................... /////////////////////////////////////////////////////////////////// 
....................  
....................  
....................  
.................... #include "ds1820.c" 
....................  
.................... /***************************************************/ 
.................... /*Driver básico del termómetro/termostato ds1820.c */ 
.................... // 
.................... //Realiza una secuencia completa de incialización, conversión 
.................... //de temperatura, y lectura del (único) sensor de temperatura 
.................... //con alimentación externa (no parásita). 
.................... // 
.................... /***************************************************/ 
....................  
.................... float ds1820_read() 
.................... { 
....................  int8 busy=0, temp1, temp2; 
*
16BC:  CLRF   x91
....................  signed int16 temp3; 
....................  float result; 
....................  
....................  onewire_reset();     // Cada acceso al sensor debe iniciarse con reset 
16BE:  RCALL  1454
....................  onewire_write(0xCC); //Instrucción SKIP ROM (selecciona todos los dispositivos del 1wire) 
16C0:  MOVLW  CC
16C2:  MOVWF  x9A
16C4:  RCALL  148A
....................  onewire_write(0x44); //Orden de inicio de conversión de temperatura 
16C6:  MOVLW  44
16C8:  MOVWF  x9A
16CA:  RCALL  148A
....................  
....................  while (busy == 0) 	//el sensor mantiene la linea a 0 mientras realiza la conversión 
....................   busy = onewire_read(); //y la deja a 1 al completarla 
16CC:  MOVF   x91,F
16CE:  BNZ   16D8
16D0:  RCALL  14C8
16D2:  MOVFF  01,91
16D6:  BRA    16CC
....................  
....................  onewire_reset(); 
16D8:  RCALL  1454
....................  onewire_write(0xCC); 
16DA:  MOVLW  CC
16DC:  MOVWF  x9A
16DE:  RCALL  148A
....................  onewire_write(0xBE); //Envío de la orden READ SCRATCHPAD (lectura de la memoria temporal) 
16E0:  MOVLW  BE
16E2:  MOVWF  x9A
16E4:  RCALL  148A
....................  temp1 = onewire_read(); //lectura del LSB de la temperatura 
16E6:  RCALL  14C8
16E8:  MOVFF  01,92
....................  temp2 = onewire_read(); //lectura del MSB de la temperatura 
16EC:  RCALL  14C8
16EE:  MOVFF  01,93
....................  
....................  temp3 = make16(temp2, temp1); // 
16F2:  MOVFF  93,95
16F6:  MOVFF  92,94
....................  result = (float) temp3 / 2.0;   //Calculation for DS18S20 with 0.5 deg C resolution 
16FA:  MOVFF  95,9B
16FE:  MOVFF  94,9A
1702:  BRA    1510
1704:  MOVFF  00,9A
1708:  MOVFF  01,9B
170C:  MOVFF  02,9C
1710:  MOVFF  03,9D
1714:  MOVFF  03,29B
1718:  MOVFF  02,29A
171C:  MOVFF  01,299
1720:  MOVFF  00,298
1724:  MOVLB  2
1726:  CLRF   x9F
1728:  CLRF   x9E
172A:  CLRF   x9D
172C:  MOVLW  80
172E:  MOVWF  x9C
1730:  MOVLB  0
1732:  RCALL  155C
1734:  MOVFF  03,99
1738:  MOVFF  02,98
173C:  MOVFF  01,97
1740:  MOVFF  00,96
.................... // result = (float) temp3 / 16.0;  //Calculation for DS18B20 with 0.1 deg C resolution 
....................  
....................  delay_ms(200); 
1744:  MOVLW  C8
1746:  MOVLB  2
1748:  MOVWF  x9A
174A:  MOVLB  0
174C:  CALL   0BE8
....................  return(result); 
1750:  MOVFF  96,00
1754:  MOVFF  97,01
1758:  MOVFF  98,02
175C:  MOVFF  99,03
.................... } 
1760:  RETLW  00
....................  
.................... //Las siguientes funciones al final no las hemos usado en el programa. 
.................... //De todas formas, las mantenemos aquí por si son necesarias en otra ocasión. 
....................  
.................... //Establece la temperatura máxima y mínima para el termostato 
.................... void ds1820_establecer_TH_TL(float th, float tl){ 
....................    float th2, tl2; 
....................    onewire_reset(); 
....................    onewire_write(0xCC); //Accedemos a todos los dispositivos 
....................    onewire_write(0x4E); //Envío de la orden Write Scratchpad (escritura en la memoria principal) 
....................    th2=2*th; 
....................    tl2=2*tl; 
....................    onewire_write((int8)th2); 
....................    onewire_write((int8)tl2); 
....................  
....................    //Copiamos los valores en la ROM 
....................    onewire_reset(); 
....................    onewire_write(0xCC); 
....................    onewire_write(0x48); 
....................  
....................    //Dejamos un poco de tiempo para que se escriba en la EEPROM 
....................    //El tiempo ha sido calculado a partir de la simulación en Proteus 
....................    delay_us(10600); 
....................  
.................... } 
....................  
.................... //Intenta buscar la alarma del dispositivo por si ha saltado el termostato 
.................... void ds1820_termostato(){ 
....................    int8 busy=0; 
....................  
....................    onewire_reset(); 
....................    onewire_write(0xCC); 
....................    onewire_write(0x44); 
....................  
....................    while(busy == 0) 
....................       busy = onewire_read(); 
....................  
....................    onewire_reset(); 
....................    onewire_write(0xEC); //Buscamos la alarma de algún dispositivo (función ALARM SEARCH) 
....................  
.................... } 
....................  
.................... ////////////////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #include "teclado.c" 
.................... //*********************************************************************************** 
.................... // Método que permite gestionar un teclado matricial de 4x3 conectado a los pines 
.................... // B4B5B6B7 (filas) y a los D0D1D2 (columnas). El puerto D deberá estar definido como 
.................... // port_d y los bits utilizados de B deberán ser "tecladox", dónde x va de 1 a 4 
.................... //*********************************************************************************** 
.................... //Author: Julio Navarro Lara 
....................  
.................... //Definimos los caracteres que corresponden a cada botón del teclado 
.................... const char caracteres[12]={'1','2','3','4','5','6','7','8','9','S','0','N'}; 
....................  
.................... //Método para detectar la pulsación de una tecla. Devuelve el caracter pulsado. 
.................... char find_key() 
.................... { 
....................    //Variables auxiliares 
....................    int8 fila, columna, temp, contador, puertoB; 
....................    char key = 0; //Tecla pulsada 
*
2120:  MOVLB  2
2122:  CLRF   x98
....................  
....................    //Recorremos las filas forzando un valor con el puerto B para detectar 
....................    //la tecla pulsada 
....................    for(fila=0; fila < NUM_FILAS; fila++){ 
2124:  CLRF   x93
2126:  MOVF   x93,W
2128:  SUBLW  03
212A:  BTFSS  FD8.0
212C:  BRA    220E
....................  
....................       //Forzamos la salida de B a que tenga todo 1 menos la posición a inspeccionar 
....................       puertoB = ~(1 << fila); 
212E:  MOVLW  01
2130:  MOVWF  00
2132:  MOVF   x93,W
2134:  MOVWF  01
2136:  BZ    2140
2138:  BCF    FD8.0
213A:  RLCF   00,F
213C:  DECFSZ 01,F
213E:  BRA    2138
2140:  MOVF   00,W
2142:  XORLW  FF
2144:  MOVWF  x97
....................       teclado1 = puertoB & 0b1; 
2146:  MOVF   x97,W
2148:  ANDLW  01
214A:  MOVWF  01
214C:  BTFSC  FE8.0
214E:  BRA    2154
2150:  BCF    F81.4
2152:  BRA    2156
2154:  BSF    F81.4
....................       teclado2 = (puertoB & 0b10) >> 1; 
2156:  MOVF   x97,W
2158:  ANDLW  02
215A:  MOVWF  00
215C:  BCF    FD8.0
215E:  RRCF   00,F
2160:  MOVFF  00,01
2164:  BTFSC  00.0
2166:  BRA    216C
2168:  BCF    F81.5
216A:  BRA    216E
216C:  BSF    F81.5
....................       teclado3 = (puertoB & 0b100) >> 2; 
216E:  MOVF   x97,W
2170:  ANDLW  04
2172:  MOVWF  00
2174:  RRCF   00,F
2176:  RRCF   00,F
2178:  MOVLW  3F
217A:  ANDWF  00,F
217C:  MOVFF  00,01
2180:  BTFSC  00.0
2182:  BRA    2188
2184:  BCF    F81.6
2186:  BRA    218A
2188:  BSF    F81.6
....................       teclado4 = (puertoB & 0b1000) >> 3; 
218A:  MOVF   x97,W
218C:  ANDLW  08
218E:  MOVWF  00
2190:  RRCF   00,F
2192:  RRCF   00,F
2194:  RRCF   00,F
2196:  MOVLW  1F
2198:  ANDWF  00,F
219A:  MOVFF  00,01
219E:  BTFSC  00.0
21A0:  BRA    21A6
21A2:  BCF    F81.7
21A4:  BRA    21A8
21A6:  BSF    F81.7
....................  
....................       //Introducimos un poco de retraso 
....................       for(contador=0; contador<100; contador++); 
21A8:  CLRF   x96
21AA:  MOVF   x96,W
21AC:  SUBLW  63
21AE:  BNC   21B4
21B0:  INCF   x96,F
21B2:  BRA    21AA
....................  
....................       //Guardamos el valor que aparece en el puerto D 
....................       //(en sus 3 bits menos significativos) 
....................       temp = port_d & 0b00000111; 
21B4:  MOVF   F83,W
21B6:  ANDLW  07
21B8:  MOVWF  x95
....................  
....................       //Iteramos en base a esto para ver si alguna columna está activa 
....................       //Una vez localizada la columna, podemos encontrar el caracter teniendo en cuenta 
....................       //también la fila que está activa. 
....................       for(columna=0; columna < NUM_COLUMNAS; columna++){ 
21BA:  CLRF   x94
21BC:  MOVF   x94,W
21BE:  SUBLW  02
21C0:  BNC   220A
....................  
....................          //Realizamos la operación AND entre el valor que hay y un 1 desplazado 
....................          //según la columna que nos encontremos 
....................          if((temp & (1 << columna))==0) 
21C2:  MOVLW  01
21C4:  MOVWF  00
21C6:  MOVF   x94,W
21C8:  MOVWF  01
21CA:  BZ    21D4
21CC:  BCF    FD8.0
21CE:  RLCF   00,F
21D0:  DECFSZ 01,F
21D2:  BRA    21CC
21D4:  MOVF   00,W
21D6:  ANDWF  x95,W
21D8:  BNZ   2206
....................          { 
....................             //Si da 0, hemos localizado la columna dónde se encuentra la tecla 
....................             //Guardamos su índice teniendo en cuenta que las teclas se numeran de izquierda a derecha y 
....................             //de arriba a abajo. 
....................             int8 index; 
....................             index = (fila*NUM_COLUMNAS)+(2-columna); 
21DA:  MOVF   x93,W
21DC:  MULLW  03
21DE:  MOVFF  FF3,29A
21E2:  MOVLW  02
21E4:  BSF    FD8.0
21E6:  SUBFWB x94,W
21E8:  ADDWF  x9A,W
21EA:  MOVWF  x99
....................  
....................             //Buscamos la tecla a la que se hace referencia 
....................             key = caracteres[index]; 
21EC:  CLRF   03
21EE:  MOVF   x99,W
21F0:  MOVFF  FF2,29A
21F4:  BCF    FF2.7
21F6:  MOVLB  0
21F8:  CALL   00C6
21FC:  MOVLB  2
21FE:  BTFSC  x9A.7
2200:  BSF    FF2.7
2202:  MOVWF  x98
....................  
....................             //Saltamos para salirnos del bucle 
....................             goto hecho; 
2204:  BRA    220E
....................  
....................          } 
....................  
....................       } 
2206:  INCF   x94,F
2208:  BRA    21BC
....................    } 
220A:  INCF   x93,F
220C:  BRA    2126
....................  
....................    hecho: 
....................  
....................    //Devolvemos el caracter 
....................    return key; 
220E:  MOVFF  298,01
....................  
.................... } 
2212:  MOVLB  0
2214:  RETLW  00
....................  
.................... //Devuelve la tecla pulsada, esperando a que el usuario la suelte 
.................... char get_key() 
.................... { 
....................    char key; 
....................    //Detectamos la tecla pulsada 
....................    key=find_key(); 
2216:  RCALL  2120
2218:  MOVFF  01,292
....................    //Si se pulsa alguna tecla, nos esperamos hasta que se suelte para recoger el valor 
....................    if(key) 
221C:  MOVLB  2
221E:  MOVF   x92,F
2220:  BZ    2232
....................       while(find_key() != 0); 
2222:  MOVLB  0
2224:  RCALL  2120
2226:  MOVF   01,F
2228:  BTFSC  FD8.2
222A:  BRA    2230
222C:  MOVLB  2
222E:  BRA    2222
2230:  MOVLB  2
....................    return key; 
2232:  MOVFF  292,01
.................... } 
2236:  MOVLB  0
2238:  RETLW  00
....................  
....................  
....................  
.................... #include "eeprom.c" 
.................... //****************************************************** 
.................... //Programa para escritura y lectura de la memoria EEPROM 
.................... //****************************************************** 
.................... //Author: Julio Navarro Lara 
....................  
....................  
.................... //Definimos las palabras de control, que constan de tres partes 
.................... //   - Los bits más altos de direccionamiento del dispositivo (fijos): 1010 
.................... //   - Los bits de dirección configurables A2A1A0: 111 (en este caso) 
.................... //   - El bit R/W', 1 para lectura y 0 para escritura 
.................... #define CONTROL_W 0b10101110 
.................... #define CONTROL_R 0b10101111 
....................  
.................... void graba_ee(long int dir, int tam, int *wdata) 
.................... { 
....................    boolean ack; 
....................    int i; 
....................    //Escribimos la palabra de control 
....................    do{ 
....................       i2c_start(); 
*
1E54:  BSF    F94.4
1E56:  NOP   
1E58:  NOP   
1E5A:  BSF    F94.3
1E5C:  NOP   
1E5E:  NOP   
1E60:  NOP   
1E62:  BCF    F8B.4
1E64:  BCF    F94.4
1E66:  NOP   
1E68:  NOP   
1E6A:  BCF    F8B.3
1E6C:  BCF    F94.3
....................       ack=i2c_write(CONTROL_W); 
1E6E:  MOVLW  AE
1E70:  MOVLB  2
1E72:  MOVWF  x9E
1E74:  MOVLB  0
1E76:  CALL   0D90
1E7A:  MOVF   01,W
1E7C:  BTFSC  01.0
1E7E:  BRA    1E84
1E80:  BCF    x9C.0
1E82:  BRA    1E86
1E84:  BSF    x9C.0
....................    }while(ack); //Esperamos a que el dispositivo responda 
1E86:  BTFSC  x9C.0
1E88:  BRA    1E54
....................    //Cuando está listo, devuelve un ACK como 0 
....................    //Mandamos la dirección en la que se quiere escribir 
....................    i2c_write(dir>>8); 
1E8A:  MOVFF  98,9E
1E8E:  CLRF   x9F
1E90:  MOVFF  98,29E
1E94:  CALL   0D90
....................    i2c_write(dir & 255); 
1E98:  MOVFF  97,9E
1E9C:  CLRF   x9F
1E9E:  MOVFF  97,29E
1EA2:  CALL   0D90
....................  
....................    //Escribimos los datos contenidos en wdata 
....................    for(i=0;i<tam;i++){ 
1EA6:  CLRF   x9D
1EA8:  MOVF   x99,W
1EAA:  SUBWF  x9D,W
1EAC:  BC    1ED0
....................       i2c_write(*wdata); 
1EAE:  MOVFF  9B,03
1EB2:  MOVFF  9A,FE9
1EB6:  MOVFF  9B,FEA
1EBA:  MOVFF  FEF,9E
1EBE:  MOVFF  9E,29E
1EC2:  CALL   0D90
....................       wdata++; 
1EC6:  INCF   x9A,F
1EC8:  BTFSC  FD8.2
1ECA:  INCF   x9B,F
....................    } 
1ECC:  INCF   x9D,F
1ECE:  BRA    1EA8
....................  
....................    //Finalizamos la comunicación 
....................    i2c_stop(); 
1ED0:  BCF    F94.4
1ED2:  NOP   
1ED4:  BSF    F94.3
1ED6:  BTFSS  F82.3
1ED8:  BRA    1ED6
1EDA:  NOP   
1EDC:  NOP   
1EDE:  NOP   
1EE0:  NOP   
1EE2:  NOP   
1EE4:  BSF    F94.4
1EE6:  NOP   
1EE8:  NOP   
.................... } 
1EEA:  RETLW  00
....................  
.................... void lee_ee(long int dir, int tam, int8 *rdata) 
.................... { 
....................    boolean ack; 
....................    int i; 
....................    //Comenzamos escribiendo la dirección que queremos consultar 
....................    //al igual que ya hicimos con el método de escritura 
....................    do{ 
....................       i2c_start(); 
*
0E54:  BSF    F94.4
0E56:  NOP   
0E58:  NOP   
0E5A:  BSF    F94.3
0E5C:  NOP   
0E5E:  NOP   
0E60:  NOP   
0E62:  BCF    F8B.4
0E64:  BCF    F94.4
0E66:  NOP   
0E68:  NOP   
0E6A:  BCF    F8B.3
0E6C:  BCF    F94.3
....................       ack=i2c_write(CONTROL_W); 
0E6E:  MOVLW  AE
0E70:  MOVLB  2
0E72:  MOVWF  x9E
0E74:  MOVLB  0
0E76:  RCALL  0D90
0E78:  MOVF   01,W
0E7A:  BTFSC  01.0
0E7C:  BRA    0E84
0E7E:  MOVLB  2
0E80:  BCF    x9A.0
0E82:  BRA    0E88
0E84:  MOVLB  2
0E86:  BSF    x9A.0
....................    }while(ack); //Esperamos a que el dispositivo responda 
0E88:  BTFSS  x9A.0
0E8A:  BRA    0E90
0E8C:  MOVLB  0
0E8E:  BRA    0E54
....................    i2c_write(dir>>8); 
0E90:  MOVFF  296,29C
0E94:  CLRF   x9D
0E96:  MOVFF  296,29E
0E9A:  MOVLB  0
0E9C:  RCALL  0D90
....................    i2c_write(dir & 255); 
0E9E:  MOVLB  2
0EA0:  MOVFF  295,29C
0EA4:  CLRF   x9D
0EA6:  MOVFF  295,29E
0EAA:  MOVLB  0
0EAC:  RCALL  0D90
....................  
....................    //Reiniciamos la comunicación para leer los datos 
....................    i2c_start(); 
0EAE:  BSF    F94.4
0EB0:  NOP   
0EB2:  NOP   
0EB4:  BSF    F94.3
0EB6:  NOP   
0EB8:  NOP   
0EBA:  NOP   
0EBC:  BTFSS  F82.3
0EBE:  BRA    0EBC
0EC0:  BCF    F8B.4
0EC2:  BCF    F94.4
0EC4:  NOP   
0EC6:  NOP   
0EC8:  BCF    F8B.3
0ECA:  BCF    F94.3
....................    //Escribimos palabra de control de escritura 
....................    i2c_write(CONTROL_R); 
0ECC:  MOVLW  AF
0ECE:  MOVLB  2
0ED0:  MOVWF  x9E
0ED2:  MOVLB  0
0ED4:  RCALL  0D90
....................  
....................    //Leemos hasta que completemos el bus 
....................    for(i=0; i<tam-1; i++){ 
0ED6:  MOVLB  2
0ED8:  CLRF   x9B
0EDA:  MOVLW  01
0EDC:  SUBWF  x97,W
0EDE:  SUBWF  x9B,W
0EE0:  BC    0F06
....................       //Se responde en cada caso con ACK 
....................       //(la función i2c_read tiene su argumento al revés: 1 corresponde a 
....................       //ACK y 0 a NACK, cuando en la línea un valor bajo es ACK y uno alto, NACK) 
....................       *rdata=i2c_read(1); 
0EE2:  MOVFF  299,03
0EE6:  MOVFF  298,FE9
0EEA:  MOVFF  299,FEA
0EEE:  MOVLW  01
0EF0:  MOVWF  00
0EF2:  MOVLB  0
0EF4:  RCALL  0DF8
0EF6:  MOVFF  01,FEF
....................       rdata++; 
0EFA:  MOVLB  2
0EFC:  INCF   x98,F
0EFE:  BTFSC  FD8.2
0F00:  INCF   x99,F
....................    } 
0F02:  INCF   x9B,F
0F04:  BRA    0EDA
....................    //Debemos terminar la lectura con un NACK 
....................    *rdata=i2c_read(0); 
0F06:  MOVFF  299,03
0F0A:  MOVFF  298,FE9
0F0E:  MOVFF  299,FEA
0F12:  CLRF   00
0F14:  MOVLB  0
0F16:  RCALL  0DF8
0F18:  MOVFF  01,FEF
....................    i2c_stop(); 
0F1C:  BCF    F94.4
0F1E:  NOP   
0F20:  BSF    F94.3
0F22:  BTFSS  F82.3
0F24:  BRA    0F22
0F26:  NOP   
0F28:  NOP   
0F2A:  NOP   
0F2C:  NOP   
0F2E:  NOP   
0F30:  BSF    F94.4
0F32:  NOP   
0F34:  NOP   
.................... } 
0F36:  RETLW  00
....................  
....................  
....................  
.................... #use fast_io(A) 
.................... #use fast_io(B) 
.................... #use fast_io(C) 
.................... #use fast_io(D) 
....................  
.................... int temperatura_caldera_superada; //Control de la histéresis en la caldera 
.................... int temp_habitacion_superada;  //Control de la histéresis del ambiente 
.................... int encendido_por_alarma; //Indica si la última vez que se encendió fue en respuesta o no a una alarma 
.................... int toca_encender; //Indica si la próxima alarma es de encendido o de apagado 
.................... float termostato; //Temperatura límite de la vivienda 
.................... float termostato_provisional; //Valor de termostato provisional para cuando saltan las alarmas 
.................... float temperatura; //Temperatura de la vivienda 
.................... float histeresis_vivienda = 0.5; //Intervalo de histéresis de la vivienda 
.................... char key; //Tecla a pulsar 
.................... char keys[2]; //Cadena para almacenar números como caracteres 
....................  
.................... //Estructura de un intervalo de programación 
.................... typedef struct 
.................... { 
....................    unsigned int horas_inicio;    //Hora a la que se inicia el encendido 
....................    unsigned int minutos_inicio;  // 
....................    unsigned int horas_fin;       //Hora a la que se apaga el sistema 
....................    unsigned int minutos_fin;     // 
....................    unsigned int termostato;      //Termostato vigente en ese intervalo 
.................... }programacion; 
....................  
.................... //Vector que incluye todas las programaciones horarias 
.................... //La información se distribuye en grupos de 5: hora_inicio, minutos_inicio, 
.................... //hora_fin, minutos_fin y termostato. 
.................... programacion programaciones[5]; 
....................  
.................... //Programación en curso en este momento 
.................... programacion prg; 
.................... int num_intervalos; //Número de intervalos de programación con los que contamos 
.................... int posicion_alarmas; //Variable que apunta a la posición de la próxima alarma 
....................  
.................... //Estructura para leer el tiempo del reloj 
.................... date_time_t tiempo; 
....................  
.................... //Registro de la hora en la que se enciende el sistema 
.................... int hora_encendido; 
.................... int minutos_encendido; 
....................  
.................... //Registro de la hora en la que se enciende la caldera 
.................... //Se supone que el encendido de la caldera se realiza en intervalos cortos, 
.................... //que se alcanza la temperatura deseada relativamente rápido. 
.................... int hora_caldera; 
.................... int minutos_caldera; 
.................... int segundos_caldera; 
.................... //Tiempo total de encendido de la caldera en cada intervalo de encendido del sistema 
.................... long t_total_caldera; 
....................  
.................... //Variables para el registro en memoria 
.................... unsigned long num_registros;  //Número de registros de fechas almacenados 
.................... int anno_actual;             //Año en el que estamos (de 0 a 99) 
.................... int anno_actual_1_to_3;      //Año en el que estamos (de 0 a 3, a pesar de 
....................                               //que la variable se llame 1_to_3 por razones "históricas") 
....................  
.................... //Flag para activar las interrupciones de interfaz con el teclado y alarma 
.................... int led_int; 
.................... int alarma_int; 
....................  
....................  
.................... //Listado de métodos utilizados 
.................... //***************************** 
.................... //Mostramos aquí una breve explicación de cada uno. El interior de los métodos está 
.................... //descrito después del método main. 
....................  
.................... //comprobar_temperatura() -> Devuelve TRUE si la temperatura de la habitación es menor 
.................... //que la indicada en el termostato, y FALSE en caso contrario. 
.................... int comprobar_temperatura(); 
.................... //comp_caldera() -> Devuelve TRUE si debemos apagar la caldera. Esta función tiene en cuenta 
.................... //cierta histéresis para evitar ciclos continuos de apagado-encendido. Hay que considerar 
.................... //que sólo puede emplearse una vez que la temperatura del agua ha superado ya el valor necesario. 
.................... int comp_caldera(); 
.................... //mostrar_temperatura() -> Muestra en la pantalla LCD la temperatura actual y la hora. 
.................... void mostrar_temperatura(); 
.................... //encender_sistema() -> Realiza todas las operaciones necesarias para el encendido 
.................... //del sistema, como registro del tiempo de inicio. 
.................... void encender_sistema(); 
.................... //apagar_sistema() -> Realiza todas las operaciones necesarias para el apagado 
.................... //del sistema, como el almacenamiento de los datos necesarios en memoria. 
.................... void apagar_sistema(); 
.................... //encender_caldera() -> Enciende la caldera, almacenando el tiempo de encendido en 
.................... //las variables correspondientes. 
.................... void encender_caldera(); 
.................... //apagar_caldera() -> Apaga la caldera, almacenando el tiempo que ha estado encendida. 
.................... void apagar_caldera(); 
.................... //buscar_numero() -> Escanea el teclado hasta encontrar un número de dos cifras o hasta que se decida salir 
.................... //mediante la pulsación de los botones de SI o NO. 
.................... int buscar_numero(); 
.................... //comprobar_hora(int hora1, int min1, int hora2, int min2) -> Devuelve TRUE 
.................... //si hora1:min1 corresponde a un tiempo menor o igual que hora2:min2. 
.................... int comprobar_hora(int hora1,int min1, int hora2, int min2); 
.................... //ordenar_programaciones -> Ordena las programaciones por orden creciente de hora. 
.................... void ordenar_programaciones(); 
.................... //diferencia_tiempo(int hora1, int min1, int hora2, int min2) -> Calcula la 
.................... //diferencia de tiempo en minutos entre hora1:min1 y hora2:min2. 
.................... //Si hora1:min1 es mayor que hora2:min2, los considera en días consecutivos. 
.................... long diferencia_tiempo(int hora1,int min1, int hora2, int min2); 
.................... //diferencia_tiempo_sec(int hora1, int min1, int sec1, int hora2, int min2, int sec2) -> 
.................... //Calcula la diferencia de tiempo en segundos entre hora1:min1:sec1 y hora2:min2:sec2 
.................... //Si hora1:min1:sec1 es mayor que hora2:min2:sec2, los considera en días consecutivos 
.................... long diferencia_tiempo_sec(int hora1,int min1, int sec1, int hora2, int min2, int sec2); 
.................... //seleccionar_alarma() -> Selecciona la alarma más cercana a la hora en la que nos encontramos, 
.................... //en el caso de que las hubiese. 
.................... void seleccionar_alarma(); 
.................... //programar_proxima_alarma() -> Programa la próxima alarma que tendrá lugar. 
.................... //Siempre se tratará de una alarma para el encendido. 
.................... void programar_proxima_alarma(); 
.................... //grabar_programaciones() -> Graba los datos de las programaciones en la memoria EEPROM. 
.................... void grabar_programaciones(); 
.................... //leer_programaciones() -> Recupera de la memoria los datos de las programaciones. 
.................... void leer_programaciones(); 
.................... //representar_registros() -> Representa la información de los registros en el puerto RS232 
.................... //Nunca guardamos la información de los registros para no saturar la memoria y 
.................... //aprovechamos la representación de los datos para calcular medias y demás y así 
.................... //no tener que realizar un segundo barrido de lectura en memoria. 
.................... void representar_registros(); 
....................  
.................... //-------------------------------------------------------------------------------- 
....................  
.................... //Gestión de interrupciones de activación de la interfaz de usuario 
.................... #INT_EXT 
.................... activacion_led(){ 
....................    //Se activa el flag correspondiente 
....................    led_int = TRUE; 
*
0BD4:  MOVLW  01
0BD6:  MOVWF  68
.................... } 
....................  
.................... //Gestión de interrupciones de activación de la alarma 
0BD8:  BCF    FF2.1
0BDA:  GOTO   0064
.................... #INT_EXT1 
.................... alarma(){ 
....................    //Se activa el flag correspondiente 
....................    alarma_int = TRUE; 
0BDE:  MOVLW  01
0BE0:  MOVWF  69
.................... } 
....................  
.................... //*********************************************************** 
.................... //Método main 
.................... //*********************************************************** 
0BE2:  BCF    FF0.0
0BE4:  GOTO   0064
.................... main() 
.................... { 
*
4BC2:  CLRF   FF8
4BC4:  BCF    FD0.7
4BC6:  BSF    0D.7
4BC8:  CLRF   FEA
4BCA:  CLRF   FE9
4BCC:  BCF    FB8.3
4BCE:  MOVLW  19
4BD0:  MOVWF  FAF
4BD2:  MOVLW  22
4BD4:  MOVWF  FAC
4BD6:  MOVLW  90
4BD8:  MOVWF  FAB
4BDA:  MOVF   FC1,W
4BDC:  ANDLW  C0
4BDE:  IORLW  0F
4BE0:  MOVWF  FC1
4BE2:  MOVLW  07
4BE4:  MOVWF  FB4
4BE6:  CLRF   18
4BE8:  CLRF   19
4BEA:  MOVLW  01
4BEC:  MOVWF  1A
4BEE:  CLRF   1B
4BF0:  CLRF   1C
4BF2:  CLRF   1D
4BF4:  CLRF   1E
4BF6:  MOVLW  7E
4BF8:  MOVWF  2F
4BFA:  CLRF   30
4BFC:  CLRF   31
4BFE:  CLRF   32
....................    //Vector para recoger los datos iniciales leídos de memoria 
....................    int data[6]; 
....................  
....................    //Establecemos el estado de los puertos como entradas o salidas 
....................    set_tris_b(0x03); 
4C00:  MOVLW  03
4C02:  MOVWF  F93
....................    set_tris_d(0x0F); 
4C04:  MOVLW  0F
4C06:  MOVWF  F95
....................  
....................    //Inicializamos la pantalla lcd 
....................    lcd_init(); 
4C08:  GOTO   0CB0
....................  
....................    //Mostramos un mensaje de inicio 
....................    lcd_send_byte(LCD_ORDEN, LCD_CLEAR); 
4C0C:  MOVLB  2
4C0E:  CLRF   x98
4C10:  MOVLW  01
4C12:  MOVWF  x99
4C14:  MOVLB  0
4C16:  CALL   0C60
....................    lcd_send_byte(LCD_ORDEN, LCD_NO_CURSOR); 
4C1A:  MOVLB  2
4C1C:  CLRF   x98
4C1E:  MOVLW  0C
4C20:  MOVWF  x99
4C22:  MOVLB  0
4C24:  CALL   0C60
....................    printf(lcd_putc, "Inicializando..."); 
4C28:  CLRF   x81
4C2A:  MOVF   x81,W
4C2C:  CALL   00EC
4C30:  IORLW  00
4C32:  BZ    4C42
4C34:  INCF   x81,F
4C36:  MOVLB  2
4C38:  MOVWF  x93
4C3A:  MOVLB  0
4C3C:  CALL   0D34
4C40:  BRA    4C2A
....................  
....................    //Propiedades de conversión analógico digital 
....................    //Establecemos el comparador entre A0 y A3, y entre A1 y A2 
....................    setup_comparator(A0_A3_A1_A2); 
4C42:  MOVLW  02
4C44:  MOVWF  FB4
4C46:  MOVF   F92,W
4C48:  IORLW  0F
4C4A:  MOVWF  F92
4C4C:  CLRWDT
4C4E:  MOVLW  06
4C50:  MOVWF  00
4C52:  DECFSZ 00,F
4C54:  BRA    4C52
4C56:  MOVF   FB4,W
4C58:  BCF    FA1.6
....................    //Caracterizamos los puertos A0 a A3 como entradas analógicas 
....................    setup_adc_ports(AN0_TO_AN3); 
4C5A:  MOVF   FC1,W
4C5C:  ANDLW  C0
4C5E:  IORLW  0B
4C60:  MOVWF  FC1
....................    //Definimos el reloj de conversión 
....................    setup_adc(adc_clock_div_32); 
4C62:  MOVF   FC0,W
4C64:  ANDLW  C0
4C66:  IORLW  02
4C68:  MOVWF  FC0
4C6A:  BCF    FC0.7
4C6C:  BSF    FC2.0
....................  
....................    //Recuperación de datos de la memoria 
....................    //Recuperamos a partir de la dirección eeprom_termostato los datos en 
....................    //el siguiente orden: termostato, número de intervalos de alarma, número de registros 
....................    //de encendido de la caldera, año actual en valores de 0 a 99 y año actual en valores de 0 a 3. 
....................    lee_ee(eeprom_termostato, 6, data); 
4C6E:  MOVLB  2
4C70:  CLRF   x96
4C72:  MOVLW  10
4C74:  MOVWF  x95
4C76:  MOVLW  06
4C78:  MOVWF  x97
4C7A:  CLRF   x99
4C7C:  MOVLW  6A
4C7E:  MOVWF  x98
4C80:  MOVLB  0
4C82:  CALL   0E54
....................    termostato = (float)data[0]; 
4C86:  MOVLB  2
4C88:  CLRF   x99
4C8A:  MOVFF  6A,298
4C8E:  MOVLB  0
4C90:  CALL   0F38
4C94:  MOVFF  03,26
4C98:  MOVFF  02,25
4C9C:  MOVFF  01,24
4CA0:  MOVFF  00,23
....................    num_intervalos = data[1]; 
4CA4:  MOVFF  6B,54
....................    //El número de registros está almacenado en un long y debemos realizar la conversión desde dos int 
....................    num_registros = (long)data[2]*256 + (long)data[3]; 
4CA8:  CLRF   x83
4CAA:  CLRF   03
4CAC:  MOVF   6D,W
4CAE:  ADDWF  x83,W
4CB0:  MOVWF  64
4CB2:  MOVF   03,W
4CB4:  ADDWFC 6C,W
4CB6:  MOVWF  65
....................    anno_actual = data[4]; 
4CB8:  MOVFF  6E,66
....................    anno_actual_1_to_3 = data[5]; 
4CBC:  MOVFF  6F,67
....................  
....................    //Lee las programaciones de alarmas guardadas en memoria 
....................    leer_programaciones(); 
4CC0:  GOTO   0F70
....................  
....................    //Comprobamos si hay alarmas programadas en memoria 
....................    if(num_intervalos!=0) 
4CC4:  MOVF   54,F
4CC6:  BZ    4CD6
....................    { 
....................       //Si las hay, seleccionamos la siguiente y programamos su activación 
....................       seleccionar_alarma(); 
4CC8:  CALL   12C8
....................       programar_proxima_alarma(); 
4CCC:  CALL   140C
....................       toca_encender = TRUE; 
4CD0:  MOVLW  01
4CD2:  MOVWF  22
....................    }else 
4CD4:  BRA    4CDE
....................    { 
....................       //Si no, simplemente inciamos la cuenta del reloj 
....................       PCF8583_write_byte(PCF8583_CTRL_STATUS_REG, 
....................                               PCF8583_START_COUNTING); 
4CD6:  CLRF   x9A
4CD8:  CLRF   x9B
4CDA:  CALL   1082
....................    } 
....................  
....................  
....................  
....................    //Inicializamos salidas 
....................    //Comenzamos con todo apagado (sistema, motor y caldera) 
....................    sistema_encendido = FALSE; 
4CDE:  BCF    F83.5
....................    motor = FALSE; 
4CE0:  BCF    F83.6
....................    caldera_encendida = FALSE; 
4CE2:  BCF    F83.7
....................    encendido_por_alarma = FALSE; 
4CE4:  CLRF   21
....................    t_total_caldera = 0; //El tiempo total de encendido de la caldera también lo ponemos a 0 
4CE6:  CLRF   63
4CE8:  CLRF   62
....................  
....................    //Leemos la temperatura 
....................    temperatura = ds1820_read(); 
4CEA:  CALL   16BC
4CEE:  MOVFF  03,2E
4CF2:  MOVFF  02,2D
4CF6:  MOVFF  01,2C
4CFA:  MOVFF  00,2B
....................    if(temperatura >= termostato) 
4CFE:  MOVFF  26,8C
4D02:  MOVFF  25,8B
4D06:  MOVFF  24,8A
4D0A:  MOVFF  23,89
4D0E:  MOVFF  2E,90
4D12:  MOVFF  2D,8F
4D16:  MOVFF  2C,8E
4D1A:  MOVFF  2B,8D
4D1E:  CALL   1762
4D22:  BC    4D26
4D24:  BNZ   4D62
....................    { 
....................       //Si supera el valor del termostato, lo indicamos con el flag 
....................       temp_habitacion_superada = TRUE; 
4D26:  MOVLW  01
4D28:  MOVWF  20
....................       //Tendremos que establecer un nuevo termostato teniendo en cuenta la histéresis de la temperatura 
....................       termostato = termostato - histeresis_vivienda; 
4D2A:  BSF    FD8.1
4D2C:  MOVFF  26,295
4D30:  MOVFF  25,294
4D34:  MOVFF  24,293
4D38:  MOVFF  23,292
4D3C:  MOVFF  32,299
4D40:  MOVFF  31,298
4D44:  MOVFF  30,297
4D48:  MOVFF  2F,296
4D4C:  CALL   17D8
4D50:  MOVFF  03,26
4D54:  MOVFF  02,25
4D58:  MOVFF  01,24
4D5C:  MOVFF  00,23
....................    }else 
4D60:  BRA    4D64
....................       //Si no se supera, se indica también 
....................       temp_habitacion_superada = FALSE; 
4D62:  CLRF   20
....................  
....................  
....................    if(!C1OUT) 
4D64:  BTFSC  FB4.6
4D66:  BRA    4D6E
....................       //Si la temperatura del agua en la caldera supera el termostato, activamos el flag 
....................       temperatura_caldera_superada = TRUE; 
4D68:  MOVLW  01
4D6A:  MOVWF  1F
....................    else 
4D6C:  BRA    4D70
....................       //Si no es así, lo desactivamos 
....................       temperatura_caldera_superada = FALSE; 
4D6E:  CLRF   1F
....................  
....................    //Desactivamos los flag de las interrupciones 
....................    alarma_int = led_int = FALSE; 
4D70:  CLRF   68
4D72:  MOVFF  68,69
....................  
....................    //Activamos las interrupciones del puerto B0 y B1 
....................    enable_interrupts(INT_EXT); 
4D76:  BSF    FF2.4
....................    enable_interrupts(INT_EXT1); 
4D78:  BSF    FF0.3
....................  
....................    //Repetimos la siguiente rutina hasta que se desconecte el micro 
....................    while(1){ 
....................       //Inhabilitamos el perro guardián para que no interfiera con las gestión de interrupciones y 
....................       //con la medida de la temperatura 
....................       setup_wdt(WDT_OFF); 
4D7A:  BCF    FD1.0
....................       //Desactivamos también las interrupciones por el mismo motivo 
....................       disable_interrupts(GLOBAL); 
4D7C:  BCF    FF2.6
4D7E:  BCF    FF2.7
4D80:  BTFSC  FF2.7
4D82:  BRA    4D7E
....................  
....................       //Si la interrupción de alarma se activa, gestionamos el proceso 
....................       if(alarma_int) 
4D84:  MOVF   69,F
4D86:  BZ    4E5C
....................       { 
....................          //Variables para almacenar el tiempo 
....................          int hora, minutos; 
....................  
....................          //Desactivamos el flag de la alarma en el PCF8583 
....................          PCF8583_write_byte(PCF8583_CTRL_STATUS_REG, 
....................                                  PCF8583_START_COUNTING); 
4D88:  CLRF   x9A
4D8A:  CLRF   x9B
4D8C:  CALL   1082
....................  
....................          if(toca_encender) 
4D90:  MOVF   22,F
4D92:  BZ    4E14
....................          { 
....................             if(!sistema_encendido) 
4D94:  BTFSC  F83.5
4D96:  BRA    4DF4
....................             { 
....................                //Ejecutamos esto si se trata de una alarma de encendido y el sistema 
....................                //está apagado. 
....................                //Actualizamos el termostato, guardando el valor que había ya 
....................                termostato_provisional = termostato; 
4D98:  MOVFF  26,2A
4D9C:  MOVFF  25,29
4DA0:  MOVFF  24,28
4DA4:  MOVFF  23,27
....................                termostato = prg.termostato; 
4DA8:  MOVLB  2
4DAA:  CLRF   x99
4DAC:  MOVFF  53,298
4DB0:  MOVLB  0
4DB2:  CALL   0F38
4DB6:  MOVFF  03,26
4DBA:  MOVFF  02,25
4DBE:  MOVFF  01,24
4DC2:  MOVFF  00,23
....................  
....................                //Determinamos la próxima alarma como de apagado 
....................                toca_encender = FALSE; 
4DC6:  CLRF   22
....................  
....................                //Activamos el flag de sistema encendido por alarma 
....................                encendido_por_alarma = TRUE; 
4DC8:  MOVLW  01
4DCA:  MOVWF  21
....................                //Encendemos el sistema 
....................                encender_sistema(); 
4DCC:  CALL   1A52
....................  
....................                //Recogemos el tiempo en el que debe de saltar la alarma de apagado. 
....................                //Lo hacemos mediante variables auxiliares para dividir mejor las tareas 
....................                //y no condensar todo en una línea. 
....................                hora = prg.horas_fin; 
4DD0:  MOVFF  51,70
....................                minutos = prg.minutos_fin; 
4DD4:  MOVFF  52,71
....................  
....................                delay_ms(250); //Retraso para evitar solapamiento de alarmas 
4DD8:  MOVLW  FA
4DDA:  MOVLB  2
4DDC:  MOVWF  x9A
4DDE:  MOVLB  0
4DE0:  CALL   0BE8
....................                               //(que salte una dos veces seguidas o algo así) 
....................  
....................                //Establecemos la alarma de apagado del sistema (segundos=0) 
....................                PCF8583_establecer_alarma(hora, minutos, 0); 
4DE4:  MOVFF  70,83
4DE8:  MOVFF  71,84
4DEC:  CLRF   x85
4DEE:  CALL   1364
....................  
....................             }else 
4DF2:  BRA    4E12
....................             { 
....................                //Si se trata de una alarma de encendido y el sistema está encendido 
....................                delay_ms(250); //Retraso para evitar solapamiento de alarmas 
4DF4:  MOVLW  FA
4DF6:  MOVLB  2
4DF8:  MOVWF  x9A
4DFA:  MOVLB  0
4DFC:  CALL   0BE8
....................  
....................                //Nos vamos a la siguiente alarma 
....................                posicion_alarmas++; 
4E00:  INCF   55,F
....................                //Si hemos llegado al final de la lista, volvemos al principio 
....................                if(posicion_alarmas==num_intervalos) 
4E02:  MOVF   54,W
4E04:  SUBWF  55,W
4E06:  BNZ   4E0A
....................                   posicion_alarmas = 0; 
4E08:  CLRF   55
....................  
....................                //Programamos la próxima alarma de encendido 
....................                programar_proxima_alarma(); 
4E0A:  CALL   140C
....................  
....................                //Determinamos que la siguiente es de encendido 
....................                toca_encender = TRUE; 
4E0E:  MOVLW  01
4E10:  MOVWF  22
....................             } 
....................          }else 
4E12:  BRA    4E50
....................          { 
....................             //Si se trata de una alarma de apagado 
....................  
....................             delay_ms(250); //Retraso para evitar el solapamiento de alarmas 
4E14:  MOVLW  FA
4E16:  MOVLB  2
4E18:  MOVWF  x9A
4E1A:  MOVLB  0
4E1C:  CALL   0BE8
....................  
....................             if(sistema_encendido && encendido_por_alarma) 
4E20:  BTFSS  F83.5
4E22:  BRA    4E3E
4E24:  MOVF   21,F
4E26:  BZ    4E3E
....................             { 
....................                //Si el sistema está encendido y se trata de un encendido por alarma: 
....................                //Restauramos el valor del termostato que había antes de la alarma 
....................                termostato=termostato_provisional; 
4E28:  MOVFF  2A,26
4E2C:  MOVFF  29,25
4E30:  MOVFF  28,24
4E34:  MOVFF  27,23
....................                //Determinamos que la próxima vez que se encienda no sea por alarma 
....................                encendido_por_alarma = FALSE; 
4E38:  CLRF   21
....................                //Apagamos el sistema 
....................                apagar_sistema(); 
4E3A:  CALL   1EEC
....................             } 
....................  
....................             //Nos vamos a la siguiente alarma 
....................             posicion_alarmas++; 
4E3E:  INCF   55,F
....................             //Si llegamos al final de la lista, volvemos al principio 
....................             if(posicion_alarmas==num_intervalos) 
4E40:  MOVF   54,W
4E42:  SUBWF  55,W
4E44:  BNZ   4E48
....................                posicion_alarmas = 0; 
4E46:  CLRF   55
....................  
....................             //Programamos la próxima alarma de encendido 
....................             programar_proxima_alarma(); 
4E48:  CALL   140C
....................  
....................             //Y activamos que, efectivamente, se trata de una alarma de encendido 
....................             toca_encender = TRUE; 
4E4C:  MOVLW  01
4E4E:  MOVWF  22
....................          } 
....................  
....................          //Activamos de nuevo la alarma 
....................          PCF8583_write_byte(PCF8583_CTRL_STATUS_REG, 
....................                                  PCF8583_ACTIVAR_ALARMA); 
4E50:  CLRF   x9A
4E52:  MOVLW  04
4E54:  MOVWF  x9B
4E56:  CALL   1082
....................  
....................          //Desactivamos el flag de interrupción 
....................          alarma_int = FALSE; 
4E5A:  CLRF   69
....................       } 
....................  
....................  
....................       //Si se activa la interrupción de interfaz con el usuario, se gestiona el proceso 
....................       if(led_int) 
4E5C:  MOVF   68,F
4E5E:  BTFSC  FD8.2
4E60:  GOTO   5998
....................       { 
....................          //Contadores y valores auxiliares 
....................          int contador, contador2, valor; 
....................          //Variable para la conversión de los valores de teclado 
....................          long numero; 
....................          //Variables provisionales para buscar en la lista de programaciones 
....................          programacion pr, pr2; 
....................  
....................          //Ponemos en key un caracter cualquiera para que no se corresponda 
....................          //con ningún botón del teclado. 
....................          key='J'; 
4E64:  MOVLW  4A
4E66:  MOVWF  33
....................  
....................          //Mostramos un mensaje al usuario para que elija su opción 
....................          lcd_send_byte(LCD_ORDEN,LCD_CLEAR); 
4E68:  MOVLB  2
4E6A:  CLRF   x98
4E6C:  MOVLW  01
4E6E:  MOVWF  x99
4E70:  MOVLB  0
4E72:  CALL   0C60
....................          printf(lcd_putc, "  Indique la \n  operacion"); 
4E76:  CLRF   x81
4E78:  MOVF   x81,W
4E7A:  CALL   0118
4E7E:  IORLW  00
4E80:  BZ    4E90
4E82:  INCF   x81,F
4E84:  MOVLB  2
4E86:  MOVWF  x93
4E88:  MOVLB  0
4E8A:  CALL   0D34
4E8E:  BRA    4E78
....................  
....................          //Mientras que la tecla pulsada no sea una de las válidas, seguimos barriendo el teclado 
....................          while(key!='1' && key!='2' && key!='3' && key!='4' && key!='N'){ 
4E90:  MOVF   33,W
4E92:  SUBLW  31
4E94:  BZ    4EB8
4E96:  MOVF   33,W
4E98:  SUBLW  32
4E9A:  BZ    4EB8
4E9C:  MOVF   33,W
4E9E:  SUBLW  33
4EA0:  BZ    4EB8
4EA2:  MOVF   33,W
4EA4:  SUBLW  34
4EA6:  BZ    4EB8
4EA8:  MOVF   33,W
4EAA:  SUBLW  4E
4EAC:  BZ    4EB8
....................             key=get_key(); 
4EAE:  CALL   2216
4EB2:  MOVFF  01,33
....................          } 
4EB6:  BRA    4E90
....................  
....................          //Se elige la opción pertinente 
....................          switch(key) 
....................          { 
4EB8:  MOVF   33,W
4EBA:  XORLW  31
4EBC:  BZ    4EDC
4EBE:  XORLW  03
4EC0:  BZ    4F5A
4EC2:  XORLW  01
4EC4:  BTFSC  FD8.2
4EC6:  BRA    5250
4EC8:  XORLW  07
4ECA:  BTFSC  FD8.2
4ECC:  GOTO   5792
4ED0:  XORLW  7A
4ED2:  BTFSC  FD8.2
4ED4:  GOTO   594A
4ED8:  GOTO   5996
....................             //Si es 1, entramos en la opción de apagado y encendido manual del sistema 
....................             case '1': 
....................                      //Si el sistema está apagado, lo encendemos 
....................                      if(!sistema_encendido) 
4EDC:  BTFSC  F83.5
4EDE:  BRA    4F0E
....................                      { 
....................                         lcd_send_byte(LCD_ORDEN,LCD_CLEAR); 
4EE0:  MOVLB  2
4EE2:  CLRF   x98
4EE4:  MOVLW  01
4EE6:  MOVWF  x99
4EE8:  MOVLB  0
4EEA:  CALL   0C60
....................                         printf(lcd_putc, "  Encendiendo\n  sistema..."); 
4EEE:  CLRF   x81
4EF0:  MOVF   x81,W
4EF2:  CALL   014C
4EF6:  IORLW  00
4EF8:  BZ    4F08
4EFA:  INCF   x81,F
4EFC:  MOVLB  2
4EFE:  MOVWF  x93
4F00:  MOVLB  0
4F02:  CALL   0D34
4F06:  BRA    4EF0
....................                         encender_sistema(); 
4F08:  CALL   1A52
....................                      }else 
4F0C:  BRA    4F56
....................                      //Si está encendido, lo apagamos 
....................                      { 
....................                         lcd_send_byte(LCD_ORDEN,LCD_CLEAR); 
4F0E:  MOVLB  2
4F10:  CLRF   x98
4F12:  MOVLW  01
4F14:  MOVWF  x99
4F16:  MOVLB  0
4F18:  CALL   0C60
....................                         printf(lcd_putc, "  Apagando\n  sistema..."); 
4F1C:  CLRF   x81
4F1E:  MOVF   x81,W
4F20:  CALL   0182
4F24:  IORLW  00
4F26:  BZ    4F36
4F28:  INCF   x81,F
4F2A:  MOVLB  2
4F2C:  MOVWF  x93
4F2E:  MOVLB  0
4F30:  CALL   0D34
4F34:  BRA    4F1E
....................                         apagar_sistema(); 
4F36:  CALL   1EEC
....................                         //Si el motor estaba en marcha, debemos apagarlo 
....................                         if(motor) 
4F3A:  BTFSS  F83.6
4F3C:  BRA    4F40
....................                            motor = FALSE; 
4F3E:  BCF    F83.6
....................  
....................                         //Si estaba encendido por alguna alarma debemos indicarlo 
....................                         if(encendido_por_alarma) 
4F40:  MOVF   21,F
4F42:  BZ    4F56
....................                         { 
....................                            //Recuperamos el valor del termostato 
....................                            termostato=termostato_provisional; 
4F44:  MOVFF  2A,26
4F48:  MOVFF  29,25
4F4C:  MOVFF  28,24
4F50:  MOVFF  27,23
....................                            encendido_por_alarma = FALSE; 
4F54:  CLRF   21
....................                         } 
....................                      } 
....................                      break; 
4F56:  GOTO   5996
....................  
....................  
....................             //Si es 2, entramos en la opción de configuración del termostato 
....................             case '2': 
....................                      key = 'J'; //Letra falsa para evitar una opción indeseada 
4F5A:  MOVLW  4A
4F5C:  MOVWF  33
....................  
....................                      //Mostramos el valor del termostato actual 
....................                      lcd_send_byte(LCD_ORDEN, LCD_CLEAR); 
4F5E:  MOVLB  2
4F60:  CLRF   x98
4F62:  MOVLW  01
4F64:  MOVWF  x99
4F66:  MOVLB  0
4F68:  CALL   0C60
....................                      //Para considerar el valor del termostato hay que tener en cuenta el valor de la histéresis 
....................                      if(temp_habitacion_superada) 
4F6C:  MOVF   20,F
4F6E:  BZ    4FF4
....................                         printf(lcd_putc, "Modificar\ntermostato %.0f%cC",termostato+histeresis_vivienda,223); 
4F70:  BCF    FD8.1
4F72:  MOVFF  26,295
4F76:  MOVFF  25,294
4F7A:  MOVFF  24,293
4F7E:  MOVFF  23,292
4F82:  MOVFF  32,299
4F86:  MOVFF  31,298
4F8A:  MOVFF  30,297
4F8E:  MOVFF  2F,296
4F92:  CALL   17D8
4F96:  MOVFF  00,81
4F9A:  MOVFF  01,82
4F9E:  MOVFF  02,83
4FA2:  MOVFF  03,84
4FA6:  CLRF   x85
4FA8:  MOVF   x85,W
4FAA:  CALL   01B4
4FAE:  INCF   x85,F
4FB0:  MOVWF  00
4FB2:  MOVFF  FE8,293
4FB6:  CALL   0D34
4FBA:  MOVLW  15
4FBC:  SUBWF  x85,W
4FBE:  BNZ   4FA8
4FC0:  MOVLW  89
4FC2:  MOVWF  FE9
4FC4:  MOVFF  84,89
4FC8:  MOVFF  83,88
4FCC:  MOVFF  82,87
4FD0:  MOVFF  81,86
4FD4:  CLRF   x8A
4FD6:  CALL   22FE
4FDA:  MOVLW  DF
4FDC:  MOVLB  2
4FDE:  MOVWF  x93
4FE0:  MOVLB  0
4FE2:  CALL   0D34
4FE6:  MOVLW  43
4FE8:  MOVLB  2
4FEA:  MOVWF  x93
4FEC:  MOVLB  0
4FEE:  CALL   0D34
....................                      else 
4FF2:  BRA    5040
....................                         printf(lcd_putc, "Modificar\ntermostato %.0f%cC",termostato,223); 
4FF4:  CLRF   x81
4FF6:  MOVF   x81,W
4FF8:  CALL   01B4
4FFC:  INCF   x81,F
4FFE:  MOVWF  00
5000:  MOVFF  FE8,293
5004:  CALL   0D34
5008:  MOVLW  15
500A:  SUBWF  x81,W
500C:  BNZ   4FF6
500E:  MOVLW  89
5010:  MOVWF  FE9
5012:  MOVFF  26,89
5016:  MOVFF  25,88
501A:  MOVFF  24,87
501E:  MOVFF  23,86
5022:  CLRF   x8A
5024:  CALL   22FE
5028:  MOVLW  DF
502A:  MOVLB  2
502C:  MOVWF  x93
502E:  MOVLB  0
5030:  CALL   0D34
5034:  MOVLW  43
5036:  MOVLB  2
5038:  MOVWF  x93
503A:  MOVLB  0
503C:  CALL   0D34
....................  
....................                      //Retardamos cierto tiempo para que el usuario vea correctamente los datos de la pantalla 
....................                      delay_ms(LCD_T_RETARDO*2); 
5040:  MOVLW  04
5042:  MOVWF  x81
5044:  MOVLW  FA
5046:  MOVLB  2
5048:  MOVWF  x9A
504A:  MOVLB  0
504C:  CALL   0BE8
5050:  DECFSZ x81,F
5052:  BRA    5044
....................  
....................                      //Pedimos la introducción de nuevo valor 
....................                      lcd_send_byte(LCD_ORDEN, LCD_CLEAR); 
5054:  MOVLB  2
5056:  CLRF   x98
5058:  MOVLW  01
505A:  MOVWF  x99
505C:  MOVLB  0
505E:  CALL   0C60
....................                      lcd_send_byte(LCD_ORDEN, LCD_CURSOR); //Activamos el cursor en la pantalla 
5062:  MOVLB  2
5064:  CLRF   x98
5066:  MOVLW  0E
5068:  MOVWF  x99
506A:  MOVLB  0
506C:  CALL   0C60
....................                      printf(lcd_putc, "Nuevo valor:\n       %cC",223); 
5070:  CLRF   x81
5072:  MOVF   x81,W
5074:  CALL   01EC
5078:  INCF   x81,F
507A:  MOVWF  00
507C:  MOVFF  FE8,293
5080:  CALL   0D34
5084:  MOVLW  0D
5086:  SUBWF  x81,W
5088:  BNZ   5072
508A:  MOVLW  07
508C:  MOVWF  x82
508E:  MOVLW  20
5090:  MOVLB  2
5092:  MOVWF  x93
5094:  MOVLB  0
5096:  CALL   0D34
509A:  DECFSZ x82,F
509C:  BRA    508E
509E:  MOVLW  DF
50A0:  MOVLB  2
50A2:  MOVWF  x93
50A4:  MOVLB  0
50A6:  CALL   0D34
50AA:  MOVLW  43
50AC:  MOVLB  2
50AE:  MOVWF  x93
50B0:  MOVLB  0
50B2:  CALL   0D34
....................                      lcd_gotoxy(6,2); 
50B6:  MOVLW  06
50B8:  MOVLB  2
50BA:  MOVWF  x94
50BC:  MOVLW  02
50BE:  MOVWF  x95
50C0:  MOVLB  0
50C2:  CALL   0D0E
....................  
....................                      //Recogemos el número de dos cifras introducido por el teclado 
....................                      valor=buscar_numero(); 
50C6:  CALL   267E
50CA:  MOVFF  01,74
....................  
....................                      //Si se pulsa la tecla SI o NO, salimos 
....................                      if(valor==NO || valor==SI) 
50CE:  MOVF   74,W
50D0:  SUBLW  64
50D2:  BZ    50DA
50D4:  MOVF   74,W
50D6:  SUBLW  65
50D8:  BNZ   50E0
....................                         goto salir; 
50DA:  GOTO   594A
....................                      else 
50DE:  BRA    524C
....................                      { 
....................                         //Retardamos cierto tiempo para permitir al usuario visualizar el valor que ha introducido 
....................                         delay_ms(LCD_T_RETARDO); 
50E0:  MOVLW  02
50E2:  MOVWF  x81
50E4:  MOVLW  FA
50E6:  MOVLB  2
50E8:  MOVWF  x9A
50EA:  MOVLB  0
50EC:  CALL   0BE8
50F0:  DECFSZ x81,F
50F2:  BRA    50E4
....................  
....................                         //Mostramos un mensaje de aplicación de cambios y desactivamos el cursor 
....................                         lcd_send_byte(LCD_ORDEN, LCD_CLEAR); 
50F4:  MOVLB  2
50F6:  CLRF   x98
50F8:  MOVLW  01
50FA:  MOVWF  x99
50FC:  MOVLB  0
50FE:  CALL   0C60
....................                         lcd_send_byte(LCD_ORDEN, LCD_NO_CURSOR); 
5102:  MOVLB  2
5104:  CLRF   x98
5106:  MOVLW  0C
5108:  MOVWF  x99
510A:  MOVLB  0
510C:  CALL   0C60
....................                         printf(lcd_putc, "  Aplicando\n  cambios..."); 
5110:  CLRF   x81
5112:  MOVF   x81,W
5114:  CALL   0218
5118:  IORLW  00
511A:  BZ    512A
511C:  INCF   x81,F
511E:  MOVLB  2
5120:  MOVWF  x93
5122:  MOVLB  0
5124:  CALL   0D34
5128:  BRA    5112
....................  
....................                         if(valor<=temp_max && valor>=temp_min) 
512A:  MOVF   74,W
512C:  SUBLW  20
512E:  BNC   5210
5130:  MOVF   74,W
5132:  SUBLW  0F
5134:  BC    5210
....................                         { 
....................                            //Si el valor está dentro de los límites propuestos, guardamos el valor nuevo 
....................  
....................                            //Leemos la temperatura 
....................                            temperatura = ds1820_read(); 
5136:  CALL   16BC
513A:  MOVFF  03,2E
513E:  MOVFF  02,2D
5142:  MOVFF  01,2C
5146:  MOVFF  00,2B
....................                            if(temperatura >= (float)valor) 
514A:  MOVLB  2
514C:  CLRF   x99
514E:  MOVFF  74,298
5152:  MOVLB  0
5154:  CALL   0F38
5158:  MOVFF  03,8C
515C:  MOVFF  02,8B
5160:  MOVFF  01,8A
5164:  MOVFF  00,89
5168:  MOVFF  2E,90
516C:  MOVFF  2D,8F
5170:  MOVFF  2C,8E
5174:  MOVFF  2B,8D
5178:  CALL   1762
517C:  BC    5180
517E:  BNZ   51DA
....................                            { 
....................                               //Si supera el valor del termostato, lo indicamos con el flag 
....................                               temp_habitacion_superada = TRUE; 
5180:  MOVLW  01
5182:  MOVWF  20
....................                               //Guardamos el termostato nuevo teniendo en cuenta la histeresis de la vivienda 
....................                               termostato = (float)valor - histeresis_vivienda; 
5184:  MOVLB  2
5186:  CLRF   x99
5188:  MOVFF  74,298
518C:  MOVLB  0
518E:  CALL   0F38
5192:  MOVFF  00,81
5196:  MOVFF  01,82
519A:  MOVFF  02,83
519E:  MOVFF  03,84
51A2:  BSF    FD8.1
51A4:  MOVFF  03,295
51A8:  MOVFF  02,294
51AC:  MOVFF  01,293
51B0:  MOVFF  00,292
51B4:  MOVFF  32,299
51B8:  MOVFF  31,298
51BC:  MOVFF  30,297
51C0:  MOVFF  2F,296
51C4:  CALL   17D8
51C8:  MOVFF  03,26
51CC:  MOVFF  02,25
51D0:  MOVFF  01,24
51D4:  MOVFF  00,23
....................                            }else 
51D8:  BRA    51FA
....................                            { 
....................                               //Si no se supera, se indica también 
....................                               temp_habitacion_superada = FALSE; 
51DA:  CLRF   20
....................                               //Se guarda el valor tal cual 
....................                               termostato = (float)valor; 
51DC:  MOVLB  2
51DE:  CLRF   x99
51E0:  MOVFF  74,298
51E4:  MOVLB  0
51E6:  CALL   0F38
51EA:  MOVFF  03,26
51EE:  MOVFF  02,25
51F2:  MOVFF  01,24
51F6:  MOVFF  00,23
....................  
....................                            } 
....................  
....................                            //Guardamos el nuevo valor del termostato en memoria 
....................                            graba_ee(eeprom_termostato, 1, &valor); 
51FA:  CLRF   x98
51FC:  MOVLW  10
51FE:  MOVWF  x97
5200:  MOVLW  01
5202:  MOVWF  x99
5204:  CLRF   x9B
5206:  MOVLW  74
5208:  MOVWF  x9A
520A:  CALL   1E54
....................  
....................                         } 
....................                         else 
520E:  BRA    524C
....................                         { 
....................                            //Si el valor es incorrecto, mostramos un mensaje de error 
....................                            lcd_send_byte(LCD_ORDEN, LCD_CLEAR); 
5210:  MOVLB  2
5212:  CLRF   x98
5214:  MOVLW  01
5216:  MOVWF  x99
5218:  MOVLB  0
521A:  CALL   0C60
....................                            printf(lcd_putc, "   Valor\n   incorrecto"); 
521E:  CLRF   x81
5220:  MOVF   x81,W
5222:  CALL   024C
5226:  IORLW  00
5228:  BZ    5238
522A:  INCF   x81,F
522C:  MOVLB  2
522E:  MOVWF  x93
5230:  MOVLB  0
5232:  CALL   0D34
5236:  BRA    5220
....................                            delay_ms(LCD_T_RETARDO); 
5238:  MOVLW  02
523A:  MOVWF  x81
523C:  MOVLW  FA
523E:  MOVLB  2
5240:  MOVWF  x9A
5242:  MOVLB  0
5244:  CALL   0BE8
5248:  DECFSZ x81,F
524A:  BRA    523C
....................                         } 
....................                      } 
....................  
....................                      break; 
524C:  GOTO   5996
....................  
....................  
....................             //Si es 3, entramos en la opción de configuración de las alarmas 
....................             case '3': 
....................                      key='J'; //Caracter inutil para permitir la introducción de información en el teclado 
5250:  MOVLW  4A
5252:  MOVWF  33
....................  
....................                      //Mostramos el encabezamiento de la operación 
....................                      lcd_send_byte(LCD_ORDEN, LCD_CLEAR); 
5254:  MOVLB  2
5256:  CLRF   x98
5258:  MOVLW  01
525A:  MOVWF  x99
525C:  MOVLB  0
525E:  CALL   0C60
....................                      printf(lcd_putc," Programar\n sistema"); 
5262:  CLRF   x81
5264:  MOVF   x81,W
5266:  CALL   027E
526A:  IORLW  00
526C:  BZ    527C
526E:  INCF   x81,F
5270:  MOVLB  2
5272:  MOVWF  x93
5274:  MOVLB  0
5276:  CALL   0D34
527A:  BRA    5264
....................                      delay_ms(LCD_T_RETARDO); 
527C:  MOVLW  02
527E:  MOVWF  x81
5280:  MOVLW  FA
5282:  MOVLB  2
5284:  MOVWF  x9A
5286:  MOVLB  0
5288:  CALL   0BE8
528C:  DECFSZ x81,F
528E:  BRA    5280
....................  
....................                      //Tenemos la posibilidad de introducir 5 intervalos de alarma. 
....................                      //Se va guiando al usuario por la configuración de cada intervalo mediante el siguiente bucle 
....................                      for(contador=0; contador<5; contador++) 
5290:  CLRF   72
5292:  MOVF   72,W
5294:  SUBLW  04
5296:  BTFSS  FD8.0
5298:  BRA    5770
....................                      { 
....................                         //Se muestra el intervalo a configurar 
....................                         lcd_send_byte(LCD_ORDEN, LCD_CLEAR); 
529A:  MOVLB  2
529C:  CLRF   x98
529E:  MOVLW  01
52A0:  MOVWF  x99
52A2:  MOVLB  0
52A4:  CALL   0C60
....................                         printf(lcd_putc, " INTERVALO %i\n   :      :",contador+1); 
52A8:  MOVLW  01
52AA:  ADDWF  72,W
52AC:  MOVWF  x81
52AE:  CLRF   x82
52B0:  MOVF   x82,W
52B2:  CALL   02AC
52B6:  INCF   x82,F
52B8:  MOVWF  00
52BA:  MOVFF  FE8,293
52BE:  CALL   0D34
52C2:  MOVLW  0B
52C4:  SUBWF  x82,W
52C6:  BNZ   52B0
52C8:  MOVFF  81,83
52CC:  MOVLW  1F
52CE:  MOVWF  x84
52D0:  CALL   271C
52D4:  MOVLW  0A
52D6:  MOVLB  2
52D8:  MOVWF  x93
52DA:  MOVLB  0
52DC:  CALL   0D34
52E0:  MOVLW  03
52E2:  MOVWF  x83
52E4:  MOVLW  20
52E6:  MOVLB  2
52E8:  MOVWF  x93
52EA:  MOVLB  0
52EC:  CALL   0D34
52F0:  DECFSZ x83,F
52F2:  BRA    52E4
52F4:  MOVLW  3A
52F6:  MOVLB  2
52F8:  MOVWF  x93
52FA:  MOVLB  0
52FC:  CALL   0D34
5300:  MOVLW  06
5302:  MOVWF  x84
5304:  MOVLW  20
5306:  MOVLB  2
5308:  MOVWF  x93
530A:  MOVLB  0
530C:  CALL   0D34
5310:  DECFSZ x84,F
5312:  BRA    5304
5314:  MOVLW  3A
5316:  MOVLB  2
5318:  MOVWF  x93
531A:  MOVLB  0
531C:  CALL   0D34
....................                         lcd_gotoxy(2,2); 
5320:  MOVLW  02
5322:  MOVLB  2
5324:  MOVWF  x94
5326:  MOVWF  x95
5328:  MOVLB  0
532A:  CALL   0D0E
....................                         lcd_send_byte(LCD_ORDEN, LCD_CURSOR); 
532E:  MOVLB  2
5330:  CLRF   x98
5332:  MOVLW  0E
5334:  MOVWF  x99
5336:  MOVLB  0
5338:  CALL   0C60
....................  
....................                         //Se pide al usuario el valor de hora de inicio de la alarma 
....................                         pr.horas_inicio = buscar_numero(); 
533C:  CALL   267E
5340:  MOVFF  01,77
....................  
....................                         //Si se pulsa el botón de NO, se sale de la configuración 
....................                         if(pr.horas_inicio==NO) 
5344:  MOVF   77,W
5346:  SUBLW  64
5348:  BNZ   534C
....................                            goto salir; 
534A:  BRA    594A
....................  
....................                         //Si se pulsa Sí, se indica que no quieren introducirse más alarmas 
....................                         if(pr.horas_inicio==SI) 
534C:  MOVF   77,W
534E:  SUBLW  65
5350:  BNZ   5364
....................                         { 
....................                            //Si era la primera alarma que se gestionaba, se interpreta como que 
....................                            //no se quiere activar ninguna alarma 
....................                            if(contador==0) 
5352:  MOVF   72,F
5354:  BNZ   5362
....................                            { 
....................                               //Desactivamos las alarmas 
....................                               PCF8583_write_byte(PCF8583_CTRL_STATUS_REG, 
....................                                     PCF8583_START_COUNTING); 
5356:  CLRF   x9A
5358:  CLRF   x9B
535A:  CALL   1082
....................                               //Salimos 
....................                               goto salir; 
535E:  BRA    594A
....................                            } 
....................                            else 
5360:  BRA    5364
....................                               //Salimos simplemente del bucle 
....................                               break; 
5362:  BRA    5770
....................                         } 
....................  
....................                         //Movemos el cursor en la pantalla 
....................                         lcd_gotoxy(5,2); 
5364:  MOVLW  05
5366:  MOVLB  2
5368:  MOVWF  x94
536A:  MOVLW  02
536C:  MOVWF  x95
536E:  MOVLB  0
5370:  CALL   0D0E
....................  
....................                         //Se pide al usuario el valor de los minutos de inicio 
....................                         pr.minutos_inicio = buscar_numero(); 
5374:  CALL   267E
5378:  MOVFF  01,78
....................  
....................                         //Si se pulsa NO, se sale 
....................                         if(pr.minutos_inicio==NO) 
537C:  MOVF   78,W
537E:  SUBLW  64
5380:  BNZ   5384
....................                            goto salir; 
5382:  BRA    594A
....................  
....................                         //Si se pulsa SI, interrumpimos la introducción de alarmas 
....................                         if(pr.minutos_inicio==SI) 
5384:  MOVF   78,W
5386:  SUBLW  65
5388:  BNZ   539C
....................                         { 
....................                            //Si es el primer intervalo, interpretamos como que el usuario 
....................                            //no quiere programar alarmas 
....................                            if(contador==0) 
538A:  MOVF   72,F
538C:  BNZ   539A
....................                            { 
....................                               //Desactivamos las alarmas 
....................                               PCF8583_write_byte(PCF8583_CTRL_STATUS_REG, 
....................                                     PCF8583_START_COUNTING); 
538E:  CLRF   x9A
5390:  CLRF   x9B
5392:  CALL   1082
....................                               goto salir; 
5396:  BRA    594A
....................                            } 
....................                            else 
5398:  BRA    539C
....................                               //Salimos del bucle 
....................                               break; 
539A:  BRA    5770
....................                         } 
....................  
....................                         //******************************************************************************** 
....................                         //Los comentarios a partir de este punto y hasta la siguiente línea de asteriscos 
....................                         //son equivalentes a los mostrados arriba pero esta vez con la hora de finalización 
....................  
....................                         lcd_gotoxy(9,2); 
539C:  MOVLW  09
539E:  MOVLB  2
53A0:  MOVWF  x94
53A2:  MOVLW  02
53A4:  MOVWF  x95
53A6:  MOVLB  0
53A8:  CALL   0D0E
....................  
....................                         pr.horas_fin = buscar_numero(); 
53AC:  CALL   267E
53B0:  MOVFF  01,79
....................  
....................                         if(pr.horas_fin==NO) 
53B4:  MOVF   79,W
53B6:  SUBLW  64
53B8:  BNZ   53BC
....................                            goto salir; 
53BA:  BRA    594A
....................  
....................                         if(pr.horas_fin==SI) 
53BC:  MOVF   79,W
53BE:  SUBLW  65
53C0:  BNZ   53D4
....................                         { 
....................                            if(contador==0) 
53C2:  MOVF   72,F
53C4:  BNZ   53D2
....................                            { 
....................                               PCF8583_write_byte(PCF8583_CTRL_STATUS_REG, 
....................                                     PCF8583_START_COUNTING); 
53C6:  CLRF   x9A
53C8:  CLRF   x9B
53CA:  CALL   1082
....................                               goto salir; 
53CE:  BRA    594A
....................                            } 
....................                            else 
53D0:  BRA    53D4
....................                               break; 
53D2:  BRA    5770
....................                         } 
....................  
....................  
....................                         lcd_gotoxy(12,2); 
53D4:  MOVLW  0C
53D6:  MOVLB  2
53D8:  MOVWF  x94
53DA:  MOVLW  02
53DC:  MOVWF  x95
53DE:  MOVLB  0
53E0:  CALL   0D0E
....................  
....................                         pr.minutos_fin = buscar_numero(); 
53E4:  CALL   267E
53E8:  MOVFF  01,7A
....................  
....................                         if(pr.minutos_fin==NO) 
53EC:  MOVF   7A,W
53EE:  SUBLW  64
53F0:  BNZ   53F4
....................                            goto salir; 
53F2:  BRA    594A
....................  
....................                         if(pr.minutos_fin==SI) 
53F4:  MOVF   7A,W
53F6:  SUBLW  65
53F8:  BNZ   540C
....................                         { 
....................                            if(contador==0) 
53FA:  MOVF   72,F
53FC:  BNZ   540A
....................                            { 
....................                               PCF8583_write_byte(PCF8583_CTRL_STATUS_REG, 
....................                                     PCF8583_START_COUNTING); 
53FE:  CLRF   x9A
5400:  CLRF   x9B
5402:  CALL   1082
....................                               goto salir; 
5406:  BRA    594A
....................                            } 
....................                            else 
5408:  BRA    540C
....................                               break; 
540A:  BRA    5770
....................                         } 
....................  
....................                         //Ver comentarios arriba 
....................                         //************************************************************ 
....................  
....................                         //Desactivamos el cursor de la pantalla 
....................                         lcd_send_byte(LCD_ORDEN, LCD_NO_CURSOR); 
540C:  MOVLB  2
540E:  CLRF   x98
5410:  MOVLW  0C
5412:  MOVWF  x99
5414:  MOVLB  0
5416:  CALL   0C60
....................  
....................                         //Introducimos cierto retardo para que el usuario pueda visualizar los valores introducidos en la pantalla 
....................                         delay_ms(LCD_T_RETARDO); 
541A:  MOVLW  02
541C:  MOVWF  x81
541E:  MOVLW  FA
5420:  MOVLB  2
5422:  MOVWF  x9A
5424:  MOVLB  0
5426:  CALL   0BE8
542A:  DECFSZ x81,F
542C:  BRA    541E
....................  
....................                         //Comprobamos que los valores introducidos son correctos: horas menores que 24 y minutos menores que 60 
....................                         //Además, comprobamos que la hora de finalización no vaya antes que la de inicio 
....................                         if(pr.horas_inicio>23 || pr.horas_fin>23 || pr.minutos_inicio>59 || pr.minutos_fin>59 
....................                               || comprobar_hora(pr.horas_fin,pr.minutos_fin,pr.horas_inicio,pr.minutos_inicio)) 
542E:  MOVF   77,W
5430:  SUBLW  17
5432:  BNC   545E
5434:  MOVF   79,W
5436:  SUBLW  17
5438:  BNC   545E
543A:  MOVF   78,W
543C:  SUBLW  3B
543E:  BNC   545E
5440:  MOVF   7A,W
5442:  SUBLW  3B
5444:  BNC   545E
5446:  MOVFF  79,9B
544A:  MOVFF  7A,9C
544E:  MOVFF  77,9D
5452:  MOVFF  78,9E
5456:  CALL   1294
545A:  MOVF   01,F
545C:  BZ    549E
....................                         { 
....................                            //Si se produce un error de este tipo, se indica 
....................                            lcd_send_byte(LCD_ORDEN, LCD_CLEAR); 
545E:  MOVLB  2
5460:  CLRF   x98
5462:  MOVLW  01
5464:  MOVWF  x99
5466:  MOVLB  0
5468:  CALL   0C60
....................                            printf(lcd_putc, "   Valores\n   incorrectos"); 
546C:  CLRF   x81
546E:  MOVF   x81,W
5470:  CALL   02D8
5474:  IORLW  00
5476:  BZ    5486
5478:  INCF   x81,F
547A:  MOVLB  2
547C:  MOVWF  x93
547E:  MOVLB  0
5480:  CALL   0D34
5484:  BRA    546E
....................                            delay_ms(LCD_T_RETARDO); 
5486:  MOVLW  02
5488:  MOVWF  x81
548A:  MOVLW  FA
548C:  MOVLB  2
548E:  MOVWF  x9A
5490:  MOVLB  0
5492:  CALL   0BE8
5496:  DECFSZ x81,F
5498:  BRA    548A
....................                            //Se repite la última iteración del bloque 
....................                            contador--; 
549A:  DECF   72,F
....................                            continue; 
549C:  BRA    576C
....................                         } 
....................  
....................                         //No puede haber un intervalo de encendido de más de 4 horas. 
....................                         //Esto deriva de un problema propio de almacenamiento de números enteros, pero es perfectamente lógico 
....................                         //que un sistema de calefacción tenga un tiempo máximo de encendido para regular el uso abusivo del sistema 
....................                         //y evitar averías por un funcionamiento muy prolongado. 
....................                         if(diferencia_tiempo(pr.horas_inicio, pr.minutos_inicio, pr.horas_fin, pr.minutos_fin)>240) 
549E:  MOVFF  77,91
54A2:  MOVFF  78,92
54A6:  MOVFF  79,93
54AA:  MOVFF  7A,94
54AE:  CALL   1A9A
54B2:  MOVFF  02,82
54B6:  MOVFF  01,81
54BA:  MOVF   x82,F
54BC:  BNZ   54C4
54BE:  MOVF   x81,W
54C0:  SUBLW  F0
54C2:  BC    5504
....................                         { 
....................                            //Mostramos un aviso 
....................                            lcd_send_byte(LCD_ORDEN, LCD_CLEAR); 
54C4:  MOVLB  2
54C6:  CLRF   x98
54C8:  MOVLW  01
54CA:  MOVWF  x99
54CC:  MOVLB  0
54CE:  CALL   0C60
....................                            printf(lcd_putc, "Intervalo limite\nde 4 horas"); 
54D2:  CLRF   x81
54D4:  MOVF   x81,W
54D6:  CALL   030C
54DA:  IORLW  00
54DC:  BZ    54EC
54DE:  INCF   x81,F
54E0:  MOVLB  2
54E2:  MOVWF  x93
54E4:  MOVLB  0
54E6:  CALL   0D34
54EA:  BRA    54D4
....................                            delay_ms(LCD_T_RETARDO); 
54EC:  MOVLW  02
54EE:  MOVWF  x81
54F0:  MOVLW  FA
54F2:  MOVLB  2
54F4:  MOVWF  x9A
54F6:  MOVLB  0
54F8:  CALL   0BE8
54FC:  DECFSZ x81,F
54FE:  BRA    54F0
....................                            //Se repite la última iteración del bloque 
....................                            contador--; 
5500:  DECF   72,F
....................                            continue; 
5502:  BRA    576C
....................  
....................                         } 
....................  
....................                         //El usuario debe ahora introducir el valor del temostato para ese periodo de encendido 
....................                         lcd_send_byte(LCD_ORDEN, LCD_CLEAR); 
5504:  MOVLB  2
5506:  CLRF   x98
5508:  MOVLW  01
550A:  MOVWF  x99
550C:  MOVLB  0
550E:  CALL   0C60
....................                         printf(lcd_putc, "Termostato %i\n      %cC", contador+1, 223); 
5512:  MOVLW  01
5514:  ADDWF  72,W
5516:  MOVWF  x81
5518:  CLRF   x82
551A:  MOVF   x82,W
551C:  CALL   0342
5520:  INCF   x82,F
5522:  MOVWF  00
5524:  MOVFF  FE8,293
5528:  CALL   0D34
552C:  MOVLW  0B
552E:  SUBWF  x82,W
5530:  BNZ   551A
5532:  MOVFF  81,83
5536:  MOVLW  1F
5538:  MOVWF  x84
553A:  CALL   271C
553E:  MOVLW  0A
5540:  MOVLB  2
5542:  MOVWF  x93
5544:  MOVLB  0
5546:  CALL   0D34
554A:  MOVLW  06
554C:  MOVWF  x83
554E:  MOVLW  20
5550:  MOVLB  2
5552:  MOVWF  x93
5554:  MOVLB  0
5556:  CALL   0D34
555A:  DECFSZ x83,F
555C:  BRA    554E
555E:  MOVLW  DF
5560:  MOVLB  2
5562:  MOVWF  x93
5564:  MOVLB  0
5566:  CALL   0D34
556A:  MOVLW  43
556C:  MOVLB  2
556E:  MOVWF  x93
5570:  MOVLB  0
5572:  CALL   0D34
....................                         lcd_gotoxy(4,2); 
5576:  MOVLW  04
5578:  MOVLB  2
557A:  MOVWF  x94
557C:  MOVLW  02
557E:  MOVWF  x95
5580:  MOVLB  0
5582:  CALL   0D0E
....................                         lcd_send_byte(LCD_ORDEN, LCD_CURSOR); //Activamos el cursor 
5586:  MOVLB  2
5588:  CLRF   x98
558A:  MOVLW  0E
558C:  MOVWF  x99
558E:  MOVLB  0
5590:  CALL   0C60
....................  
....................                         //Recogemos el número introducido por el usuario 
....................                         pr.termostato = buscar_numero(); 
5594:  CALL   267E
5598:  MOVFF  01,7B
....................  
....................                         //Eliminamos el cursor 
....................                         lcd_send_byte(LCD_ORDEN, LCD_NO_CURSOR); 
559C:  MOVLB  2
559E:  CLRF   x98
55A0:  MOVLW  0C
55A2:  MOVWF  x99
55A4:  MOVLB  0
55A6:  CALL   0C60
....................  
....................                         //Retardamos para que el usuario pueda ver el valor que ha introducido 
....................                         delay_ms(LCD_T_RETARDO); 
55AA:  MOVLW  02
55AC:  MOVWF  x81
55AE:  MOVLW  FA
55B0:  MOVLB  2
55B2:  MOVWF  x9A
55B4:  MOVLB  0
55B6:  CALL   0BE8
55BA:  DECFSZ x81,F
55BC:  BRA    55AE
....................  
....................                         //Si no se cumplen los límites de temperatura especificados para el termostato, no es válido el valor 
....................                         if(pr.termostato>temp_max || pr.termostato<temp_min) 
55BE:  MOVF   7B,W
55C0:  SUBLW  20
55C2:  BNC   55CA
55C4:  MOVF   7B,W
55C6:  SUBLW  0F
55C8:  BNC   560A
....................                         { 
....................                            //Se muestra un mensaje de error 
....................                            lcd_send_byte(LCD_ORDEN, LCD_CLEAR); 
55CA:  MOVLB  2
55CC:  CLRF   x98
55CE:  MOVLW  01
55D0:  MOVWF  x99
55D2:  MOVLB  0
55D4:  CALL   0C60
....................                            printf(lcd_putc, "   Valor\n   incorrecto"); 
55D8:  CLRF   x81
55DA:  MOVF   x81,W
55DC:  CALL   024C
55E0:  IORLW  00
55E2:  BZ    55F2
55E4:  INCF   x81,F
55E6:  MOVLB  2
55E8:  MOVWF  x93
55EA:  MOVLB  0
55EC:  CALL   0D34
55F0:  BRA    55DA
....................                            delay_ms(LCD_T_RETARDO); 
55F2:  MOVLW  02
55F4:  MOVWF  x81
55F6:  MOVLW  FA
55F8:  MOVLB  2
55FA:  MOVWF  x9A
55FC:  MOVLB  0
55FE:  CALL   0BE8
5602:  DECFSZ x81,F
5604:  BRA    55F6
....................                            //Se repite la última iteración 
....................                            contador--; 
5606:  DECF   72,F
....................                            continue; 
5608:  BRA    576C
....................                         } 
....................  
....................                         //Comprobamos que los intervalos sean correctos respecto a los otros, es decir, 
....................                         //que no haya solapamiento entre los distintos intervalos programados. 
....................                         for(contador2=0; contador2<contador; contador2++) 
560A:  CLRF   73
560C:  MOVF   72,W
560E:  SUBWF  73,W
5610:  BTFSC  FD8.0
5612:  BRA    5748
....................                         { 
....................                            //Tomamos las programaciones almacenadas anteriormente 
....................                            pr2 = programaciones[contador2]; 
5614:  MOVF   73,W
5616:  MULLW  05
5618:  MOVF   FF3,W
561A:  CLRF   03
561C:  ADDLW  36
561E:  MOVWF  01
5620:  MOVLW  00
5622:  ADDWFC 03,F
5624:  MOVFF  01,81
5628:  MOVFF  03,82
562C:  CLRF   FEA
562E:  MOVLW  7C
5630:  MOVWF  FE9
5632:  MOVFF  03,FE2
5636:  MOVFF  01,FE1
563A:  MOVLW  05
563C:  MOVWF  01
563E:  MOVFF  FE6,FEE
5642:  DECFSZ 01,F
5644:  BRA    563E
....................  
....................                            //Controlamos todas las posibilidades de solapamiento 
....................                            if( 
....................                               (comprobar_hora(pr2.horas_inicio, pr2.minutos_inicio, pr.horas_fin, pr.minutos_fin) && 
....................                               !comprobar_hora(pr2.horas_inicio, pr2.minutos_inicio, pr.horas_inicio, pr.minutos_inicio)) 
....................  
....................                               ||(comprobar_hora(pr2.horas_fin, pr2.minutos_fin, pr.horas_fin, pr.minutos_fin) && 
....................                                 !comprobar_hora(pr2.horas_fin, pr2.minutos_fin, pr.horas_inicio, pr.minutos_inicio)) 
....................  
....................                               ||(comprobar_hora(pr.horas_inicio, pr.minutos_inicio, pr2.horas_fin, pr2.minutos_fin) && 
....................                                 !comprobar_hora(pr.horas_inicio, pr.minutos_inicio, pr2.horas_inicio, pr2.minutos_inicio)) 
....................  
....................                               ||(comprobar_hora(pr.horas_fin, pr.minutos_fin, pr2.horas_fin, pr2.minutos_fin) && 
....................                                 !comprobar_hora(pr.horas_fin, pr.minutos_fin, pr2.horas_inicio, pr2.minutos_inicio)) 
....................                            ) 
5646:  MOVFF  7C,9B
564A:  MOVFF  7D,9C
564E:  MOVFF  79,9D
5652:  MOVFF  7A,9E
5656:  CALL   1294
565A:  MOVF   01,F
565C:  BZ    5676
565E:  MOVFF  7C,9B
5662:  MOVFF  7D,9C
5666:  MOVFF  77,9D
566A:  MOVFF  78,9E
566E:  CALL   1294
5672:  MOVF   01,F
5674:  BZ    5706
5676:  MOVFF  7E,9B
567A:  MOVFF  7F,9C
567E:  MOVFF  79,9D
5682:  MOVFF  7A,9E
5686:  CALL   1294
568A:  MOVF   01,F
568C:  BZ    56A6
568E:  MOVFF  7E,9B
5692:  MOVFF  7F,9C
5696:  MOVFF  77,9D
569A:  MOVFF  78,9E
569E:  CALL   1294
56A2:  MOVF   01,F
56A4:  BZ    5706
56A6:  MOVFF  77,9B
56AA:  MOVFF  78,9C
56AE:  MOVFF  7E,9D
56B2:  MOVFF  7F,9E
56B6:  CALL   1294
56BA:  MOVF   01,F
56BC:  BZ    56D6
56BE:  MOVFF  77,9B
56C2:  MOVFF  78,9C
56C6:  MOVFF  7C,9D
56CA:  MOVFF  7D,9E
56CE:  CALL   1294
56D2:  MOVF   01,F
56D4:  BZ    5706
56D6:  MOVFF  79,9B
56DA:  MOVFF  7A,9C
56DE:  MOVFF  7E,9D
56E2:  MOVFF  7F,9E
56E6:  CALL   1294
56EA:  MOVF   01,F
56EC:  BZ    5744
56EE:  MOVFF  79,9B
56F2:  MOVFF  7A,9C
56F6:  MOVFF  7C,9D
56FA:  MOVFF  7D,9E
56FE:  CALL   1294
5702:  MOVF   01,F
5704:  BNZ   5744
....................                            { 
....................                               //Si hay solapamiento, mostramos un mensaje de error y salimos 
....................                               lcd_send_byte(LCD_ORDEN, LCD_CLEAR); 
5706:  MOVLB  2
5708:  CLRF   x98
570A:  MOVLW  01
570C:  MOVWF  x99
570E:  MOVLB  0
5710:  CALL   0C60
....................                               printf(lcd_putc, "Solapamiento\nde intervalos!"); 
5714:  CLRF   x81
5716:  MOVF   x81,W
5718:  CALL   036E
571C:  IORLW  00
571E:  BZ    572E
5720:  INCF   x81,F
5722:  MOVLB  2
5724:  MOVWF  x93
5726:  MOVLB  0
5728:  CALL   0D34
572C:  BRA    5716
....................                               delay_ms(LCD_T_RETARDO*2); 
572E:  MOVLW  04
5730:  MOVWF  x81
5732:  MOVLW  FA
5734:  MOVLB  2
5736:  MOVWF  x9A
5738:  MOVLB  0
573A:  CALL   0BE8
573E:  DECFSZ x81,F
5740:  BRA    5732
....................                               goto salir; 
5742:  BRA    594A
....................                            } 
....................                         } 
5744:  INCF   73,F
5746:  BRA    560C
....................  
....................                         //Añadimos esta programación a la lista de programaciones 
....................                         programaciones[contador]=pr; 
5748:  MOVF   72,W
574A:  MULLW  05
574C:  MOVF   FF3,W
574E:  CLRF   03
5750:  ADDLW  36
5752:  MOVWF  FE9
5754:  MOVLW  00
5756:  ADDWFC 03,W
5758:  MOVWF  FEA
575A:  CLRF   FE2
575C:  MOVLW  77
575E:  MOVWF  FE1
5760:  MOVLW  05
5762:  MOVWF  01
5764:  MOVFF  FE6,FEE
5768:  DECFSZ 01,F
576A:  BRA    5764
....................                      } 
576C:  INCF   72,F
576E:  BRA    5292
....................  
....................                      //Habilitamos la alarma 
....................                      PCF8583_write_byte(PCF8583_CTRL_STATUS_REG, 
....................                                  PCF8583_ACTIVAR_ALARMA); 
5770:  CLRF   x9A
5772:  MOVLW  04
5774:  MOVWF  x9B
5776:  CALL   1082
....................  
....................                      //Guardamos el número de intervalos configurados 
....................                      num_intervalos = contador; 
577A:  MOVFF  72,54
....................  
....................                      //Ordenamos las programaciones por orden de hora de inicio 
....................                      ordenar_programaciones(); 
577E:  GOTO   27F4
....................  
....................                      //Seleccionamos la próxima alarma a ejecutar 
....................                      seleccionar_alarma(); 
5782:  CALL   12C8
....................  
....................                      //Programamos la próxima alarma para que salte el reloj en el momento indicado 
....................                      programar_proxima_alarma(); 
5786:  CALL   140C
....................  
....................                      //Indicamos que se trata de una alarma de encendido 
....................                      toca_encender = TRUE; 
578A:  MOVLW  01
578C:  MOVWF  22
....................  
....................                      //Guardamos las programaciones introducidas 
....................                      grabar_programaciones(); 
578E:  GOTO   292C
....................  
....................                      break; 
....................  
....................  
....................             //Si es 4, entramos en el modo de revisión y obtención de datos históricos 
....................             case '4': 
....................                      key = 'J'; //Carácter falso para permitir la entrada de datos 
5792:  MOVLW  4A
5794:  MOVWF  33
....................                      //Solicitamos la introducción de una clave 
....................                      lcd_send_byte(LCD_ORDEN, LCD_CLEAR); 
5796:  MOVLB  2
5798:  CLRF   x98
579A:  MOVLW  01
579C:  MOVWF  x99
579E:  MOVLB  0
57A0:  CALL   0C60
....................                      lcd_send_byte(LCD_ORDEN, LCD_CURSOR); 
57A4:  MOVLB  2
57A6:  CLRF   x98
57A8:  MOVLW  0E
57AA:  MOVWF  x99
57AC:  MOVLB  0
57AE:  CALL   0C60
....................                      printf(lcd_putc, "  CLAVE:\n  "); 
57B2:  CLRF   x81
57B4:  MOVF   x81,W
57B6:  CALL   03A4
57BA:  IORLW  00
57BC:  BZ    57CC
57BE:  INCF   x81,F
57C0:  MOVLB  2
57C2:  MOVWF  x93
57C4:  MOVLB  0
57C6:  CALL   0D34
57CA:  BRA    57B4
....................  
....................                      //Introducimos primero los dos primero dígitos 
....................                      contador = 0; 
57CC:  CLRF   72
....................                      while(contador!=2) 
....................                      { 
57CE:  MOVF   72,W
57D0:  SUBLW  02
57D2:  BZ    580E
....................                         key = get_key(); 
57D4:  CALL   2216
57D8:  MOVFF  01,33
....................                         //Si se trata de un número, lo guardamos y mostramos un asterisco 
....................                         //por tratarse de una clave 
....................                         if(isdigit(key)){ 
57DC:  MOVF   33,W
57DE:  SUBLW  2F
57E0:  BC    580C
57E2:  MOVF   33,W
57E4:  SUBLW  39
57E6:  BNC   580C
....................                            lcd_putc('*'); 
57E8:  MOVLW  2A
57EA:  MOVLB  2
57EC:  MOVWF  x93
57EE:  MOVLB  0
57F0:  CALL   0D34
....................                            keys[contador] = key; 
57F4:  CLRF   03
57F6:  MOVF   72,W
57F8:  ADDLW  34
57FA:  MOVWF  FE9
57FC:  MOVLW  00
57FE:  ADDWFC 03,W
5800:  MOVWF  FEA
5802:  MOVFF  33,FEF
....................                            key = 'J'; 
5806:  MOVLW  4A
5808:  MOVWF  33
....................                            contador++; 
580A:  INCF   72,F
....................                         } 
....................                      } 
580C:  BRA    57CE
....................  
....................                      //Convertimos los dígitos introducidos a un valor numérico 
....................                      numero = atoi(keys); 
580E:  CLRF   x84
5810:  MOVLW  34
5812:  MOVWF  x83
5814:  CALL   24E4
5818:  CLRF   03
581A:  MOVFF  01,75
581E:  MOVFF  03,76
....................  
....................                      //Repetimos la operación con los dos dígitos menos significativos 
....................                      contador = 0; 
5822:  CLRF   72
....................                      while(contador!=2) 
....................                      { 
5824:  MOVF   72,W
5826:  SUBLW  02
5828:  BZ    5864
....................                         key = get_key(); 
582A:  CALL   2216
582E:  MOVFF  01,33
....................                         if(isdigit(key)){ 
5832:  MOVF   33,W
5834:  SUBLW  2F
5836:  BC    5862
5838:  MOVF   33,W
583A:  SUBLW  39
583C:  BNC   5862
....................                            lcd_putc('*'); 
583E:  MOVLW  2A
5840:  MOVLB  2
5842:  MOVWF  x93
5844:  MOVLB  0
5846:  CALL   0D34
....................                            keys[contador] = key; 
584A:  CLRF   03
584C:  MOVF   72,W
584E:  ADDLW  34
5850:  MOVWF  FE9
5852:  MOVLW  00
5854:  ADDWFC 03,W
5856:  MOVWF  FEA
5858:  MOVFF  33,FEF
....................                            key = 'J'; 
585C:  MOVLW  4A
585E:  MOVWF  33
....................                            contador++; 
5860:  INCF   72,F
....................                         } 
....................                      } 
5862:  BRA    5824
....................  
....................                      //Construimos la clave a partir de las dos lecturas 
....................                      numero = numero*100 + atoi(keys); 
5864:  MOVFF  76,A3
5868:  MOVFF  75,A2
586C:  CLRF   xA5
586E:  MOVLW  64
5870:  MOVWF  xA4
5872:  CALL   1A7C
5876:  MOVFF  02,82
587A:  MOVFF  01,81
587E:  CLRF   x84
5880:  MOVLW  34
5882:  MOVWF  x83
5884:  CALL   24E4
5888:  CLRF   03
588A:  MOVF   01,W
588C:  BTFSC  FE8.7
588E:  DECF   03,F
5890:  ADDWF  x81,W
5892:  MOVWF  01
5894:  MOVF   x82,W
5896:  ADDWFC 03,F
5898:  MOVFF  01,75
589C:  MOVFF  03,76
....................  
....................                      //Retardamos un poco para que el usuario pueda ver que ha introducido 4 dígitos 
....................                      delay_ms(LCD_T_RETARDO); 
58A0:  MOVLW  02
58A2:  MOVWF  x81
58A4:  MOVLW  FA
58A6:  MOVLB  2
58A8:  MOVWF  x9A
58AA:  MOVLB  0
58AC:  CALL   0BE8
58B0:  DECFSZ x81,F
58B2:  BRA    58A4
....................  
....................                      if(numero == clave) 
58B4:  MOVF   75,W
58B6:  SUBLW  61
58B8:  BNZ   58FC
58BA:  MOVF   76,W
58BC:  SUBLW  09
58BE:  BNZ   58FC
....................                      { 
....................                         //Si la clave es correcta, entramos en el modo revisión 
....................                         lcd_send_byte(LCD_ORDEN, LCD_CLEAR); 
58C0:  MOVLB  2
58C2:  CLRF   x98
58C4:  MOVLW  01
58C6:  MOVWF  x99
58C8:  MOVLB  0
58CA:  CALL   0C60
....................                         lcd_send_byte(LCD_ORDEN, LCD_NO_CURSOR); 
58CE:  MOVLB  2
58D0:  CLRF   x98
58D2:  MOVLW  0C
58D4:  MOVWF  x99
58D6:  MOVLB  0
58D8:  CALL   0C60
....................                         printf(lcd_putc, "  Modo\n  revision"); 
58DC:  CLRF   x81
58DE:  MOVF   x81,W
58E0:  CALL   03CA
58E4:  IORLW  00
58E6:  BZ    58F6
58E8:  INCF   x81,F
58EA:  MOVLB  2
58EC:  MOVWF  x93
58EE:  MOVLB  0
58F0:  CALL   0D34
58F4:  BRA    58DE
....................                         //Representamos el contenido de los registros y activamos la interfaz RS-232 
....................                         representar_registros(); 
58F6:  GOTO   2C86
....................                      }else 
58FA:  BRA    5948
....................                      { 
....................                         //Si la clave es incorrecta, lo indicamos y salimos 
....................                         lcd_send_byte(LCD_ORDEN, LCD_CLEAR); 
58FC:  MOVLB  2
58FE:  CLRF   x98
5900:  MOVLW  01
5902:  MOVWF  x99
5904:  MOVLB  0
5906:  CALL   0C60
....................                         lcd_send_byte(LCD_ORDEN, LCD_NO_CURSOR); 
590A:  MOVLB  2
590C:  CLRF   x98
590E:  MOVLW  0C
5910:  MOVWF  x99
5912:  MOVLB  0
5914:  CALL   0C60
....................                         printf(lcd_putc, "  Clave\n  incorrecta"); 
5918:  CLRF   x81
591A:  MOVF   x81,W
591C:  CALL   03F6
5920:  IORLW  00
5922:  BZ    5932
5924:  INCF   x81,F
5926:  MOVLB  2
5928:  MOVWF  x93
592A:  MOVLB  0
592C:  CALL   0D34
5930:  BRA    591A
....................                         delay_ms(LCD_T_RETARDO); 
5932:  MOVLW  02
5934:  MOVWF  x81
5936:  MOVLW  FA
5938:  MOVLB  2
593A:  MOVWF  x9A
593C:  MOVLB  0
593E:  CALL   0BE8
5942:  DECFSZ x81,F
5944:  BRA    5936
....................                         goto salir; 
5946:  BRA    594A
....................                      } 
....................  
....................                      break; 
5948:  BRA    5996
....................  
....................  
....................             //Si se pulsa NO, salimos del menú de interfaz con el usuario 
....................             case 'N': 
....................                      //Aquí confluyen todas las salidas de esta rutina 
....................                      salir: 
....................                      //Se muestra un mensaje de finalización 
....................                      lcd_send_byte(LCD_ORDEN,LCD_CLEAR); 
594A:  MOVLB  2
594C:  CLRF   x98
594E:  MOVLW  01
5950:  MOVWF  x99
5952:  MOVLB  0
5954:  CALL   0C60
....................                      lcd_send_byte(LCD_ORDEN,LCD_NO_CURSOR); 
5958:  MOVLB  2
595A:  CLRF   x98
595C:  MOVLW  0C
595E:  MOVWF  x99
5960:  MOVLB  0
5962:  CALL   0C60
....................                      printf(lcd_putc, "  Anulando\n  operacion..."); 
5966:  CLRF   x81
5968:  MOVF   x81,W
596A:  CALL   0426
596E:  IORLW  00
5970:  BZ    5980
5972:  INCF   x81,F
5974:  MOVLB  2
5976:  MOVWF  x93
5978:  MOVLB  0
597A:  CALL   0D34
597E:  BRA    5968
....................                      delay_ms(LCD_T_RETARDO); 
5980:  MOVLW  02
5982:  MOVWF  x81
5984:  MOVLW  FA
5986:  MOVLB  2
5988:  MOVWF  x9A
598A:  MOVLB  0
598C:  CALL   0BE8
5990:  DECFSZ x81,F
5992:  BRA    5984
....................                      break; 
5994:  BRA    5996
....................  
....................          } 
....................  
....................          //Se desactiva el flag de indicación de la interrupción 
....................          led_int = FALSE; 
5996:  CLRF   68
....................       } 
....................  
....................       //Comenzamos el bloque de comprobación de parámetros y activación de los procesos necesarios. 
....................  
....................       //Comparamos primero la temperatura del agua en la caldera. Esta comprobación se 
....................       //realiza siempre, independientemente de que el sistema esté o no encendido. 
....................       if(C1OUT) 
5998:  BTFSS  FB4.6
599A:  BRA    59BA
....................       { 
....................          //Entramos aquí si la temperatura de la caldera es menor que la necesaria 
....................          if(temperatura_caldera_superada) 
599C:  MOVF   1F,F
599E:  BZ    59B0
....................          { 
....................             //Si la temperatura de la caldera estaba superada la última vez, tenemos en cuenta cierta histéresis 
....................             //de los valores. 
....................             if(!comp_caldera()) 
59A0:  GOTO   4774
59A4:  MOVF   01,F
59A6:  BNZ   59AE
....................             { 
....................                //Si la temperatura de la caldera es menor que la necesaria, encendemos la caldera. 
....................                temperatura_caldera_superada = FALSE; 
59A8:  CLRF   1F
....................                encender_caldera(); 
59AA:  CALL   4942
....................             } 
....................  
....................          } 
....................          else if(!caldera_encendida) 
59AE:  BRA    59B8
59B0:  BTFSC  F83.7
59B2:  BRA    59B8
....................          { 
....................             //Si no estaba encendida, la encendemos 
....................             encender_caldera(); 
59B4:  CALL   4942
....................          } 
....................       } 
....................       else 
59B8:  BRA    59CA
....................       { 
....................          //Si la temperatura de la caldera es mayor que la necesaria, apagamos la caldera si está encendida 
....................          //y activamos el flag correspondiente 
....................          if(!temperatura_caldera_superada) 
59BA:  MOVF   1F,F
59BC:  BNZ   59C2
....................             temperatura_caldera_superada = TRUE; 
59BE:  MOVLW  01
59C0:  MOVWF  1F
....................          if(caldera_encendida) 
59C2:  BTFSS  F83.7
59C4:  BRA    59CA
....................             apagar_caldera(); 
59C6:  GOTO   495C
....................       } 
....................  
....................       //Comprobamos ahora la temperatura de la vivienda. Esto se realiza sólo si el sistema está encendido 
....................       if(comprobar_temperatura() && sistema_encendido && temperatura_caldera_superada) 
59CA:  GOTO   4AFA
59CE:  MOVF   01,F
59D0:  BZ    5A8C
59D2:  BTFSS  F83.5
59D4:  BRA    5A8C
59D6:  MOVF   1F,F
59D8:  BZ    5A8C
....................       { 
....................          //Si la temperatura es menor que la necesaria, el sistema está encendido y la temperatura del 
....................          //agua en la caldera es la adecuada, encendemos el motor de circulación del agua 
....................          if(!motor) 
59DA:  BTFSC  F83.6
59DC:  BRA    59E0
....................             motor = TRUE; 
59DE:  BSF    F83.6
....................  
....................          //Comprobamos que el sistema no lleve encendido más de 4 horas, ya que en ese caso hay riesgo de avería 
....................          //(en realidad esta limitación deriva de un problema propio de representación en memoria). 
....................          //Ya leimos el tiempo en comprobar_temperatura(), así que no necesitamos leerlo de nuevo. 
....................          if(diferencia_tiempo(hora_encendido, minutos_encendido, tiempo.hours, tiempo.minutes)>240) 
59E0:  MOVFF  5D,91
59E4:  MOVFF  5E,92
59E8:  MOVFF  58,93
59EC:  MOVFF  57,94
59F0:  CALL   1A9A
59F4:  MOVFF  02,82
59F8:  MOVFF  01,81
59FC:  MOVF   x82,F
59FE:  BNZ   5A06
5A00:  MOVF   x81,W
5A02:  SUBLW  F0
5A04:  BC    5A8A
....................          { 
....................             //Si la diferencia de tiempo es mayor que 4 horas, lo indicamos y apagamos el motor y el sistema 
....................             lcd_send_byte(LCD_ORDEN,LCD_CLEAR); 
5A06:  MOVLB  2
5A08:  CLRF   x98
5A0A:  MOVLW  01
5A0C:  MOVWF  x99
5A0E:  MOVLB  0
5A10:  CALL   0C60
....................             printf(lcd_putc, "Demasiado tiempo\nencendido!"); 
5A14:  CLRF   x81
5A16:  MOVF   x81,W
5A18:  CALL   045A
5A1C:  IORLW  00
5A1E:  BZ    5A2E
5A20:  INCF   x81,F
5A22:  MOVLB  2
5A24:  MOVWF  x93
5A26:  MOVLB  0
5A28:  CALL   0D34
5A2C:  BRA    5A16
....................             delay_ms(LCD_T_RETARDO); 
5A2E:  MOVLW  02
5A30:  MOVWF  x81
5A32:  MOVLW  FA
5A34:  MOVLB  2
5A36:  MOVWF  x9A
5A38:  MOVLB  0
5A3A:  CALL   0BE8
5A3E:  DECFSZ x81,F
5A40:  BRA    5A32
....................             lcd_send_byte(LCD_ORDEN,LCD_CLEAR); 
5A42:  MOVLB  2
5A44:  CLRF   x98
5A46:  MOVLW  01
5A48:  MOVWF  x99
5A4A:  MOVLB  0
5A4C:  CALL   0C60
....................             printf(lcd_putc, "  Apagando\n  sistema..."); 
5A50:  CLRF   x81
5A52:  MOVF   x81,W
5A54:  CALL   0182
5A58:  IORLW  00
5A5A:  BZ    5A6A
5A5C:  INCF   x81,F
5A5E:  MOVLB  2
5A60:  MOVWF  x93
5A62:  MOVLB  0
5A64:  CALL   0D34
5A68:  BRA    5A52
....................             apagar_sistema(); 
5A6A:  CALL   1EEC
....................  
....................             if(motor) 
5A6E:  BTFSS  F83.6
5A70:  BRA    5A74
....................               motor = FALSE; 
5A72:  BCF    F83.6
....................  
....................             //Si estaba encendido por alguna alarma, recuperamos el termostato anterior. 
....................             if(encendido_por_alarma) 
5A74:  MOVF   21,F
5A76:  BZ    5A8A
....................             { 
....................                termostato = termostato_provisional; 
5A78:  MOVFF  2A,26
5A7C:  MOVFF  29,25
5A80:  MOVFF  28,24
5A84:  MOVFF  27,23
....................                encendido_por_alarma = FALSE; 
5A88:  CLRF   21
....................             } 
....................  
....................          } 
....................  
....................       } 
....................       else if(motor) 
5A8A:  BRA    5A92
5A8C:  BTFSS  F83.6
5A8E:  BRA    5A92
....................          //Si no se cumplen las condiciones, apagamos el motor si está encendido 
....................          motor = FALSE; 
5A90:  BCF    F83.6
....................  
....................       //Volvemos a habilitar las interrupciones 
....................       enable_interrupts(GLOBAL); 
5A92:  MOVLW  C0
5A94:  IORWF  FF2,F
....................  
....................       //Activamos el perro guardián 
....................       setup_wdt(WDT_ON); 
5A96:  BSF    FD1.0
....................  
....................       //Ponemos a "dormir" al microcontrolador para que el gasto de energía sea menor 
....................       sleep(); 
5A98:  SLEEP 
....................  
....................    } 
5A9A:  GOTO   4D7A
....................  
.................... } 
....................  
.................... //********************************************* 
.................... //    Descripción de los métodos utilizados 
.................... //********************************************* 
.................... //Puede verse una explicación general de su función al principio del programa 
....................  
.................... int comprobar_temperatura() 
.................... { 
5A9E:  SLEEP 
....................    //Leemos la temperatura 
....................    temperatura = ds1820_read(); 
*
4AFA:  CALL   16BC
4AFE:  MOVFF  03,2E
4B02:  MOVFF  02,2D
4B06:  MOVFF  01,2C
4B0A:  MOVFF  00,2B
....................  
....................    //Mostramos la información en la pantalla lcd 
....................    mostrar_temperatura(); 
4B0E:  BRA    4A14
....................  
....................    if(temperatura < termostato) 
4B10:  MOVFF  2E,8C
4B14:  MOVFF  2D,8B
4B18:  MOVFF  2C,8A
4B1C:  MOVFF  2B,89
4B20:  MOVFF  26,90
4B24:  MOVFF  25,8F
4B28:  MOVFF  24,8E
4B2C:  MOVFF  23,8D
4B30:  CALL   1762
4B34:  BNC   4B7A
....................    { 
....................       //Si la temperatura es menor que la del termostato, devolvemos TRUE 
....................       if(temp_habitacion_superada) 
4B36:  MOVF   20,F
4B38:  BZ    4B72
....................       { 
....................          //Si la temperatura antes era mayor, indicamos el cambio en el flag 
....................          temp_habitacion_superada = FALSE; 
4B3A:  CLRF   20
....................          //Tenemos en cuenta la histéresis para el nuevo valor del termostato 
....................          termostato = termostato + histeresis_vivienda; 
4B3C:  BCF    FD8.1
4B3E:  MOVFF  26,295
4B42:  MOVFF  25,294
4B46:  MOVFF  24,293
4B4A:  MOVFF  23,292
4B4E:  MOVFF  32,299
4B52:  MOVFF  31,298
4B56:  MOVFF  30,297
4B5A:  MOVFF  2F,296
4B5E:  CALL   17D8
4B62:  MOVFF  03,26
4B66:  MOVFF  02,25
4B6A:  MOVFF  01,24
4B6E:  MOVFF  00,23
....................       } 
....................       return TRUE; 
4B72:  MOVLW  01
4B74:  MOVWF  01
4B76:  BRA    4BBE
....................    } 
....................    else 
4B78:  BRA    4BBE
....................    { 
....................       //Si la temperatura es mayor que la del termostato, devolvemos FALSE 
....................       if(!temp_habitacion_superada) 
4B7A:  MOVF   20,F
4B7C:  BNZ   4BB8
....................       { 
....................          //Si antes era menor, cambiamos el flag 
....................          temp_habitacion_superada = TRUE; 
4B7E:  MOVLW  01
4B80:  MOVWF  20
....................          //Guardamos el nuevo valor del termostato teniendo en cuenta la histéresis 
....................          termostato = termostato - histeresis_vivienda; 
4B82:  BSF    FD8.1
4B84:  MOVFF  26,295
4B88:  MOVFF  25,294
4B8C:  MOVFF  24,293
4B90:  MOVFF  23,292
4B94:  MOVFF  32,299
4B98:  MOVFF  31,298
4B9C:  MOVFF  30,297
4BA0:  MOVFF  2F,296
4BA4:  CALL   17D8
4BA8:  MOVFF  03,26
4BAC:  MOVFF  02,25
4BB0:  MOVFF  01,24
4BB4:  MOVFF  00,23
....................       } 
....................       return FALSE; 
4BB8:  MOVLW  00
4BBA:  MOVWF  01
4BBC:  BRA    4BBE
....................    } 
.................... } 
4BBE:  GOTO   59CE (RETURN)
....................  
....................  
.................... int comp_caldera() 
.................... { 
....................    //Suponemos una variación de la temperatura del agua en la caldera de t_max_calderaºC 
....................    //a t_min_calderaºC, con una precisión que depende del potenciómetro. 
....................  
....................    //Variables para registrar el termostato y la temperatura de la caldera 
....................    float termo, temp; 
....................  
....................    //Establecemos como entrada analógica a analizar la del termostato 
....................    set_adc_channel(termostato_caldera); 
*
4774:  MOVLW  0C
4776:  MOVWF  01
4778:  MOVF   FC2,W
477A:  ANDLW  C3
477C:  IORWF  01,W
477E:  MOVWF  FC2
....................    delay_us(10);  //Retraso para posibilitar la lectura 
4780:  CLRWDT
4782:  MOVLW  06
4784:  MOVWF  00
4786:  DECFSZ 00,F
4788:  BRA    4786
....................    //Transformamos el valor analógico leído en la escala utilizada por el termostato 
....................    termo = t_min_caldera + ((t_max_caldera-t_min_caldera)*(float)read_adc())/AD_num_valores; 
478A:  BSF    FC2.1
478C:  BTFSC  FC2.1
478E:  BRA    478C
4790:  MOVF   FC4,W
4792:  MOVLB  2
4794:  CLRF   x99
4796:  MOVWF  x98
4798:  MOVLB  0
479A:  CALL   0F38
479E:  MOVLB  2
47A0:  CLRF   xB1
47A2:  CLRF   xB0
47A4:  MOVLW  34
47A6:  MOVWF  xAF
47A8:  MOVLW  84
47AA:  MOVWF  xAE
47AC:  MOVFF  03,2B5
47B0:  MOVFF  02,2B4
47B4:  MOVFF  01,2B3
47B8:  MOVFF  00,2B2
47BC:  MOVLB  0
47BE:  CALL   1BC2
47C2:  MOVFF  00,89
47C6:  MOVFF  01,8A
47CA:  MOVFF  02,8B
47CE:  MOVFF  03,8C
47D2:  MOVFF  03,29B
47D6:  MOVFF  02,29A
47DA:  MOVFF  01,299
47DE:  MOVFF  00,298
47E2:  MOVLB  2
47E4:  CLRF   x9F
47E6:  CLRF   x9E
47E8:  MOVLW  7F
47EA:  MOVWF  x9D
47EC:  MOVLW  86
47EE:  MOVWF  x9C
47F0:  MOVLB  0
47F2:  CALL   155C
47F6:  BCF    FD8.1
47F8:  MOVLB  2
47FA:  CLRF   x95
47FC:  CLRF   x94
47FE:  MOVLW  48
4800:  MOVWF  x93
4802:  MOVLW  83
4804:  MOVWF  x92
4806:  MOVFF  03,299
480A:  MOVFF  02,298
480E:  MOVFF  01,297
4812:  MOVFF  00,296
4816:  MOVLB  0
4818:  CALL   17D8
481C:  MOVFF  03,84
4820:  MOVFF  02,83
4824:  MOVFF  01,82
4828:  MOVFF  00,81
....................  
....................    //Establecemos como entrada analógica a analizar la de la temperatura del agua 
....................    set_adc_channel(temperatura_caldera); 
482C:  MOVLW  00
482E:  MOVWF  01
4830:  MOVF   FC2,W
4832:  ANDLW  C3
4834:  IORWF  01,W
4836:  MOVWF  FC2
....................    delay_us(10); //Retraso para posibilitar la lectura 
4838:  CLRWDT
483A:  MOVLW  06
483C:  MOVWF  00
483E:  DECFSZ 00,F
4840:  BRA    483E
....................    //Transformamos el valor analógico leído a la escala utlizada en la temperatura 
....................    temp = t_min_caldera + ((t_max_caldera-t_min_caldera)*(float)read_adc())/AD_num_valores; 
4842:  BSF    FC2.1
4844:  BTFSC  FC2.1
4846:  BRA    4844
4848:  MOVF   FC4,W
484A:  MOVLB  2
484C:  CLRF   x99
484E:  MOVWF  x98
4850:  MOVLB  0
4852:  CALL   0F38
4856:  MOVLB  2
4858:  CLRF   xB1
485A:  CLRF   xB0
485C:  MOVLW  34
485E:  MOVWF  xAF
4860:  MOVLW  84
4862:  MOVWF  xAE
4864:  MOVFF  03,2B5
4868:  MOVFF  02,2B4
486C:  MOVFF  01,2B3
4870:  MOVFF  00,2B2
4874:  MOVLB  0
4876:  CALL   1BC2
487A:  MOVFF  00,89
487E:  MOVFF  01,8A
4882:  MOVFF  02,8B
4886:  MOVFF  03,8C
488A:  MOVFF  03,29B
488E:  MOVFF  02,29A
4892:  MOVFF  01,299
4896:  MOVFF  00,298
489A:  MOVLB  2
489C:  CLRF   x9F
489E:  CLRF   x9E
48A0:  MOVLW  7F
48A2:  MOVWF  x9D
48A4:  MOVLW  86
48A6:  MOVWF  x9C
48A8:  MOVLB  0
48AA:  CALL   155C
48AE:  BCF    FD8.1
48B0:  MOVLB  2
48B2:  CLRF   x95
48B4:  CLRF   x94
48B6:  MOVLW  48
48B8:  MOVWF  x93
48BA:  MOVLW  83
48BC:  MOVWF  x92
48BE:  MOVFF  03,299
48C2:  MOVFF  02,298
48C6:  MOVFF  01,297
48CA:  MOVFF  00,296
48CE:  MOVLB  0
48D0:  CALL   17D8
48D4:  MOVFF  03,88
48D8:  MOVFF  02,87
48DC:  MOVFF  01,86
48E0:  MOVFF  00,85
....................  
....................    //Comparamos ambas temperaturas teniendo en cuenta la histéresis de la caldera 
....................    if(temp > termo-histeresis_caldera) 
48E4:  BSF    FD8.1
48E6:  MOVFF  84,295
48EA:  MOVFF  83,294
48EE:  MOVFF  82,293
48F2:  MOVFF  81,292
48F6:  MOVLB  2
48F8:  CLRF   x99
48FA:  CLRF   x98
48FC:  MOVLW  20
48FE:  MOVWF  x97
4900:  MOVLW  81
4902:  MOVWF  x96
4904:  MOVLB  0
4906:  CALL   17D8
490A:  MOVFF  03,8C
490E:  MOVFF  02,8B
4912:  MOVFF  01,8A
4916:  MOVFF  00,89
491A:  MOVFF  88,90
491E:  MOVFF  87,8F
4922:  MOVFF  86,8E
4926:  MOVFF  85,8D
492A:  CALL   1762
492E:  BNC   4938
....................       return TRUE; 
4930:  MOVLW  01
4932:  MOVWF  01
4934:  BRA    493E
....................    else 
4936:  BRA    493E
....................       return FALSE; 
4938:  MOVLW  00
493A:  MOVWF  01
493C:  BRA    493E
.................... } 
493E:  GOTO   59A4 (RETURN)
....................  
....................  
.................... void mostrar_temperatura() 
.................... { 
....................    //Leemos el tiempo y lo guardamos en la variable tiempo 
....................    PCF8583_read_datetime(&tiempo); 
*
4A14:  CLRF   x92
4A16:  MOVLW  56
4A18:  MOVWF  x91
4A1A:  CALL   10D6
....................  
....................    //Mostramos la temperatura registrada 
....................    lcd_send_byte(LCD_ORDEN, LCD_CLEAR); 
4A1E:  MOVLB  2
4A20:  CLRF   x98
4A22:  MOVLW  01
4A24:  MOVWF  x99
4A26:  MOVLB  0
4A28:  CALL   0C60
....................    printf(lcd_putc, "TEMP - %3.1f %cC\nHORA - ", temperatura, 223); 
4A2C:  CLRF   x81
4A2E:  MOVF   x81,W
4A30:  CALL   0490
4A34:  INCF   x81,F
4A36:  MOVWF  00
4A38:  MOVFF  FE8,293
4A3C:  CALL   0D34
4A40:  MOVLW  07
4A42:  SUBWF  x81,W
4A44:  BNZ   4A2E
4A46:  MOVLW  02
4A48:  MOVWF  FE9
4A4A:  MOVFF  2E,89
4A4E:  MOVFF  2D,88
4A52:  MOVFF  2C,87
4A56:  MOVFF  2B,86
4A5A:  MOVLW  01
4A5C:  MOVWF  x8A
4A5E:  CALL   22FE
4A62:  MOVLW  20
4A64:  MOVLB  2
4A66:  MOVWF  x93
4A68:  MOVLB  0
4A6A:  CALL   0D34
4A6E:  MOVLW  DF
4A70:  MOVLB  2
4A72:  MOVWF  x93
4A74:  MOVLB  0
4A76:  CALL   0D34
4A7A:  MOVLW  0F
4A7C:  MOVWF  x82
4A7E:  MOVF   x82,W
4A80:  CALL   0490
4A84:  INCF   x82,F
4A86:  MOVWF  00
4A88:  MOVFF  FE8,293
4A8C:  CALL   0D34
4A90:  MOVLW  18
4A92:  SUBWF  x82,W
4A94:  BNZ   4A7E
....................  
....................    //Mostramos la hora 
....................    //Comprobamos si los valores son menores que 10 para añadir un cero 
....................    //delante y que queden los valores alineados 
....................    if(tiempo.hours < 10) 
4A96:  MOVF   58,W
4A98:  SUBLW  09
4A9A:  BNC   4AB6
....................       printf(lcd_putc, "0"); 
4A9C:  CLRF   x81
4A9E:  MOVF   x81,W
4AA0:  CALL   04C4
4AA4:  IORLW  00
4AA6:  BZ    4AB6
4AA8:  INCF   x81,F
4AAA:  MOVLB  2
4AAC:  MOVWF  x93
4AAE:  MOVLB  0
4AB0:  CALL   0D34
4AB4:  BRA    4A9E
....................    printf(lcd_putc, "%u:", tiempo.hours); 
4AB6:  MOVFF  58,81
4ABA:  MOVLW  1B
4ABC:  MOVWF  x82
4ABE:  RCALL  499C
4AC0:  MOVLW  3A
4AC2:  MOVLB  2
4AC4:  MOVWF  x93
4AC6:  MOVLB  0
4AC8:  CALL   0D34
....................    if(tiempo.minutes < 10) 
4ACC:  MOVF   57,W
4ACE:  SUBLW  09
4AD0:  BNC   4AEC
....................       printf(lcd_putc, "0"); 
4AD2:  CLRF   x81
4AD4:  MOVF   x81,W
4AD6:  CALL   04C4
4ADA:  IORLW  00
4ADC:  BZ    4AEC
4ADE:  INCF   x81,F
4AE0:  MOVLB  2
4AE2:  MOVWF  x93
4AE4:  MOVLB  0
4AE6:  CALL   0D34
4AEA:  BRA    4AD4
....................    printf(lcd_putc, "%u", tiempo.minutes); 
4AEC:  MOVFF  57,81
4AF0:  MOVLW  1B
4AF2:  MOVWF  x82
4AF4:  RCALL  499C
.................... } 
4AF6:  GOTO   4B10 (RETURN)
....................  
....................  
.................... void encender_sistema() 
.................... { 
....................    //Leemos el tiempo actual 
....................    PCF8583_read_datetime(&tiempo); 
*
1A52:  CLRF   x92
1A54:  MOVLW  56
1A56:  MOVWF  x91
1A58:  CALL   10D6
....................  
....................    //Registramos la hora y minutos en los que se enciende el sistema 
....................    hora_encendido    = tiempo.hours; 
1A5C:  MOVFF  58,5D
....................    minutos_encendido = tiempo.minutes; 
1A60:  MOVFF  57,5E
....................  
....................    //Inicializamos a 0 el tiempo total que está encendida la caldera 
....................    t_total_caldera = 0; 
1A64:  CLRF   63
1A66:  CLRF   62
....................  
....................    //Si la caldera está encendida, inicializamos el instante de encendido a 
....................    //éste. 
....................    if(caldera_encendida) 
1A68:  BTFSS  F83.7
1A6A:  BRA    1A78
....................    { 
....................       hora_caldera = tiempo.hours; 
1A6C:  MOVFF  58,5F
....................       minutos_caldera = tiempo.minutes; 
1A70:  MOVFF  57,60
....................       segundos_caldera = tiempo.seconds; 
1A74:  MOVFF  56,61
....................    } 
....................  
....................    //Encendemos el sistema 
....................    sistema_encendido = TRUE; 
1A78:  BSF    F83.5
.................... } 
1A7A:  RETLW  00
....................  
....................  
.................... void apagar_sistema() 
.................... { 
....................    long minutos_trans;  //Minutos transcurridos desde el encendido del sistema 
....................    int t_entera, t_decimal; //Temperatura del hogar en ese momento (parte entera y decimal) 
....................    float temperatura;  //Temperatura leída 
....................    int data[8];  //Vector para almacenar los datos a guardar 
....................  
....................    //Si llegamos al límite de la memoria, se resetea el indicador 
....................    if((eeprom_registros + num_registros*2*8)>=0x1000) 
*
1EEC:  BCF    FD8.0
1EEE:  RLCF   64,W
1EF0:  MOVWF  x91
1EF2:  RLCF   65,W
1EF4:  MOVWF  x92
1EF6:  RLCF   x91,W
1EF8:  MOVWF  02
1EFA:  RLCF   x92,W
1EFC:  MOVWF  03
1EFE:  RLCF   02,F
1F00:  RLCF   03,F
1F02:  RLCF   02,F
1F04:  RLCF   03,F
1F06:  MOVLW  F8
1F08:  ANDWF  02,F
1F0A:  MOVF   02,W
1F0C:  ADDLW  50
1F0E:  MOVWF  x93
1F10:  MOVLW  00
1F12:  ADDWFC 03,W
1F14:  MOVWF  x94
1F16:  SUBLW  0F
1F18:  BC    1F1E
....................       num_registros = 0; 
1F1A:  CLRF   65
1F1C:  CLRF   64
....................  
....................    //Leemos el tiempo actual 
....................    PCF8583_read_datetime(&tiempo); 
1F1E:  CLRF   x92
1F20:  MOVLW  56
1F22:  MOVWF  x91
1F24:  CALL   10D6
....................  
....................    //Calculamos los minutos transcurridos desde el encendido como una diferencia de tiempos 
....................    minutos_trans = diferencia_tiempo(hora_encendido, minutos_encendido, tiempo.hours, tiempo.minutes); 
1F28:  MOVFF  5D,91
1F2C:  MOVFF  5E,92
1F30:  MOVFF  58,93
1F34:  MOVFF  57,94
1F38:  RCALL  1A9A
1F3A:  MOVFF  02,82
1F3E:  MOVFF  01,81
....................  
....................    //Leemos la temperatura en ese momento 
....................    temperatura = ds1820_read(); 
1F42:  CALL   16BC
1F46:  MOVFF  03,88
1F4A:  MOVFF  02,87
1F4E:  MOVFF  01,86
1F52:  MOVFF  00,85
....................  
....................    //Descomponemos la temperatura en su parte entera y parte decimal para almacenarla 
....................    t_entera = (int)temperatura; 
1F56:  MOVFF  88,98
1F5A:  MOVFF  87,97
1F5E:  MOVFF  86,96
1F62:  MOVFF  85,95
1F66:  RCALL  1B88
1F68:  MOVFF  01,83
....................    t_decimal = (int)((temperatura-t_entera)*100); 
1F6C:  MOVLB  2
1F6E:  CLRF   x99
1F70:  MOVFF  83,298
1F74:  MOVLB  0
1F76:  CALL   0F38
1F7A:  BSF    FD8.1
1F7C:  MOVFF  88,295
1F80:  MOVFF  87,294
1F84:  MOVFF  86,293
1F88:  MOVFF  85,292
1F8C:  MOVFF  03,299
1F90:  MOVFF  02,298
1F94:  MOVFF  01,297
1F98:  MOVFF  00,296
1F9C:  RCALL  17D8
1F9E:  MOVFF  00,91
1FA2:  MOVFF  01,92
1FA6:  MOVFF  02,93
1FAA:  MOVFF  03,94
1FAE:  MOVFF  03,2B1
1FB2:  MOVFF  02,2B0
1FB6:  MOVFF  01,2AF
1FBA:  MOVFF  00,2AE
1FBE:  MOVLB  2
1FC0:  CLRF   xB5
1FC2:  CLRF   xB4
1FC4:  MOVLW  48
1FC6:  MOVWF  xB3
1FC8:  MOVLW  85
1FCA:  MOVWF  xB2
1FCC:  MOVLB  0
1FCE:  RCALL  1BC2
1FD0:  MOVFF  03,98
1FD4:  MOVFF  02,97
1FD8:  MOVFF  01,96
1FDC:  MOVFF  00,95
1FE0:  RCALL  1B88
1FE2:  MOVFF  01,84
....................  
....................    //Si la caldera estaba encendida, sumamos el último intervalo de encendido al tiempo total 
....................    if(caldera_encendida) 
1FE6:  BTFSS  F83.7
1FE8:  BRA    200C
....................       t_total_caldera = t_total_caldera + diferencia_tiempo_sec(hora_caldera, minutos_caldera, segundos_caldera, tiempo.hours, tiempo.minutes, tiempo.seconds); 
1FEA:  MOVFF  5F,91
1FEE:  MOVFF  60,92
1FF2:  MOVFF  61,93
1FF6:  MOVFF  58,94
1FFA:  MOVFF  57,95
1FFE:  MOVFF  56,96
2002:  RCALL  1CBA
2004:  MOVF   01,W
2006:  ADDWF  62,F
2008:  MOVF   02,W
200A:  ADDWFC 63,F
....................  
....................  
....................  
....................    //Almacenamos todos los datos requeridos 
....................    data[0] = tiempo.day;                  //Día de desconexión 
200C:  MOVFF  59,89
....................    data[1] = tiempo.month;                //Mes de desconexión 
2010:  MOVFF  5A,8A
....................    data[2] = tiempo.hours;                //Hora de desconexión 
2014:  MOVFF  58,8B
....................    data[3] = tiempo.minutes;              //Minutos de desconexión 
2018:  MOVFF  57,8C
....................    data[4] = t_entera;                    //Valor entero de última temperatura medida 
201C:  MOVFF  83,8D
....................    data[5] = t_decimal;                   //Valor decimal de última temperatura medida 
2020:  MOVFF  84,8E
....................    data[6] = (int)minutos_trans;          //Minutos transcurridos desde el encendido 
2024:  MOVFF  81,8F
....................    data[7] = (int)(t_total_caldera/60);   //Tiempo total que ha estado encendida la caldera 
2028:  MOVFF  63,92
202C:  MOVFF  62,91
2030:  CLRF   x94
2032:  MOVLW  3C
2034:  MOVWF  x93
2036:  BRA    1E0E
2038:  MOVFF  01,90
....................                                           //en este intervalo (en minutos) 
....................  
....................    //Grabamos los datos en memoria 
....................    graba_ee(eeprom_registros + num_registros*2*8, 8, data); 
203C:  BCF    FD8.0
203E:  RLCF   64,W
2040:  MOVWF  x91
2042:  RLCF   65,W
2044:  MOVWF  x92
2046:  RLCF   x91,W
2048:  MOVWF  02
204A:  RLCF   x92,W
204C:  MOVWF  03
204E:  RLCF   02,F
2050:  RLCF   03,F
2052:  RLCF   02,F
2054:  RLCF   03,F
2056:  MOVLW  F8
2058:  ANDWF  02,F
205A:  MOVF   02,W
205C:  ADDLW  50
205E:  MOVWF  x93
2060:  MOVLW  00
2062:  ADDWFC 03,W
2064:  MOVWF  x94
2066:  MOVWF  x98
2068:  MOVFF  93,97
206C:  MOVLW  08
206E:  MOVWF  x99
2070:  CLRF   x9B
2072:  MOVLW  89
2074:  MOVWF  x9A
2076:  RCALL  1E54
....................  
....................    //Calculamos el año en el que nos encontramos 
....................    if(anno_actual_1_to_3 != tiempo.year) 
2078:  MOVF   5B,W
207A:  SUBWF  67,W
207C:  BZ    209C
....................    { 
....................       //Si el año que teníamos almacenado no es igual que el que marca el reloj, 
....................       //debemos de actualizar las variables correspondientes. 
....................       anno_actual++; 
207E:  INCF   66,F
....................       anno_actual_1_to_3++; 
2080:  INCF   67,F
....................  
....................       //Guardamos los valores en el vector data 
....................       data[0] = anno_actual; 
2082:  MOVFF  66,89
....................       data[1] = anno_actual_1_to_3; 
2086:  MOVFF  67,8A
....................  
....................       //Guardamos los valores en memoria 
....................       graba_ee(eeprom_anno_actual, 2, data); 
208A:  CLRF   x98
208C:  MOVLW  14
208E:  MOVWF  x97
2090:  MOVLW  02
2092:  MOVWF  x99
2094:  CLRF   x9B
2096:  MOVLW  89
2098:  MOVWF  x9A
209A:  RCALL  1E54
....................    } 
....................  
....................    //Grabamos el año en el que nos encontramos en la posición correspondiente 
....................    graba_ee(eeprom_registros + num_registros*2*8 + 8, 1, &anno_actual); 
209C:  BCF    FD8.0
209E:  RLCF   64,W
20A0:  MOVWF  x91
20A2:  RLCF   65,W
20A4:  MOVWF  x92
20A6:  RLCF   x91,W
20A8:  MOVWF  02
20AA:  RLCF   x92,W
20AC:  MOVWF  03
20AE:  RLCF   02,F
20B0:  RLCF   03,F
20B2:  RLCF   02,F
20B4:  RLCF   03,F
20B6:  MOVLW  F8
20B8:  ANDWF  02,F
20BA:  MOVF   02,W
20BC:  ADDLW  50
20BE:  MOVWF  x93
20C0:  MOVLW  00
20C2:  ADDWFC 03,W
20C4:  MOVWF  x94
20C6:  MOVLW  08
20C8:  ADDWF  x93,W
20CA:  MOVWF  x95
20CC:  MOVLW  00
20CE:  ADDWFC x94,W
20D0:  MOVWF  x96
20D2:  MOVWF  x98
20D4:  MOVFF  95,97
20D8:  MOVLW  01
20DA:  MOVWF  x99
20DC:  CLRF   x9B
20DE:  MOVLW  66
20E0:  MOVWF  x9A
20E2:  RCALL  1E54
....................  
....................    //Aumentamos en uno el número de registros 
....................    num_registros++; 
20E4:  INCF   64,F
20E6:  BTFSC  FD8.2
20E8:  INCF   65,F
....................  
....................    //Guardamos el número de registros en memoria (descomponiendo antes en dos int) 
....................    data[0] = (int)(num_registros/256); 
20EA:  MOVF   65,W
20EC:  MOVWF  x89
....................    data[1] = (int)(num_registros - data[0]*256); 
20EE:  CLRF   xA3
20F0:  MOVFF  89,A2
20F4:  MOVLW  01
20F6:  MOVWF  xA5
20F8:  CLRF   xA4
20FA:  RCALL  1A7C
20FC:  MOVF   01,W
20FE:  SUBWF  64,W
2100:  MOVWF  00
2102:  MOVF   02,W
2104:  SUBWFB 65,W
2106:  MOVFF  00,8A
....................  
....................    graba_ee(eeprom_num_registros, 2, data); 
210A:  CLRF   x98
210C:  MOVLW  12
210E:  MOVWF  x97
2110:  MOVLW  02
2112:  MOVWF  x99
2114:  CLRF   x9B
2116:  MOVLW  89
2118:  MOVWF  x9A
211A:  RCALL  1E54
....................  
....................    //Finalmente, apagamos el sistema 
....................    sistema_encendido = FALSE; 
211C:  BCF    F83.5
.................... } 
211E:  RETLW  00
....................  
....................  
.................... void encender_caldera() 
.................... { 
....................    //Leemos el tiempo actual 
....................    PCF8583_read_datetime(&tiempo); 
*
4942:  CLRF   x92
4944:  MOVLW  56
4946:  MOVWF  x91
4948:  CALL   10D6
....................  
....................    //Guardamos los datos en las variables correspondientes 
....................    hora_caldera = tiempo.hours; 
494C:  MOVFF  58,5F
....................    minutos_caldera = tiempo.minutes; 
4950:  MOVFF  57,60
....................    segundos_caldera = tiempo.seconds; 
4954:  MOVFF  56,61
....................  
....................    //Encendemos la caldera 
....................    caldera_encendida = TRUE; 
4958:  BSF    F83.7
.................... } 
495A:  RETLW  00
....................  
....................  
.................... void apagar_caldera() 
.................... { 
....................    int hora, minutos, segundos; //Variables para el tiempo 
....................  
....................    //Leemos el tiempo 
....................    PCF8583_read_datetime(&tiempo); 
495C:  CLRF   x92
495E:  MOVLW  56
4960:  MOVWF  x91
4962:  CALL   10D6
....................  
....................    //Copiamos en las variables 
....................    hora = tiempo.hours; 
4966:  MOVFF  58,81
....................    minutos = tiempo.minutes; 
496A:  MOVFF  57,82
....................    segundos = tiempo.seconds; 
496E:  MOVFF  56,83
....................  
....................    //Sumamos al tiempo total de encendido de la caldera el tiempo que ha estado encendida esta vez 
....................    t_total_caldera = t_total_caldera + diferencia_tiempo_sec(hora_caldera, minutos_caldera, segundos_caldera, hora, minutos, segundos); 
4972:  MOVFF  5F,91
4976:  MOVFF  60,92
497A:  MOVFF  61,93
497E:  MOVFF  81,94
4982:  MOVFF  82,95
4986:  MOVFF  83,96
498A:  CALL   1CBA
498E:  MOVF   01,W
4990:  ADDWF  62,F
4992:  MOVF   02,W
4994:  ADDWFC 63,F
....................  
....................    //Apagamos la caldera 
....................    caldera_encendida = FALSE; 
4996:  BCF    F83.7
.................... } 
4998:  GOTO   59CA (RETURN)
....................  
....................  
....................  
.................... int buscar_numero(){ 
....................    //Variables auxiliares 
....................    int contador = 0; 
*
267E:  CLRF   x81
....................    int numero; 
....................  
....................    //Se continua la búsqueda hasta que no se pulse SI o NO o hasta 
....................    //que no se introduzca un número de 2 cifras. 
....................    while(key != 'N' && key!='S' && contador!=2) 
....................    { 
2680:  MOVF   33,W
2682:  SUBLW  4E
2684:  BZ    26C6
2686:  MOVF   33,W
2688:  SUBLW  53
268A:  BZ    26C6
268C:  MOVF   x81,W
268E:  SUBLW  02
2690:  BZ    26C6
....................       key = get_key(); 
2692:  RCALL  2216
2694:  MOVFF  01,33
....................       //Si la tecla corresponde a un dígito, la imprimimos por pantalla 
....................       //y pasamos a la siguiente 
....................       if(isdigit(key)){ 
2698:  MOVF   33,W
269A:  SUBLW  2F
269C:  BC    26C4
269E:  MOVF   33,W
26A0:  SUBLW  39
26A2:  BNC   26C4
....................          lcd_putc(key); 
26A4:  MOVFF  33,293
26A8:  CALL   0D34
....................          keys[contador] = key; 
26AC:  CLRF   03
26AE:  MOVF   x81,W
26B0:  ADDLW  34
26B2:  MOVWF  FE9
26B4:  MOVLW  00
26B6:  ADDWFC 03,W
26B8:  MOVWF  FEA
26BA:  MOVFF  33,FEF
....................          key = 'J'; 
26BE:  MOVLW  4A
26C0:  MOVWF  33
....................          contador++; 
26C2:  INCF   x81,F
....................       } 
....................    } 
26C4:  BRA    2680
....................  
....................    //Si la tecla es NO, devolvemos el código correspondiente 
....................    if(key == 'N') 
26C6:  MOVF   33,W
26C8:  SUBLW  4E
26CA:  BNZ   26D2
....................       return NO; 
26CC:  MOVLW  64
26CE:  MOVWF  01
26D0:  BRA    26EE
....................  
....................    //Procedemos de la misma manera si es SÍ 
....................    if(key == 'S') 
26D2:  MOVF   33,W
26D4:  SUBLW  53
26D6:  BNZ   26DE
....................       return SI; 
26D8:  MOVLW  65
26DA:  MOVWF  01
26DC:  BRA    26EE
....................  
....................    //Transformamos los caracteres a entero 
....................    numero = atoi(keys); 
26DE:  CLRF   x84
26E0:  MOVLW  34
26E2:  MOVWF  x83
26E4:  RCALL  24E4
26E6:  MOVFF  01,82
....................  
....................    //Devolvemos el resultado 
....................    return numero; 
26EA:  MOVFF  82,01
....................  
.................... } 
26EE:  RETLW  00
....................  
....................  
.................... int comprobar_hora(int hora1, int min1, int hora2, int min2) 
.................... { 
....................    //Si hora1 es menor, devolvemos TRUE 
....................    if(hora1 < hora2) 
*
1294:  MOVF   x9D,W
1296:  SUBWF  x9B,W
1298:  BC    12A0
....................       return TRUE; 
129A:  MOVLW  01
129C:  MOVWF  01
129E:  BRA    12C6
....................    //Si hora1 es mayor, devolvemos FALSE 
....................    if(hora1 > hora2) 
12A0:  MOVF   x9B,W
12A2:  SUBWF  x9D,W
12A4:  BC    12AC
....................       return FALSE; 
12A6:  MOVLW  00
12A8:  MOVWF  01
12AA:  BRA    12C6
....................    //Si las horas coinciden habrá que comparar los minutos 
....................    if(hora1==hora2) 
12AC:  MOVF   x9D,W
12AE:  SUBWF  x9B,W
12B0:  BNZ   12C6
....................    { 
....................       //Se sigue el mismo criterio de antes con la comparación 
....................       //de los minutos. 
....................       if(min1 <= min2) 
12B2:  MOVF   x9C,W
12B4:  SUBWF  x9E,W
12B6:  BNC   12C0
....................          return TRUE; 
12B8:  MOVLW  01
12BA:  MOVWF  01
12BC:  BRA    12C6
....................       else 
12BE:  BRA    12C6
....................          return FALSE; 
12C0:  MOVLW  00
12C2:  MOVWF  01
12C4:  BRA    12C6
....................    } 
.................... } 
12C6:  RETLW  00
....................  
....................  
.................... void ordenar_programaciones() 
.................... { 
....................    //Variables temporales y contadores auxiliares 
....................    programacion *pr1; 
....................    programacion *pr2; 
....................    int contador1, contador2; 
....................    int h_inicio_1, min_inicio_1, h_inicio_2, min_inicio_2; 
....................  
....................    //Ambos punteros comienzan apuntando al principio de programaciones 
....................    pr1 = programaciones; 
*
27F4:  CLRF   x82
27F6:  MOVLW  36
27F8:  MOVWF  x81
....................    pr2 = programaciones; 
27FA:  CLRF   x84
27FC:  MOVWF  x83
....................  
....................  
....................    //Algoritmo de la burbuja 
....................    for(contador1=0; contador1 < num_intervalos; contador1++) 
27FE:  CLRF   x85
2800:  MOVF   54,W
2802:  SUBWF  x85,W
2804:  BTFSC  FD8.0
2806:  BRA    2928
....................    { 
....................       //Apuntamos a las dos últimas posiciones del vector 
....................       pr1 = programaciones+num_intervalos-2; 
2808:  MOVF   54,W
280A:  MULLW  05
280C:  MOVF   FF3,W
280E:  ADDLW  36
2810:  MOVWF  x90
2812:  CLRF   x91
2814:  BTFSC  FD8.0
2816:  INCF   x91,F
2818:  MOVLW  0A
281A:  SUBWF  x90,W
281C:  MOVWF  x81
281E:  MOVLW  00
2820:  SUBWFB x91,W
2822:  MOVWF  x82
....................       pr2 = programaciones+num_intervalos-1; 
2824:  MOVF   54,W
2826:  MULLW  05
2828:  MOVF   FF3,W
282A:  ADDLW  36
282C:  MOVWF  x90
282E:  CLRF   x91
2830:  BTFSC  FD8.0
2832:  INCF   x91,F
2834:  MOVLW  05
2836:  SUBWF  x90,W
2838:  MOVWF  x83
283A:  MOVLW  00
283C:  SUBWFB x91,W
283E:  MOVWF  x84
....................  
....................       //Iteramos hasta llegar a la zona ordenada del vector 
....................       for(contador2=0; contador2 < num_intervalos-contador1-1; contador2++) 
2840:  CLRF   x86
2842:  MOVF   x85,W
2844:  SUBWF  54,W
2846:  ADDLW  FF
2848:  SUBWF  x86,W
284A:  BC    2924
....................       { 
....................          //Tomamos para la comparación los instantes de inicio 
....................          h_inicio_1   = (*pr1).horas_inicio; 
284C:  MOVFF  81,FE9
2850:  MOVFF  82,FEA
2854:  MOVFF  FEF,87
....................          min_inicio_1 = (*pr1).minutos_inicio; 
2858:  MOVLW  01
285A:  ADDWF  x81,W
285C:  MOVWF  FE9
285E:  MOVLW  00
2860:  ADDWFC x82,W
2862:  MOVWF  FEA
2864:  MOVFF  FEF,88
....................          h_inicio_2   = (*pr2).horas_inicio; 
2868:  MOVFF  83,FE9
286C:  MOVFF  84,FEA
2870:  MOVFF  FEF,89
....................          min_inicio_2 = (*pr2).minutos_inicio; 
2874:  MOVLW  01
2876:  ADDWF  x83,W
2878:  MOVWF  FE9
287A:  MOVLW  00
287C:  ADDWFC x84,W
287E:  MOVWF  FEA
2880:  MOVFF  FEF,8A
....................  
....................          //Si la hora de pr2 es menor que la de pr1, habrá que intercambiar los 
....................          //valores para mover la menor a una posición más baja 
....................          if(comprobar_hora(h_inicio_2, min_inicio_2, h_inicio_1, min_inicio_1)) 
2884:  MOVFF  89,9B
2888:  MOVFF  8A,9C
288C:  MOVFF  87,9D
2890:  MOVFF  88,9E
2894:  CALL   1294
2898:  MOVF   01,F
289A:  BZ    2910
....................          { 
....................             programacion temporal; 
....................             temporal = *pr1; 
289C:  MOVFF  82,03
28A0:  MOVFF  81,90
28A4:  MOVFF  82,91
28A8:  CLRF   FEA
28AA:  MOVLW  8B
28AC:  MOVWF  FE9
28AE:  MOVFF  82,FE2
28B2:  MOVFF  81,FE1
28B6:  MOVLW  05
28B8:  MOVWF  01
28BA:  MOVFF  FE6,FEE
28BE:  DECFSZ 01,F
28C0:  BRA    28BA
....................             *pr1 = *pr2; 
28C2:  MOVFF  81,92
28C6:  MOVFF  82,93
28CA:  MOVFF  84,03
28CE:  MOVFF  83,94
28D2:  MOVFF  84,95
28D6:  MOVFF  82,FEA
28DA:  MOVFF  81,FE9
28DE:  MOVFF  84,FE2
28E2:  MOVFF  83,FE1
28E6:  MOVLW  05
28E8:  MOVWF  01
28EA:  MOVFF  FE6,FEE
28EE:  DECFSZ 01,F
28F0:  BRA    28EA
....................             *pr2 = temporal; 
28F2:  MOVFF  84,03
28F6:  MOVFF  83,FE9
28FA:  MOVFF  03,FEA
28FE:  CLRF   FE2
2900:  MOVLW  8B
2902:  MOVWF  FE1
2904:  MOVLW  05
2906:  MOVWF  01
2908:  MOVFF  FE6,FEE
290C:  DECFSZ 01,F
290E:  BRA    2908
....................          } 
....................  
....................          //Pasamos a la siguiente posición y repetimos el proceso 
....................          pr1--; 
2910:  MOVLW  FB
2912:  ADDWF  x81,F
2914:  BTFSS  FD8.0
2916:  DECF   x82,F
....................          pr2--; 
2918:  MOVLW  FB
291A:  ADDWF  x83,F
291C:  BTFSS  FD8.0
291E:  DECF   x84,F
....................       } 
2920:  INCF   x86,F
2922:  BRA    2842
....................  
....................    } 
2924:  INCF   x85,F
2926:  BRA    2800
....................  
.................... } 
2928:  GOTO   5782 (RETURN)
....................  
....................  
.................... long diferencia_tiempo(int hora1, int min1, int hora2, int min2) 
.................... { 
....................    long dif; 
....................  
....................    //Si hora1:min1 es menor que hora2:min2, devolvemos simplemente la diferencia en minutos 
....................    if(comprobar_hora(hora1,min1,hora2,min2)) 
*
1A9A:  MOVFF  91,9B
1A9E:  MOVFF  92,9C
1AA2:  MOVFF  93,9D
1AA6:  MOVFF  94,9E
1AAA:  CALL   1294
1AAE:  MOVF   01,F
1AB0:  BZ    1B12
....................       dif = ((long)hora2*60 + (long)min2) - ((long)hora1*60 + (long)min1); 
1AB2:  CLRF   x98
1AB4:  MOVFF  93,97
1AB8:  MOVFF  98,A3
1ABC:  MOVFF  93,A2
1AC0:  CLRF   xA5
1AC2:  MOVLW  3C
1AC4:  MOVWF  xA4
1AC6:  RCALL  1A7C
1AC8:  MOVFF  02,99
1ACC:  MOVFF  01,98
1AD0:  CLRF   03
1AD2:  MOVF   x94,W
1AD4:  ADDWF  01,W
1AD6:  MOVWF  x9A
1AD8:  MOVF   03,W
1ADA:  ADDWFC 02,W
1ADC:  MOVWF  x9B
1ADE:  CLRF   x9D
1AE0:  MOVFF  91,9C
1AE4:  MOVFF  9D,A3
1AE8:  MOVFF  91,A2
1AEC:  CLRF   xA5
1AEE:  MOVLW  3C
1AF0:  MOVWF  xA4
1AF2:  RCALL  1A7C
1AF4:  MOVFF  01,9D
1AF8:  CLRF   03
1AFA:  MOVF   x92,W
1AFC:  ADDWF  01,W
1AFE:  MOVWF  01
1B00:  MOVF   02,W
1B02:  ADDWFC 03,F
1B04:  MOVF   01,W
1B06:  SUBWF  x9A,W
1B08:  MOVWF  x95
1B0A:  MOVF   03,W
1B0C:  SUBWFB x9B,W
1B0E:  MOVWF  x96
....................    //Si no es así, habrá que tener en cuenta que hora1:min1 se encuentra en el día anterior 
....................    //al de hora2:min2 
....................    else 
1B10:  BRA    1B7E
....................       dif = (24*60-((long)hora1*60 + (long)min1)) + (long)hora2*60 + (long)min2; 
1B12:  CLRF   x98
1B14:  MOVFF  91,97
1B18:  MOVFF  98,A3
1B1C:  MOVFF  91,A2
1B20:  CLRF   xA5
1B22:  MOVLW  3C
1B24:  MOVWF  xA4
1B26:  RCALL  1A7C
1B28:  MOVFF  02,99
1B2C:  MOVFF  01,98
1B30:  CLRF   03
1B32:  MOVF   x92,W
1B34:  ADDWF  01,W
1B36:  MOVWF  01
1B38:  MOVF   02,W
1B3A:  ADDWFC 03,F
1B3C:  MOVF   01,W
1B3E:  XORLW  FF
1B40:  ADDLW  A1
1B42:  MOVWF  x9A
1B44:  MOVLW  05
1B46:  SUBFWB 03,W
1B48:  MOVWF  x9B
1B4A:  CLRF   x9D
1B4C:  MOVFF  93,9C
1B50:  MOVFF  9D,A3
1B54:  MOVFF  93,A2
1B58:  CLRF   xA5
1B5A:  MOVLW  3C
1B5C:  MOVWF  xA4
1B5E:  RCALL  1A7C
1B60:  MOVFF  02,03
1B64:  MOVF   01,W
1B66:  ADDWF  x9A,W
1B68:  MOVWF  x9D
1B6A:  MOVF   02,W
1B6C:  ADDWFC x9B,W
1B6E:  MOVWF  x9E
1B70:  CLRF   03
1B72:  MOVF   x94,W
1B74:  ADDWF  x9D,W
1B76:  MOVWF  x95
1B78:  MOVF   03,W
1B7A:  ADDWFC x9E,W
1B7C:  MOVWF  x96
....................  
....................    //Devolvemos el resultado 
....................    return dif; 
1B7E:  MOVFF  95,01
1B82:  MOVFF  96,02
.................... } 
1B86:  RETLW  00
....................  
....................  
.................... long diferencia_tiempo_sec(int hora1, int min1, int sec1, int hora2, int min2, int sec2) 
.................... { 
....................    unsigned long dif; 
....................    unsigned long dif2; 
....................  
....................    //Si hora1:min1 es menor que hora2:min2, ambas horas están en el mismo día 
....................    if(comprobar_hora(hora1,min1,hora2,min2)) 
*
1CBA:  MOVFF  91,9B
1CBE:  MOVFF  92,9C
1CC2:  MOVFF  94,9D
1CC6:  MOVFF  95,9E
1CCA:  CALL   1294
1CCE:  MOVF   01,F
1CD0:  BZ    1D70
....................    { 
....................       //Si la hora y los minutos son iguales, devolvemos simplemente la diferencia en segundos 
....................       if(hora1==hora2 && min1==min2) 
1CD2:  MOVF   x94,W
1CD4:  SUBWF  x91,W
1CD6:  BNZ   1CE8
1CD8:  MOVF   x95,W
1CDA:  SUBWF  x92,W
1CDC:  BNZ   1CE8
....................          dif = abs(sec2-sec1); 
1CDE:  MOVF   x93,W
1CE0:  SUBWF  x96,W
1CE2:  CLRF   x98
1CE4:  MOVWF  x97
....................       else 
1CE6:  BRA    1D6E
....................       { 
....................          //Si no habrá que tener en cuenta también la diferencia entre horas y minutos 
....................          dif2 = ((long)hora2*60 + (long)min2) - ((long)hora1*60 + (long)min1); 
1CE8:  CLRF   x9C
1CEA:  MOVFF  94,9B
1CEE:  MOVFF  9C,A3
1CF2:  MOVFF  94,A2
1CF6:  CLRF   xA5
1CF8:  MOVLW  3C
1CFA:  MOVWF  xA4
1CFC:  RCALL  1A7C
1CFE:  MOVFF  02,9D
1D02:  MOVFF  01,9C
1D06:  CLRF   03
1D08:  MOVF   x95,W
1D0A:  ADDWF  01,W
1D0C:  MOVWF  x9E
1D0E:  MOVF   03,W
1D10:  ADDWFC 02,W
1D12:  MOVWF  x9F
1D14:  CLRF   xA1
1D16:  MOVFF  91,A0
1D1A:  MOVFF  A1,A3
1D1E:  MOVFF  91,A2
1D22:  CLRF   xA5
1D24:  MOVLW  3C
1D26:  MOVWF  xA4
1D28:  RCALL  1A7C
1D2A:  MOVFF  01,A1
1D2E:  CLRF   03
1D30:  MOVF   x92,W
1D32:  ADDWF  01,W
1D34:  MOVWF  01
1D36:  MOVF   02,W
1D38:  ADDWFC 03,F
1D3A:  MOVF   01,W
1D3C:  SUBWF  x9E,W
1D3E:  MOVWF  x99
1D40:  MOVF   03,W
1D42:  SUBWFB x9F,W
1D44:  MOVWF  x9A
....................          //No hacemos la diferencia en segundos directamente porque el long no da de sí 
....................          dif = dif2*60 + sec2 - sec1; 
1D46:  MOVFF  9A,A3
1D4A:  MOVFF  99,A2
1D4E:  CLRF   xA5
1D50:  MOVLW  3C
1D52:  MOVWF  xA4
1D54:  RCALL  1A7C
1D56:  MOVF   x96,W
1D58:  ADDWF  01,W
1D5A:  MOVWF  x9D
1D5C:  MOVLW  00
1D5E:  ADDWFC 02,W
1D60:  MOVWF  x9E
1D62:  MOVF   x93,W
1D64:  SUBWF  x9D,W
1D66:  MOVWF  x97
1D68:  MOVLW  00
1D6A:  SUBWFB x9E,W
1D6C:  MOVWF  x98
....................       } 
....................    } 
....................    else{ 
1D6E:  BRA    1E04
....................       //Si no, simplemente tenemos en cuenta que están en días diferentes y luego le añadimos la 
....................       //diferencia en segundos 
....................       dif2 = (24*60-((long)hora1*60 + (long)min1)) + (long)hora2*60 + (long)min2; 
1D70:  CLRF   x9C
1D72:  MOVFF  91,9B
1D76:  MOVFF  9C,A3
1D7A:  MOVFF  91,A2
1D7E:  CLRF   xA5
1D80:  MOVLW  3C
1D82:  MOVWF  xA4
1D84:  RCALL  1A7C
1D86:  MOVFF  02,9D
1D8A:  MOVFF  01,9C
1D8E:  CLRF   03
1D90:  MOVF   x92,W
1D92:  ADDWF  01,W
1D94:  MOVWF  01
1D96:  MOVF   02,W
1D98:  ADDWFC 03,F
1D9A:  MOVF   01,W
1D9C:  XORLW  FF
1D9E:  ADDLW  A1
1DA0:  MOVWF  x9E
1DA2:  MOVLW  05
1DA4:  SUBFWB 03,W
1DA6:  MOVWF  x9F
1DA8:  CLRF   xA1
1DAA:  MOVFF  94,A0
1DAE:  MOVFF  A1,A3
1DB2:  MOVFF  94,A2
1DB6:  CLRF   xA5
1DB8:  MOVLW  3C
1DBA:  MOVWF  xA4
1DBC:  RCALL  1A7C
1DBE:  MOVFF  02,03
1DC2:  MOVF   01,W
1DC4:  ADDWF  x9E,W
1DC6:  MOVWF  xA1
1DC8:  MOVF   02,W
1DCA:  ADDWFC x9F,W
1DCC:  MOVWF  xA2
1DCE:  CLRF   03
1DD0:  MOVF   x95,W
1DD2:  ADDWF  xA1,W
1DD4:  MOVWF  x99
1DD6:  MOVF   03,W
1DD8:  ADDWFC xA2,W
1DDA:  MOVWF  x9A
....................       dif = dif2*60 + sec2 - sec1; 
1DDC:  MOVFF  9A,A3
1DE0:  MOVFF  99,A2
1DE4:  CLRF   xA5
1DE6:  MOVLW  3C
1DE8:  MOVWF  xA4
1DEA:  RCALL  1A7C
1DEC:  MOVF   x96,W
1DEE:  ADDWF  01,W
1DF0:  MOVWF  x9D
1DF2:  MOVLW  00
1DF4:  ADDWFC 02,W
1DF6:  MOVWF  x9E
1DF8:  MOVF   x93,W
1DFA:  SUBWF  x9D,W
1DFC:  MOVWF  x97
1DFE:  MOVLW  00
1E00:  SUBWFB x9E,W
1E02:  MOVWF  x98
....................    } 
....................  
....................    //Devolvemos el resultado 
....................    return dif; 
1E04:  MOVFF  97,01
1E08:  MOVFF  98,02
.................... } 
1E0C:  RETLW  00
....................  
....................  
.................... void seleccionar_alarma() 
.................... { 
....................    //Contador y variables auxiliares 
....................    int contador; 
....................    int hora, minutos, hora_p, min_p; 
....................  
....................    //Ponemos la posición en el vector de alarmas incialmente a 0 
....................    posicion_alarmas = 0; 
*
12C8:  CLRF   55
....................  
....................    //Leemos el tiempo actual 
....................    PCF8583_read_datetime(&tiempo); 
12CA:  CLRF   x92
12CC:  MOVLW  56
12CE:  MOVWF  x91
12D0:  RCALL  10D6
....................    hora = tiempo.hours; 
12D2:  MOVFF  58,82
....................    minutos = tiempo.minutes; 
12D6:  MOVFF  57,83
....................  
....................    //Recorremos todas las programaciones 
....................    for(contador=0; contador<num_intervalos; contador++) 
12DA:  CLRF   x81
12DC:  MOVF   54,W
12DE:  SUBWF  x81,W
12E0:  BC    1342
....................    { 
....................        hora_p = programaciones[contador].horas_inicio; 
12E2:  MOVF   x81,W
12E4:  MULLW  05
12E6:  MOVF   FF3,W
12E8:  CLRF   x87
12EA:  MOVWF  x86
12EC:  MOVLW  36
12EE:  ADDWF  x86,W
12F0:  MOVWF  FE9
12F2:  MOVLW  00
12F4:  ADDWFC x87,W
12F6:  MOVWF  FEA
12F8:  MOVFF  FEF,84
....................        min_p  = programaciones[contador].minutos_inicio; 
12FC:  MOVF   x81,W
12FE:  MULLW  05
1300:  MOVF   FF3,W
1302:  CLRF   x87
1304:  MOVWF  x86
1306:  MOVLW  01
1308:  ADDWF  x86,W
130A:  MOVWF  01
130C:  MOVLW  00
130E:  ADDWFC x87,W
1310:  MOVWF  03
1312:  MOVF   01,W
1314:  ADDLW  36
1316:  MOVWF  FE9
1318:  MOVLW  00
131A:  ADDWFC 03,W
131C:  MOVWF  FEA
131E:  MOVFF  FEF,85
....................  
....................        //Comprobamos las horas y tomamos la primera programación que tenga una 
....................        //hora mayor que la actual 
....................        if(!comprobar_hora(hora_p, min_p, hora, minutos)) 
1322:  MOVFF  84,9B
1326:  MOVFF  85,9C
132A:  MOVFF  82,9D
132E:  MOVFF  83,9E
1332:  RCALL  1294
1334:  MOVF   01,F
1336:  BNZ   133E
....................        { 
....................            //Guardamos la posición de esta programación y salimos 
....................            posicion_alarmas = contador; 
1338:  MOVFF  81,55
....................            break; 
133C:  BRA    1342
....................        } 
....................    } 
133E:  INCF   x81,F
1340:  BRA    12DC
.................... } 
1342:  RETLW  00
....................  
....................  
.................... void programar_proxima_alarma() 
.................... { 
....................    //Variables auxiliares 
....................    int hora, minutos; 
....................  
....................    //Recuperamos los datos de inicio de la alarma actual 
....................    prg=programaciones[posicion_alarmas]; 
*
140C:  MOVF   55,W
140E:  MULLW  05
1410:  MOVF   FF3,W
1412:  CLRF   03
1414:  ADDLW  36
1416:  MOVWF  01
1418:  MOVLW  00
141A:  ADDWFC 03,F
141C:  MOVFF  01,83
1420:  MOVFF  03,84
1424:  CLRF   FEA
1426:  MOVLW  4F
1428:  MOVWF  FE9
142A:  MOVFF  03,FE2
142E:  MOVFF  01,FE1
1432:  MOVLW  05
1434:  MOVWF  01
1436:  MOVFF  FE6,FEE
143A:  DECFSZ 01,F
143C:  BRA    1436
....................    hora = prg.horas_inicio; 
143E:  MOVFF  4F,81
....................    minutos = prg.minutos_inicio; 
1442:  MOVFF  50,82
....................  
....................    //Establecemos la alarma a ese tiempo 
....................    PCF8583_establecer_alarma(hora, minutos, 0); 
1446:  MOVFF  81,83
144A:  MOVFF  82,84
144E:  CLRF   x85
1450:  RCALL  1364
.................... } 
1452:  RETLW  00
....................  
....................  
.................... void grabar_programaciones() 
.................... { 
....................    int datos[5];   //Vector para contener los datos a grabar 
....................    programacion pr; //Variable temporal de programacion 
....................    int contador;   //Contador para el bucle 
....................  
....................    //Recorremos todo el vector de programaciones (hasta el número de programaciones que tengamos) 
....................    for(contador=0; contador<num_intervalos; contador++) 
*
292C:  CLRF   x8B
292E:  MOVF   54,W
2930:  SUBWF  x8B,W
2932:  BC    299C
....................    { 
....................       //Seleccionamos la programación 
....................       pr = programaciones[contador]; 
2934:  MOVF   x8B,W
2936:  MULLW  05
2938:  MOVF   FF3,W
293A:  CLRF   03
293C:  ADDLW  36
293E:  MOVWF  01
2940:  MOVLW  00
2942:  ADDWFC 03,F
2944:  MOVFF  01,8C
2948:  MOVFF  03,8D
294C:  CLRF   FEA
294E:  MOVLW  86
2950:  MOVWF  FE9
2952:  MOVFF  03,FE2
2956:  MOVFF  01,FE1
295A:  MOVLW  05
295C:  MOVWF  01
295E:  MOVFF  FE6,FEE
2962:  DECFSZ 01,F
2964:  BRA    295E
....................  
....................       //Almacenamos los datos en el vector 
....................       datos[0] = pr.horas_inicio; 
2966:  MOVFF  86,81
....................       datos[1] = pr.minutos_inicio; 
296A:  MOVFF  87,82
....................       datos[2] = pr.horas_fin; 
296E:  MOVFF  88,83
....................       datos[3] = pr.minutos_fin; 
2972:  MOVFF  89,84
....................       datos[4] = pr.termostato; 
2976:  MOVFF  8A,85
....................  
....................       //Guardamos los datos en la posición de memoria correspondiente de la EEPROM 
....................       graba_ee(eeprom_programaciones + (contador+1)*8, 5, datos); 
297A:  MOVLW  01
297C:  ADDWF  x8B,W
297E:  MULLW  08
2980:  MOVF   FF3,W
2982:  ADDLW  18
2984:  MOVWF  x8D
2986:  CLRF   x98
2988:  MOVWF  x97
298A:  MOVLW  05
298C:  MOVWF  x99
298E:  CLRF   x9B
2990:  MOVLW  81
2992:  MOVWF  x9A
2994:  CALL   1E54
....................    } 
2998:  INCF   x8B,F
299A:  BRA    292E
....................  
....................    //Guardamos en la EEPROM en el número de intervalos 
....................    graba_ee(eeprom_num_intervalos, 1, &num_intervalos); 
299C:  CLRF   x98
299E:  MOVLW  11
29A0:  MOVWF  x97
29A2:  MOVLW  01
29A4:  MOVWF  x99
29A6:  CLRF   x9B
29A8:  MOVLW  54
29AA:  MOVWF  x9A
29AC:  CALL   1E54
....................  
....................    //He optado por escribir de programación en programación porque a pesar de que 
....................    //en el datasheet aseguran que la memoria tiene una paginación de 32 bytes en la 
....................    //simulación parece tener menos, así que de este modo nos evitamos problemas 
....................  
.................... } 
29B0:  GOTO   5996 (RETURN)
....................  
....................  
.................... void leer_programaciones(){ 
....................    int datos[5];    //Vector para almacenar los datos recuperados 
....................    programacion pr;  //Variable temporal para guardar la programación 
....................    int contador;    //Contador del bucle 
....................  
....................    //Se supone que antes ha sido recuperado el número de intervalos 
....................    //Recorremos todas las programaciones guardadas 
....................    for(contador=0; contador<num_intervalos; contador++) 
*
0F70:  CLRF   x8B
0F72:  MOVF   54,W
0F74:  SUBWF  x8B,W
0F76:  BC    0FD4
....................    { 
....................       //Leemos de memoria 
....................       lee_ee(eeprom_programaciones + (contador+1)*8, 5, datos); 
0F78:  MOVLW  01
0F7A:  ADDWF  x8B,W
0F7C:  MULLW  08
0F7E:  MOVF   FF3,W
0F80:  ADDLW  18
0F82:  MOVWF  x8D
0F84:  MOVLB  2
0F86:  CLRF   x96
0F88:  MOVWF  x95
0F8A:  MOVLW  05
0F8C:  MOVWF  x97
0F8E:  CLRF   x99
0F90:  MOVLW  81
0F92:  MOVWF  x98
0F94:  MOVLB  0
0F96:  RCALL  0E54
....................  
....................       //Guardamos los datos en la programación 
....................       pr.horas_inicio   = datos[0]; 
0F98:  MOVFF  81,86
....................       pr.minutos_inicio = datos[1]; 
0F9C:  MOVFF  82,87
....................       pr.horas_fin      = datos[2]; 
0FA0:  MOVFF  83,88
....................       pr.minutos_fin    = datos[3]; 
0FA4:  MOVFF  84,89
....................       pr.termostato     = datos[4]; 
0FA8:  MOVFF  85,8A
....................  
....................       //Guardamos la programación en el vector correspondiente 
....................       programaciones[contador] = pr; 
0FAC:  MOVF   x8B,W
0FAE:  MULLW  05
0FB0:  MOVF   FF3,W
0FB2:  CLRF   03
0FB4:  ADDLW  36
0FB6:  MOVWF  FE9
0FB8:  MOVLW  00
0FBA:  ADDWFC 03,W
0FBC:  MOVWF  FEA
0FBE:  CLRF   FE2
0FC0:  MOVLW  86
0FC2:  MOVWF  FE1
0FC4:  MOVLW  05
0FC6:  MOVWF  01
0FC8:  MOVFF  FE6,FEE
0FCC:  DECFSZ 01,F
0FCE:  BRA    0FC8
....................  
....................    } 
0FD0:  INCF   x8B,F
0FD2:  BRA    0F72
....................  
.................... } 
0FD4:  GOTO   4CC4 (RETURN)
....................  
....................  
.................... void representar_registros() 
.................... { 
....................    //Contadores y variables auxiliares 
....................    int contador, contador2; 
....................    unsigned int data[8]; 
....................    int anno; 
....................  
....................    float media_dia_mes[12];         //Tiempos medios en minutos que se enciende el sistema en cada mes 
....................    int dias_meses[12];              //Número de dias que tiene cada mes 
....................    float media_dia_caldera;         //Tiempo medio que se enciende la caldera cada día 
....................    float valor;                     //Tiempo medio en minutos que se enciende el sistema por día 
....................    float media_dia_mes_caldera[12]; //Tiempo medio que se enciende la caldera en cada mes 
....................  
....................    unsigned long valor_total;  //Tiempo total de encendido de la caldera 
....................    unsigned long valor_total_caldera; //Tiempo total de encendido del sistema 
....................  
....................    //Capacidad para 4 años de datos 
....................    //Vectores de almacenamiento de los datos anuales 
....................    float media_annos[4][12]; 
....................    float media_annos_caldera[4][12]; 
....................    //Número de años de los que se tienen datos 
....................    int num_annos; 
....................    //Años correspondientes 
....................    int annos[4]; 
....................  
....................    //Variables para almacenar valores provisionales 
....................    long tiempo_x_dia;         //Tiempo que se enciende cada día el sistema (minutos) 
....................    long tiempo_x_dia_caldera; //Tiempo que se enciende cada día la caldera (minutos) 
....................    int dia[3];               //Día con el que estamos trabajando (día/mes/año) 
....................    long num_dias;             //Número de días que llevamos analizados 
....................  
....................    //dias_meses = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}; 
....................    dias_meses[0] = dias_meses[2] = dias_meses[4] = dias_meses[6] = dias_meses[7] = dias_meses[9] = dias_meses[11] = 31; 
*
2C86:  MOVLW  1F
2C88:  MOVWF  xC7
2C8A:  MOVFF  C7,C5
2C8E:  MOVFF  C5,C3
2C92:  MOVFF  C3,C2
2C96:  MOVFF  C2,C0
2C9A:  MOVFF  C0,BE
2C9E:  MOVFF  BE,BC
....................    dias_meses[1] = 28; 
2CA2:  MOVLW  1C
2CA4:  MOVWF  xBD
....................    dias_meses[3] = dias_meses[5] = dias_meses[8] = dias_meses[10] = 30; 
2CA6:  MOVLW  1E
2CA8:  MOVWF  xC6
2CAA:  MOVFF  C6,C4
2CAE:  MOVFF  C4,C1
2CB2:  MOVFF  C1,BF
....................  
....................    //Inicializamos los vectores a 0 
....................    for(contador=0; contador<12;contador++) 
2CB6:  CLRF   x81
2CB8:  MOVF   x81,W
2CBA:  SUBLW  0B
2CBC:  BNC   2CDC
....................    { 
....................       media_dia_mes[contador]=0; 
2CBE:  MOVF   x81,W
2CC0:  MULLW  04
2CC2:  MOVF   FF3,W
2CC4:  CLRF   03
2CC6:  ADDLW  8C
2CC8:  MOVWF  FE9
2CCA:  MOVLW  00
2CCC:  ADDWFC 03,W
2CCE:  MOVWF  FEA
2CD0:  CLRF   FEF
2CD2:  CLRF   FEC
2CD4:  CLRF   FEC
2CD6:  CLRF   FEC
....................    } 
2CD8:  INCF   x81,F
2CDA:  BRA    2CB8
....................  
....................    for(contador=0; contador<12;contador++) 
2CDC:  CLRF   x81
2CDE:  MOVF   x81,W
2CE0:  SUBLW  0B
2CE2:  BNC   2D02
....................    { 
....................       media_dia_mes_caldera[contador]=0; 
2CE4:  MOVF   x81,W
2CE6:  MULLW  04
2CE8:  MOVF   FF3,W
2CEA:  CLRF   03
2CEC:  ADDLW  D0
2CEE:  MOVWF  FE9
2CF0:  MOVLW  00
2CF2:  ADDWFC 03,W
2CF4:  MOVWF  FEA
2CF6:  CLRF   FEF
2CF8:  CLRF   FEC
2CFA:  CLRF   FEC
2CFC:  CLRF   FEC
....................    } 
2CFE:  INCF   x81,F
2D00:  BRA    2CDE
....................  
....................    for(contador=0; contador<4 ;contador++) 
2D02:  CLRF   x81
2D04:  MOVF   x81,W
2D06:  SUBLW  03
2D08:  BNC   2D50
....................    { 
....................       for(contador2=0; contador2<12 ;contador2++) 
2D0A:  CLRF   x82
2D0C:  MOVF   x82,W
2D0E:  SUBLW  0B
2D10:  BNC   2D4C
....................       { 
....................          media_annos[contador][contador2]=0; 
2D12:  MOVF   x81,W
2D14:  MULLW  30
2D16:  MOVF   FF3,W
2D18:  MOVLB  2
2D1A:  CLRF   x93
2D1C:  MOVWF  x92
2D1E:  MOVLB  0
2D20:  MOVF   x82,W
2D22:  MULLW  04
2D24:  MOVF   FF3,W
2D26:  CLRF   03
2D28:  MOVLB  2
2D2A:  ADDWF  x92,W
2D2C:  MOVWF  01
2D2E:  MOVF   x93,W
2D30:  ADDWFC 03,F
2D32:  MOVF   01,W
2D34:  ADDLW  04
2D36:  MOVWF  FE9
2D38:  MOVLW  01
2D3A:  ADDWFC 03,W
2D3C:  MOVWF  FEA
2D3E:  CLRF   FEF
2D40:  CLRF   FEC
2D42:  CLRF   FEC
2D44:  CLRF   FEC
....................       } 
2D46:  MOVLB  0
2D48:  INCF   x82,F
2D4A:  BRA    2D0C
....................    } 
2D4C:  INCF   x81,F
2D4E:  BRA    2D04
....................  
....................    for(contador=0; contador<4 ;contador++) 
2D50:  CLRF   x81
2D52:  MOVF   x81,W
2D54:  SUBLW  03
2D56:  BNC   2D9E
....................    { 
....................       for(contador2=0; contador2<12 ;contador2++) 
2D58:  CLRF   x82
2D5A:  MOVF   x82,W
2D5C:  SUBLW  0B
2D5E:  BNC   2D9A
....................       { 
....................          media_annos_caldera[contador][contador2]=0; 
2D60:  MOVF   x81,W
2D62:  MULLW  30
2D64:  MOVF   FF3,W
2D66:  MOVLB  2
2D68:  CLRF   x93
2D6A:  MOVWF  x92
2D6C:  MOVLB  0
2D6E:  MOVF   x82,W
2D70:  MULLW  04
2D72:  MOVF   FF3,W
2D74:  CLRF   03
2D76:  MOVLB  2
2D78:  ADDWF  x92,W
2D7A:  MOVWF  01
2D7C:  MOVF   x93,W
2D7E:  ADDWFC 03,F
2D80:  MOVF   01,W
2D82:  ADDLW  C4
2D84:  MOVWF  FE9
2D86:  MOVLW  01
2D88:  ADDWFC 03,W
2D8A:  MOVWF  FEA
2D8C:  CLRF   FEF
2D8E:  CLRF   FEC
2D90:  CLRF   FEC
2D92:  CLRF   FEC
....................       } 
2D94:  MOVLB  0
2D96:  INCF   x82,F
2D98:  BRA    2D5A
....................    } 
2D9A:  INCF   x81,F
2D9C:  BRA    2D52
....................  
....................    //Iniciamos a cero las otras variables 
....................    dia[0] = dia[1] = dia[2] = 0; 
2D9E:  MOVLB  2
2DA0:  CLRF   x8F
2DA2:  MOVFF  28F,28E
2DA6:  MOVFF  28E,28D
....................    num_dias = 0; 
2DAA:  CLRF   x91
2DAC:  CLRF   x90
....................    num_annos = 0; 
2DAE:  CLRF   x84
....................  
....................    media_dia_caldera = 0; 
2DB0:  MOVLB  0
2DB2:  CLRF   xCB
2DB4:  CLRF   xCA
2DB6:  CLRF   xC9
2DB8:  CLRF   xC8
....................    valor = 0; 
2DBA:  CLRF   xCF
2DBC:  CLRF   xCE
2DBE:  CLRF   xCD
2DC0:  CLRF   xCC
....................    valor_total = 0; 
2DC2:  MOVLB  1
2DC4:  CLRF   x01
2DC6:  CLRF   x00
....................    valor_total_caldera = 0; 
2DC8:  CLRF   x03
2DCA:  CLRF   x02
....................  
....................    //Imprimimos el encabezamiento 
....................    printf("REGISTRO DE EVENTOS\r"); 
2DCC:  MOVLB  2
2DCE:  CLRF   x92
2DD0:  MOVF   x92,W
2DD2:  MOVLB  0
2DD4:  CALL   04E0
2DD8:  IORLW  00
2DDA:  BZ    2DEA
2DDC:  MOVLB  2
2DDE:  INCF   x92,F
2DE0:  BTFSS  F9E.4
2DE2:  BRA    2DE0
2DE4:  MOVWF  FAD
2DE6:  BRA    2DD0
2DE8:  MOVLB  0
....................    printf("*******************\r"); 
2DEA:  MOVLB  2
2DEC:  CLRF   x92
2DEE:  MOVF   x92,W
2DF0:  MOVLB  0
2DF2:  CALL   0510
2DF6:  IORLW  00
2DF8:  BZ    2E08
2DFA:  MOVLB  2
2DFC:  INCF   x92,F
2DFE:  BTFSS  F9E.4
2E00:  BRA    2DFE
2E02:  MOVWF  FAD
2E04:  BRA    2DEE
2E06:  MOVLB  0
....................    printf("Momento de apagado     Temperatura        Minutos encendido       Minutos caldera\r"); 
2E08:  MOVLB  2
2E0A:  CLRF   x92
2E0C:  MOVF   x92,W
2E0E:  MOVLB  0
2E10:  CALL   0540
2E14:  IORLW  00
2E16:  BZ    2E26
2E18:  MOVLB  2
2E1A:  INCF   x92,F
2E1C:  BTFSS  F9E.4
2E1E:  BRA    2E1C
2E20:  MOVWF  FAD
2E22:  BRA    2E0C
2E24:  MOVLB  0
....................    printf("=================================================================================\r"); 
2E26:  MOVLB  2
2E28:  CLRF   x92
2E2A:  MOVF   x92,W
2E2C:  MOVLB  0
2E2E:  CALL   05AE
2E32:  IORLW  00
2E34:  BZ    2E44
2E36:  MOVLB  2
2E38:  INCF   x92,F
2E3A:  BTFSS  F9E.4
2E3C:  BRA    2E3A
2E3E:  MOVWF  FAD
2E40:  BRA    2E2A
2E42:  MOVLB  0
....................  
....................    //Recorremos todos los registros almacenados 
....................    for(contador=0; contador<num_registros; contador++) 
2E44:  CLRF   x81
2E46:  MOVF   65,F
2E48:  BNZ   2E52
2E4A:  MOVF   64,W
2E4C:  SUBWF  x81,W
2E4E:  BTFSC  FD8.0
2E50:  BRA    3502
....................    { 
....................       //Comenzamos leyendo los datos de memoria 
....................       lee_ee(eeprom_registros + contador*2*8, 8, data); 
2E52:  BCF    FD8.0
2E54:  RLCF   x81,W
2E56:  MULLW  08
2E58:  MOVF   FF3,W
2E5A:  ADDLW  50
2E5C:  MOVLB  2
2E5E:  MOVWF  x93
2E60:  CLRF   x96
2E62:  MOVWF  x95
2E64:  MOVLW  08
2E66:  MOVWF  x97
2E68:  CLRF   x99
2E6A:  MOVLW  83
2E6C:  MOVWF  x98
2E6E:  MOVLB  0
2E70:  CALL   0E54
....................       lee_ee(eeprom_registros + contador*2*8 + 8, 8, &anno); 
2E74:  BCF    FD8.0
2E76:  RLCF   x81,W
2E78:  MULLW  08
2E7A:  MOVF   FF3,W
2E7C:  ADDLW  50
2E7E:  ADDLW  08
2E80:  MOVLB  2
2E82:  MOVWF  x94
2E84:  CLRF   x96
2E86:  MOVWF  x95
2E88:  MOVLW  08
2E8A:  MOVWF  x97
2E8C:  CLRF   x99
2E8E:  MOVLW  8B
2E90:  MOVWF  x98
2E92:  MOVLB  0
2E94:  CALL   0E54
....................  
....................       //Si cambiamos de día debemos gestionar los datos del nuevo día y almacenar los del anterior 
....................       if(dia[0]!=data[0] || dia[1]!=data[1] || dia[2]!=anno) 
2E98:  MOVF   x83,W
2E9A:  MOVLB  2
2E9C:  SUBWF  x8D,W
2E9E:  BNZ   2EB6
2EA0:  MOVLB  0
2EA2:  MOVF   x84,W
2EA4:  MOVLB  2
2EA6:  SUBWF  x8E,W
2EA8:  BNZ   2EB6
2EAA:  MOVLB  0
2EAC:  MOVF   x8B,W
2EAE:  MOVLB  2
2EB0:  SUBWF  x8F,W
2EB2:  BTFSC  FD8.2
2EB4:  BRA    322C
....................       { 
....................          //Lógicamente, no tenemos en cuenta para la media los días en los que no se enciende: 
....................          //días de verano, calurosos, etc. Esta información puede visualizarse en la media 
....................          //por meses. 
....................          //Guardamos los datos del día anterior si el día no es el primero 
....................          if(dia[0]!=0) 
2EB6:  MOVF   x8D,F
2EB8:  BZ    2F8E
....................          { 
....................             //En la media de tiempo por día, acumulamos el tiempo que ha estado encendido el último día 
....................             valor = valor + (float)tiempo_x_dia; 
2EBA:  MOVFF  28A,299
2EBE:  MOVFF  289,298
2EC2:  MOVLB  0
2EC4:  CALL   0F38
2EC8:  BCF    FD8.1
2ECA:  MOVFF  CF,295
2ECE:  MOVFF  CE,294
2ED2:  MOVFF  CD,293
2ED6:  MOVFF  CC,292
2EDA:  MOVFF  03,299
2EDE:  MOVFF  02,298
2EE2:  MOVFF  01,297
2EE6:  MOVFF  00,296
2EEA:  CALL   17D8
2EEE:  MOVFF  03,CF
2EF2:  MOVFF  02,CE
2EF6:  MOVFF  01,CD
2EFA:  MOVFF  00,CC
....................             //Guardamos también este valor en el registro del año 
....................             media_dia_mes[dia[1]-1] = valor; 
2EFE:  MOVLW  01
2F00:  MOVLB  2
2F02:  SUBWF  x8E,W
2F04:  MULLW  04
2F06:  MOVF   FF3,W
2F08:  CLRF   03
2F0A:  ADDLW  8C
2F0C:  MOVWF  FE9
2F0E:  MOVLW  00
2F10:  ADDWFC 03,W
2F12:  MOVWF  FEA
2F14:  MOVFF  CC,FEF
2F18:  MOVFF  CD,FEC
2F1C:  MOVFF  CE,FEC
2F20:  MOVFF  CF,FEC
....................             //Realizamos la misma operación con la media de encendido de la caldera 
....................             media_dia_caldera = media_dia_caldera + (float)tiempo_x_dia_caldera; 
2F24:  MOVFF  28C,299
2F28:  MOVFF  28B,298
2F2C:  MOVLB  0
2F2E:  CALL   0F38
2F32:  BCF    FD8.1
2F34:  MOVFF  CB,295
2F38:  MOVFF  CA,294
2F3C:  MOVFF  C9,293
2F40:  MOVFF  C8,292
2F44:  MOVFF  03,299
2F48:  MOVFF  02,298
2F4C:  MOVFF  01,297
2F50:  MOVFF  00,296
2F54:  CALL   17D8
2F58:  MOVFF  03,CB
2F5C:  MOVFF  02,CA
2F60:  MOVFF  01,C9
2F64:  MOVFF  00,C8
....................             media_dia_mes_caldera[dia[1]-1] = media_dia_caldera; 
2F68:  MOVLW  01
2F6A:  MOVLB  2
2F6C:  SUBWF  x8E,W
2F6E:  MULLW  04
2F70:  MOVF   FF3,W
2F72:  CLRF   03
2F74:  ADDLW  D0
2F76:  MOVWF  FE9
2F78:  MOVLW  00
2F7A:  ADDWFC 03,W
2F7C:  MOVWF  FEA
2F7E:  MOVFF  C8,FEF
2F82:  MOVFF  C9,FEC
2F86:  MOVFF  CA,FEC
2F8A:  MOVFF  CB,FEC
....................          } 
....................          //La sumatoria podría alcanzar un valor muy alto. El sistema no está preparado para estas eventualidades 
....................          //y debería ser reseteado cada cierto tiempo. Si el sistema va a utilizarse mucho (zonas muy frías o mal 
....................          //aisladas), el usuario debería informar al fabricante para aumentar la memoria de almacenamiento y el 
....................          //tamaño de las variables 
....................  
....................          //Si cambiamos de año, habrá que guardar los datos anuales 
....................          if(dia[2]!=anno) 
2F8E:  MOVLB  0
2F90:  MOVF   x8B,W
2F92:  MOVLB  2
2F94:  SUBWF  x8F,W
2F96:  BTFSC  FD8.2
2F98:  BRA    3212
....................          { 
....................             //Comprobamos que no nos encontrabamos en el año introducido por defecto 
....................             if(dia[2]!=0) 
2F9A:  MOVF   x8F,F
2F9C:  BTFSC  FD8.2
2F9E:  BRA    31FE
....................             { 
....................                //En ese caso, guardamos los datos de todo el año 
....................                for(contador2=0; contador2<12; contador2++) 
2FA0:  MOVLB  0
2FA2:  CLRF   x82
2FA4:  MOVF   x82,W
2FA6:  SUBLW  0B
2FA8:  BTFSS  FD8.0
2FAA:  BRA    31E8
....................                { 
....................                   media_dia_mes[contador2] = media_dia_mes[contador2]/(float)dias_meses[contador2]; 
2FAC:  MOVF   x82,W
2FAE:  MULLW  04
2FB0:  MOVF   FF3,W
2FB2:  CLRF   03
2FB4:  ADDLW  8C
2FB6:  MOVWF  01
2FB8:  MOVLW  00
2FBA:  ADDWFC 03,F
2FBC:  MOVFF  01,292
2FC0:  MOVFF  03,293
2FC4:  MOVLB  0
2FC6:  MOVF   x82,W
2FC8:  MULLW  04
2FCA:  MOVF   FF3,W
2FCC:  CLRF   03
2FCE:  ADDLW  8C
2FD0:  MOVWF  FE9
2FD2:  MOVLW  00
2FD4:  ADDWFC 03,W
2FD6:  MOVWF  FEA
2FD8:  MOVFF  FEF,294
2FDC:  MOVFF  FEC,295
2FE0:  MOVFF  FEC,296
2FE4:  MOVFF  FEC,297
2FE8:  CLRF   03
2FEA:  MOVF   x82,W
2FEC:  ADDLW  BC
2FEE:  MOVWF  FE9
2FF0:  MOVLW  00
2FF2:  ADDWFC 03,W
2FF4:  MOVWF  FEA
2FF6:  MOVF   FEF,W
2FF8:  MOVLB  2
2FFA:  CLRF   x99
2FFC:  MOVWF  x98
2FFE:  MOVLB  0
3000:  CALL   0F38
3004:  MOVFF  297,29B
3008:  MOVFF  296,29A
300C:  MOVFF  295,299
3010:  MOVFF  294,298
3014:  MOVFF  03,29F
3018:  MOVFF  02,29E
301C:  MOVFF  01,29D
3020:  MOVFF  00,29C
3024:  CALL   155C
3028:  MOVFF  293,FEA
302C:  MOVFF  292,FE9
3030:  MOVFF  00,FEF
3034:  MOVFF  01,FEC
3038:  MOVFF  02,FEC
303C:  MOVFF  03,FEC
....................                   media_dia_mes_caldera[contador2] = media_dia_mes_caldera[contador2]/(float)dias_meses[contador2]; 
3040:  MOVF   x82,W
3042:  MULLW  04
3044:  MOVF   FF3,W
3046:  CLRF   03
3048:  ADDLW  D0
304A:  MOVWF  01
304C:  MOVLW  00
304E:  ADDWFC 03,F
3050:  MOVFF  01,292
3054:  MOVFF  03,293
3058:  MOVLB  0
305A:  MOVF   x82,W
305C:  MULLW  04
305E:  MOVF   FF3,W
3060:  CLRF   03
3062:  ADDLW  D0
3064:  MOVWF  FE9
3066:  MOVLW  00
3068:  ADDWFC 03,W
306A:  MOVWF  FEA
306C:  MOVFF  FEF,294
3070:  MOVFF  FEC,295
3074:  MOVFF  FEC,296
3078:  MOVFF  FEC,297
307C:  CLRF   03
307E:  MOVF   x82,W
3080:  ADDLW  BC
3082:  MOVWF  FE9
3084:  MOVLW  00
3086:  ADDWFC 03,W
3088:  MOVWF  FEA
308A:  MOVF   FEF,W
308C:  MOVLB  2
308E:  CLRF   x99
3090:  MOVWF  x98
3092:  MOVLB  0
3094:  CALL   0F38
3098:  MOVFF  297,29B
309C:  MOVFF  296,29A
30A0:  MOVFF  295,299
30A4:  MOVFF  294,298
30A8:  MOVFF  03,29F
30AC:  MOVFF  02,29E
30B0:  MOVFF  01,29D
30B4:  MOVFF  00,29C
30B8:  CALL   155C
30BC:  MOVFF  293,FEA
30C0:  MOVFF  292,FE9
30C4:  MOVFF  00,FEF
30C8:  MOVFF  01,FEC
30CC:  MOVFF  02,FEC
30D0:  MOVFF  03,FEC
....................                   media_annos[num_annos][contador2] = media_dia_mes[contador2]; 
30D4:  MOVLB  2
30D6:  MOVF   x84,W
30D8:  MULLW  30
30DA:  MOVF   FF3,W
30DC:  CLRF   x93
30DE:  MOVWF  x92
30E0:  MOVLB  0
30E2:  MOVF   x82,W
30E4:  MULLW  04
30E6:  MOVF   FF3,W
30E8:  CLRF   03
30EA:  MOVLB  2
30EC:  ADDWF  x92,W
30EE:  MOVWF  01
30F0:  MOVF   x93,W
30F2:  ADDWFC 03,F
30F4:  MOVF   01,W
30F6:  ADDLW  04
30F8:  MOVWF  01
30FA:  MOVLW  01
30FC:  ADDWFC 03,F
30FE:  MOVFF  01,294
3102:  MOVFF  03,295
3106:  MOVLB  0
3108:  MOVF   x82,W
310A:  MULLW  04
310C:  MOVF   FF3,W
310E:  CLRF   03
3110:  ADDLW  8C
3112:  MOVWF  FE9
3114:  MOVLW  00
3116:  ADDWFC 03,W
3118:  MOVWF  FEA
311A:  MOVFF  FEF,00
311E:  MOVFF  FEC,01
3122:  MOVFF  FEC,02
3126:  MOVFF  FEC,03
312A:  MOVFF  295,FEA
312E:  MOVFF  294,FE9
3132:  MOVFF  00,FEF
3136:  MOVFF  01,FEC
313A:  MOVFF  02,FEC
313E:  MOVFF  03,FEC
....................                   media_annos_caldera[num_annos][contador2] = media_dia_mes_caldera[contador2]; 
3142:  MOVLB  2
3144:  MOVF   x84,W
3146:  MULLW  30
3148:  MOVF   FF3,W
314A:  CLRF   x93
314C:  MOVWF  x92
314E:  MOVLB  0
3150:  MOVF   x82,W
3152:  MULLW  04
3154:  MOVF   FF3,W
3156:  CLRF   03
3158:  MOVLB  2
315A:  ADDWF  x92,W
315C:  MOVWF  01
315E:  MOVF   x93,W
3160:  ADDWFC 03,F
3162:  MOVF   01,W
3164:  ADDLW  C4
3166:  MOVWF  01
3168:  MOVLW  01
316A:  ADDWFC 03,F
316C:  MOVFF  01,294
3170:  MOVFF  03,295
3174:  MOVLB  0
3176:  MOVF   x82,W
3178:  MULLW  04
317A:  MOVF   FF3,W
317C:  CLRF   03
317E:  ADDLW  D0
3180:  MOVWF  FE9
3182:  MOVLW  00
3184:  ADDWFC 03,W
3186:  MOVWF  FEA
3188:  MOVFF  FEF,00
318C:  MOVFF  FEC,01
3190:  MOVFF  FEC,02
3194:  MOVFF  FEC,03
3198:  MOVFF  295,FEA
319C:  MOVFF  294,FE9
31A0:  MOVFF  00,FEF
31A4:  MOVFF  01,FEC
31A8:  MOVFF  02,FEC
31AC:  MOVFF  03,FEC
....................                   //Volvemos a inicializar a 0 los contenedores de los datos por mes 
....................                   media_dia_mes[contador2]=0; 
31B0:  MOVF   x82,W
31B2:  MULLW  04
31B4:  MOVF   FF3,W
31B6:  CLRF   03
31B8:  ADDLW  8C
31BA:  MOVWF  FE9
31BC:  MOVLW  00
31BE:  ADDWFC 03,W
31C0:  MOVWF  FEA
31C2:  CLRF   FEF
31C4:  CLRF   FEC
31C6:  CLRF   FEC
31C8:  CLRF   FEC
....................                   media_dia_mes_caldera[contador2]=0; 
31CA:  MOVF   x82,W
31CC:  MULLW  04
31CE:  MOVF   FF3,W
31D0:  CLRF   03
31D2:  ADDLW  D0
31D4:  MOVWF  FE9
31D6:  MOVLW  00
31D8:  ADDWFC 03,W
31DA:  MOVWF  FEA
31DC:  CLRF   FEF
31DE:  CLRF   FEC
31E0:  CLRF   FEC
31E2:  CLRF   FEC
....................                } 
31E4:  INCF   x82,F
31E6:  BRA    2FA4
....................  
....................                //Guardamos el año del que se trata 
....................                annos[num_annos]=dia[2]; 
31E8:  CLRF   03
31EA:  MOVLB  2
31EC:  MOVF   x84,W
31EE:  ADDLW  85
31F0:  MOVWF  FE9
31F2:  MOVLW  02
31F4:  ADDWFC 03,W
31F6:  MOVWF  FEA
31F8:  MOVFF  28F,FEF
....................  
....................                //Aumentamos en 1 el número de años 
....................                num_annos++; 
31FC:  INCF   x84,F
....................             } 
....................  
....................             //COMPROBAR BISIESTO 
....................             //En realidad, un año será bisiesto si es divisible por 4 y no lo es por 100, 
....................             //excepto si este último lo es por 400. Sin embargo, dado que trabajamos con las 
....................             //dos últimas cifras y que el próximo año divisible por 4 que no lo es por 100 
....................             //es el 2100, mejor nos limitaremos a la divisibilidad por 4. 
....................             //Dependiendo si el año es bisiesto o no, le damos a febrero 29 o 28 días. 
....................             if(anno%4 == 0) 
31FE:  MOVLB  0
3200:  MOVF   x8B,W
3202:  ANDLW  03
3204:  BNZ   320C
....................                dias_meses[1] = 29; 
3206:  MOVLW  1D
3208:  MOVWF  xBD
....................             else 
320A:  BRA    3210
....................                dias_meses[1] = 28; 
320C:  MOVLW  1C
320E:  MOVWF  xBD
3210:  MOVLB  2
....................          } 
....................  
....................          //Modificamos la información del día 
....................          dia[0] = data[0]; 
3212:  MOVFF  83,28D
....................          dia[1] = data[1]; 
3216:  MOVFF  84,28E
....................          dia[2] = anno; 
321A:  MOVFF  8B,28F
....................  
....................          //Aumentamos en 1 el número de días 
....................          num_dias++; 
321E:  INCF   x90,F
3220:  BTFSC  FD8.2
3222:  INCF   x91,F
....................  
....................          //Reseteamos las variables acumulativas de tiempo por día 
....................          tiempo_x_dia = 0; 
3224:  CLRF   x8A
3226:  CLRF   x89
....................          tiempo_x_dia_caldera = 0; 
3228:  CLRF   x8C
322A:  CLRF   x8B
....................       } 
....................  
....................       //Le sumamos al tiempo de encendido de sistema y caldera el correspondiente de este registro 
....................       tiempo_x_dia = tiempo_x_dia + data[6]; 
322C:  MOVLB  0
322E:  MOVF   x89,W
3230:  MOVLB  2
3232:  ADDWF  x89,F
3234:  MOVLW  00
3236:  ADDWFC x8A,F
....................       tiempo_x_dia_caldera = tiempo_x_dia_caldera + data[7]; 
3238:  MOVLB  0
323A:  MOVF   x8A,W
323C:  MOVLB  2
323E:  ADDWF  x8B,F
3240:  MOVLW  00
3242:  ADDWFC x8C,F
....................       //También incrementamos los tiempos totales 
....................       valor_total = valor_total + data[6]; 
3244:  MOVLB  0
3246:  MOVF   x89,W
3248:  MOVLB  1
324A:  ADDWF  x00,F
324C:  MOVLW  00
324E:  ADDWFC x01,F
....................       valor_total_caldera = valor_total_caldera + data[7]; 
3250:  MOVLB  0
3252:  MOVF   x8A,W
3254:  MOVLB  1
3256:  ADDWF  x02,F
3258:  MOVLW  00
325A:  ADDWFC x03,F
....................  
....................       //Representamos todos los datos, teniendo en cuenta algunos requisitos representativos 
....................       //para que los datos queden alineados (número menores que 10, que 100, etc). 
....................       if(data[0]<10) 
325C:  MOVLB  0
325E:  MOVF   x83,W
3260:  SUBLW  09
3262:  BNC   3282
....................          printf(" "); 
3264:  MOVLB  2
3266:  CLRF   x92
3268:  MOVF   x92,W
326A:  MOVLB  0
326C:  CALL   061C
3270:  IORLW  00
3272:  BZ    3282
3274:  MOVLB  2
3276:  INCF   x92,F
3278:  BTFSS  F9E.4
327A:  BRA    3278
327C:  MOVWF  FAD
327E:  BRA    3268
3280:  MOVLB  0
....................  
....................       printf("%u/", data[0]); 
3282:  MOVFF  83,293
3286:  MOVLW  1B
3288:  MOVLB  2
328A:  MOVWF  x94
328C:  MOVLB  0
328E:  CALL   29B4
3292:  MOVLW  2F
3294:  BTFSS  F9E.4
3296:  BRA    3294
3298:  MOVWF  FAD
....................  
....................       if(data[1]<10) 
329A:  MOVF   x84,W
329C:  SUBLW  09
329E:  BNC   32BE
....................          printf("0"); 
32A0:  MOVLB  2
32A2:  CLRF   x92
32A4:  MOVF   x92,W
32A6:  MOVLB  0
32A8:  CALL   04C4
32AC:  IORLW  00
32AE:  BZ    32BE
32B0:  MOVLB  2
32B2:  INCF   x92,F
32B4:  BTFSS  F9E.4
32B6:  BRA    32B4
32B8:  MOVWF  FAD
32BA:  BRA    32A4
32BC:  MOVLB  0
....................  
....................       printf("%u/", data[1]); 
32BE:  MOVFF  84,293
32C2:  MOVLW  1B
32C4:  MOVLB  2
32C6:  MOVWF  x94
32C8:  MOVLB  0
32CA:  CALL   29B4
32CE:  MOVLW  2F
32D0:  BTFSS  F9E.4
32D2:  BRA    32D0
32D4:  MOVWF  FAD
....................  
....................       if(anno<10) 
32D6:  MOVF   x8B,W
32D8:  SUBLW  09
32DA:  BNC   32FA
....................          printf("0"); 
32DC:  MOVLB  2
32DE:  CLRF   x92
32E0:  MOVF   x92,W
32E2:  MOVLB  0
32E4:  CALL   04C4
32E8:  IORLW  00
32EA:  BZ    32FA
32EC:  MOVLB  2
32EE:  INCF   x92,F
32F0:  BTFSS  F9E.4
32F2:  BRA    32F0
32F4:  MOVWF  FAD
32F6:  BRA    32E0
32F8:  MOVLB  0
....................  
....................       printf("%u  ", anno); 
32FA:  MOVFF  8B,293
32FE:  MOVLW  1B
3300:  MOVLB  2
3302:  MOVWF  x94
3304:  MOVLB  0
3306:  CALL   29B4
330A:  MOVLW  20
330C:  BTFSS  F9E.4
330E:  BRA    330C
3310:  MOVWF  FAD
3312:  MOVLW  20
3314:  BTFSS  F9E.4
3316:  BRA    3314
3318:  MOVWF  FAD
....................  
....................       if(data[2]<10) 
331A:  MOVF   x85,W
331C:  SUBLW  09
331E:  BNC   333E
....................          printf("0"); 
3320:  MOVLB  2
3322:  CLRF   x92
3324:  MOVF   x92,W
3326:  MOVLB  0
3328:  CALL   04C4
332C:  IORLW  00
332E:  BZ    333E
3330:  MOVLB  2
3332:  INCF   x92,F
3334:  BTFSS  F9E.4
3336:  BRA    3334
3338:  MOVWF  FAD
333A:  BRA    3324
333C:  MOVLB  0
....................  
....................       printf("%u:", data[2]); 
333E:  MOVFF  85,293
3342:  MOVLW  1B
3344:  MOVLB  2
3346:  MOVWF  x94
3348:  MOVLB  0
334A:  CALL   29B4
334E:  MOVLW  3A
3350:  BTFSS  F9E.4
3352:  BRA    3350
3354:  MOVWF  FAD
....................  
....................       if(data[3]<10) 
3356:  MOVF   x86,W
3358:  SUBLW  09
335A:  BNC   337A
....................          printf("0"); 
335C:  MOVLB  2
335E:  CLRF   x92
3360:  MOVF   x92,W
3362:  MOVLB  0
3364:  CALL   04C4
3368:  IORLW  00
336A:  BZ    337A
336C:  MOVLB  2
336E:  INCF   x92,F
3370:  BTFSS  F9E.4
3372:  BRA    3370
3374:  MOVWF  FAD
3376:  BRA    3360
3378:  MOVLB  0
....................  
....................       printf("%u          ", data[3]); 
337A:  MOVFF  86,293
337E:  MOVLW  1B
3380:  MOVLB  2
3382:  MOVWF  x94
3384:  MOVLB  0
3386:  CALL   29B4
338A:  MOVLW  0A
338C:  MOVLB  2
338E:  MOVWF  x92
3390:  MOVLW  20
3392:  BTFSS  F9E.4
3394:  BRA    3392
3396:  MOVWF  FAD
3398:  DECFSZ x92,F
339A:  BRA    3390
....................  
....................       if(data[4]<10) 
339C:  MOVLB  0
339E:  MOVF   x87,W
33A0:  SUBLW  09
33A2:  BNC   33C2
....................          printf(" "); 
33A4:  MOVLB  2
33A6:  CLRF   x92
33A8:  MOVF   x92,W
33AA:  MOVLB  0
33AC:  CALL   061C
33B0:  IORLW  00
33B2:  BZ    33C2
33B4:  MOVLB  2
33B6:  INCF   x92,F
33B8:  BTFSS  F9E.4
33BA:  BRA    33B8
33BC:  MOVWF  FAD
33BE:  BRA    33A8
33C0:  MOVLB  0
....................  
....................       printf("%u.", data[4]); 
33C2:  MOVFF  87,293
33C6:  MOVLW  1B
33C8:  MOVLB  2
33CA:  MOVWF  x94
33CC:  MOVLB  0
33CE:  CALL   29B4
33D2:  MOVLW  2E
33D4:  BTFSS  F9E.4
33D6:  BRA    33D4
33D8:  MOVWF  FAD
....................  
....................       if(data[5]<10) 
33DA:  MOVF   x88,W
33DC:  SUBLW  09
33DE:  BNC   33FE
....................          printf("0"); 
33E0:  MOVLB  2
33E2:  CLRF   x92
33E4:  MOVF   x92,W
33E6:  MOVLB  0
33E8:  CALL   04C4
33EC:  IORLW  00
33EE:  BZ    33FE
33F0:  MOVLB  2
33F2:  INCF   x92,F
33F4:  BTFSS  F9E.4
33F6:  BRA    33F4
33F8:  MOVWF  FAD
33FA:  BRA    33E4
33FC:  MOVLB  0
....................  
....................       printf("%u%cC                ", data[5], 223); 
33FE:  MOVFF  88,293
3402:  MOVLW  1B
3404:  MOVLB  2
3406:  MOVWF  x94
3408:  MOVLB  0
340A:  CALL   29B4
340E:  MOVLW  DF
3410:  BTFSS  F9E.4
3412:  BRA    3410
3414:  MOVWF  FAD
3416:  MOVLW  43
3418:  BTFSS  F9E.4
341A:  BRA    3418
341C:  MOVWF  FAD
341E:  MOVLW  10
3420:  MOVLB  2
3422:  MOVWF  x92
3424:  MOVLW  20
3426:  BTFSS  F9E.4
3428:  BRA    3426
342A:  MOVWF  FAD
342C:  DECFSZ x92,F
342E:  BRA    3424
....................  
....................       if(data[6]<100) 
3430:  MOVLB  0
3432:  MOVF   x89,W
3434:  SUBLW  63
3436:  BNC   3456
....................          printf(" "); 
3438:  MOVLB  2
343A:  CLRF   x92
343C:  MOVF   x92,W
343E:  MOVLB  0
3440:  CALL   061C
3444:  IORLW  00
3446:  BZ    3456
3448:  MOVLB  2
344A:  INCF   x92,F
344C:  BTFSS  F9E.4
344E:  BRA    344C
3450:  MOVWF  FAD
3452:  BRA    343C
3454:  MOVLB  0
....................       if(data[6]<10) 
3456:  MOVF   x89,W
3458:  SUBLW  09
345A:  BNC   347A
....................          printf(" "); 
345C:  MOVLB  2
345E:  CLRF   x92
3460:  MOVF   x92,W
3462:  MOVLB  0
3464:  CALL   061C
3468:  IORLW  00
346A:  BZ    347A
346C:  MOVLB  2
346E:  INCF   x92,F
3470:  BTFSS  F9E.4
3472:  BRA    3470
3474:  MOVWF  FAD
3476:  BRA    3460
3478:  MOVLB  0
....................  
....................       printf("%u                   ", data[6]); 
347A:  MOVFF  89,293
347E:  MOVLW  1B
3480:  MOVLB  2
3482:  MOVWF  x94
3484:  MOVLB  0
3486:  CALL   29B4
348A:  MOVLW  13
348C:  MOVLB  2
348E:  MOVWF  x92
3490:  MOVLW  20
3492:  BTFSS  F9E.4
3494:  BRA    3492
3496:  MOVWF  FAD
3498:  DECFSZ x92,F
349A:  BRA    3490
....................  
....................       if(data[7]<100) 
349C:  MOVLB  0
349E:  MOVF   x8A,W
34A0:  SUBLW  63
34A2:  BNC   34C2
....................          printf(" "); 
34A4:  MOVLB  2
34A6:  CLRF   x92
34A8:  MOVF   x92,W
34AA:  MOVLB  0
34AC:  CALL   061C
34B0:  IORLW  00
34B2:  BZ    34C2
34B4:  MOVLB  2
34B6:  INCF   x92,F
34B8:  BTFSS  F9E.4
34BA:  BRA    34B8
34BC:  MOVWF  FAD
34BE:  BRA    34A8
34C0:  MOVLB  0
....................       if(data[7]<10) 
34C2:  MOVF   x8A,W
34C4:  SUBLW  09
34C6:  BNC   34E6
....................          printf(" "); 
34C8:  MOVLB  2
34CA:  CLRF   x92
34CC:  MOVF   x92,W
34CE:  MOVLB  0
34D0:  CALL   061C
34D4:  IORLW  00
34D6:  BZ    34E6
34D8:  MOVLB  2
34DA:  INCF   x92,F
34DC:  BTFSS  F9E.4
34DE:  BRA    34DC
34E0:  MOVWF  FAD
34E2:  BRA    34CC
34E4:  MOVLB  0
....................  
....................       printf("%u\r", data[7]); 
34E6:  MOVFF  8A,293
34EA:  MOVLW  1B
34EC:  MOVLB  2
34EE:  MOVWF  x94
34F0:  MOVLB  0
34F2:  CALL   29B4
34F6:  MOVLW  0D
34F8:  BTFSS  F9E.4
34FA:  BRA    34F8
34FC:  MOVWF  FAD
....................  
....................    } 
34FE:  INCF   x81,F
3500:  BRA    2E46
....................  
....................    //Debemos realizar la operación de guardado para el último día. El proceso es el mismo 
....................    //que hemos seguido arriba. 
....................    if(dia[0]!=0) 
3502:  MOVLB  2
3504:  MOVF   x8D,F
3506:  BZ    35DC
....................    { 
....................       valor = valor + (float)tiempo_x_dia; 
3508:  MOVFF  28A,299
350C:  MOVFF  289,298
3510:  MOVLB  0
3512:  CALL   0F38
3516:  BCF    FD8.1
3518:  MOVFF  CF,295
351C:  MOVFF  CE,294
3520:  MOVFF  CD,293
3524:  MOVFF  CC,292
3528:  MOVFF  03,299
352C:  MOVFF  02,298
3530:  MOVFF  01,297
3534:  MOVFF  00,296
3538:  CALL   17D8
353C:  MOVFF  03,CF
3540:  MOVFF  02,CE
3544:  MOVFF  01,CD
3548:  MOVFF  00,CC
....................       media_dia_mes[dia[1]-1] = valor; 
354C:  MOVLW  01
354E:  MOVLB  2
3550:  SUBWF  x8E,W
3552:  MULLW  04
3554:  MOVF   FF3,W
3556:  CLRF   03
3558:  ADDLW  8C
355A:  MOVWF  FE9
355C:  MOVLW  00
355E:  ADDWFC 03,W
3560:  MOVWF  FEA
3562:  MOVFF  CC,FEF
3566:  MOVFF  CD,FEC
356A:  MOVFF  CE,FEC
356E:  MOVFF  CF,FEC
....................       media_dia_caldera = media_dia_caldera + (float)tiempo_x_dia_caldera; 
3572:  MOVFF  28C,299
3576:  MOVFF  28B,298
357A:  MOVLB  0
357C:  CALL   0F38
3580:  BCF    FD8.1
3582:  MOVFF  CB,295
3586:  MOVFF  CA,294
358A:  MOVFF  C9,293
358E:  MOVFF  C8,292
3592:  MOVFF  03,299
3596:  MOVFF  02,298
359A:  MOVFF  01,297
359E:  MOVFF  00,296
35A2:  CALL   17D8
35A6:  MOVFF  03,CB
35AA:  MOVFF  02,CA
35AE:  MOVFF  01,C9
35B2:  MOVFF  00,C8
....................       media_dia_mes_caldera[dia[1]-1] = media_dia_caldera; 
35B6:  MOVLW  01
35B8:  MOVLB  2
35BA:  SUBWF  x8E,W
35BC:  MULLW  04
35BE:  MOVF   FF3,W
35C0:  CLRF   03
35C2:  ADDLW  D0
35C4:  MOVWF  FE9
35C6:  MOVLW  00
35C8:  ADDWFC 03,W
35CA:  MOVWF  FEA
35CC:  MOVFF  C8,FEF
35D0:  MOVFF  C9,FEC
35D4:  MOVFF  CA,FEC
35D8:  MOVFF  CB,FEC
....................    } 
....................  
....................    //Comprobamos que no nos encontrabamos en el año introducido por defecto 
....................    if(dia[2]!=0) 
35DC:  MOVF   x8F,F
35DE:  BTFSC  FD8.2
35E0:  BRA    380C
....................    { 
....................       for(contador2=0; contador2<12; contador2++) 
35E2:  MOVLB  0
35E4:  CLRF   x82
35E6:  MOVF   x82,W
35E8:  SUBLW  0B
35EA:  BTFSS  FD8.0
35EC:  BRA    37F6
....................       { 
....................          media_dia_mes[contador2] = media_dia_mes[contador2]/(float)dias_meses[contador2]; 
35EE:  MOVF   x82,W
35F0:  MULLW  04
35F2:  MOVF   FF3,W
35F4:  CLRF   03
35F6:  ADDLW  8C
35F8:  MOVWF  01
35FA:  MOVLW  00
35FC:  ADDWFC 03,F
35FE:  MOVFF  01,292
3602:  MOVFF  03,293
3606:  MOVLB  0
3608:  MOVF   x82,W
360A:  MULLW  04
360C:  MOVF   FF3,W
360E:  CLRF   03
3610:  ADDLW  8C
3612:  MOVWF  FE9
3614:  MOVLW  00
3616:  ADDWFC 03,W
3618:  MOVWF  FEA
361A:  MOVFF  FEF,294
361E:  MOVFF  FEC,295
3622:  MOVFF  FEC,296
3626:  MOVFF  FEC,297
362A:  CLRF   03
362C:  MOVF   x82,W
362E:  ADDLW  BC
3630:  MOVWF  FE9
3632:  MOVLW  00
3634:  ADDWFC 03,W
3636:  MOVWF  FEA
3638:  MOVF   FEF,W
363A:  MOVLB  2
363C:  CLRF   x99
363E:  MOVWF  x98
3640:  MOVLB  0
3642:  CALL   0F38
3646:  MOVFF  297,29B
364A:  MOVFF  296,29A
364E:  MOVFF  295,299
3652:  MOVFF  294,298
3656:  MOVFF  03,29F
365A:  MOVFF  02,29E
365E:  MOVFF  01,29D
3662:  MOVFF  00,29C
3666:  CALL   155C
366A:  MOVFF  293,FEA
366E:  MOVFF  292,FE9
3672:  MOVFF  00,FEF
3676:  MOVFF  01,FEC
367A:  MOVFF  02,FEC
367E:  MOVFF  03,FEC
....................          media_dia_mes_caldera[contador2] = media_dia_mes_caldera[contador2]/(float)dias_meses[contador2]; 
3682:  MOVF   x82,W
3684:  MULLW  04
3686:  MOVF   FF3,W
3688:  CLRF   03
368A:  ADDLW  D0
368C:  MOVWF  01
368E:  MOVLW  00
3690:  ADDWFC 03,F
3692:  MOVFF  01,292
3696:  MOVFF  03,293
369A:  MOVLB  0
369C:  MOVF   x82,W
369E:  MULLW  04
36A0:  MOVF   FF3,W
36A2:  CLRF   03
36A4:  ADDLW  D0
36A6:  MOVWF  FE9
36A8:  MOVLW  00
36AA:  ADDWFC 03,W
36AC:  MOVWF  FEA
36AE:  MOVFF  FEF,294
36B2:  MOVFF  FEC,295
36B6:  MOVFF  FEC,296
36BA:  MOVFF  FEC,297
36BE:  CLRF   03
36C0:  MOVF   x82,W
36C2:  ADDLW  BC
36C4:  MOVWF  FE9
36C6:  MOVLW  00
36C8:  ADDWFC 03,W
36CA:  MOVWF  FEA
36CC:  MOVF   FEF,W
36CE:  MOVLB  2
36D0:  CLRF   x99
36D2:  MOVWF  x98
36D4:  MOVLB  0
36D6:  CALL   0F38
36DA:  MOVFF  297,29B
36DE:  MOVFF  296,29A
36E2:  MOVFF  295,299
36E6:  MOVFF  294,298
36EA:  MOVFF  03,29F
36EE:  MOVFF  02,29E
36F2:  MOVFF  01,29D
36F6:  MOVFF  00,29C
36FA:  CALL   155C
36FE:  MOVFF  293,FEA
3702:  MOVFF  292,FE9
3706:  MOVFF  00,FEF
370A:  MOVFF  01,FEC
370E:  MOVFF  02,FEC
3712:  MOVFF  03,FEC
....................          media_annos[num_annos][contador2] = media_dia_mes[contador2]; 
3716:  MOVLB  2
3718:  MOVF   x84,W
371A:  MULLW  30
371C:  MOVF   FF3,W
371E:  CLRF   x93
3720:  MOVWF  x92
3722:  MOVLB  0
3724:  MOVF   x82,W
3726:  MULLW  04
3728:  MOVF   FF3,W
372A:  CLRF   03
372C:  MOVLB  2
372E:  ADDWF  x92,W
3730:  MOVWF  01
3732:  MOVF   x93,W
3734:  ADDWFC 03,F
3736:  MOVF   01,W
3738:  ADDLW  04
373A:  MOVWF  01
373C:  MOVLW  01
373E:  ADDWFC 03,F
3740:  MOVFF  01,294
3744:  MOVFF  03,295
3748:  MOVLB  0
374A:  MOVF   x82,W
374C:  MULLW  04
374E:  MOVF   FF3,W
3750:  CLRF   03
3752:  ADDLW  8C
3754:  MOVWF  FE9
3756:  MOVLW  00
3758:  ADDWFC 03,W
375A:  MOVWF  FEA
375C:  MOVFF  FEF,00
3760:  MOVFF  FEC,01
3764:  MOVFF  FEC,02
3768:  MOVFF  FEC,03
376C:  MOVFF  295,FEA
3770:  MOVFF  294,FE9
3774:  MOVFF  00,FEF
3778:  MOVFF  01,FEC
377C:  MOVFF  02,FEC
3780:  MOVFF  03,FEC
....................          media_annos_caldera[num_annos][contador2] = media_dia_mes_caldera[contador2]; 
3784:  MOVLB  2
3786:  MOVF   x84,W
3788:  MULLW  30
378A:  MOVF   FF3,W
378C:  CLRF   x93
378E:  MOVWF  x92
3790:  MOVLB  0
3792:  MOVF   x82,W
3794:  MULLW  04
3796:  MOVF   FF3,W
3798:  CLRF   03
379A:  MOVLB  2
379C:  ADDWF  x92,W
379E:  MOVWF  01
37A0:  MOVF   x93,W
37A2:  ADDWFC 03,F
37A4:  MOVF   01,W
37A6:  ADDLW  C4
37A8:  MOVWF  01
37AA:  MOVLW  01
37AC:  ADDWFC 03,F
37AE:  MOVFF  01,294
37B2:  MOVFF  03,295
37B6:  MOVLB  0
37B8:  MOVF   x82,W
37BA:  MULLW  04
37BC:  MOVF   FF3,W
37BE:  CLRF   03
37C0:  ADDLW  D0
37C2:  MOVWF  FE9
37C4:  MOVLW  00
37C6:  ADDWFC 03,W
37C8:  MOVWF  FEA
37CA:  MOVFF  FEF,00
37CE:  MOVFF  FEC,01
37D2:  MOVFF  FEC,02
37D6:  MOVFF  FEC,03
37DA:  MOVFF  295,FEA
37DE:  MOVFF  294,FE9
37E2:  MOVFF  00,FEF
37E6:  MOVFF  01,FEC
37EA:  MOVFF  02,FEC
37EE:  MOVFF  03,FEC
....................       } 
37F2:  INCF   x82,F
37F4:  BRA    35E6
....................  
....................       annos[num_annos]=dia[2]; 
37F6:  CLRF   03
37F8:  MOVLB  2
37FA:  MOVF   x84,W
37FC:  ADDLW  85
37FE:  MOVWF  FE9
3800:  MOVLW  02
3802:  ADDWFC 03,W
3804:  MOVWF  FEA
3806:  MOVFF  28F,FEF
....................  
....................       num_annos++; 
380A:  INCF   x84,F
....................    } 
....................  
....................    //Calculamos la media como el cociente entre los valore de tiempo calculados y el número de 
....................    //días en los que se ha encendido la caldera 
....................    valor = valor/(float)num_dias; 
380C:  MOVFF  291,299
3810:  MOVFF  290,298
3814:  MOVLB  0
3816:  CALL   0F38
381A:  MOVFF  CF,29B
381E:  MOVFF  CE,29A
3822:  MOVFF  CD,299
3826:  MOVFF  CC,298
382A:  MOVFF  03,29F
382E:  MOVFF  02,29E
3832:  MOVFF  01,29D
3836:  MOVFF  00,29C
383A:  CALL   155C
383E:  MOVFF  03,CF
3842:  MOVFF  02,CE
3846:  MOVFF  01,CD
384A:  MOVFF  00,CC
....................    media_dia_caldera = media_dia_caldera/(float)num_dias; 
384E:  MOVFF  291,299
3852:  MOVFF  290,298
3856:  CALL   0F38
385A:  MOVFF  CB,29B
385E:  MOVFF  CA,29A
3862:  MOVFF  C9,299
3866:  MOVFF  C8,298
386A:  MOVFF  03,29F
386E:  MOVFF  02,29E
3872:  MOVFF  01,29D
3876:  MOVFF  00,29C
387A:  CALL   155C
387E:  MOVFF  03,CB
3882:  MOVFF  02,CA
3886:  MOVFF  01,C9
388A:  MOVFF  00,C8
....................  
....................    repetir: 
....................    //Menú para mostrar los datos 
....................    printf("=================================================================================\r"); 
388E:  MOVLB  2
3890:  CLRF   x92
3892:  MOVF   x92,W
3894:  MOVLB  0
3896:  CALL   05AE
389A:  IORLW  00
389C:  BZ    38AC
389E:  MOVLB  2
38A0:  INCF   x92,F
38A2:  BTFSS  F9E.4
38A4:  BRA    38A2
38A6:  MOVWF  FAD
38A8:  BRA    3892
38AA:  MOVLB  0
....................    printf("¿Que operacion desea realizar?\r"); 
38AC:  MOVLB  2
38AE:  CLRF   x92
38B0:  MOVF   x92,W
38B2:  MOVLB  0
38B4:  CALL   0638
38B8:  IORLW  00
38BA:  BZ    38CA
38BC:  MOVLB  2
38BE:  INCF   x92,F
38C0:  BTFSS  F9E.4
38C2:  BRA    38C0
38C4:  MOVWF  FAD
38C6:  BRA    38B0
38C8:  MOVLB  0
....................    printf("0. Salir\r"); 
38CA:  MOVLB  2
38CC:  CLRF   x92
38CE:  MOVF   x92,W
38D0:  MOVLB  0
38D2:  CALL   0672
38D6:  IORLW  00
38D8:  BZ    38E8
38DA:  MOVLB  2
38DC:  INCF   x92,F
38DE:  BTFSS  F9E.4
38E0:  BRA    38DE
38E2:  MOVWF  FAD
38E4:  BRA    38CE
38E6:  MOVLB  0
....................    printf("1. Extraer tiempos medios por dia\r"); 
38E8:  MOVLB  2
38EA:  CLRF   x92
38EC:  MOVF   x92,W
38EE:  MOVLB  0
38F0:  CALL   0696
38F4:  IORLW  00
38F6:  BZ    3906
38F8:  MOVLB  2
38FA:  INCF   x92,F
38FC:  BTFSS  F9E.4
38FE:  BRA    38FC
3900:  MOVWF  FAD
3902:  BRA    38EC
3904:  MOVLB  0
....................    printf("2. Extraer tiempos totales\r"); 
3906:  MOVLB  2
3908:  CLRF   x92
390A:  MOVF   x92,W
390C:  MOVLB  0
390E:  CALL   06D4
3912:  IORLW  00
3914:  BZ    3924
3916:  MOVLB  2
3918:  INCF   x92,F
391A:  BTFSS  F9E.4
391C:  BRA    391A
391E:  MOVWF  FAD
3920:  BRA    390A
3922:  MOVLB  0
....................    printf("3. Extraer datos mensuales\r"); 
3924:  MOVLB  2
3926:  CLRF   x92
3928:  MOVF   x92,W
392A:  MOVLB  0
392C:  CALL   070A
3930:  IORLW  00
3932:  BZ    3942
3934:  MOVLB  2
3936:  INCF   x92,F
3938:  BTFSS  F9E.4
393A:  BRA    3938
393C:  MOVWF  FAD
393E:  BRA    3928
3940:  MOVLB  0
....................    printf("=================================================================================\r"); 
3942:  MOVLB  2
3944:  CLRF   x92
3946:  MOVF   x92,W
3948:  MOVLB  0
394A:  CALL   05AE
394E:  IORLW  00
3950:  BZ    3960
3952:  MOVLB  2
3954:  INCF   x92,F
3956:  BTFSS  F9E.4
3958:  BRA    3956
395A:  MOVWF  FAD
395C:  BRA    3946
395E:  MOVLB  0
....................  
....................    //Esperamos la introducción de una de las opciones por parte del técnico 
....................    while(key!='1' && key!='2' && key!='3' && key!='0'){ 
3960:  MOVF   33,W
3962:  SUBLW  31
3964:  BZ    3982
3966:  MOVF   33,W
3968:  SUBLW  32
396A:  BZ    3982
396C:  MOVF   33,W
396E:  SUBLW  33
3970:  BZ    3982
3972:  MOVF   33,W
3974:  SUBLW  30
3976:  BZ    3982
....................       key=get_key(); 
3978:  CALL   2216
397C:  MOVFF  01,33
....................    } 
3980:  BRA    3960
....................  
....................    switch(key) 
....................    { 
3982:  MOVLW  30
3984:  SUBWF  33,W
3986:  ADDLW  FC
3988:  BTFSC  FD8.0
398A:  GOTO   4744
398E:  ADDLW  04
3990:  GOTO   4748
....................       //En el caso 0, se sale del sistema 
....................       case '0': 
....................                //Se indica por pantalla la salida 
....................                lcd_send_byte(LCD_ORDEN, LCD_CLEAR); 
3994:  MOVLB  2
3996:  CLRF   x98
3998:  MOVLW  01
399A:  MOVWF  x99
399C:  MOVLB  0
399E:  CALL   0C60
....................                printf(lcd_putc, "  Saliendo..."); 
39A2:  MOVLB  2
39A4:  CLRF   x92
39A6:  MOVF   x92,W
39A8:  MOVLB  0
39AA:  CALL   0740
39AE:  IORLW  00
39B0:  BZ    39C4
39B2:  MOVLB  2
39B4:  INCF   x92,F
39B6:  MOVWF  x93
39B8:  MOVLB  0
39BA:  CALL   0D34
39BE:  MOVLB  2
39C0:  BRA    39A6
39C2:  MOVLB  0
....................                break; 
39C4:  GOTO   4744
....................  
....................       //En el caso 1, se muestran los valores medios 
....................       case '1': 
....................                key = 'J';  //Utilizamos este carácter para evitar la elección errónea de la misma acción 
39C8:  MOVLW  4A
39CA:  MOVWF  33
....................                printf("\rTiempo medio de encendido del sistema por dia: %3.2f minutos\r\r", valor); 
39CC:  MOVLB  2
39CE:  CLRF   x92
39D0:  MOVF   x92,W
39D2:  MOVLB  0
39D4:  CALL   0768
39D8:  MOVLB  2
39DA:  INCF   x92,F
39DC:  MOVWF  00
39DE:  MOVF   00,W
39E0:  BTFSS  F9E.4
39E2:  BRA    39E0
39E4:  MOVWF  FAD
39E6:  MOVLW  30
39E8:  SUBWF  x92,W
39EA:  BNZ   39D0
39EC:  MOVLW  02
39EE:  MOVWF  FE9
39F0:  MOVFF  CF,2A4
39F4:  MOVFF  CE,2A3
39F8:  MOVFF  CD,2A2
39FC:  MOVFF  CC,2A1
3A00:  MOVWF  xA5
3A02:  MOVLB  0
3A04:  CALL   2A32
3A08:  MOVLW  35
3A0A:  MOVLB  2
3A0C:  MOVWF  x93
3A0E:  MOVF   x93,W
3A10:  MOVLB  0
3A12:  CALL   0768
3A16:  MOVLB  2
3A18:  INCF   x93,F
3A1A:  MOVWF  00
3A1C:  MOVF   00,W
3A1E:  BTFSS  F9E.4
3A20:  BRA    3A1E
3A22:  MOVWF  FAD
3A24:  MOVLW  3F
3A26:  SUBWF  x93,W
3A28:  BNZ   3A0E
....................                printf("Tiempo medio de encendido de la caldera por dia: %3.2f minutos\r\r", media_dia_caldera); 
3A2A:  CLRF   x92
3A2C:  MOVF   x92,W
3A2E:  MOVLB  0
3A30:  CALL   07C2
3A34:  MOVLB  2
3A36:  INCF   x92,F
3A38:  MOVWF  00
3A3A:  MOVF   00,W
3A3C:  BTFSS  F9E.4
3A3E:  BRA    3A3C
3A40:  MOVWF  FAD
3A42:  MOVLW  31
3A44:  SUBWF  x92,W
3A46:  BNZ   3A2C
3A48:  MOVLW  02
3A4A:  MOVWF  FE9
3A4C:  MOVFF  CB,2A4
3A50:  MOVFF  CA,2A3
3A54:  MOVFF  C9,2A2
3A58:  MOVFF  C8,2A1
3A5C:  MOVWF  xA5
3A5E:  MOVLB  0
3A60:  CALL   2A32
3A64:  MOVLW  36
3A66:  MOVLB  2
3A68:  MOVWF  x93
3A6A:  MOVF   x93,W
3A6C:  MOVLB  0
3A6E:  CALL   07C2
3A72:  MOVLB  2
3A74:  INCF   x93,F
3A76:  MOVWF  00
3A78:  MOVF   00,W
3A7A:  BTFSS  F9E.4
3A7C:  BRA    3A7A
3A7E:  MOVWF  FAD
3A80:  MOVLW  40
3A82:  SUBWF  x93,W
3A84:  BNZ   3A6A
....................                goto repetir; 
3A86:  MOVLB  0
3A88:  BRA    388E
....................                break; 
3A8A:  GOTO   4744
....................  
....................       //En el caso 2, se muestran los valores totales 
....................       case '2': 
....................                key = 'J'; //Ídem 
3A8E:  MOVLW  4A
3A90:  MOVWF  33
....................                printf("\rTiempo total de encendido del sistema: %lu minutos\r\r", valor_total); 
3A92:  MOVLB  2
3A94:  CLRF   x92
3A96:  MOVF   x92,W
3A98:  MOVLB  0
3A9A:  CALL   081E
3A9E:  MOVLB  2
3AA0:  INCF   x92,F
3AA2:  MOVWF  00
3AA4:  MOVF   00,W
3AA6:  BTFSS  F9E.4
3AA8:  BRA    3AA6
3AAA:  MOVWF  FAD
3AAC:  MOVLW  28
3AAE:  SUBWF  x92,W
3AB0:  BNZ   3A96
3AB2:  MOVLW  10
3AB4:  MOVWF  FE9
3AB6:  MOVFF  101,294
3ABA:  MOVFF  100,293
3ABE:  MOVLB  0
3AC0:  CALL   2BDC
3AC4:  MOVLW  2B
3AC6:  MOVLB  2
3AC8:  MOVWF  x93
3ACA:  MOVF   x93,W
3ACC:  MOVLB  0
3ACE:  CALL   081E
3AD2:  MOVLB  2
3AD4:  INCF   x93,F
3AD6:  MOVWF  00
3AD8:  MOVF   00,W
3ADA:  BTFSS  F9E.4
3ADC:  BRA    3ADA
3ADE:  MOVWF  FAD
3AE0:  MOVLW  35
3AE2:  SUBWF  x93,W
3AE4:  BNZ   3ACA
....................                printf("Tiempo total de encendido de la caldera: %lu minutos\r\r", valor_total_caldera); 
3AE6:  CLRF   x92
3AE8:  MOVF   x92,W
3AEA:  MOVLB  0
3AEC:  CALL   086E
3AF0:  MOVLB  2
3AF2:  INCF   x92,F
3AF4:  MOVWF  00
3AF6:  MOVF   00,W
3AF8:  BTFSS  F9E.4
3AFA:  BRA    3AF8
3AFC:  MOVWF  FAD
3AFE:  MOVLW  29
3B00:  SUBWF  x92,W
3B02:  BNZ   3AE8
3B04:  MOVLW  10
3B06:  MOVWF  FE9
3B08:  MOVFF  103,294
3B0C:  MOVFF  102,293
3B10:  MOVLB  0
3B12:  CALL   2BDC
3B16:  MOVLW  2C
3B18:  MOVLB  2
3B1A:  MOVWF  x93
3B1C:  MOVF   x93,W
3B1E:  MOVLB  0
3B20:  CALL   086E
3B24:  MOVLB  2
3B26:  INCF   x93,F
3B28:  MOVWF  00
3B2A:  MOVF   00,W
3B2C:  BTFSS  F9E.4
3B2E:  BRA    3B2C
3B30:  MOVWF  FAD
3B32:  MOVLW  36
3B34:  SUBWF  x93,W
3B36:  BNZ   3B1C
....................                goto repetir; 
3B38:  MOVLB  0
3B3A:  BRA    388E
....................                break; 
3B3C:  GOTO   4744
....................  
....................       //En el caso 3, se muestran todos los valores medios por meses y años 
....................       case '3': 
....................                key = 'J'; //Ídem 
3B40:  MOVLW  4A
3B42:  MOVWF  33
....................                //Se representan todos los años de los que se tiene registro 
....................                for(contador=0; contador<num_annos; contador++) 
3B44:  CLRF   x81
3B46:  MOVLB  2
3B48:  MOVF   x84,W
3B4A:  MOVLB  0
3B4C:  SUBWF  x81,W
3B4E:  BTFSC  FD8.0
3B50:  GOTO   473E
....................                { 
....................                   //Imprimimos el año en el que nos encontramos 
....................                   printf("\r20"); 
3B54:  MOVLB  2
3B56:  CLRF   x92
3B58:  MOVF   x92,W
3B5A:  MOVLB  0
3B5C:  CALL   08C0
3B60:  IORLW  00
3B62:  BZ    3B72
3B64:  MOVLB  2
3B66:  INCF   x92,F
3B68:  BTFSS  F9E.4
3B6A:  BRA    3B68
3B6C:  MOVWF  FAD
3B6E:  BRA    3B58
3B70:  MOVLB  0
....................                   if(annos[contador]<10) 
3B72:  CLRF   03
3B74:  MOVF   x81,W
3B76:  ADDLW  85
3B78:  MOVWF  FE9
3B7A:  MOVLW  02
3B7C:  ADDWFC 03,W
3B7E:  MOVWF  FEA
3B80:  MOVF   FEF,W
3B82:  SUBLW  09
3B84:  BNC   3BA4
....................                      printf("0"); 
3B86:  MOVLB  2
3B88:  CLRF   x92
3B8A:  MOVF   x92,W
3B8C:  MOVLB  0
3B8E:  CALL   04C4
3B92:  IORLW  00
3B94:  BZ    3BA4
3B96:  MOVLB  2
3B98:  INCF   x92,F
3B9A:  BTFSS  F9E.4
3B9C:  BRA    3B9A
3B9E:  MOVWF  FAD
3BA0:  BRA    3B8A
3BA2:  MOVLB  0
....................                   printf("%u\r", annos[contador]); 
3BA4:  CLRF   03
3BA6:  MOVF   x81,W
3BA8:  ADDLW  85
3BAA:  MOVWF  FE9
3BAC:  MOVLW  02
3BAE:  ADDWFC 03,W
3BB0:  MOVWF  FEA
3BB2:  MOVFF  FEF,292
3BB6:  MOVFF  292,293
3BBA:  MOVLW  1B
3BBC:  MOVLB  2
3BBE:  MOVWF  x94
3BC0:  MOVLB  0
3BC2:  CALL   29B4
3BC6:  MOVLW  0D
3BC8:  BTFSS  F9E.4
3BCA:  BRA    3BC8
3BCC:  MOVWF  FAD
....................                   printf("--------------------------------------------------------------------------------------------------------------------\r"); 
3BCE:  MOVLB  2
3BD0:  CLRF   x92
3BD2:  MOVF   x92,W
3BD4:  MOVLB  0
3BD6:  CALL   08DE
3BDA:  IORLW  00
3BDC:  BZ    3BEC
3BDE:  MOVLB  2
3BE0:  INCF   x92,F
3BE2:  BTFSS  F9E.4
3BE4:  BRA    3BE2
3BE6:  MOVWF  FAD
3BE8:  BRA    3BD2
3BEA:  MOVLB  0
....................                   printf("              Tiempo medio de encendido del sistema (min/dia)      Tiempo medio de encendido de la caldera (min/dia)\r"); 
3BEC:  MOVLB  2
3BEE:  CLRF   x92
3BF0:  MOVF   x92,W
3BF2:  MOVLB  0
3BF4:  CALL   096E
3BF8:  IORLW  00
3BFA:  BZ    3C0A
3BFC:  MOVLB  2
3BFE:  INCF   x92,F
3C00:  BTFSS  F9E.4
3C02:  BRA    3C00
3C04:  MOVWF  FAD
3C06:  BRA    3BF0
3C08:  MOVLB  0
....................                   printf("ENERO                              %f                                                     %f\r", media_annos[contador][0], media_annos_caldera[contador][0]); 
3C0A:  MOVF   x81,W
3C0C:  MULLW  30
3C0E:  MOVF   FF3,W
3C10:  MOVLB  2
3C12:  CLRF   x93
3C14:  MOVWF  x92
3C16:  MOVLW  04
3C18:  ADDWF  x92,W
3C1A:  MOVWF  FE9
3C1C:  MOVLW  01
3C1E:  ADDWFC x93,W
3C20:  MOVWF  FEA
3C22:  MOVFF  FEF,294
3C26:  MOVFF  FEC,295
3C2A:  MOVFF  FEC,296
3C2E:  MOVFF  FEC,297
3C32:  MOVLB  0
3C34:  MOVF   x81,W
3C36:  MULLW  30
3C38:  MOVF   FF3,W
3C3A:  MOVLB  2
3C3C:  CLRF   x99
3C3E:  MOVWF  x98
3C40:  MOVLW  C4
3C42:  ADDWF  x98,W
3C44:  MOVWF  FE9
3C46:  MOVLW  01
3C48:  ADDWFC x99,W
3C4A:  MOVWF  FEA
3C4C:  MOVFF  FEF,29A
3C50:  MOVFF  FEC,29B
3C54:  MOVFF  FEC,29C
3C58:  MOVFF  FEC,29D
3C5C:  CLRF   x9E
3C5E:  MOVF   x9E,W
3C60:  MOVLB  0
3C62:  CALL   09FE
3C66:  MOVLB  2
3C68:  INCF   x9E,F
3C6A:  MOVWF  00
3C6C:  MOVF   00,W
3C6E:  BTFSS  F9E.4
3C70:  BRA    3C6E
3C72:  MOVWF  FAD
3C74:  MOVLW  05
3C76:  SUBWF  x9E,W
3C78:  BNZ   3C5E
3C7A:  MOVLW  1E
3C7C:  MOVWF  x9F
3C7E:  MOVLW  20
3C80:  BTFSS  F9E.4
3C82:  BRA    3C80
3C84:  MOVWF  FAD
3C86:  DECFSZ x9F,F
3C88:  BRA    3C7E
3C8A:  MOVLW  89
3C8C:  MOVWF  FE9
3C8E:  MOVFF  297,2A4
3C92:  MOVFF  296,2A3
3C96:  MOVFF  295,2A2
3C9A:  MOVFF  294,2A1
3C9E:  MOVLW  06
3CA0:  MOVWF  xA5
3CA2:  MOVLB  0
3CA4:  CALL   2A32
3CA8:  MOVLW  35
3CAA:  MOVLB  2
3CAC:  MOVWF  xA0
3CAE:  MOVLW  20
3CB0:  BTFSS  F9E.4
3CB2:  BRA    3CB0
3CB4:  MOVWF  FAD
3CB6:  DECFSZ xA0,F
3CB8:  BRA    3CAE
3CBA:  MOVLW  89
3CBC:  MOVWF  FE9
3CBE:  MOVFF  29D,2A4
3CC2:  MOVFF  29C,2A3
3CC6:  MOVFF  29B,2A2
3CCA:  MOVFF  29A,2A1
3CCE:  MOVLW  06
3CD0:  MOVWF  xA5
3CD2:  MOVLB  0
3CD4:  CALL   2A32
3CD8:  MOVLW  0D
3CDA:  BTFSS  F9E.4
3CDC:  BRA    3CDA
3CDE:  MOVWF  FAD
....................                   printf("FEBRERO                            %f                                                     %f\r", media_annos[contador][1], media_annos_caldera[contador][1]); 
3CE0:  MOVF   x81,W
3CE2:  MULLW  30
3CE4:  MOVF   FF3,W
3CE6:  MOVLB  2
3CE8:  CLRF   x93
3CEA:  MOVWF  x92
3CEC:  MOVLW  04
3CEE:  ADDWF  x92,W
3CF0:  MOVWF  01
3CF2:  MOVLW  00
3CF4:  ADDWFC x93,W
3CF6:  MOVWF  03
3CF8:  MOVF   01,W
3CFA:  ADDLW  04
3CFC:  MOVWF  FE9
3CFE:  MOVLW  01
3D00:  ADDWFC 03,W
3D02:  MOVWF  FEA
3D04:  MOVFF  FEF,294
3D08:  MOVFF  FEC,295
3D0C:  MOVFF  FEC,296
3D10:  MOVFF  FEC,297
3D14:  MOVLB  0
3D16:  MOVF   x81,W
3D18:  MULLW  30
3D1A:  MOVF   FF3,W
3D1C:  MOVLB  2
3D1E:  CLRF   x99
3D20:  MOVWF  x98
3D22:  MOVLW  04
3D24:  ADDWF  x98,W
3D26:  MOVWF  01
3D28:  MOVLW  00
3D2A:  ADDWFC x99,W
3D2C:  MOVWF  03
3D2E:  MOVF   01,W
3D30:  ADDLW  C4
3D32:  MOVWF  FE9
3D34:  MOVLW  01
3D36:  ADDWFC 03,W
3D38:  MOVWF  FEA
3D3A:  MOVFF  FEF,29A
3D3E:  MOVFF  FEC,29B
3D42:  MOVFF  FEC,29C
3D46:  MOVFF  FEC,29D
3D4A:  CLRF   x9E
3D4C:  MOVF   x9E,W
3D4E:  MOVLB  0
3D50:  CALL   0A24
3D54:  MOVLB  2
3D56:  INCF   x9E,F
3D58:  MOVWF  00
3D5A:  MOVF   00,W
3D5C:  BTFSS  F9E.4
3D5E:  BRA    3D5C
3D60:  MOVWF  FAD
3D62:  MOVLW  07
3D64:  SUBWF  x9E,W
3D66:  BNZ   3D4C
3D68:  MOVLW  1C
3D6A:  MOVWF  x9F
3D6C:  MOVLW  20
3D6E:  BTFSS  F9E.4
3D70:  BRA    3D6E
3D72:  MOVWF  FAD
3D74:  DECFSZ x9F,F
3D76:  BRA    3D6C
3D78:  MOVLW  89
3D7A:  MOVWF  FE9
3D7C:  MOVFF  297,2A4
3D80:  MOVFF  296,2A3
3D84:  MOVFF  295,2A2
3D88:  MOVFF  294,2A1
3D8C:  MOVLW  06
3D8E:  MOVWF  xA5
3D90:  MOVLB  0
3D92:  CALL   2A32
3D96:  MOVLW  35
3D98:  MOVLB  2
3D9A:  MOVWF  xA0
3D9C:  MOVLW  20
3D9E:  BTFSS  F9E.4
3DA0:  BRA    3D9E
3DA2:  MOVWF  FAD
3DA4:  DECFSZ xA0,F
3DA6:  BRA    3D9C
3DA8:  MOVLW  89
3DAA:  MOVWF  FE9
3DAC:  MOVFF  29D,2A4
3DB0:  MOVFF  29C,2A3
3DB4:  MOVFF  29B,2A2
3DB8:  MOVFF  29A,2A1
3DBC:  MOVLW  06
3DBE:  MOVWF  xA5
3DC0:  MOVLB  0
3DC2:  CALL   2A32
3DC6:  MOVLW  0D
3DC8:  BTFSS  F9E.4
3DCA:  BRA    3DC8
3DCC:  MOVWF  FAD
....................                   printf("MARZO                              %f                                                     %f\r", media_annos[contador][2], media_annos_caldera[contador][2]); 
3DCE:  MOVF   x81,W
3DD0:  MULLW  30
3DD2:  MOVF   FF3,W
3DD4:  MOVLB  2
3DD6:  CLRF   x93
3DD8:  MOVWF  x92
3DDA:  MOVLW  08
3DDC:  ADDWF  x92,W
3DDE:  MOVWF  01
3DE0:  MOVLW  00
3DE2:  ADDWFC x93,W
3DE4:  MOVWF  03
3DE6:  MOVF   01,W
3DE8:  ADDLW  04
3DEA:  MOVWF  FE9
3DEC:  MOVLW  01
3DEE:  ADDWFC 03,W
3DF0:  MOVWF  FEA
3DF2:  MOVFF  FEF,294
3DF6:  MOVFF  FEC,295
3DFA:  MOVFF  FEC,296
3DFE:  MOVFF  FEC,297
3E02:  MOVLB  0
3E04:  MOVF   x81,W
3E06:  MULLW  30
3E08:  MOVF   FF3,W
3E0A:  MOVLB  2
3E0C:  CLRF   x99
3E0E:  MOVWF  x98
3E10:  MOVLW  08
3E12:  ADDWF  x98,W
3E14:  MOVWF  01
3E16:  MOVLW  00
3E18:  ADDWFC x99,W
3E1A:  MOVWF  03
3E1C:  MOVF   01,W
3E1E:  ADDLW  C4
3E20:  MOVWF  FE9
3E22:  MOVLW  01
3E24:  ADDWFC 03,W
3E26:  MOVWF  FEA
3E28:  MOVFF  FEF,29A
3E2C:  MOVFF  FEC,29B
3E30:  MOVFF  FEC,29C
3E34:  MOVFF  FEC,29D
3E38:  CLRF   x9E
3E3A:  MOVF   x9E,W
3E3C:  MOVLB  0
3E3E:  CALL   0A4C
3E42:  MOVLB  2
3E44:  INCF   x9E,F
3E46:  MOVWF  00
3E48:  MOVF   00,W
3E4A:  BTFSS  F9E.4
3E4C:  BRA    3E4A
3E4E:  MOVWF  FAD
3E50:  MOVLW  05
3E52:  SUBWF  x9E,W
3E54:  BNZ   3E3A
3E56:  MOVLW  1E
3E58:  MOVWF  x9F
3E5A:  MOVLW  20
3E5C:  BTFSS  F9E.4
3E5E:  BRA    3E5C
3E60:  MOVWF  FAD
3E62:  DECFSZ x9F,F
3E64:  BRA    3E5A
3E66:  MOVLW  89
3E68:  MOVWF  FE9
3E6A:  MOVFF  297,2A4
3E6E:  MOVFF  296,2A3
3E72:  MOVFF  295,2A2
3E76:  MOVFF  294,2A1
3E7A:  MOVLW  06
3E7C:  MOVWF  xA5
3E7E:  MOVLB  0
3E80:  CALL   2A32
3E84:  MOVLW  35
3E86:  MOVLB  2
3E88:  MOVWF  xA0
3E8A:  MOVLW  20
3E8C:  BTFSS  F9E.4
3E8E:  BRA    3E8C
3E90:  MOVWF  FAD
3E92:  DECFSZ xA0,F
3E94:  BRA    3E8A
3E96:  MOVLW  89
3E98:  MOVWF  FE9
3E9A:  MOVFF  29D,2A4
3E9E:  MOVFF  29C,2A3
3EA2:  MOVFF  29B,2A2
3EA6:  MOVFF  29A,2A1
3EAA:  MOVLW  06
3EAC:  MOVWF  xA5
3EAE:  MOVLB  0
3EB0:  CALL   2A32
3EB4:  MOVLW  0D
3EB6:  BTFSS  F9E.4
3EB8:  BRA    3EB6
3EBA:  MOVWF  FAD
....................                   printf("ABRIL                              %f                                                     %f\r", media_annos[contador][3], media_annos_caldera[contador][3]); 
3EBC:  MOVF   x81,W
3EBE:  MULLW  30
3EC0:  MOVF   FF3,W
3EC2:  MOVLB  2
3EC4:  CLRF   x93
3EC6:  MOVWF  x92
3EC8:  MOVLW  0C
3ECA:  ADDWF  x92,W
3ECC:  MOVWF  01
3ECE:  MOVLW  00
3ED0:  ADDWFC x93,W
3ED2:  MOVWF  03
3ED4:  MOVF   01,W
3ED6:  ADDLW  04
3ED8:  MOVWF  FE9
3EDA:  MOVLW  01
3EDC:  ADDWFC 03,W
3EDE:  MOVWF  FEA
3EE0:  MOVFF  FEF,294
3EE4:  MOVFF  FEC,295
3EE8:  MOVFF  FEC,296
3EEC:  MOVFF  FEC,297
3EF0:  MOVLB  0
3EF2:  MOVF   x81,W
3EF4:  MULLW  30
3EF6:  MOVF   FF3,W
3EF8:  MOVLB  2
3EFA:  CLRF   x99
3EFC:  MOVWF  x98
3EFE:  MOVLW  0C
3F00:  ADDWF  x98,W
3F02:  MOVWF  01
3F04:  MOVLW  00
3F06:  ADDWFC x99,W
3F08:  MOVWF  03
3F0A:  MOVF   01,W
3F0C:  ADDLW  C4
3F0E:  MOVWF  FE9
3F10:  MOVLW  01
3F12:  ADDWFC 03,W
3F14:  MOVWF  FEA
3F16:  MOVFF  FEF,29A
3F1A:  MOVFF  FEC,29B
3F1E:  MOVFF  FEC,29C
3F22:  MOVFF  FEC,29D
3F26:  CLRF   x9E
3F28:  MOVF   x9E,W
3F2A:  MOVLB  0
3F2C:  CALL   0A72
3F30:  MOVLB  2
3F32:  INCF   x9E,F
3F34:  MOVWF  00
3F36:  MOVF   00,W
3F38:  BTFSS  F9E.4
3F3A:  BRA    3F38
3F3C:  MOVWF  FAD
3F3E:  MOVLW  05
3F40:  SUBWF  x9E,W
3F42:  BNZ   3F28
3F44:  MOVLW  1E
3F46:  MOVWF  x9F
3F48:  MOVLW  20
3F4A:  BTFSS  F9E.4
3F4C:  BRA    3F4A
3F4E:  MOVWF  FAD
3F50:  DECFSZ x9F,F
3F52:  BRA    3F48
3F54:  MOVLW  89
3F56:  MOVWF  FE9
3F58:  MOVFF  297,2A4
3F5C:  MOVFF  296,2A3
3F60:  MOVFF  295,2A2
3F64:  MOVFF  294,2A1
3F68:  MOVLW  06
3F6A:  MOVWF  xA5
3F6C:  MOVLB  0
3F6E:  CALL   2A32
3F72:  MOVLW  35
3F74:  MOVLB  2
3F76:  MOVWF  xA0
3F78:  MOVLW  20
3F7A:  BTFSS  F9E.4
3F7C:  BRA    3F7A
3F7E:  MOVWF  FAD
3F80:  DECFSZ xA0,F
3F82:  BRA    3F78
3F84:  MOVLW  89
3F86:  MOVWF  FE9
3F88:  MOVFF  29D,2A4
3F8C:  MOVFF  29C,2A3
3F90:  MOVFF  29B,2A2
3F94:  MOVFF  29A,2A1
3F98:  MOVLW  06
3F9A:  MOVWF  xA5
3F9C:  MOVLB  0
3F9E:  CALL   2A32
3FA2:  MOVLW  0D
3FA4:  BTFSS  F9E.4
3FA6:  BRA    3FA4
3FA8:  MOVWF  FAD
....................                   printf("MAYO                               %f                                                     %f\r", media_annos[contador][4], media_annos_caldera[contador][4]); 
3FAA:  MOVF   x81,W
3FAC:  MULLW  30
3FAE:  MOVF   FF3,W
3FB0:  MOVLB  2
3FB2:  CLRF   x93
3FB4:  MOVWF  x92
3FB6:  MOVLW  10
3FB8:  ADDWF  x92,W
3FBA:  MOVWF  01
3FBC:  MOVLW  00
3FBE:  ADDWFC x93,W
3FC0:  MOVWF  03
3FC2:  MOVF   01,W
3FC4:  ADDLW  04
3FC6:  MOVWF  FE9
3FC8:  MOVLW  01
3FCA:  ADDWFC 03,W
3FCC:  MOVWF  FEA
3FCE:  MOVFF  FEF,294
3FD2:  MOVFF  FEC,295
3FD6:  MOVFF  FEC,296
3FDA:  MOVFF  FEC,297
3FDE:  MOVLB  0
3FE0:  MOVF   x81,W
3FE2:  MULLW  30
3FE4:  MOVF   FF3,W
3FE6:  MOVLB  2
3FE8:  CLRF   x99
3FEA:  MOVWF  x98
3FEC:  MOVLW  10
3FEE:  ADDWF  x98,W
3FF0:  MOVWF  01
3FF2:  MOVLW  00
3FF4:  ADDWFC x99,W
3FF6:  MOVWF  03
3FF8:  MOVF   01,W
3FFA:  ADDLW  C4
3FFC:  MOVWF  FE9
3FFE:  MOVLW  01
4000:  ADDWFC 03,W
4002:  MOVWF  FEA
4004:  MOVFF  FEF,29A
4008:  MOVFF  FEC,29B
400C:  MOVFF  FEC,29C
4010:  MOVFF  FEC,29D
4014:  CLRF   x9E
4016:  MOVF   x9E,W
4018:  MOVLB  0
401A:  CALL   0A98
401E:  MOVLB  2
4020:  INCF   x9E,F
4022:  MOVWF  00
4024:  MOVF   00,W
4026:  BTFSS  F9E.4
4028:  BRA    4026
402A:  MOVWF  FAD
402C:  MOVLW  04
402E:  SUBWF  x9E,W
4030:  BNZ   4016
4032:  MOVLW  1F
4034:  MOVWF  x9F
4036:  MOVLW  20
4038:  BTFSS  F9E.4
403A:  BRA    4038
403C:  MOVWF  FAD
403E:  DECFSZ x9F,F
4040:  BRA    4036
4042:  MOVLW  89
4044:  MOVWF  FE9
4046:  MOVFF  297,2A4
404A:  MOVFF  296,2A3
404E:  MOVFF  295,2A2
4052:  MOVFF  294,2A1
4056:  MOVLW  06
4058:  MOVWF  xA5
405A:  MOVLB  0
405C:  CALL   2A32
4060:  MOVLW  35
4062:  MOVLB  2
4064:  MOVWF  xA0
4066:  MOVLW  20
4068:  BTFSS  F9E.4
406A:  BRA    4068
406C:  MOVWF  FAD
406E:  DECFSZ xA0,F
4070:  BRA    4066
4072:  MOVLW  89
4074:  MOVWF  FE9
4076:  MOVFF  29D,2A4
407A:  MOVFF  29C,2A3
407E:  MOVFF  29B,2A2
4082:  MOVFF  29A,2A1
4086:  MOVLW  06
4088:  MOVWF  xA5
408A:  MOVLB  0
408C:  CALL   2A32
4090:  MOVLW  0D
4092:  BTFSS  F9E.4
4094:  BRA    4092
4096:  MOVWF  FAD
....................                   printf("JUNIO                              %f                                                     %f\r", media_annos[contador][5], media_annos_caldera[contador][5]); 
4098:  MOVF   x81,W
409A:  MULLW  30
409C:  MOVF   FF3,W
409E:  MOVLB  2
40A0:  CLRF   x93
40A2:  MOVWF  x92
40A4:  MOVLW  14
40A6:  ADDWF  x92,W
40A8:  MOVWF  01
40AA:  MOVLW  00
40AC:  ADDWFC x93,W
40AE:  MOVWF  03
40B0:  MOVF   01,W
40B2:  ADDLW  04
40B4:  MOVWF  FE9
40B6:  MOVLW  01
40B8:  ADDWFC 03,W
40BA:  MOVWF  FEA
40BC:  MOVFF  FEF,294
40C0:  MOVFF  FEC,295
40C4:  MOVFF  FEC,296
40C8:  MOVFF  FEC,297
40CC:  MOVLB  0
40CE:  MOVF   x81,W
40D0:  MULLW  30
40D2:  MOVF   FF3,W
40D4:  MOVLB  2
40D6:  CLRF   x99
40D8:  MOVWF  x98
40DA:  MOVLW  14
40DC:  ADDWF  x98,W
40DE:  MOVWF  01
40E0:  MOVLW  00
40E2:  ADDWFC x99,W
40E4:  MOVWF  03
40E6:  MOVF   01,W
40E8:  ADDLW  C4
40EA:  MOVWF  FE9
40EC:  MOVLW  01
40EE:  ADDWFC 03,W
40F0:  MOVWF  FEA
40F2:  MOVFF  FEF,29A
40F6:  MOVFF  FEC,29B
40FA:  MOVFF  FEC,29C
40FE:  MOVFF  FEC,29D
4102:  CLRF   x9E
4104:  MOVF   x9E,W
4106:  MOVLB  0
4108:  CALL   0ABC
410C:  MOVLB  2
410E:  INCF   x9E,F
4110:  MOVWF  00
4112:  MOVF   00,W
4114:  BTFSS  F9E.4
4116:  BRA    4114
4118:  MOVWF  FAD
411A:  MOVLW  05
411C:  SUBWF  x9E,W
411E:  BNZ   4104
4120:  MOVLW  1E
4122:  MOVWF  x9F
4124:  MOVLW  20
4126:  BTFSS  F9E.4
4128:  BRA    4126
412A:  MOVWF  FAD
412C:  DECFSZ x9F,F
412E:  BRA    4124
4130:  MOVLW  89
4132:  MOVWF  FE9
4134:  MOVFF  297,2A4
4138:  MOVFF  296,2A3
413C:  MOVFF  295,2A2
4140:  MOVFF  294,2A1
4144:  MOVLW  06
4146:  MOVWF  xA5
4148:  MOVLB  0
414A:  CALL   2A32
414E:  MOVLW  35
4150:  MOVLB  2
4152:  MOVWF  xA0
4154:  MOVLW  20
4156:  BTFSS  F9E.4
4158:  BRA    4156
415A:  MOVWF  FAD
415C:  DECFSZ xA0,F
415E:  BRA    4154
4160:  MOVLW  89
4162:  MOVWF  FE9
4164:  MOVFF  29D,2A4
4168:  MOVFF  29C,2A3
416C:  MOVFF  29B,2A2
4170:  MOVFF  29A,2A1
4174:  MOVLW  06
4176:  MOVWF  xA5
4178:  MOVLB  0
417A:  CALL   2A32
417E:  MOVLW  0D
4180:  BTFSS  F9E.4
4182:  BRA    4180
4184:  MOVWF  FAD
....................                   printf("JULIO                              %f                                                     %f\r", media_annos[contador][6], media_annos_caldera[contador][6]); 
4186:  MOVF   x81,W
4188:  MULLW  30
418A:  MOVF   FF3,W
418C:  MOVLB  2
418E:  CLRF   x93
4190:  MOVWF  x92
4192:  MOVLW  18
4194:  ADDWF  x92,W
4196:  MOVWF  01
4198:  MOVLW  00
419A:  ADDWFC x93,W
419C:  MOVWF  03
419E:  MOVF   01,W
41A0:  ADDLW  04
41A2:  MOVWF  FE9
41A4:  MOVLW  01
41A6:  ADDWFC 03,W
41A8:  MOVWF  FEA
41AA:  MOVFF  FEF,294
41AE:  MOVFF  FEC,295
41B2:  MOVFF  FEC,296
41B6:  MOVFF  FEC,297
41BA:  MOVLB  0
41BC:  MOVF   x81,W
41BE:  MULLW  30
41C0:  MOVF   FF3,W
41C2:  MOVLB  2
41C4:  CLRF   x99
41C6:  MOVWF  x98
41C8:  MOVLW  18
41CA:  ADDWF  x98,W
41CC:  MOVWF  01
41CE:  MOVLW  00
41D0:  ADDWFC x99,W
41D2:  MOVWF  03
41D4:  MOVF   01,W
41D6:  ADDLW  C4
41D8:  MOVWF  FE9
41DA:  MOVLW  01
41DC:  ADDWFC 03,W
41DE:  MOVWF  FEA
41E0:  MOVFF  FEF,29A
41E4:  MOVFF  FEC,29B
41E8:  MOVFF  FEC,29C
41EC:  MOVFF  FEC,29D
41F0:  CLRF   x9E
41F2:  MOVF   x9E,W
41F4:  MOVLB  0
41F6:  CALL   0AE2
41FA:  MOVLB  2
41FC:  INCF   x9E,F
41FE:  MOVWF  00
4200:  MOVF   00,W
4202:  BTFSS  F9E.4
4204:  BRA    4202
4206:  MOVWF  FAD
4208:  MOVLW  05
420A:  SUBWF  x9E,W
420C:  BNZ   41F2
420E:  MOVLW  1E
4210:  MOVWF  x9F
4212:  MOVLW  20
4214:  BTFSS  F9E.4
4216:  BRA    4214
4218:  MOVWF  FAD
421A:  DECFSZ x9F,F
421C:  BRA    4212
421E:  MOVLW  89
4220:  MOVWF  FE9
4222:  MOVFF  297,2A4
4226:  MOVFF  296,2A3
422A:  MOVFF  295,2A2
422E:  MOVFF  294,2A1
4232:  MOVLW  06
4234:  MOVWF  xA5
4236:  MOVLB  0
4238:  CALL   2A32
423C:  MOVLW  35
423E:  MOVLB  2
4240:  MOVWF  xA0
4242:  MOVLW  20
4244:  BTFSS  F9E.4
4246:  BRA    4244
4248:  MOVWF  FAD
424A:  DECFSZ xA0,F
424C:  BRA    4242
424E:  MOVLW  89
4250:  MOVWF  FE9
4252:  MOVFF  29D,2A4
4256:  MOVFF  29C,2A3
425A:  MOVFF  29B,2A2
425E:  MOVFF  29A,2A1
4262:  MOVLW  06
4264:  MOVWF  xA5
4266:  MOVLB  0
4268:  CALL   2A32
426C:  MOVLW  0D
426E:  BTFSS  F9E.4
4270:  BRA    426E
4272:  MOVWF  FAD
....................                   printf("AGOSTO                             %f                                                     %f\r", media_annos[contador][7], media_annos_caldera[contador][7]); 
4274:  MOVF   x81,W
4276:  MULLW  30
4278:  MOVF   FF3,W
427A:  MOVLB  2
427C:  CLRF   x93
427E:  MOVWF  x92
4280:  MOVLW  1C
4282:  ADDWF  x92,W
4284:  MOVWF  01
4286:  MOVLW  00
4288:  ADDWFC x93,W
428A:  MOVWF  03
428C:  MOVF   01,W
428E:  ADDLW  04
4290:  MOVWF  FE9
4292:  MOVLW  01
4294:  ADDWFC 03,W
4296:  MOVWF  FEA
4298:  MOVFF  FEF,294
429C:  MOVFF  FEC,295
42A0:  MOVFF  FEC,296
42A4:  MOVFF  FEC,297
42A8:  MOVLB  0
42AA:  MOVF   x81,W
42AC:  MULLW  30
42AE:  MOVF   FF3,W
42B0:  MOVLB  2
42B2:  CLRF   x99
42B4:  MOVWF  x98
42B6:  MOVLW  1C
42B8:  ADDWF  x98,W
42BA:  MOVWF  01
42BC:  MOVLW  00
42BE:  ADDWFC x99,W
42C0:  MOVWF  03
42C2:  MOVF   01,W
42C4:  ADDLW  C4
42C6:  MOVWF  FE9
42C8:  MOVLW  01
42CA:  ADDWFC 03,W
42CC:  MOVWF  FEA
42CE:  MOVFF  FEF,29A
42D2:  MOVFF  FEC,29B
42D6:  MOVFF  FEC,29C
42DA:  MOVFF  FEC,29D
42DE:  CLRF   x9E
42E0:  MOVF   x9E,W
42E2:  MOVLB  0
42E4:  CALL   0B08
42E8:  MOVLB  2
42EA:  INCF   x9E,F
42EC:  MOVWF  00
42EE:  MOVF   00,W
42F0:  BTFSS  F9E.4
42F2:  BRA    42F0
42F4:  MOVWF  FAD
42F6:  MOVLW  06
42F8:  SUBWF  x9E,W
42FA:  BNZ   42E0
42FC:  MOVLW  1D
42FE:  MOVWF  x9F
4300:  MOVLW  20
4302:  BTFSS  F9E.4
4304:  BRA    4302
4306:  MOVWF  FAD
4308:  DECFSZ x9F,F
430A:  BRA    4300
430C:  MOVLW  89
430E:  MOVWF  FE9
4310:  MOVFF  297,2A4
4314:  MOVFF  296,2A3
4318:  MOVFF  295,2A2
431C:  MOVFF  294,2A1
4320:  MOVLW  06
4322:  MOVWF  xA5
4324:  MOVLB  0
4326:  CALL   2A32
432A:  MOVLW  35
432C:  MOVLB  2
432E:  MOVWF  xA0
4330:  MOVLW  20
4332:  BTFSS  F9E.4
4334:  BRA    4332
4336:  MOVWF  FAD
4338:  DECFSZ xA0,F
433A:  BRA    4330
433C:  MOVLW  89
433E:  MOVWF  FE9
4340:  MOVFF  29D,2A4
4344:  MOVFF  29C,2A3
4348:  MOVFF  29B,2A2
434C:  MOVFF  29A,2A1
4350:  MOVLW  06
4352:  MOVWF  xA5
4354:  MOVLB  0
4356:  CALL   2A32
435A:  MOVLW  0D
435C:  BTFSS  F9E.4
435E:  BRA    435C
4360:  MOVWF  FAD
....................                   printf("SEPTIEMBRE                         %f                                                     %f\r", media_annos[contador][8], media_annos_caldera[contador][8]); 
4362:  MOVF   x81,W
4364:  MULLW  30
4366:  MOVF   FF3,W
4368:  MOVLB  2
436A:  CLRF   x93
436C:  MOVWF  x92
436E:  MOVLW  20
4370:  ADDWF  x92,W
4372:  MOVWF  01
4374:  MOVLW  00
4376:  ADDWFC x93,W
4378:  MOVWF  03
437A:  MOVF   01,W
437C:  ADDLW  04
437E:  MOVWF  FE9
4380:  MOVLW  01
4382:  ADDWFC 03,W
4384:  MOVWF  FEA
4386:  MOVFF  FEF,294
438A:  MOVFF  FEC,295
438E:  MOVFF  FEC,296
4392:  MOVFF  FEC,297
4396:  MOVLB  0
4398:  MOVF   x81,W
439A:  MULLW  30
439C:  MOVF   FF3,W
439E:  MOVLB  2
43A0:  CLRF   x99
43A2:  MOVWF  x98
43A4:  MOVLW  20
43A6:  ADDWF  x98,W
43A8:  MOVWF  01
43AA:  MOVLW  00
43AC:  ADDWFC x99,W
43AE:  MOVWF  03
43B0:  MOVF   01,W
43B2:  ADDLW  C4
43B4:  MOVWF  FE9
43B6:  MOVLW  01
43B8:  ADDWFC 03,W
43BA:  MOVWF  FEA
43BC:  MOVFF  FEF,29A
43C0:  MOVFF  FEC,29B
43C4:  MOVFF  FEC,29C
43C8:  MOVFF  FEC,29D
43CC:  CLRF   x9E
43CE:  MOVF   x9E,W
43D0:  MOVLB  0
43D2:  CALL   0B2E
43D6:  MOVLB  2
43D8:  INCF   x9E,F
43DA:  MOVWF  00
43DC:  MOVF   00,W
43DE:  BTFSS  F9E.4
43E0:  BRA    43DE
43E2:  MOVWF  FAD
43E4:  MOVLW  0A
43E6:  SUBWF  x9E,W
43E8:  BNZ   43CE
43EA:  MOVLW  19
43EC:  MOVWF  x9F
43EE:  MOVLW  20
43F0:  BTFSS  F9E.4
43F2:  BRA    43F0
43F4:  MOVWF  FAD
43F6:  DECFSZ x9F,F
43F8:  BRA    43EE
43FA:  MOVLW  89
43FC:  MOVWF  FE9
43FE:  MOVFF  297,2A4
4402:  MOVFF  296,2A3
4406:  MOVFF  295,2A2
440A:  MOVFF  294,2A1
440E:  MOVLW  06
4410:  MOVWF  xA5
4412:  MOVLB  0
4414:  CALL   2A32
4418:  MOVLW  35
441A:  MOVLB  2
441C:  MOVWF  xA0
441E:  MOVLW  20
4420:  BTFSS  F9E.4
4422:  BRA    4420
4424:  MOVWF  FAD
4426:  DECFSZ xA0,F
4428:  BRA    441E
442A:  MOVLW  89
442C:  MOVWF  FE9
442E:  MOVFF  29D,2A4
4432:  MOVFF  29C,2A3
4436:  MOVFF  29B,2A2
443A:  MOVFF  29A,2A1
443E:  MOVLW  06
4440:  MOVWF  xA5
4442:  MOVLB  0
4444:  CALL   2A32
4448:  MOVLW  0D
444A:  BTFSS  F9E.4
444C:  BRA    444A
444E:  MOVWF  FAD
....................                   printf("OCTUBRE                            %f                                                     %f\r", media_annos[contador][9], media_annos_caldera[contador][9]); 
4450:  MOVF   x81,W
4452:  MULLW  30
4454:  MOVF   FF3,W
4456:  MOVLB  2
4458:  CLRF   x93
445A:  MOVWF  x92
445C:  MOVLW  24
445E:  ADDWF  x92,W
4460:  MOVWF  01
4462:  MOVLW  00
4464:  ADDWFC x93,W
4466:  MOVWF  03
4468:  MOVF   01,W
446A:  ADDLW  04
446C:  MOVWF  FE9
446E:  MOVLW  01
4470:  ADDWFC 03,W
4472:  MOVWF  FEA
4474:  MOVFF  FEF,294
4478:  MOVFF  FEC,295
447C:  MOVFF  FEC,296
4480:  MOVFF  FEC,297
4484:  MOVLB  0
4486:  MOVF   x81,W
4488:  MULLW  30
448A:  MOVF   FF3,W
448C:  MOVLB  2
448E:  CLRF   x99
4490:  MOVWF  x98
4492:  MOVLW  24
4494:  ADDWF  x98,W
4496:  MOVWF  01
4498:  MOVLW  00
449A:  ADDWFC x99,W
449C:  MOVWF  03
449E:  MOVF   01,W
44A0:  ADDLW  C4
44A2:  MOVWF  FE9
44A4:  MOVLW  01
44A6:  ADDWFC 03,W
44A8:  MOVWF  FEA
44AA:  MOVFF  FEF,29A
44AE:  MOVFF  FEC,29B
44B2:  MOVFF  FEC,29C
44B6:  MOVFF  FEC,29D
44BA:  CLRF   x9E
44BC:  MOVF   x9E,W
44BE:  MOVLB  0
44C0:  CALL   0B58
44C4:  MOVLB  2
44C6:  INCF   x9E,F
44C8:  MOVWF  00
44CA:  MOVF   00,W
44CC:  BTFSS  F9E.4
44CE:  BRA    44CC
44D0:  MOVWF  FAD
44D2:  MOVLW  07
44D4:  SUBWF  x9E,W
44D6:  BNZ   44BC
44D8:  MOVLW  1C
44DA:  MOVWF  x9F
44DC:  MOVLW  20
44DE:  BTFSS  F9E.4
44E0:  BRA    44DE
44E2:  MOVWF  FAD
44E4:  DECFSZ x9F,F
44E6:  BRA    44DC
44E8:  MOVLW  89
44EA:  MOVWF  FE9
44EC:  MOVFF  297,2A4
44F0:  MOVFF  296,2A3
44F4:  MOVFF  295,2A2
44F8:  MOVFF  294,2A1
44FC:  MOVLW  06
44FE:  MOVWF  xA5
4500:  MOVLB  0
4502:  CALL   2A32
4506:  MOVLW  35
4508:  MOVLB  2
450A:  MOVWF  xA0
450C:  MOVLW  20
450E:  BTFSS  F9E.4
4510:  BRA    450E
4512:  MOVWF  FAD
4514:  DECFSZ xA0,F
4516:  BRA    450C
4518:  MOVLW  89
451A:  MOVWF  FE9
451C:  MOVFF  29D,2A4
4520:  MOVFF  29C,2A3
4524:  MOVFF  29B,2A2
4528:  MOVFF  29A,2A1
452C:  MOVLW  06
452E:  MOVWF  xA5
4530:  MOVLB  0
4532:  CALL   2A32
4536:  MOVLW  0D
4538:  BTFSS  F9E.4
453A:  BRA    4538
453C:  MOVWF  FAD
....................                   printf("NOVIEMBRE                          %f                                                     %f\r", media_annos[contador][10], media_annos_caldera[contador][10]); 
453E:  MOVF   x81,W
4540:  MULLW  30
4542:  MOVF   FF3,W
4544:  MOVLB  2
4546:  CLRF   x93
4548:  MOVWF  x92
454A:  MOVLW  28
454C:  ADDWF  x92,W
454E:  MOVWF  01
4550:  MOVLW  00
4552:  ADDWFC x93,W
4554:  MOVWF  03
4556:  MOVF   01,W
4558:  ADDLW  04
455A:  MOVWF  FE9
455C:  MOVLW  01
455E:  ADDWFC 03,W
4560:  MOVWF  FEA
4562:  MOVFF  FEF,294
4566:  MOVFF  FEC,295
456A:  MOVFF  FEC,296
456E:  MOVFF  FEC,297
4572:  MOVLB  0
4574:  MOVF   x81,W
4576:  MULLW  30
4578:  MOVF   FF3,W
457A:  MOVLB  2
457C:  CLRF   x99
457E:  MOVWF  x98
4580:  MOVLW  28
4582:  ADDWF  x98,W
4584:  MOVWF  01
4586:  MOVLW  00
4588:  ADDWFC x99,W
458A:  MOVWF  03
458C:  MOVF   01,W
458E:  ADDLW  C4
4590:  MOVWF  FE9
4592:  MOVLW  01
4594:  ADDWFC 03,W
4596:  MOVWF  FEA
4598:  MOVFF  FEF,29A
459C:  MOVFF  FEC,29B
45A0:  MOVFF  FEC,29C
45A4:  MOVFF  FEC,29D
45A8:  CLRF   x9E
45AA:  MOVF   x9E,W
45AC:  MOVLB  0
45AE:  CALL   0B80
45B2:  MOVLB  2
45B4:  INCF   x9E,F
45B6:  MOVWF  00
45B8:  MOVF   00,W
45BA:  BTFSS  F9E.4
45BC:  BRA    45BA
45BE:  MOVWF  FAD
45C0:  MOVLW  09
45C2:  SUBWF  x9E,W
45C4:  BNZ   45AA
45C6:  MOVLW  1A
45C8:  MOVWF  x9F
45CA:  MOVLW  20
45CC:  BTFSS  F9E.4
45CE:  BRA    45CC
45D0:  MOVWF  FAD
45D2:  DECFSZ x9F,F
45D4:  BRA    45CA
45D6:  MOVLW  89
45D8:  MOVWF  FE9
45DA:  MOVFF  297,2A4
45DE:  MOVFF  296,2A3
45E2:  MOVFF  295,2A2
45E6:  MOVFF  294,2A1
45EA:  MOVLW  06
45EC:  MOVWF  xA5
45EE:  MOVLB  0
45F0:  CALL   2A32
45F4:  MOVLW  35
45F6:  MOVLB  2
45F8:  MOVWF  xA0
45FA:  MOVLW  20
45FC:  BTFSS  F9E.4
45FE:  BRA    45FC
4600:  MOVWF  FAD
4602:  DECFSZ xA0,F
4604:  BRA    45FA
4606:  MOVLW  89
4608:  MOVWF  FE9
460A:  MOVFF  29D,2A4
460E:  MOVFF  29C,2A3
4612:  MOVFF  29B,2A2
4616:  MOVFF  29A,2A1
461A:  MOVLW  06
461C:  MOVWF  xA5
461E:  MOVLB  0
4620:  CALL   2A32
4624:  MOVLW  0D
4626:  BTFSS  F9E.4
4628:  BRA    4626
462A:  MOVWF  FAD
....................                   printf("DICIEMBRE                          %f                                                     %f\r", media_annos[contador][11], media_annos_caldera[contador][11]); 
462C:  MOVF   x81,W
462E:  MULLW  30
4630:  MOVF   FF3,W
4632:  MOVLB  2
4634:  CLRF   x93
4636:  MOVWF  x92
4638:  MOVLW  2C
463A:  ADDWF  x92,W
463C:  MOVWF  01
463E:  MOVLW  00
4640:  ADDWFC x93,W
4642:  MOVWF  03
4644:  MOVF   01,W
4646:  ADDLW  04
4648:  MOVWF  FE9
464A:  MOVLW  01
464C:  ADDWFC 03,W
464E:  MOVWF  FEA
4650:  MOVFF  FEF,294
4654:  MOVFF  FEC,295
4658:  MOVFF  FEC,296
465C:  MOVFF  FEC,297
4660:  MOVLB  0
4662:  MOVF   x81,W
4664:  MULLW  30
4666:  MOVF   FF3,W
4668:  MOVLB  2
466A:  CLRF   x99
466C:  MOVWF  x98
466E:  MOVLW  2C
4670:  ADDWF  x98,W
4672:  MOVWF  01
4674:  MOVLW  00
4676:  ADDWFC x99,W
4678:  MOVWF  03
467A:  MOVF   01,W
467C:  ADDLW  C4
467E:  MOVWF  FE9
4680:  MOVLW  01
4682:  ADDWFC 03,W
4684:  MOVWF  FEA
4686:  MOVFF  FEF,29A
468A:  MOVFF  FEC,29B
468E:  MOVFF  FEC,29C
4692:  MOVFF  FEC,29D
4696:  CLRF   x9E
4698:  MOVF   x9E,W
469A:  MOVLB  0
469C:  CALL   0BAA
46A0:  MOVLB  2
46A2:  INCF   x9E,F
46A4:  MOVWF  00
46A6:  MOVF   00,W
46A8:  BTFSS  F9E.4
46AA:  BRA    46A8
46AC:  MOVWF  FAD
46AE:  MOVLW  09
46B0:  SUBWF  x9E,W
46B2:  BNZ   4698
46B4:  MOVLW  1A
46B6:  MOVWF  x9F
46B8:  MOVLW  20
46BA:  BTFSS  F9E.4
46BC:  BRA    46BA
46BE:  MOVWF  FAD
46C0:  DECFSZ x9F,F
46C2:  BRA    46B8
46C4:  MOVLW  89
46C6:  MOVWF  FE9
46C8:  MOVFF  297,2A4
46CC:  MOVFF  296,2A3
46D0:  MOVFF  295,2A2
46D4:  MOVFF  294,2A1
46D8:  MOVLW  06
46DA:  MOVWF  xA5
46DC:  MOVLB  0
46DE:  CALL   2A32
46E2:  MOVLW  35
46E4:  MOVLB  2
46E6:  MOVWF  xA0
46E8:  MOVLW  20
46EA:  BTFSS  F9E.4
46EC:  BRA    46EA
46EE:  MOVWF  FAD
46F0:  DECFSZ xA0,F
46F2:  BRA    46E8
46F4:  MOVLW  89
46F6:  MOVWF  FE9
46F8:  MOVFF  29D,2A4
46FC:  MOVFF  29C,2A3
4700:  MOVFF  29B,2A2
4704:  MOVFF  29A,2A1
4708:  MOVLW  06
470A:  MOVWF  xA5
470C:  MOVLB  0
470E:  CALL   2A32
4712:  MOVLW  0D
4714:  BTFSS  F9E.4
4716:  BRA    4714
4718:  MOVWF  FAD
....................                   printf("--------------------------------------------------------------------------------------------------------------------\r"); 
471A:  MOVLB  2
471C:  CLRF   x92
471E:  MOVF   x92,W
4720:  MOVLB  0
4722:  CALL   08DE
4726:  IORLW  00
4728:  BZ    4738
472A:  MOVLB  2
472C:  INCF   x92,F
472E:  BTFSS  F9E.4
4730:  BRA    472E
4732:  MOVWF  FAD
4734:  BRA    471E
4736:  MOVLB  0
....................                } 
4738:  INCF   x81,F
473A:  GOTO   3B46
....................  
....................                goto repetir; 
473E:  GOTO   388E
....................                break; 
4742:  BRA    4744
....................  
....................       //En los tres casos, vuelve a mostrarse el menú tras imprimir las estadísticas 
....................    } 
....................  
.................... } 
4744:  GOTO   58FA (RETURN)
....................  

Configuration Fuses:
   Word  1: 0200   HS NOIESO NOFCMEN RESERVED
   Word  2: 161E   BROWNOUT NOWDT BORV25 PUT WDT2048
   Word  3: 8300   PBADEN CCP2C1 NOLPT1OSC MCLR RESERVED
   Word  4: 0081   STVREN NODEBUG NOLVP NOXINST RESERVED
   Word  5: C00F   NOPROTECT NOCPD NOCPB
   Word  6: E00F   NOWRT NOWRTD NOWRTC NOWRTB
   Word  7: 400F   NOEBTR NOEBTRB
