CCS PCH C Compiler, Version 3.249, 28193               27-ene-10 20:26

               Filename: D:\programming\sed\Proyecto 1\Prototipo 2 (placa)\proyecto1.lst

               ROM used: 25530 bytes (78%)
                         Largest free fragment is 7234
               RAM used: 92 (6%) at main() level
                         680 (44%) worst case
               Stack:    8 worst case (7 in main + 1 for interrupts)

*
0000:  GOTO   5522
*
0008:  MOVWF  05
000A:  MOVFF  FD8,06
000E:  MOVFF  FE0,07
0012:  MOVLB  0
0014:  MOVFF  FE9,0D
0018:  MOVFF  FEA,08
001C:  MOVFF  FE1,09
0020:  MOVFF  FE2,0A
0024:  MOVFF  FD9,0B
0028:  MOVFF  FDA,0C
002C:  MOVFF  FF3,14
0030:  MOVFF  FF4,15
0034:  MOVFF  FFA,16
0038:  MOVFF  00,0F
003C:  MOVFF  01,10
0040:  MOVFF  02,11
0044:  MOVFF  03,12
0048:  MOVFF  04,13
004C:  BTFSS  FF2.4
004E:  GOTO   0058
0052:  BTFSC  FF2.1
0054:  GOTO   0D1C
0058:  BTFSS  FF0.3
005A:  GOTO   0064
005E:  BTFSC  FF0.0
0060:  GOTO   0D26
0064:  MOVFF  0F,00
0068:  MOVFF  10,01
006C:  MOVFF  11,02
0070:  MOVFF  12,03
0074:  MOVFF  13,04
0078:  MOVFF  0D,FE9
007C:  MOVFF  08,FEA
0080:  MOVFF  09,FE1
0084:  MOVFF  0A,FE2
0088:  MOVFF  0B,FD9
008C:  MOVFF  0C,FDA
0090:  MOVFF  14,FF3
0094:  MOVFF  15,FF4
0098:  MOVFF  16,FFA
009C:  MOVF   05,W
009E:  MOVFF  07,FE0
00A2:  MOVFF  06,FD8
00A6:  RETFIE 0
.................... //***************************************************************** 
.................... //***   PROYECTO 1: Control de un sistema de calefacción de una *** 
.................... //***   vivienda utilizando un microcontrolador PIC18F4520      *** 
.................... //***************************************************************** 
.................... //Author: Julio Navarro Lara        2010 
....................  
.................... //En este caso está preparado para probarse en la placa EasyPic3 
....................  
....................  
....................  
.................... #include "18F4520.H" 
.................... //////// Standard Header file for the PIC18F4520 device //////////////// 
.................... #DEVICE PIC18F4520 //Aunque el convertidor A/D es de 10 bits, con esta directiva 
00A8:  MOVFF  FF2,0E
00AC:  BCF    FF2.7
00AE:  CLRF   FF7
00B0:  ADDLW  C2
00B2:  MOVWF  FF6
00B4:  MOVLW  00
00B6:  ADDWFC FF7,F
00B8:  TBLRD*+
00BA:  MOVF   FF5,W
00BC:  BTFSC  0E.7
00BE:  BSF    FF2.7
00C0:  RETURN 0
00C2:  DATA 2C,0F
00C4:  DATA 01,06
00C6:  MOVFF  FF2,0E
00CA:  BCF    FF2.7
00CC:  CLRF   FF7
00CE:  ADDLW  E0
00D0:  MOVWF  FF6
00D2:  MOVLW  00
00D4:  ADDWFC FF7,F
00D6:  TBLRD*+
00D8:  MOVF   FF5,W
00DA:  BTFSC  0E.7
00DC:  BSF    FF2.7
00DE:  RETURN 0
00E0:  DATA 49,6E
00E2:  DATA 69,63
00E4:  DATA 69,61
00E6:  DATA 6C,69
00E8:  DATA 7A,61
00EA:  DATA 6E,64
00EC:  DATA 6F,2E
00EE:  DATA 2E,2E
00F0:  DATA 00,00
00F2:  MOVFF  FF2,0E
00F6:  BCF    FF2.7
00F8:  CLRF   FF7
00FA:  ADDLW  0C
00FC:  MOVWF  FF6
00FE:  MOVLW  01
0100:  ADDWFC FF7,F
0102:  TBLRD*+
0104:  MOVF   FF5,W
0106:  BTFSC  0E.7
0108:  BSF    FF2.7
010A:  RETURN 0
010C:  DATA 20,20
010E:  DATA 45,6E
0110:  DATA 63,65
0112:  DATA 6E,64
0114:  DATA 69,65
0116:  DATA 6E,64
0118:  DATA 6F,0A
011A:  DATA 20,20
011C:  DATA 73,69
011E:  DATA 73,74
0120:  DATA 65,6D
0122:  DATA 61,2E
0124:  DATA 2E,2E
0126:  DATA 00,00
0128:  MOVFF  FF2,0E
012C:  BCF    FF2.7
012E:  CLRF   FF7
0130:  ADDLW  42
0132:  MOVWF  FF6
0134:  MOVLW  01
0136:  ADDWFC FF7,F
0138:  TBLRD*+
013A:  MOVF   FF5,W
013C:  BTFSC  0E.7
013E:  BSF    FF2.7
0140:  RETURN 0
0142:  DATA 20,20
0144:  DATA 41,70
0146:  DATA 61,67
0148:  DATA 61,6E
014A:  DATA 64,6F
014C:  DATA 0A,20
014E:  DATA 20,73
0150:  DATA 69,73
0152:  DATA 74,65
0154:  DATA 6D,61
0156:  DATA 2E,2E
0158:  DATA 2E,00
015A:  MOVFF  FF2,0E
015E:  BCF    FF2.7
0160:  CLRF   FF7
0162:  ADDLW  74
0164:  MOVWF  FF6
0166:  MOVLW  01
0168:  ADDWFC FF7,F
016A:  TBLRD*+
016C:  MOVF   FF5,W
016E:  BTFSC  0E.7
0170:  BSF    FF2.7
0172:  RETURN 0
0174:  DATA 20,20
0176:  DATA 49,6E
0178:  DATA 64,69
017A:  DATA 71,75
017C:  DATA 65,20
017E:  DATA 6C,61
0180:  DATA 20,0A
0182:  DATA 20,20
0184:  DATA 6F,70
0186:  DATA 65,72
0188:  DATA 61,63
018A:  DATA 69,6F
018C:  DATA 6E,20
018E:  DATA 20,20
0190:  DATA 31,00
0192:  MOVFF  FF2,0E
0196:  BCF    FF2.7
0198:  CLRF   FF7
019A:  ADDLW  AC
019C:  MOVWF  FF6
019E:  MOVLW  01
01A0:  ADDWFC FF7,F
01A2:  TBLRD*+
01A4:  MOVF   FF5,W
01A6:  BTFSC  0E.7
01A8:  BSF    FF2.7
01AA:  RETURN 0
01AC:  DATA 20,20
01AE:  DATA 41,6E
01B0:  DATA 75,6C
01B2:  DATA 61,6E
01B4:  DATA 64,6F
01B6:  DATA 0A,20
01B8:  DATA 20,6F
01BA:  DATA 70,65
01BC:  DATA 72,61
01BE:  DATA 63,69
01C0:  DATA 6F,6E
01C2:  DATA 2E,2E
01C4:  DATA 2E,00
01C6:  MOVFF  FF2,0E
01CA:  BCF    FF2.7
01CC:  CLRF   FF7
01CE:  ADDLW  E0
01D0:  MOVWF  FF6
01D2:  MOVLW  01
01D4:  ADDWFC FF7,F
01D6:  TBLRD*+
01D8:  MOVF   FF5,W
01DA:  BTFSC  0E.7
01DC:  BSF    FF2.7
01DE:  RETURN 0
01E0:  DATA 4D,6F
01E2:  DATA 64,69
01E4:  DATA 66,69
01E6:  DATA 63,61
01E8:  DATA 72,0A
01EA:  DATA 74,65
01EC:  DATA 72,6D
01EE:  DATA 6F,73
01F0:  DATA 74,61
01F2:  DATA 74,6F
01F4:  DATA 20,25
01F6:  DATA 2E,30
01F8:  DATA 66,25
01FA:  DATA 63,43
01FC:  DATA 00,00
01FE:  MOVFF  FF2,0E
0202:  BCF    FF2.7
0204:  CLRF   FF7
0206:  ADDLW  18
0208:  MOVWF  FF6
020A:  MOVLW  02
020C:  ADDWFC FF7,F
020E:  TBLRD*+
0210:  MOVF   FF5,W
0212:  BTFSC  0E.7
0214:  BSF    FF2.7
0216:  RETURN 0
0218:  DATA 4E,75
021A:  DATA 65,76
021C:  DATA 6F,20
021E:  DATA 76,61
0220:  DATA 6C,6F
0222:  DATA 72,3A
0224:  DATA 0A,25
0226:  DATA 63,43
0228:  DATA 00,00
022A:  MOVFF  FF2,0E
022E:  BCF    FF2.7
0230:  CLRF   FF7
0232:  ADDLW  44
0234:  MOVWF  FF6
0236:  MOVLW  02
0238:  ADDWFC FF7,F
023A:  TBLRD*+
023C:  MOVF   FF5,W
023E:  BTFSC  0E.7
0240:  BSF    FF2.7
0242:  RETURN 0
0244:  DATA 20,20
0246:  DATA 41,70
0248:  DATA 6C,69
024A:  DATA 63,61
024C:  DATA 6E,64
024E:  DATA 6F,0A
0250:  DATA 20,20
0252:  DATA 63,61
0254:  DATA 6D,62
0256:  DATA 69,6F
0258:  DATA 73,2E
025A:  DATA 2E,2E
025C:  DATA 00,00
025E:  MOVFF  FF2,0E
0262:  BCF    FF2.7
0264:  CLRF   FF7
0266:  ADDLW  78
0268:  MOVWF  FF6
026A:  MOVLW  02
026C:  ADDWFC FF7,F
026E:  TBLRD*+
0270:  MOVF   FF5,W
0272:  BTFSC  0E.7
0274:  BSF    FF2.7
0276:  RETURN 0
0278:  DATA 20,50
027A:  DATA 72,6F
027C:  DATA 67,72
027E:  DATA 61,6D
0280:  DATA 61,72
0282:  DATA 0A,20
0284:  DATA 73,69
0286:  DATA 73,74
0288:  DATA 65,6D
028A:  DATA 61,00
028C:  MOVFF  FF2,0E
0290:  BCF    FF2.7
0292:  CLRF   FF7
0294:  ADDLW  A6
0296:  MOVWF  FF6
0298:  MOVLW  02
029A:  ADDWFC FF7,F
029C:  TBLRD*+
029E:  MOVF   FF5,W
02A0:  BTFSC  0E.7
02A2:  BSF    FF2.7
02A4:  RETURN 0
02A6:  DATA 20,49
02A8:  DATA 4E,54
02AA:  DATA 45,52
02AC:  DATA 56,41
02AE:  DATA 4C,4F
02B0:  DATA 20,25
02B2:  DATA 69,0A
02B4:  DATA 3A,3A
02B6:  DATA 00,00
02B8:  MOVFF  FF2,0E
02BC:  BCF    FF2.7
02BE:  CLRF   FF7
02C0:  ADDLW  D2
02C2:  MOVWF  FF6
02C4:  MOVLW  02
02C6:  ADDWFC FF7,F
02C8:  TBLRD*+
02CA:  MOVF   FF5,W
02CC:  BTFSC  0E.7
02CE:  BSF    FF2.7
02D0:  RETURN 0
02D2:  DATA 20,20
02D4:  DATA 20,56
02D6:  DATA 61,6C
02D8:  DATA 6F,72
02DA:  DATA 65,73
02DC:  DATA 0A,20
02DE:  DATA 20,20
02E0:  DATA 69,6E
02E2:  DATA 63,6F
02E4:  DATA 72,72
02E6:  DATA 65,63
02E8:  DATA 74,6F
02EA:  DATA 73,00
02EC:  MOVFF  FF2,0E
02F0:  BCF    FF2.7
02F2:  CLRF   FF7
02F4:  ADDLW  06
02F6:  MOVWF  FF6
02F8:  MOVLW  03
02FA:  ADDWFC FF7,F
02FC:  TBLRD*+
02FE:  MOVF   FF5,W
0300:  BTFSC  0E.7
0302:  BSF    FF2.7
0304:  RETURN 0
0306:  DATA 49,6E
0308:  DATA 74,65
030A:  DATA 72,76
030C:  DATA 61,6C
030E:  DATA 6F,20
0310:  DATA 6C,69
0312:  DATA 6D,69
0314:  DATA 74,65
0316:  DATA 0A,64
0318:  DATA 65,20
031A:  DATA 34,20
031C:  DATA 68,6F
031E:  DATA 72,61
0320:  DATA 73,00
0322:  MOVFF  FF2,0E
0326:  BCF    FF2.7
0328:  CLRF   FF7
032A:  ADDLW  3C
032C:  MOVWF  FF6
032E:  MOVLW  03
0330:  ADDWFC FF7,F
0332:  TBLRD*+
0334:  MOVF   FF5,W
0336:  BTFSC  0E.7
0338:  BSF    FF2.7
033A:  RETURN 0
033C:  DATA 54,65
033E:  DATA 72,6D
0340:  DATA 6F,73
0342:  DATA 74,61
0344:  DATA 74,6F
0346:  DATA 20,25
0348:  DATA 69,0A
034A:  DATA 25,63
034C:  DATA 43,00
034E:  MOVFF  FF2,0E
0352:  BCF    FF2.7
0354:  CLRF   FF7
0356:  ADDLW  68
0358:  MOVWF  FF6
035A:  MOVLW  03
035C:  ADDWFC FF7,F
035E:  TBLRD*+
0360:  MOVF   FF5,W
0362:  BTFSC  0E.7
0364:  BSF    FF2.7
0366:  RETURN 0
0368:  DATA 53,6F
036A:  DATA 6C,61
036C:  DATA 70,61
036E:  DATA 6D,69
0370:  DATA 65,6E
0372:  DATA 74,6F
0374:  DATA 0A,64
0376:  DATA 65,20
0378:  DATA 69,6E
037A:  DATA 74,65
037C:  DATA 72,76
037E:  DATA 61,6C
0380:  DATA 6F,73
0382:  DATA 21,00
0384:  MOVFF  FF2,0E
0388:  BCF    FF2.7
038A:  CLRF   FF7
038C:  ADDLW  9E
038E:  MOVWF  FF6
0390:  MOVLW  03
0392:  ADDWFC FF7,F
0394:  TBLRD*+
0396:  MOVF   FF5,W
0398:  BTFSC  0E.7
039A:  BSF    FF2.7
039C:  RETURN 0
039E:  DATA 20,20
03A0:  DATA 49,6E
03A2:  DATA 74,72
03A4:  DATA 6F,64
03A6:  DATA 75,7A
03A8:  DATA 63,61
03AA:  DATA 0A,20
03AC:  DATA 20,63
03AE:  DATA 6C,61
03B0:  DATA 76,65
03B2:  DATA 00,00
03B4:  MOVFF  FF2,0E
03B8:  BCF    FF2.7
03BA:  CLRF   FF7
03BC:  ADDLW  CE
03BE:  MOVWF  FF6
03C0:  MOVLW  03
03C2:  ADDWFC FF7,F
03C4:  TBLRD*+
03C6:  MOVF   FF5,W
03C8:  BTFSC  0E.7
03CA:  BSF    FF2.7
03CC:  RETURN 0
03CE:  DATA 20,20
03D0:  DATA 4D,6F
03D2:  DATA 64,6F
03D4:  DATA 0A,20
03D6:  DATA 20,72
03D8:  DATA 65,76
03DA:  DATA 69,73
03DC:  DATA 69,6F
03DE:  DATA 6E,00
03E0:  MOVFF  FF2,0E
03E4:  BCF    FF2.7
03E6:  CLRF   FF7
03E8:  ADDLW  FA
03EA:  MOVWF  FF6
03EC:  MOVLW  03
03EE:  ADDWFC FF7,F
03F0:  TBLRD*+
03F2:  MOVF   FF5,W
03F4:  BTFSC  0E.7
03F6:  BSF    FF2.7
03F8:  RETURN 0
03FA:  DATA 44,65
03FC:  DATA 6D,61
03FE:  DATA 73,69
0400:  DATA 61,64
0402:  DATA 6F,20
0404:  DATA 74,69
0406:  DATA 65,6D
0408:  DATA 70,6F
040A:  DATA 0A,65
040C:  DATA 6E,63
040E:  DATA 65,6E
0410:  DATA 64,69
0412:  DATA 64,6F
0414:  DATA 21,00
0416:  MOVFF  FF2,0E
041A:  BCF    FF2.7
041C:  CLRF   FF7
041E:  ADDLW  30
0420:  MOVWF  FF6
0422:  MOVLW  04
0424:  ADDWFC FF7,F
0426:  TBLRD*+
0428:  MOVF   FF5,W
042A:  BTFSC  0E.7
042C:  BSF    FF2.7
042E:  RETURN 0
0430:  DATA 54,45
0432:  DATA 4D,50
0434:  DATA 20,2D
0436:  DATA 20,25
0438:  DATA 33,2E
043A:  DATA 31,66
043C:  DATA 20,25
043E:  DATA 63,43
0440:  DATA 0A,48
0442:  DATA 4F,52
0444:  DATA 41,20
0446:  DATA 2D,20
0448:  DATA 00,00
044A:  MOVFF  FF2,0E
044E:  BCF    FF2.7
0450:  CLRF   FF7
0452:  ADDLW  64
0454:  MOVWF  FF6
0456:  MOVLW  04
0458:  ADDWFC FF7,F
045A:  TBLRD*+
045C:  MOVF   FF5,W
045E:  BTFSC  0E.7
0460:  BSF    FF2.7
0462:  RETURN 0
0464:  DATA 30,00
0466:  MOVFF  FF2,0E
046A:  BCF    FF2.7
046C:  CLRF   FF7
046E:  ADDLW  80
0470:  MOVWF  FF6
0472:  MOVLW  04
0474:  ADDWFC FF7,F
0476:  TBLRD*+
0478:  MOVF   FF5,W
047A:  BTFSC  0E.7
047C:  BSF    FF2.7
047E:  RETURN 0
0480:  DATA 52,45
0482:  DATA 47,49
0484:  DATA 53,54
0486:  DATA 52,4F
0488:  DATA 20,44
048A:  DATA 45,20
048C:  DATA 45,56
048E:  DATA 45,4E
0490:  DATA 54,4F
0492:  DATA 53,0D
0494:  DATA 00,00
0496:  MOVFF  FF2,0E
049A:  BCF    FF2.7
049C:  CLRF   FF7
049E:  ADDLW  B0
04A0:  MOVWF  FF6
04A2:  MOVLW  04
04A4:  ADDWFC FF7,F
04A6:  TBLRD*+
04A8:  MOVF   FF5,W
04AA:  BTFSC  0E.7
04AC:  BSF    FF2.7
04AE:  RETURN 0
04B0:  DATA 2A,2A
04B2:  DATA 2A,2A
04B4:  DATA 2A,2A
04B6:  DATA 2A,2A
04B8:  DATA 2A,2A
04BA:  DATA 2A,2A
04BC:  DATA 2A,2A
04BE:  DATA 2A,2A
04C0:  DATA 2A,2A
04C2:  DATA 2A,0D
04C4:  DATA 00,00
04C6:  MOVFF  FF2,0E
04CA:  BCF    FF2.7
04CC:  CLRF   FF7
04CE:  ADDLW  E0
04D0:  MOVWF  FF6
04D2:  MOVLW  04
04D4:  ADDWFC FF7,F
04D6:  TBLRD*+
04D8:  MOVF   FF5,W
04DA:  BTFSC  0E.7
04DC:  BSF    FF2.7
04DE:  RETURN 0
04E0:  DATA 4D,6F
04E2:  DATA 6D,65
04E4:  DATA 6E,74
04E6:  DATA 6F,20
04E8:  DATA 64,65
04EA:  DATA 20,61
04EC:  DATA 70,61
04EE:  DATA 67,61
04F0:  DATA 64,6F
04F2:  DATA 20,20
04F4:  DATA 20,20
04F6:  DATA 20,54
04F8:  DATA 65,6D
04FA:  DATA 70,65
04FC:  DATA 72,61
04FE:  DATA 74,75
0500:  DATA 72,61
0502:  DATA 20,20
0504:  DATA 20,20
0506:  DATA 20,20
0508:  DATA 20,20
050A:  DATA 54,65
050C:  DATA 72,6D
050E:  DATA 6F,73
0510:  DATA 74,61
0512:  DATA 74,6F
0514:  DATA 20,20
0516:  DATA 20,20
0518:  DATA 20,20
051A:  DATA 20,20
051C:  DATA 4D,69
051E:  DATA 6E,75
0520:  DATA 74,6F
0522:  DATA 73,20
0524:  DATA 65,6E
0526:  DATA 63,65
0528:  DATA 6E,64
052A:  DATA 69,64
052C:  DATA 6F,20
052E:  DATA 20,20
0530:  DATA 20,20
0532:  DATA 20,20
0534:  DATA 4D,69
0536:  DATA 6E,75
0538:  DATA 74,6F
053A:  DATA 73,20
053C:  DATA 63,61
053E:  DATA 6C,64
0540:  DATA 65,72
0542:  DATA 61,0D
0544:  DATA 00,00
0546:  MOVFF  FF2,0E
054A:  BCF    FF2.7
054C:  CLRF   FF7
054E:  ADDLW  60
0550:  MOVWF  FF6
0552:  MOVLW  05
0554:  ADDWFC FF7,F
0556:  TBLRD*+
0558:  MOVF   FF5,W
055A:  BTFSC  0E.7
055C:  BSF    FF2.7
055E:  RETURN 0
0560:  DATA 3D,3D
0562:  DATA 3D,3D
0564:  DATA 3D,3D
0566:  DATA 3D,3D
0568:  DATA 3D,3D
056A:  DATA 3D,3D
056C:  DATA 3D,3D
056E:  DATA 3D,3D
0570:  DATA 3D,3D
0572:  DATA 3D,3D
0574:  DATA 3D,3D
0576:  DATA 3D,3D
0578:  DATA 3D,3D
057A:  DATA 3D,3D
057C:  DATA 3D,3D
057E:  DATA 3D,3D
0580:  DATA 3D,3D
0582:  DATA 3D,3D
0584:  DATA 3D,3D
0586:  DATA 3D,3D
0588:  DATA 3D,3D
058A:  DATA 3D,3D
058C:  DATA 3D,3D
058E:  DATA 3D,3D
0590:  DATA 3D,3D
0592:  DATA 3D,3D
0594:  DATA 3D,3D
0596:  DATA 3D,3D
0598:  DATA 3D,3D
059A:  DATA 3D,3D
059C:  DATA 3D,3D
059E:  DATA 3D,3D
05A0:  DATA 3D,3D
05A2:  DATA 3D,3D
05A4:  DATA 3D,3D
05A6:  DATA 3D,3D
05A8:  DATA 3D,3D
05AA:  DATA 3D,3D
05AC:  DATA 3D,3D
05AE:  DATA 3D,3D
05B0:  DATA 3D,3D
05B2:  DATA 3D,3D
05B4:  DATA 3D,3D
05B6:  DATA 3D,3D
05B8:  DATA 3D,3D
05BA:  DATA 3D,3D
05BC:  DATA 3D,3D
05BE:  DATA 3D,3D
05C0:  DATA 3D,3D
05C2:  DATA 3D,3D
05C4:  DATA 3D,3D
05C6:  DATA 0D,00
05C8:  MOVFF  FF2,0E
05CC:  BCF    FF2.7
05CE:  CLRF   FF7
05D0:  ADDLW  E2
05D2:  MOVWF  FF6
05D4:  MOVLW  05
05D6:  ADDWFC FF7,F
05D8:  TBLRD*+
05DA:  MOVF   FF5,W
05DC:  BTFSC  0E.7
05DE:  BSF    FF2.7
05E0:  RETURN 0
05E2:  DATA 20,00
05E4:  MOVFF  FF2,0E
05E8:  BCF    FF2.7
05EA:  CLRF   FF7
05EC:  ADDLW  FE
05EE:  MOVWF  FF6
05F0:  MOVLW  05
05F2:  ADDWFC FF7,F
05F4:  TBLRD*+
05F6:  MOVF   FF5,W
05F8:  BTFSC  0E.7
05FA:  BSF    FF2.7
05FC:  RETURN 0
05FE:  DATA BF,51
0600:  DATA 75,65
0602:  DATA 20,6F
0604:  DATA 70,65
0606:  DATA 72,61
0608:  DATA 63,69
060A:  DATA 6F,6E
060C:  DATA 20,64
060E:  DATA 65,73
0610:  DATA 65,61
0612:  DATA 20,72
0614:  DATA 65,61
0616:  DATA 6C,69
0618:  DATA 7A,61
061A:  DATA 72,3F
061C:  DATA 0D,00
061E:  MOVFF  FF2,0E
0622:  BCF    FF2.7
0624:  CLRF   FF7
0626:  ADDLW  38
0628:  MOVWF  FF6
062A:  MOVLW  06
062C:  ADDWFC FF7,F
062E:  TBLRD*+
0630:  MOVF   FF5,W
0632:  BTFSC  0E.7
0634:  BSF    FF2.7
0636:  RETURN 0
0638:  DATA 20,2D
063A:  DATA 2E,20
063C:  DATA 53,61
063E:  DATA 6C,69
0640:  DATA 72,0D
0642:  DATA 00,00
0644:  MOVFF  FF2,0E
0648:  BCF    FF2.7
064A:  CLRF   FF7
064C:  ADDLW  5E
064E:  MOVWF  FF6
0650:  MOVLW  06
0652:  ADDWFC FF7,F
0654:  TBLRD*+
0656:  MOVF   FF5,W
0658:  BTFSC  0E.7
065A:  BSF    FF2.7
065C:  RETURN 0
065E:  DATA 20,2B
0660:  DATA 2E,20
0662:  DATA 45,78
0664:  DATA 74,72
0666:  DATA 61,65
0668:  DATA 72,20
066A:  DATA 74,69
066C:  DATA 65,6D
066E:  DATA 70,6F
0670:  DATA 73,20
0672:  DATA 6D,65
0674:  DATA 64,69
0676:  DATA 6F,73
0678:  DATA 20,70
067A:  DATA 6F,72
067C:  DATA 20,64
067E:  DATA 69,61
0680:  DATA 0D,00
0682:  MOVFF  FF2,0E
0686:  BCF    FF2.7
0688:  CLRF   FF7
068A:  ADDLW  9C
068C:  MOVWF  FF6
068E:  MOVLW  06
0690:  ADDWFC FF7,F
0692:  TBLRD*+
0694:  MOVF   FF5,W
0696:  BTFSC  0E.7
0698:  BSF    FF2.7
069A:  RETURN 0
069C:  DATA 53,49
069E:  DATA 2E,20
06A0:  DATA 45,78
06A2:  DATA 74,72
06A4:  DATA 61,65
06A6:  DATA 72,20
06A8:  DATA 74,69
06AA:  DATA 65,6D
06AC:  DATA 70,6F
06AE:  DATA 73,20
06B0:  DATA 74,6F
06B2:  DATA 74,61
06B4:  DATA 6C,65
06B6:  DATA 73,0D
06B8:  DATA 00,00
06BA:  MOVFF  FF2,0E
06BE:  BCF    FF2.7
06C0:  CLRF   FF7
06C2:  ADDLW  D4
06C4:  MOVWF  FF6
06C6:  MOVLW  06
06C8:  ADDWFC FF7,F
06CA:  TBLRD*+
06CC:  MOVF   FF5,W
06CE:  BTFSC  0E.7
06D0:  BSF    FF2.7
06D2:  RETURN 0
06D4:  DATA 4E,4F
06D6:  DATA 2E,20
06D8:  DATA 45,78
06DA:  DATA 74,72
06DC:  DATA 61,65
06DE:  DATA 72,20
06E0:  DATA 64,61
06E2:  DATA 74,6F
06E4:  DATA 73,20
06E6:  DATA 6D,65
06E8:  DATA 6E,73
06EA:  DATA 75,61
06EC:  DATA 6C,65
06EE:  DATA 73,0D
06F0:  DATA 00,00
06F2:  MOVFF  FF2,0E
06F6:  BCF    FF2.7
06F8:  CLRF   FF7
06FA:  ADDLW  0C
06FC:  MOVWF  FF6
06FE:  MOVLW  07
0700:  ADDWFC FF7,F
0702:  TBLRD*+
0704:  MOVF   FF5,W
0706:  BTFSC  0E.7
0708:  BSF    FF2.7
070A:  RETURN 0
070C:  DATA 20,20
070E:  DATA 53,61
0710:  DATA 6C,69
0712:  DATA 65,6E
0714:  DATA 64,6F
0716:  DATA 2E,2E
0718:  DATA 2E,00
071A:  MOVFF  FF2,0E
071E:  BCF    FF2.7
0720:  CLRF   FF7
0722:  ADDLW  34
0724:  MOVWF  FF6
0726:  MOVLW  07
0728:  ADDWFC FF7,F
072A:  TBLRD*+
072C:  MOVF   FF5,W
072E:  BTFSC  0E.7
0730:  BSF    FF2.7
0732:  RETURN 0
0734:  DATA 0D,54
0736:  DATA 69,65
0738:  DATA 6D,70
073A:  DATA 6F,20
073C:  DATA 6D,65
073E:  DATA 64,69
0740:  DATA 6F,20
0742:  DATA 64,65
0744:  DATA 20,65
0746:  DATA 6E,63
0748:  DATA 65,6E
074A:  DATA 64,69
074C:  DATA 64,6F
074E:  DATA 20,64
0750:  DATA 65,6C
0752:  DATA 20,73
0754:  DATA 69,73
0756:  DATA 74,65
0758:  DATA 6D,61
075A:  DATA 20,70
075C:  DATA 6F,72
075E:  DATA 20,64
0760:  DATA 69,61
0762:  DATA 3A,20
0764:  DATA 25,33
0766:  DATA 2E,32
0768:  DATA 66,20
076A:  DATA 6D,69
076C:  DATA 6E,75
076E:  DATA 74,6F
0770:  DATA 73,0D
0772:  DATA 0D,00
0774:  MOVFF  FF2,0E
0778:  BCF    FF2.7
077A:  CLRF   FF7
077C:  ADDLW  8E
077E:  MOVWF  FF6
0780:  MOVLW  07
0782:  ADDWFC FF7,F
0784:  TBLRD*+
0786:  MOVF   FF5,W
0788:  BTFSC  0E.7
078A:  BSF    FF2.7
078C:  RETURN 0
078E:  DATA 54,69
0790:  DATA 65,6D
0792:  DATA 70,6F
0794:  DATA 20,6D
0796:  DATA 65,64
0798:  DATA 69,6F
079A:  DATA 20,64
079C:  DATA 65,20
079E:  DATA 65,6E
07A0:  DATA 63,65
07A2:  DATA 6E,64
07A4:  DATA 69,64
07A6:  DATA 6F,20
07A8:  DATA 64,65
07AA:  DATA 20,6C
07AC:  DATA 61,20
07AE:  DATA 63,61
07B0:  DATA 6C,64
07B2:  DATA 65,72
07B4:  DATA 61,20
07B6:  DATA 70,6F
07B8:  DATA 72,20
07BA:  DATA 64,69
07BC:  DATA 61,3A
07BE:  DATA 20,25
07C0:  DATA 33,2E
07C2:  DATA 32,66
07C4:  DATA 20,6D
07C6:  DATA 69,6E
07C8:  DATA 75,74
07CA:  DATA 6F,73
07CC:  DATA 0D,0D
07CE:  DATA 00,00
07D0:  MOVFF  FF2,0E
07D4:  BCF    FF2.7
07D6:  CLRF   FF7
07D8:  ADDLW  EA
07DA:  MOVWF  FF6
07DC:  MOVLW  07
07DE:  ADDWFC FF7,F
07E0:  TBLRD*+
07E2:  MOVF   FF5,W
07E4:  BTFSC  0E.7
07E6:  BSF    FF2.7
07E8:  RETURN 0
07EA:  DATA 0D,54
07EC:  DATA 69,65
07EE:  DATA 6D,70
07F0:  DATA 6F,20
07F2:  DATA 74,6F
07F4:  DATA 74,61
07F6:  DATA 6C,20
07F8:  DATA 64,65
07FA:  DATA 20,65
07FC:  DATA 6E,63
07FE:  DATA 65,6E
0800:  DATA 64,69
0802:  DATA 64,6F
0804:  DATA 20,64
0806:  DATA 65,6C
0808:  DATA 20,73
080A:  DATA 69,73
080C:  DATA 74,65
080E:  DATA 6D,61
0810:  DATA 3A,20
0812:  DATA 25,6C
0814:  DATA 75,20
0816:  DATA 6D,69
0818:  DATA 6E,75
081A:  DATA 74,6F
081C:  DATA 73,0D
081E:  DATA 0D,00
0820:  MOVFF  FF2,0E
0824:  BCF    FF2.7
0826:  CLRF   FF7
0828:  ADDLW  3A
082A:  MOVWF  FF6
082C:  MOVLW  08
082E:  ADDWFC FF7,F
0830:  TBLRD*+
0832:  MOVF   FF5,W
0834:  BTFSC  0E.7
0836:  BSF    FF2.7
0838:  RETURN 0
083A:  DATA 54,69
083C:  DATA 65,6D
083E:  DATA 70,6F
0840:  DATA 20,74
0842:  DATA 6F,74
0844:  DATA 61,6C
0846:  DATA 20,64
0848:  DATA 65,20
084A:  DATA 65,6E
084C:  DATA 63,65
084E:  DATA 6E,64
0850:  DATA 69,64
0852:  DATA 6F,20
0854:  DATA 64,65
0856:  DATA 20,6C
0858:  DATA 61,20
085A:  DATA 63,61
085C:  DATA 6C,64
085E:  DATA 65,72
0860:  DATA 61,3A
0862:  DATA 20,25
0864:  DATA 6C,75
0866:  DATA 20,6D
0868:  DATA 69,6E
086A:  DATA 75,74
086C:  DATA 6F,73
086E:  DATA 0D,0D
0870:  DATA 00,00
0872:  MOVFF  FF2,0E
0876:  BCF    FF2.7
0878:  CLRF   FF7
087A:  ADDLW  8C
087C:  MOVWF  FF6
087E:  MOVLW  08
0880:  ADDWFC FF7,F
0882:  TBLRD*+
0884:  MOVF   FF5,W
0886:  BTFSC  0E.7
0888:  BSF    FF2.7
088A:  RETURN 0
088C:  DATA 0D,32
088E:  DATA 30,00
0890:  MOVFF  FF2,0E
0894:  BCF    FF2.7
0896:  CLRF   FF7
0898:  ADDLW  AA
089A:  MOVWF  FF6
089C:  MOVLW  08
089E:  ADDWFC FF7,F
08A0:  TBLRD*+
08A2:  MOVF   FF5,W
08A4:  BTFSC  0E.7
08A6:  BSF    FF2.7
08A8:  RETURN 0
08AA:  DATA 2D,2D
08AC:  DATA 2D,2D
08AE:  DATA 2D,2D
08B0:  DATA 2D,2D
08B2:  DATA 2D,2D
08B4:  DATA 2D,2D
08B6:  DATA 2D,2D
08B8:  DATA 2D,2D
08BA:  DATA 2D,2D
08BC:  DATA 2D,2D
08BE:  DATA 2D,2D
08C0:  DATA 2D,2D
08C2:  DATA 2D,2D
08C4:  DATA 2D,2D
08C6:  DATA 2D,2D
08C8:  DATA 2D,2D
08CA:  DATA 2D,2D
08CC:  DATA 2D,2D
08CE:  DATA 2D,2D
08D0:  DATA 2D,2D
08D2:  DATA 2D,2D
08D4:  DATA 2D,2D
08D6:  DATA 2D,2D
08D8:  DATA 2D,2D
08DA:  DATA 2D,2D
08DC:  DATA 2D,2D
08DE:  DATA 2D,2D
08E0:  DATA 2D,2D
08E2:  DATA 2D,2D
08E4:  DATA 2D,2D
08E6:  DATA 2D,2D
08E8:  DATA 2D,2D
08EA:  DATA 2D,2D
08EC:  DATA 2D,2D
08EE:  DATA 2D,2D
08F0:  DATA 2D,2D
08F2:  DATA 2D,2D
08F4:  DATA 2D,2D
08F6:  DATA 2D,2D
08F8:  DATA 2D,2D
08FA:  DATA 2D,2D
08FC:  DATA 2D,2D
08FE:  DATA 2D,2D
0900:  DATA 2D,2D
0902:  DATA 2D,2D
0904:  DATA 2D,2D
0906:  DATA 2D,2D
0908:  DATA 2D,2D
090A:  DATA 2D,2D
090C:  DATA 2D,2D
090E:  DATA 2D,2D
0910:  DATA 2D,2D
0912:  DATA 2D,2D
0914:  DATA 2D,2D
0916:  DATA 2D,2D
0918:  DATA 2D,2D
091A:  DATA 2D,2D
091C:  DATA 2D,2D
091E:  DATA 0D,00
0920:  MOVFF  FF2,0E
0924:  BCF    FF2.7
0926:  CLRF   FF7
0928:  ADDLW  3A
092A:  MOVWF  FF6
092C:  MOVLW  09
092E:  ADDWFC FF7,F
0930:  TBLRD*+
0932:  MOVF   FF5,W
0934:  BTFSC  0E.7
0936:  BSF    FF2.7
0938:  RETURN 0
093A:  DATA 20,20
093C:  DATA 20,20
093E:  DATA 20,20
0940:  DATA 20,20
0942:  DATA 20,20
0944:  DATA 20,20
0946:  DATA 20,20
0948:  DATA 54,69
094A:  DATA 65,6D
094C:  DATA 70,6F
094E:  DATA 20,6D
0950:  DATA 65,64
0952:  DATA 69,6F
0954:  DATA 20,64
0956:  DATA 65,20
0958:  DATA 65,6E
095A:  DATA 63,65
095C:  DATA 6E,64
095E:  DATA 69,64
0960:  DATA 6F,20
0962:  DATA 64,65
0964:  DATA 6C,20
0966:  DATA 73,69
0968:  DATA 73,74
096A:  DATA 65,6D
096C:  DATA 61,20
096E:  DATA 28,6D
0970:  DATA 69,6E
0972:  DATA 2F,64
0974:  DATA 69,61
0976:  DATA 29,20
0978:  DATA 20,20
097A:  DATA 20,20
097C:  DATA 20,54
097E:  DATA 69,65
0980:  DATA 6D,70
0982:  DATA 6F,20
0984:  DATA 6D,65
0986:  DATA 64,69
0988:  DATA 6F,20
098A:  DATA 64,65
098C:  DATA 20,65
098E:  DATA 6E,63
0990:  DATA 65,6E
0992:  DATA 64,69
0994:  DATA 64,6F
0996:  DATA 20,64
0998:  DATA 65,20
099A:  DATA 6C,61
099C:  DATA 20,63
099E:  DATA 61,6C
09A0:  DATA 64,65
09A2:  DATA 72,61
09A4:  DATA 20,28
09A6:  DATA 6D,69
09A8:  DATA 6E,2F
09AA:  DATA 64,69
09AC:  DATA 61,29
09AE:  DATA 0D,00
09B0:  MOVFF  FF2,0E
09B4:  BCF    FF2.7
09B6:  CLRF   FF7
09B8:  ADDLW  CA
09BA:  MOVWF  FF6
09BC:  MOVLW  09
09BE:  ADDWFC FF7,F
09C0:  TBLRD*+
09C2:  MOVF   FF5,W
09C4:  BTFSC  0E.7
09C6:  BSF    FF2.7
09C8:  RETURN 0
09CA:  DATA 45,4E
09CC:  DATA 45,52
09CE:  DATA 4F,25
09D0:  DATA 66,25
09D2:  DATA 66,0D
09D4:  DATA 00,00
09D6:  MOVFF  FF2,0E
09DA:  BCF    FF2.7
09DC:  CLRF   FF7
09DE:  ADDLW  F0
09E0:  MOVWF  FF6
09E2:  MOVLW  09
09E4:  ADDWFC FF7,F
09E6:  TBLRD*+
09E8:  MOVF   FF5,W
09EA:  BTFSC  0E.7
09EC:  BSF    FF2.7
09EE:  RETURN 0
09F0:  DATA 46,45
09F2:  DATA 42,52
09F4:  DATA 45,52
09F6:  DATA 4F,25
09F8:  DATA 66,25
09FA:  DATA 66,0D
09FC:  DATA 00,00
09FE:  MOVFF  FF2,0E
0A02:  BCF    FF2.7
0A04:  CLRF   FF7
0A06:  ADDLW  18
0A08:  MOVWF  FF6
0A0A:  MOVLW  0A
0A0C:  ADDWFC FF7,F
0A0E:  TBLRD*+
0A10:  MOVF   FF5,W
0A12:  BTFSC  0E.7
0A14:  BSF    FF2.7
0A16:  RETURN 0
0A18:  DATA 4D,41
0A1A:  DATA 52,5A
0A1C:  DATA 4F,25
0A1E:  DATA 66,25
0A20:  DATA 66,0D
0A22:  DATA 00,00
0A24:  MOVFF  FF2,0E
0A28:  BCF    FF2.7
0A2A:  CLRF   FF7
0A2C:  ADDLW  3E
0A2E:  MOVWF  FF6
0A30:  MOVLW  0A
0A32:  ADDWFC FF7,F
0A34:  TBLRD*+
0A36:  MOVF   FF5,W
0A38:  BTFSC  0E.7
0A3A:  BSF    FF2.7
0A3C:  RETURN 0
0A3E:  DATA 41,42
0A40:  DATA 52,49
0A42:  DATA 4C,25
0A44:  DATA 66,25
0A46:  DATA 66,0D
0A48:  DATA 00,00
0A4A:  MOVFF  FF2,0E
0A4E:  BCF    FF2.7
0A50:  CLRF   FF7
0A52:  ADDLW  64
0A54:  MOVWF  FF6
0A56:  MOVLW  0A
0A58:  ADDWFC FF7,F
0A5A:  TBLRD*+
0A5C:  MOVF   FF5,W
0A5E:  BTFSC  0E.7
0A60:  BSF    FF2.7
0A62:  RETURN 0
0A64:  DATA 4D,41
0A66:  DATA 59,4F
0A68:  DATA 25,66
0A6A:  DATA 25,66
0A6C:  DATA 0D,00
0A6E:  MOVFF  FF2,0E
0A72:  BCF    FF2.7
0A74:  CLRF   FF7
0A76:  ADDLW  88
0A78:  MOVWF  FF6
0A7A:  MOVLW  0A
0A7C:  ADDWFC FF7,F
0A7E:  TBLRD*+
0A80:  MOVF   FF5,W
0A82:  BTFSC  0E.7
0A84:  BSF    FF2.7
0A86:  RETURN 0
0A88:  DATA 4A,55
0A8A:  DATA 4E,49
0A8C:  DATA 4F,25
0A8E:  DATA 66,25
0A90:  DATA 66,0D
0A92:  DATA 00,00
0A94:  MOVFF  FF2,0E
0A98:  BCF    FF2.7
0A9A:  CLRF   FF7
0A9C:  ADDLW  AE
0A9E:  MOVWF  FF6
0AA0:  MOVLW  0A
0AA2:  ADDWFC FF7,F
0AA4:  TBLRD*+
0AA6:  MOVF   FF5,W
0AA8:  BTFSC  0E.7
0AAA:  BSF    FF2.7
0AAC:  RETURN 0
0AAE:  DATA 4A,55
0AB0:  DATA 4C,49
0AB2:  DATA 4F,25
0AB4:  DATA 66,25
0AB6:  DATA 66,0D
0AB8:  DATA 00,00
0ABA:  MOVFF  FF2,0E
0ABE:  BCF    FF2.7
0AC0:  CLRF   FF7
0AC2:  ADDLW  D4
0AC4:  MOVWF  FF6
0AC6:  MOVLW  0A
0AC8:  ADDWFC FF7,F
0ACA:  TBLRD*+
0ACC:  MOVF   FF5,W
0ACE:  BTFSC  0E.7
0AD0:  BSF    FF2.7
0AD2:  RETURN 0
0AD4:  DATA 41,47
0AD6:  DATA 4F,53
0AD8:  DATA 54,4F
0ADA:  DATA 25,66
0ADC:  DATA 25,66
0ADE:  DATA 0D,00
0AE0:  MOVFF  FF2,0E
0AE4:  BCF    FF2.7
0AE6:  CLRF   FF7
0AE8:  ADDLW  FA
0AEA:  MOVWF  FF6
0AEC:  MOVLW  0A
0AEE:  ADDWFC FF7,F
0AF0:  TBLRD*+
0AF2:  MOVF   FF5,W
0AF4:  BTFSC  0E.7
0AF6:  BSF    FF2.7
0AF8:  RETURN 0
0AFA:  DATA 53,45
0AFC:  DATA 50,54
0AFE:  DATA 49,45
0B00:  DATA 4D,42
0B02:  DATA 52,45
0B04:  DATA 25,66
0B06:  DATA 25,66
0B08:  DATA 0D,00
0B0A:  MOVFF  FF2,0E
0B0E:  BCF    FF2.7
0B10:  CLRF   FF7
0B12:  ADDLW  24
0B14:  MOVWF  FF6
0B16:  MOVLW  0B
0B18:  ADDWFC FF7,F
0B1A:  TBLRD*+
0B1C:  MOVF   FF5,W
0B1E:  BTFSC  0E.7
0B20:  BSF    FF2.7
0B22:  RETURN 0
0B24:  DATA 4F,43
0B26:  DATA 54,55
0B28:  DATA 42,52
0B2A:  DATA 45,25
0B2C:  DATA 66,25
0B2E:  DATA 66,0D
0B30:  DATA 00,00
0B32:  MOVFF  FF2,0E
0B36:  BCF    FF2.7
0B38:  CLRF   FF7
0B3A:  ADDLW  4C
0B3C:  MOVWF  FF6
0B3E:  MOVLW  0B
0B40:  ADDWFC FF7,F
0B42:  TBLRD*+
0B44:  MOVF   FF5,W
0B46:  BTFSC  0E.7
0B48:  BSF    FF2.7
0B4A:  RETURN 0
0B4C:  DATA 4E,4F
0B4E:  DATA 56,49
0B50:  DATA 45,4D
0B52:  DATA 42,52
0B54:  DATA 45,25
0B56:  DATA 66,25
0B58:  DATA 66,0D
0B5A:  DATA 00,00
0B5C:  MOVFF  FF2,0E
0B60:  BCF    FF2.7
0B62:  CLRF   FF7
0B64:  ADDLW  76
0B66:  MOVWF  FF6
0B68:  MOVLW  0B
0B6A:  ADDWFC FF7,F
0B6C:  TBLRD*+
0B6E:  MOVF   FF5,W
0B70:  BTFSC  0E.7
0B72:  BSF    FF2.7
0B74:  RETURN 0
0B76:  DATA 44,49
0B78:  DATA 43,49
0B7A:  DATA 45,4D
0B7C:  DATA 42,52
0B7E:  DATA 45,25
0B80:  DATA 66,25
0B82:  DATA 66,0D
0B84:  DATA 00,00
0B86:  MOVFF  FF2,0E
0B8A:  BCF    FF2.7
0B8C:  CLRF   FF7
0B8E:  ADDLW  A0
0B90:  MOVWF  FF6
0B92:  MOVLW  0B
0B94:  ADDWFC FF7,F
0B96:  TBLRD*+
0B98:  MOVF   FF5,W
0B9A:  BTFSC  0E.7
0B9C:  BSF    FF2.7
0B9E:  RETURN 0
0BA0:  DATA 20,46
0BA2:  DATA 45,43
0BA4:  DATA 48,41
0BA6:  DATA 3A,0A
0BA8:  DATA 20,4C
0BAA:  DATA 55,4E
0BAC:  DATA 20,30
0BAE:  DATA 31,2F
0BB0:  DATA 30,31
0BB2:  DATA 2F,32
0BB4:  DATA 30,30
0BB6:  DATA 39,00
0BB8:  MOVFF  FF2,0E
0BBC:  BCF    FF2.7
0BBE:  CLRF   FF7
0BC0:  ADDLW  D2
0BC2:  MOVWF  FF6
0BC4:  MOVLW  0B
0BC6:  ADDWFC FF7,F
0BC8:  TBLRD*+
0BCA:  MOVF   FF5,W
0BCC:  BTFSC  0E.7
0BCE:  BSF    FF2.7
0BD0:  RETURN 0
0BD2:  DATA 4C,55
0BD4:  DATA 4E,00
0BD6:  MOVFF  FF2,0E
0BDA:  BCF    FF2.7
0BDC:  CLRF   FF7
0BDE:  ADDLW  F0
0BE0:  MOVWF  FF6
0BE2:  MOVLW  0B
0BE4:  ADDWFC FF7,F
0BE6:  TBLRD*+
0BE8:  MOVF   FF5,W
0BEA:  BTFSC  0E.7
0BEC:  BSF    FF2.7
0BEE:  RETURN 0
0BF0:  DATA 4D,41
0BF2:  DATA 52,00
0BF4:  MOVFF  FF2,0E
0BF8:  BCF    FF2.7
0BFA:  CLRF   FF7
0BFC:  ADDLW  0E
0BFE:  MOVWF  FF6
0C00:  MOVLW  0C
0C02:  ADDWFC FF7,F
0C04:  TBLRD*+
0C06:  MOVF   FF5,W
0C08:  BTFSC  0E.7
0C0A:  BSF    FF2.7
0C0C:  RETURN 0
0C0E:  DATA 4D,49
0C10:  DATA 45,00
0C12:  MOVFF  FF2,0E
0C16:  BCF    FF2.7
0C18:  CLRF   FF7
0C1A:  ADDLW  2C
0C1C:  MOVWF  FF6
0C1E:  MOVLW  0C
0C20:  ADDWFC FF7,F
0C22:  TBLRD*+
0C24:  MOVF   FF5,W
0C26:  BTFSC  0E.7
0C28:  BSF    FF2.7
0C2A:  RETURN 0
0C2C:  DATA 4A,55
0C2E:  DATA 45,00
0C30:  MOVFF  FF2,0E
0C34:  BCF    FF2.7
0C36:  CLRF   FF7
0C38:  ADDLW  4A
0C3A:  MOVWF  FF6
0C3C:  MOVLW  0C
0C3E:  ADDWFC FF7,F
0C40:  TBLRD*+
0C42:  MOVF   FF5,W
0C44:  BTFSC  0E.7
0C46:  BSF    FF2.7
0C48:  RETURN 0
0C4A:  DATA 56,49
0C4C:  DATA 45,00
0C4E:  MOVFF  FF2,0E
0C52:  BCF    FF2.7
0C54:  CLRF   FF7
0C56:  ADDLW  68
0C58:  MOVWF  FF6
0C5A:  MOVLW  0C
0C5C:  ADDWFC FF7,F
0C5E:  TBLRD*+
0C60:  MOVF   FF5,W
0C62:  BTFSC  0E.7
0C64:  BSF    FF2.7
0C66:  RETURN 0
0C68:  DATA 53,41
0C6A:  DATA 42,00
0C6C:  MOVFF  FF2,0E
0C70:  BCF    FF2.7
0C72:  CLRF   FF7
0C74:  ADDLW  86
0C76:  MOVWF  FF6
0C78:  MOVLW  0C
0C7A:  ADDWFC FF7,F
0C7C:  TBLRD*+
0C7E:  MOVF   FF5,W
0C80:  BTFSC  0E.7
0C82:  BSF    FF2.7
0C84:  RETURN 0
0C86:  DATA 44,4F
0C88:  DATA 4D,00
0C8A:  MOVFF  FF2,0E
0C8E:  BCF    FF2.7
0C90:  CLRF   FF7
0C92:  ADDLW  A4
0C94:  MOVWF  FF6
0C96:  MOVLW  0C
0C98:  ADDWFC FF7,F
0C9A:  TBLRD*+
0C9C:  MOVF   FF5,W
0C9E:  BTFSC  0E.7
0CA0:  BSF    FF2.7
0CA2:  RETURN 0
0CA4:  DATA 20,45
0CA6:  DATA 72,72
0CA8:  DATA 6F,72
0CAA:  DATA 20,65
0CAC:  DATA 6E,0A
0CAE:  DATA 20,6C
0CB0:  DATA 61,20
0CB2:  DATA 66,65
0CB4:  DATA 63,68
0CB6:  DATA 61,00
0CB8:  MOVFF  FF2,0E
0CBC:  BCF    FF2.7
0CBE:  CLRF   FF7
0CC0:  ADDLW  D2
0CC2:  MOVWF  FF6
0CC4:  MOVLW  0C
0CC6:  ADDWFC FF7,F
0CC8:  TBLRD*+
0CCA:  MOVF   FF5,W
0CCC:  BTFSC  0E.7
0CCE:  BSF    FF2.7
0CD0:  RETURN 0
0CD2:  DATA 20,45
0CD4:  DATA 6C,20
0CD6:  DATA 61,6E
0CD8:  DATA 6E,6F
0CDA:  DATA 20,6E
0CDC:  DATA 6F,0A
0CDE:  DATA 20,65
0CE0:  DATA 73,20
0CE2:  DATA 62,69
0CE4:  DATA 73,69
0CE6:  DATA 65,73
0CE8:  DATA 74,6F
0CEA:  DATA 00,00
0CEC:  MOVFF  FF2,0E
0CF0:  BCF    FF2.7
0CF2:  CLRF   FF7
0CF4:  ADDLW  06
0CF6:  MOVWF  FF6
0CF8:  MOVLW  0D
0CFA:  ADDWFC FF7,F
0CFC:  TBLRD*+
0CFE:  MOVF   FF5,W
0D00:  BTFSC  0E.7
0D02:  BSF    FF2.7
0D04:  RETURN 0
0D06:  DATA 20,20
0D08:  DATA 20,20
0D0A:  DATA 20,48
0D0C:  DATA 4F,52
0D0E:  DATA 41,0A
0D10:  DATA 20,20
0D12:  DATA 20,20
0D14:  DATA 20,30
0D16:  DATA 30,3A
0D18:  DATA 30,30
0D1A:  DATA 00,00
*
0ED8:  MOVLB  2
0EDA:  MOVF   x83,W
0EDC:  CLRF   01
0EDE:  SUBWF  x82,W
0EE0:  BC    0EE8
0EE2:  MOVFF  282,00
0EE6:  BRA    0F00
0EE8:  CLRF   00
0EEA:  MOVLW  08
0EEC:  MOVWF  x84
0EEE:  RLCF   x82,F
0EF0:  RLCF   00,F
0EF2:  MOVF   x83,W
0EF4:  SUBWF  00,W
0EF6:  BTFSC  FD8.0
0EF8:  MOVWF  00
0EFA:  RLCF   01,F
0EFC:  DECFSZ x84,F
0EFE:  BRA    0EEE
0F00:  MOVLB  0
0F02:  RETLW  00
0F04:  MOVLW  20
0F06:  BTFSS  7D.4
0F08:  MOVLW  30
0F0A:  MOVWF  7E
0F0C:  MOVFF  7C,00
0F10:  BTFSS  7C.7
0F12:  BRA    0F22
0F14:  COMF   00,F
0F16:  INCF   00,F
0F18:  MOVFF  00,7C
0F1C:  MOVLW  2D
0F1E:  MOVWF  7E
0F20:  BSF    7D.7
0F22:  MOVF   01,W
0F24:  MOVFF  7C,282
0F28:  MOVLW  64
0F2A:  MOVLB  2
0F2C:  MOVWF  x83
0F2E:  MOVLB  0
0F30:  RCALL  0ED8
0F32:  MOVFF  00,7C
0F36:  MOVLW  30
0F38:  ADDWF  01,W
0F3A:  MOVWF  7F
0F3C:  MOVFF  7C,282
0F40:  MOVLW  0A
0F42:  MOVLB  2
0F44:  MOVWF  x83
0F46:  MOVLB  0
0F48:  RCALL  0ED8
0F4A:  MOVLW  30
0F4C:  ADDWF  00,W
0F4E:  MOVWF  x81
0F50:  MOVLW  30
0F52:  ADDWF  01,W
0F54:  MOVWF  x80
0F56:  MOVFF  7E,00
0F5A:  BTFSS  7D.3
0F5C:  BRA    0F62
0F5E:  BTFSS  7D.7
0F60:  BCF    7D.2
0F62:  BTFSC  7D.4
0F64:  BRA    0F7C
0F66:  BTFSS  7D.7
0F68:  BRA    0FAE
0F6A:  BTFSC  7D.2
0F6C:  BRA    0FAE
0F6E:  MOVFF  00,7F
0F72:  BTFSC  7D.1
0F74:  BRA    0FAE
0F76:  MOVFF  00,80
0F7A:  BRA    0FAE
0F7C:  MOVLW  30
0F7E:  SUBWF  7F,W
0F80:  BNZ   0FAE
0F82:  MOVFF  00,7F
0F86:  MOVLW  20
0F88:  MOVWF  7E
0F8A:  BTFSS  7D.3
0F8C:  BRA    0F96
0F8E:  BCF    7D.2
0F90:  BSF    7D.1
0F92:  BTFSS  7D.7
0F94:  BCF    7D.1
0F96:  MOVLW  30
0F98:  SUBWF  x80,W
0F9A:  BNZ   0FAE
0F9C:  MOVFF  00,80
0FA0:  MOVLW  20
0FA2:  MOVWF  7F
0FA4:  BTFSS  7D.3
0FA6:  BRA    0F96
0FA8:  BCF    7D.1
0FAA:  BTFSS  7D.7
0FAC:  BCF    7D.0
0FAE:  BTFSS  7D.2
0FB0:  BRA    0FB8
0FB2:  MOVFF  7E,280
0FB6:  RCALL  0E7C
0FB8:  BTFSS  7D.1
0FBA:  BRA    0FC2
0FBC:  MOVFF  7F,280
0FC0:  RCALL  0E7C
0FC2:  BTFSS  7D.0
0FC4:  BRA    0FCC
0FC6:  MOVFF  80,280
0FCA:  RCALL  0E7C
0FCC:  MOVFF  81,280
0FD0:  RCALL  0E7C
0FD2:  RETLW  00
*
142C:  MOVLW  8E
142E:  MOVWF  00
1430:  MOVF   x83,W
1432:  SUBWF  00,F
1434:  MOVFF  84,02
1438:  MOVFF  85,01
143C:  BSF    02.7
143E:  MOVF   00,F
1440:  BZ    1454
1442:  BCF    FD8.0
1444:  MOVF   02,F
1446:  BNZ   144C
1448:  MOVF   01,F
144A:  BZ    1454
144C:  RRCF   02,F
144E:  RRCF   01,F
1450:  DECFSZ 00,F
1452:  BRA    1442
1454:  BTFSS  x84.7
1456:  BRA    1462
1458:  COMF   01,F
145A:  COMF   02,F
145C:  INCF   01,F
145E:  BTFSC  FD8.2
1460:  INCF   02,F
1462:  NOP   
1464:  RETLW  00
*
14D6:  MOVLB  2
14D8:  MOVF   x9B,W
14DA:  BTFSC  FD8.2
14DC:  BRA    15C0
14DE:  MOVWF  00
14E0:  MOVF   x9F,W
14E2:  BTFSC  FD8.2
14E4:  BRA    15C0
14E6:  ADDWF  00,F
14E8:  BNC   14F2
14EA:  MOVLW  81
14EC:  ADDWF  00,F
14EE:  BC    15C0
14F0:  BRA    14FA
14F2:  MOVLW  7F
14F4:  SUBWF  00,F
14F6:  BNC   15C0
14F8:  BZ    15C0
14FA:  MOVFF  29C,2A3
14FE:  MOVF   xA0,W
1500:  XORWF  xA3,F
1502:  BSF    x9C.7
1504:  BSF    xA0.7
1506:  MOVF   x9E,W
1508:  MULWF  xA2
150A:  MOVFF  FF4,2A5
150E:  MOVF   x9D,W
1510:  MULWF  xA1
1512:  MOVFF  FF4,03
1516:  MOVFF  FF3,2A4
151A:  MULWF  xA2
151C:  MOVF   FF3,W
151E:  ADDWF  xA5,F
1520:  MOVF   FF4,W
1522:  ADDWFC xA4,F
1524:  MOVLW  00
1526:  ADDWFC 03,F
1528:  MOVF   x9E,W
152A:  MULWF  xA1
152C:  MOVF   FF3,W
152E:  ADDWF  xA5,F
1530:  MOVF   FF4,W
1532:  ADDWFC xA4,F
1534:  MOVLW  00
1536:  CLRF   02
1538:  ADDWFC 03,F
153A:  ADDWFC 02,F
153C:  MOVF   x9C,W
153E:  MULWF  xA2
1540:  MOVF   FF3,W
1542:  ADDWF  xA4,F
1544:  MOVF   FF4,W
1546:  ADDWFC 03,F
1548:  MOVLW  00
154A:  ADDWFC 02,F
154C:  MOVF   x9C,W
154E:  MULWF  xA1
1550:  MOVF   FF3,W
1552:  ADDWF  03,F
1554:  MOVF   FF4,W
1556:  ADDWFC 02,F
1558:  MOVLW  00
155A:  CLRF   01
155C:  ADDWFC 01,F
155E:  MOVF   x9E,W
1560:  MULWF  xA0
1562:  MOVF   FF3,W
1564:  ADDWF  xA4,F
1566:  MOVF   FF4,W
1568:  ADDWFC 03,F
156A:  MOVLW  00
156C:  ADDWFC 02,F
156E:  ADDWFC 01,F
1570:  MOVF   x9D,W
1572:  MULWF  xA0
1574:  MOVF   FF3,W
1576:  ADDWF  03,F
1578:  MOVF   FF4,W
157A:  ADDWFC 02,F
157C:  MOVLW  00
157E:  ADDWFC 01,F
1580:  MOVF   x9C,W
1582:  MULWF  xA0
1584:  MOVF   FF3,W
1586:  ADDWF  02,F
1588:  MOVF   FF4,W
158A:  ADDWFC 01,F
158C:  INCF   00,F
158E:  BTFSC  01.7
1590:  BRA    159C
1592:  RLCF   xA4,F
1594:  RLCF   03,F
1596:  RLCF   02,F
1598:  RLCF   01,F
159A:  DECF   00,F
159C:  MOVLW  00
159E:  BTFSS  xA4.7
15A0:  BRA    15B6
15A2:  INCF   03,F
15A4:  ADDWFC 02,F
15A6:  ADDWFC 01,F
15A8:  MOVF   01,W
15AA:  BNZ   15B6
15AC:  MOVF   02,W
15AE:  BNZ   15B6
15B0:  MOVF   03,W
15B2:  BNZ   15B6
15B4:  INCF   00,F
15B6:  BTFSC  xA3.7
15B8:  BSF    01.7
15BA:  BTFSS  xA3.7
15BC:  BCF    01.7
15BE:  BRA    15C8
15C0:  CLRF   00
15C2:  CLRF   01
15C4:  CLRF   02
15C6:  CLRF   03
15C8:  NOP   
15CA:  MOVLB  0
15CC:  RETLW  00
*
1B12:  MOVFF  FF2,0E
1B16:  BCF    FF2.7
1B18:  ADDWF  FE8,W
1B1A:  ADDLW  37
1B1C:  MOVWF  FF6
1B1E:  MOVLW  1B
1B20:  MOVWF  FF7
1B22:  BTFSC  FD8.0
1B24:  INCF   FF7,F
1B26:  TBLRD*-
1B28:  MOVF   FF5,W
1B2A:  MOVWF  FFA
1B2C:  TBLRD*
1B2E:  MOVF   FF5,W
1B30:  BTFSC  0E.7
1B32:  BSF    FF2.7
1B34:  MOVWF  FF9
1B36:  DATA 2A,17
1B38:  DATA 46,17
1B3A:  DATA 62,17
1B3C:  DATA 7E,17
1B3E:  DATA 9A,17
1B40:  DATA B6,17
1B42:  DATA D2,17
*
1B8C:  MOVLW  8E
1B8E:  MOVWF  00
1B90:  MOVFF  7F,01
1B94:  MOVFF  7E,02
1B98:  CLRF   03
1B9A:  BTFSS  7F.7
1B9C:  BRA    1BA8
1B9E:  COMF   01,F
1BA0:  COMF   02,F
1BA2:  INCF   02,F
1BA4:  BNZ   1BA8
1BA6:  INCF   01,F
1BA8:  MOVF   01,F
1BAA:  BNZ   1BBE
1BAC:  MOVFF  02,01
1BB0:  CLRF   02
1BB2:  MOVLW  08
1BB4:  SUBWF  00,F
1BB6:  MOVF   01,F
1BB8:  BNZ   1BBE
1BBA:  CLRF   00
1BBC:  BRA    1BD2
1BBE:  BCF    FD8.0
1BC0:  BTFSC  01.7
1BC2:  BRA    1BCC
1BC4:  RLCF   02,F
1BC6:  RLCF   01,F
1BC8:  DECF   00,F
1BCA:  BRA    1BBE
1BCC:  BTFSC  7F.7
1BCE:  BRA    1BD2
1BD0:  BCF    01.7
1BD2:  NOP   
1BD4:  GOTO   1D8C (RETURN)
1BD8:  MOVLB  2
1BDA:  MOVF   x85,W
1BDC:  BTFSC  FD8.2
1BDE:  BRA    1D2A
1BE0:  MOVWF  x91
1BE2:  MOVF   x89,W
1BE4:  BTFSC  FD8.2
1BE6:  BRA    1D2A
1BE8:  SUBWF  x91,F
1BEA:  BNC   1BF6
1BEC:  MOVLW  7F
1BEE:  ADDWF  x91,F
1BF0:  BTFSC  FD8.0
1BF2:  BRA    1D2A
1BF4:  BRA    1C02
1BF6:  MOVLW  81
1BF8:  SUBWF  x91,F
1BFA:  BTFSS  FD8.0
1BFC:  BRA    1D2A
1BFE:  BTFSC  FD8.2
1C00:  BRA    1D2A
1C02:  MOVFF  291,00
1C06:  CLRF   01
1C08:  CLRF   02
1C0A:  CLRF   03
1C0C:  CLRF   x90
1C0E:  MOVFF  286,28F
1C12:  BSF    x8F.7
1C14:  MOVFF  287,28E
1C18:  MOVFF  288,28D
1C1C:  MOVLW  19
1C1E:  MOVWF  x91
1C20:  MOVF   x8C,W
1C22:  SUBWF  x8D,F
1C24:  BC    1C40
1C26:  MOVLW  01
1C28:  SUBWF  x8E,F
1C2A:  BC    1C40
1C2C:  SUBWF  x8F,F
1C2E:  BC    1C40
1C30:  SUBWF  x90,F
1C32:  BC    1C40
1C34:  INCF   x90,F
1C36:  INCF   x8F,F
1C38:  INCF   x8E,F
1C3A:  MOVF   x8C,W
1C3C:  ADDWF  x8D,F
1C3E:  BRA    1C90
1C40:  MOVF   x8B,W
1C42:  SUBWF  x8E,F
1C44:  BC    1C6A
1C46:  MOVLW  01
1C48:  SUBWF  x8F,F
1C4A:  BC    1C6A
1C4C:  SUBWF  x90,F
1C4E:  BC    1C6A
1C50:  INCF   x90,F
1C52:  INCF   x8F,F
1C54:  MOVF   x8B,W
1C56:  ADDWF  x8E,F
1C58:  MOVF   x8C,W
1C5A:  ADDWF  x8D,F
1C5C:  BNC   1C90
1C5E:  INCF   x8E,F
1C60:  BNZ   1C90
1C62:  INCF   x8F,F
1C64:  BNZ   1C90
1C66:  INCF   x90,F
1C68:  BRA    1C90
1C6A:  MOVF   x8A,W
1C6C:  IORLW  80
1C6E:  SUBWF  x8F,F
1C70:  BC    1C8E
1C72:  MOVLW  01
1C74:  SUBWF  x90,F
1C76:  BC    1C8E
1C78:  INCF   x90,F
1C7A:  MOVF   x8A,W
1C7C:  IORLW  80
1C7E:  ADDWF  x8F,F
1C80:  MOVF   x8B,W
1C82:  ADDWF  x8E,F
1C84:  BNC   1C58
1C86:  INCF   x8F,F
1C88:  BNZ   1C58
1C8A:  INCF   x90,F
1C8C:  BRA    1C58
1C8E:  BSF    03.0
1C90:  DECFSZ x91,F
1C92:  BRA    1C96
1C94:  BRA    1CAC
1C96:  BCF    FD8.0
1C98:  RLCF   x8D,F
1C9A:  RLCF   x8E,F
1C9C:  RLCF   x8F,F
1C9E:  RLCF   x90,F
1CA0:  BCF    FD8.0
1CA2:  RLCF   03,F
1CA4:  RLCF   02,F
1CA6:  RLCF   01,F
1CA8:  RLCF   x92,F
1CAA:  BRA    1C20
1CAC:  BTFSS  x92.0
1CAE:  BRA    1CBC
1CB0:  BCF    FD8.0
1CB2:  RRCF   01,F
1CB4:  RRCF   02,F
1CB6:  RRCF   03,F
1CB8:  RRCF   x92,F
1CBA:  BRA    1CC0
1CBC:  DECF   00,F
1CBE:  BZ    1D2A
1CC0:  BTFSC  x92.7
1CC2:  BRA    1D00
1CC4:  BCF    FD8.0
1CC6:  RLCF   x8D,F
1CC8:  RLCF   x8E,F
1CCA:  RLCF   x8F,F
1CCC:  RLCF   x90,F
1CCE:  MOVF   x8C,W
1CD0:  SUBWF  x8D,F
1CD2:  BC    1CE2
1CD4:  MOVLW  01
1CD6:  SUBWF  x8E,F
1CD8:  BC    1CE2
1CDA:  SUBWF  x8F,F
1CDC:  BC    1CE2
1CDE:  SUBWF  x90,F
1CE0:  BNC   1D16
1CE2:  MOVF   x8B,W
1CE4:  SUBWF  x8E,F
1CE6:  BC    1CF2
1CE8:  MOVLW  01
1CEA:  SUBWF  x8F,F
1CEC:  BC    1CF2
1CEE:  SUBWF  x90,F
1CF0:  BNC   1D16
1CF2:  MOVF   x8A,W
1CF4:  IORLW  80
1CF6:  SUBWF  x8F,F
1CF8:  BC    1D00
1CFA:  MOVLW  01
1CFC:  SUBWF  x90,F
1CFE:  BNC   1D16
1D00:  INCF   03,F
1D02:  BNZ   1D16
1D04:  INCF   02,F
1D06:  BNZ   1D16
1D08:  INCF   01,F
1D0A:  BNZ   1D16
1D0C:  INCF   00,F
1D0E:  BZ    1D2A
1D10:  RRCF   01,F
1D12:  RRCF   02,F
1D14:  RRCF   03,F
1D16:  MOVFF  286,291
1D1A:  MOVF   x8A,W
1D1C:  XORWF  x91,F
1D1E:  BTFSS  x91.7
1D20:  BRA    1D26
1D22:  BSF    01.7
1D24:  BRA    1D32
1D26:  BCF    01.7
1D28:  BRA    1D32
1D2A:  CLRF   00
1D2C:  CLRF   01
1D2E:  CLRF   02
1D30:  CLRF   03
1D32:  NOP   
1D34:  MOVLB  0
1D36:  RETLW  00
*
1E96:  MOVLW  80
1E98:  BTFSS  FD8.1
1E9A:  BRA    1EA0
1E9C:  MOVLB  2
1E9E:  XORWF  x84,F
1EA0:  MOVLB  2
1EA2:  CLRF   x89
1EA4:  CLRF   x8A
1EA6:  MOVFF  280,288
1EAA:  MOVF   x84,W
1EAC:  XORWF  x88,F
1EAE:  MOVF   x7F,W
1EB0:  BTFSC  FD8.2
1EB2:  BRA    2072
1EB4:  MOVWF  x87
1EB6:  MOVWF  00
1EB8:  MOVF   x83,W
1EBA:  BTFSC  FD8.2
1EBC:  BRA    2084
1EBE:  SUBWF  x87,F
1EC0:  BTFSC  FD8.2
1EC2:  BRA    1FCA
1EC4:  BNC   1F42
1EC6:  MOVFF  284,28D
1ECA:  BSF    x8D.7
1ECC:  MOVFF  285,28C
1ED0:  MOVFF  286,28B
1ED4:  CLRF   x8A
1ED6:  BCF    FD8.0
1ED8:  RRCF   x8D,F
1EDA:  RRCF   x8C,F
1EDC:  RRCF   x8B,F
1EDE:  RRCF   x8A,F
1EE0:  DECFSZ x87,F
1EE2:  BRA    1ED4
1EE4:  BTFSS  x88.7
1EE6:  BRA    1EEE
1EE8:  BSF    x89.0
1EEA:  BRA    20AC
1EEC:  BCF    x89.0
1EEE:  BCF    x87.0
1EF0:  BSF    x89.4
1EF2:  MOVLW  02
1EF4:  MOVWF  FEA
1EF6:  MOVLW  82
1EF8:  MOVWF  FE9
1EFA:  BRA    20D2
1EFC:  BCF    x89.4
1EFE:  BTFSC  x88.7
1F00:  BRA    1F16
1F02:  BTFSS  x87.0
1F04:  BRA    1F2C
1F06:  RRCF   x8D,F
1F08:  RRCF   x8C,F
1F0A:  RRCF   x8B,F
1F0C:  RRCF   x8A,F
1F0E:  INCF   00,F
1F10:  BTFSC  FD8.2
1F12:  BRA    20A2
1F14:  BRA    1F2C
1F16:  BTFSC  x8D.7
1F18:  BRA    1F32
1F1A:  BCF    FD8.0
1F1C:  RLCF   x8A,F
1F1E:  RLCF   x8B,F
1F20:  RLCF   x8C,F
1F22:  RLCF   x8D,F
1F24:  DECF   00,F
1F26:  BTFSC  FD8.2
1F28:  BRA    20A2
1F2A:  BRA    1F16
1F2C:  BSF    x89.6
1F2E:  BRA    200A
1F30:  BCF    x89.6
1F32:  MOVFF  280,288
1F36:  BTFSS  x80.7
1F38:  BRA    1F3E
1F3A:  BSF    x8D.7
1F3C:  BRA    2094
1F3E:  BCF    x8D.7
1F40:  BRA    2094
1F42:  MOVFF  283,287
1F46:  MOVFF  283,00
1F4A:  MOVF   x7F,W
1F4C:  SUBWF  x87,F
1F4E:  MOVFF  280,28D
1F52:  BSF    x8D.7
1F54:  MOVFF  281,28C
1F58:  MOVFF  282,28B
1F5C:  CLRF   x8A
1F5E:  BCF    FD8.0
1F60:  RRCF   x8D,F
1F62:  RRCF   x8C,F
1F64:  RRCF   x8B,F
1F66:  RRCF   x8A,F
1F68:  DECFSZ x87,F
1F6A:  BRA    1F5C
1F6C:  BTFSS  x88.7
1F6E:  BRA    1F76
1F70:  BSF    x89.1
1F72:  BRA    20AC
1F74:  BCF    x89.1
1F76:  BCF    x87.0
1F78:  BSF    x89.5
1F7A:  MOVLW  02
1F7C:  MOVWF  FEA
1F7E:  MOVLW  86
1F80:  MOVWF  FE9
1F82:  BRA    20D2
1F84:  BCF    x89.5
1F86:  BTFSC  x88.7
1F88:  BRA    1F9E
1F8A:  BTFSS  x87.0
1F8C:  BRA    1FB4
1F8E:  RRCF   x8D,F
1F90:  RRCF   x8C,F
1F92:  RRCF   x8B,F
1F94:  RRCF   x8A,F
1F96:  INCF   00,F
1F98:  BTFSC  FD8.2
1F9A:  BRA    20A2
1F9C:  BRA    1FB4
1F9E:  BTFSC  x8D.7
1FA0:  BRA    1FBA
1FA2:  BCF    FD8.0
1FA4:  RLCF   x8A,F
1FA6:  RLCF   x8B,F
1FA8:  RLCF   x8C,F
1FAA:  RLCF   x8D,F
1FAC:  DECF   00,F
1FAE:  BTFSC  FD8.2
1FB0:  BRA    20A2
1FB2:  BRA    1F9E
1FB4:  BSF    x89.7
1FB6:  BRA    200A
1FB8:  BCF    x89.7
1FBA:  MOVFF  284,288
1FBE:  BTFSS  x84.7
1FC0:  BRA    1FC6
1FC2:  BSF    x8D.7
1FC4:  BRA    2094
1FC6:  BCF    x8D.7
1FC8:  BRA    2094
1FCA:  MOVFF  284,28D
1FCE:  BSF    x8D.7
1FD0:  MOVFF  285,28C
1FD4:  MOVFF  286,28B
1FD8:  BTFSS  x88.7
1FDA:  BRA    1FE4
1FDC:  BCF    x8D.7
1FDE:  BSF    x89.2
1FE0:  BRA    20AC
1FE2:  BCF    x89.2
1FE4:  CLRF   x8A
1FE6:  BCF    x87.0
1FE8:  MOVLW  02
1FEA:  MOVWF  FEA
1FEC:  MOVLW  82
1FEE:  MOVWF  FE9
1FF0:  BRA    20D2
1FF2:  BTFSC  x88.7
1FF4:  BRA    202E
1FF6:  MOVFF  280,288
1FFA:  BTFSS  x87.0
1FFC:  BRA    200A
1FFE:  RRCF   x8D,F
2000:  RRCF   x8C,F
2002:  RRCF   x8B,F
2004:  RRCF   x8A,F
2006:  INCF   00,F
2008:  BZ    20A2
200A:  BTFSS  x8A.7
200C:  BRA    2024
200E:  INCF   x8B,F
2010:  BNZ   2024
2012:  INCF   x8C,F
2014:  BNZ   2024
2016:  INCF   x8D,F
2018:  BNZ   2024
201A:  RRCF   x8D,F
201C:  RRCF   x8C,F
201E:  RRCF   x8B,F
2020:  INCF   00,F
2022:  BZ    20A2
2024:  BTFSC  x89.6
2026:  BRA    1F30
2028:  BTFSC  x89.7
202A:  BRA    1FB8
202C:  BRA    2066
202E:  MOVLW  80
2030:  XORWF  x8D,F
2032:  BTFSS  x8D.7
2034:  BRA    203E
2036:  BRA    20AC
2038:  MOVFF  284,288
203C:  BRA    2052
203E:  MOVFF  280,288
2042:  MOVF   x8D,F
2044:  BNZ   2052
2046:  MOVF   x8C,F
2048:  BNZ   2052
204A:  MOVF   x8B,F
204C:  BNZ   2052
204E:  CLRF   00
2050:  BRA    2094
2052:  BTFSC  x8D.7
2054:  BRA    2066
2056:  BCF    FD8.0
2058:  RLCF   x8A,F
205A:  RLCF   x8B,F
205C:  RLCF   x8C,F
205E:  RLCF   x8D,F
2060:  DECFSZ 00,F
2062:  BRA    2052
2064:  BRA    20A2
2066:  BTFSS  x88.7
2068:  BRA    206E
206A:  BSF    x8D.7
206C:  BRA    2094
206E:  BCF    x8D.7
2070:  BRA    2094
2072:  MOVFF  283,00
2076:  MOVFF  284,28D
207A:  MOVFF  285,28C
207E:  MOVFF  286,28B
2082:  BRA    2094
2084:  MOVFF  27F,00
2088:  MOVFF  280,28D
208C:  MOVFF  281,28C
2090:  MOVFF  282,28B
2094:  MOVFF  28D,01
2098:  MOVFF  28C,02
209C:  MOVFF  28B,03
20A0:  BRA    210A
20A2:  CLRF   00
20A4:  CLRF   01
20A6:  CLRF   02
20A8:  CLRF   03
20AA:  BRA    210A
20AC:  CLRF   x8A
20AE:  COMF   x8B,F
20B0:  COMF   x8C,F
20B2:  COMF   x8D,F
20B4:  COMF   x8A,F
20B6:  INCF   x8A,F
20B8:  BNZ   20C4
20BA:  INCF   x8B,F
20BC:  BNZ   20C4
20BE:  INCF   x8C,F
20C0:  BNZ   20C4
20C2:  INCF   x8D,F
20C4:  BTFSC  x89.0
20C6:  BRA    1EEC
20C8:  BTFSC  x89.1
20CA:  BRA    1F74
20CC:  BTFSC  x89.2
20CE:  BRA    1FE2
20D0:  BRA    2038
20D2:  MOVF   FEF,W
20D4:  ADDWF  x8B,F
20D6:  BNC   20E2
20D8:  INCF   x8C,F
20DA:  BNZ   20E2
20DC:  INCF   x8D,F
20DE:  BTFSC  FD8.2
20E0:  BSF    x87.0
20E2:  MOVF   FED,F
20E4:  MOVF   FEF,W
20E6:  ADDWF  x8C,F
20E8:  BNC   20F0
20EA:  INCF   x8D,F
20EC:  BTFSC  FD8.2
20EE:  BSF    x87.0
20F0:  MOVF   FED,F
20F2:  MOVF   FEF,W
20F4:  BTFSC  FEF.7
20F6:  BRA    20FA
20F8:  XORLW  80
20FA:  ADDWF  x8D,F
20FC:  BTFSC  FD8.0
20FE:  BSF    x87.0
2100:  BTFSC  x89.4
2102:  BRA    1EFC
2104:  BTFSC  x89.5
2106:  BRA    1F84
2108:  BRA    1FF2
210A:  NOP   
210C:  MOVLB  0
210E:  RETLW  00
2110:  MOVLW  8E
2112:  MOVWF  00
2114:  MOVFF  286,01
2118:  MOVFF  285,02
211C:  CLRF   03
211E:  MOVF   01,F
2120:  BNZ   2134
2122:  MOVFF  02,01
2126:  CLRF   02
2128:  MOVLW  08
212A:  SUBWF  00,F
212C:  MOVF   01,F
212E:  BNZ   2134
2130:  CLRF   00
2132:  BRA    2144
2134:  BCF    FD8.0
2136:  BTFSC  01.7
2138:  BRA    2142
213A:  RLCF   02,F
213C:  RLCF   01,F
213E:  DECF   00,F
2140:  BRA    2134
2142:  BCF    01.7
2144:  NOP   
2146:  RETLW  00
2148:  MOVFF  76,7D
214C:  MOVF   7A,W
214E:  XORWF  7D,F
2150:  BTFSS  7D.7
2152:  BRA    215E
2154:  BCF    FD8.2
2156:  BCF    FD8.0
2158:  BTFSC  76.7
215A:  BSF    FD8.0
215C:  BRA    21BC
215E:  MOVFF  76,7D
2162:  MOVFF  79,7E
2166:  MOVF   75,W
2168:  SUBWF  7E,F
216A:  BZ    2178
216C:  BTFSS  7D.7
216E:  BRA    21BC
2170:  MOVF   FD8,W
2172:  XORLW  01
2174:  MOVWF  FD8
2176:  BRA    21BC
2178:  MOVFF  7A,7E
217C:  MOVF   76,W
217E:  SUBWF  7E,F
2180:  BZ    218E
2182:  BTFSS  7D.7
2184:  BRA    21BC
2186:  MOVF   FD8,W
2188:  XORLW  01
218A:  MOVWF  FD8
218C:  BRA    21BC
218E:  MOVFF  7B,7E
2192:  MOVF   77,W
2194:  SUBWF  7E,F
2196:  BZ    21A4
2198:  BTFSS  7D.7
219A:  BRA    21BC
219C:  MOVF   FD8,W
219E:  XORLW  01
21A0:  MOVWF  FD8
21A2:  BRA    21BC
21A4:  MOVFF  7C,7E
21A8:  MOVF   78,W
21AA:  SUBWF  7E,F
21AC:  BZ    21BA
21AE:  BTFSS  7D.7
21B0:  BRA    21BC
21B2:  MOVF   FD8,W
21B4:  XORLW  01
21B6:  MOVWF  FD8
21B8:  BRA    21BC
21BA:  BCF    FD8.0
21BC:  RETLW  00
*
27BC:  MOVF   x86,W
27BE:  MULWF  x88
27C0:  MOVFF  FF3,01
27C4:  MOVFF  FF4,00
27C8:  MULWF  x89
27CA:  MOVF   FF3,W
27CC:  ADDWF  00,F
27CE:  MOVF   x87,W
27D0:  MULWF  x88
27D2:  MOVF   FF3,W
27D4:  ADDWFC 00,W
27D6:  MOVWF  02
27D8:  RETLW  00
*
2A18:  CLRF   01
2A1A:  CLRF   02
2A1C:  CLRF   00
2A1E:  CLRF   03
2A20:  MOVF   7A,W
2A22:  BNZ   2A28
2A24:  MOVF   79,W
2A26:  BZ    2A58
2A28:  MOVLW  10
2A2A:  MOVWF  7B
2A2C:  BCF    FD8.0
2A2E:  RLCF   77,F
2A30:  RLCF   78,F
2A32:  RLCF   00,F
2A34:  RLCF   03,F
2A36:  MOVF   7A,W
2A38:  SUBWF  03,W
2A3A:  BNZ   2A40
2A3C:  MOVF   79,W
2A3E:  SUBWF  00,W
2A40:  BNC   2A50
2A42:  MOVF   79,W
2A44:  SUBWF  00,F
2A46:  BTFSS  FD8.0
2A48:  DECF   03,F
2A4A:  MOVF   7A,W
2A4C:  SUBWF  03,F
2A4E:  BSF    FD8.0
2A50:  RLCF   01,F
2A52:  RLCF   02,F
2A54:  DECFSZ 7B,F
2A56:  BRA    2A2C
2A58:  NOP   
2A5A:  GOTO   2D66 (RETURN)
*
2E90:  MOVLB  2
2E92:  MOVF   x9B,W
2E94:  SUBLW  B6
2E96:  MOVWF  x9B
2E98:  CLRF   03
2E9A:  MOVFF  29C,29F
2E9E:  BSF    x9C.7
2EA0:  BCF    FD8.0
2EA2:  RRCF   x9C,F
2EA4:  RRCF   x9D,F
2EA6:  RRCF   x9E,F
2EA8:  RRCF   03,F
2EAA:  RRCF   02,F
2EAC:  RRCF   01,F
2EAE:  RRCF   00,F
2EB0:  DECFSZ x9B,F
2EB2:  BRA    2EA0
2EB4:  BTFSS  x9F.7
2EB6:  BRA    2ECE
2EB8:  COMF   00,F
2EBA:  COMF   01,F
2EBC:  COMF   02,F
2EBE:  COMF   03,F
2EC0:  INCF   00,F
2EC2:  BTFSC  FD8.2
2EC4:  INCF   01,F
2EC6:  BTFSC  FD8.2
2EC8:  INCF   02,F
2ECA:  BTFSC  FD8.2
2ECC:  INCF   03,F
2ECE:  MOVLB  0
2ED0:  RETLW  00
2ED2:  CLRF   00
2ED4:  CLRF   01
2ED6:  CLRF   02
2ED8:  CLRF   03
2EDA:  MOVLB  2
2EDC:  CLRF   xA3
2EDE:  CLRF   xA4
2EE0:  CLRF   xA5
2EE2:  CLRF   xA6
2EE4:  MOVF   xA2,W
2EE6:  IORWF  xA1,W
2EE8:  IORWF  xA0,W
2EEA:  IORWF  x9F,W
2EEC:  BZ    2F46
2EEE:  MOVLW  20
2EF0:  MOVWF  xA7
2EF2:  BCF    FD8.0
2EF4:  RLCF   x9B,F
2EF6:  RLCF   x9C,F
2EF8:  RLCF   x9D,F
2EFA:  RLCF   x9E,F
2EFC:  RLCF   xA3,F
2EFE:  RLCF   xA4,F
2F00:  RLCF   xA5,F
2F02:  RLCF   xA6,F
2F04:  MOVF   xA2,W
2F06:  SUBWF  xA6,W
2F08:  BNZ   2F1A
2F0A:  MOVF   xA1,W
2F0C:  SUBWF  xA5,W
2F0E:  BNZ   2F1A
2F10:  MOVF   xA0,W
2F12:  SUBWF  xA4,W
2F14:  BNZ   2F1A
2F16:  MOVF   x9F,W
2F18:  SUBWF  xA3,W
2F1A:  BNC   2F3A
2F1C:  MOVF   x9F,W
2F1E:  SUBWF  xA3,F
2F20:  MOVF   xA0,W
2F22:  BTFSS  FD8.0
2F24:  INCFSZ xA0,W
2F26:  SUBWF  xA4,F
2F28:  MOVF   xA1,W
2F2A:  BTFSS  FD8.0
2F2C:  INCFSZ xA1,W
2F2E:  SUBWF  xA5,F
2F30:  MOVF   xA2,W
2F32:  BTFSS  FD8.0
2F34:  INCFSZ xA2,W
2F36:  SUBWF  xA6,F
2F38:  BSF    FD8.0
2F3A:  RLCF   00,F
2F3C:  RLCF   01,F
2F3E:  RLCF   02,F
2F40:  RLCF   03,F
2F42:  DECFSZ xA7,F
2F44:  BRA    2EF2
2F46:  NOP   
2F48:  MOVLW  02
2F4A:  MOVWF  FEA
2F4C:  MOVLW  A3
2F4E:  MOVWF  FE9
2F50:  MOVLB  0
2F52:  RETLW  00
2F54:  MOVF   FE9,W
2F56:  MOVWF  77
2F58:  MOVF   76,W
2F5A:  MOVWF  79
2F5C:  BZ    2F96
2F5E:  MOVFF  75,29E
2F62:  MOVFF  74,29D
2F66:  MOVFF  73,29C
2F6A:  MOVFF  72,29B
2F6E:  MOVLB  2
2F70:  CLRF   xA2
2F72:  CLRF   xA1
2F74:  MOVLW  20
2F76:  MOVWF  xA0
2F78:  MOVLW  82
2F7A:  MOVWF  x9F
2F7C:  MOVLB  0
2F7E:  CALL   14D6
2F82:  MOVFF  03,75
2F86:  MOVFF  02,74
2F8A:  MOVFF  01,73
2F8E:  MOVFF  00,72
2F92:  DECFSZ 79,F
2F94:  BRA    2F5E
2F96:  MOVFF  75,29E
2F9A:  MOVFF  74,29D
2F9E:  MOVFF  73,29C
2FA2:  MOVFF  72,29B
2FA6:  RCALL  2E90
2FA8:  MOVFF  03,75
2FAC:  MOVFF  02,74
2FB0:  MOVFF  01,73
2FB4:  MOVFF  00,72
2FB8:  BTFSS  75.7
2FBA:  BRA    2FD6
2FBC:  DECF   77,F
2FBE:  BSF    77.5
2FC0:  COMF   72,F
2FC2:  COMF   73,F
2FC4:  COMF   74,F
2FC6:  COMF   75,F
2FC8:  INCF   72,F
2FCA:  BTFSC  FD8.2
2FCC:  INCF   73,F
2FCE:  BTFSC  FD8.2
2FD0:  INCF   74,F
2FD2:  BTFSC  FD8.2
2FD4:  INCF   75,F
2FD6:  MOVLW  3B
2FD8:  MOVWF  7E
2FDA:  MOVLW  9A
2FDC:  MOVWF  7D
2FDE:  MOVLW  CA
2FE0:  MOVWF  7C
2FE2:  CLRF   7B
2FE4:  MOVLW  0A
2FE6:  MOVWF  79
2FE8:  MOVF   76,W
2FEA:  BTFSC  FD8.2
2FEC:  INCF   77,F
2FEE:  MOVFF  75,29E
2FF2:  MOVFF  74,29D
2FF6:  MOVFF  73,29C
2FFA:  MOVFF  72,29B
2FFE:  MOVFF  7E,2A2
3002:  MOVFF  7D,2A1
3006:  MOVFF  7C,2A0
300A:  MOVFF  7B,29F
300E:  RCALL  2ED2
3010:  MOVF   01,W
3012:  MOVFF  FEF,72
3016:  MOVFF  FEC,73
301A:  MOVFF  FEC,74
301E:  MOVFF  FEC,75
3022:  MOVF   00,F
3024:  BNZ   3044
3026:  INCF   76,W
3028:  SUBWF  79,W
302A:  BZ    3044
302C:  MOVF   77,W
302E:  BZ    3048
3030:  ANDLW  0F
3032:  SUBWF  79,W
3034:  BZ    3038
3036:  BC    30BA
3038:  BTFSC  77.7
303A:  BRA    30BA
303C:  BTFSC  77.6
303E:  BRA    3048
3040:  MOVLW  20
3042:  BRA    30B0
3044:  MOVLW  20
3046:  ANDWF  77,F
3048:  BTFSS  77.5
304A:  BRA    306A
304C:  BCF    77.5
304E:  MOVF   76,W
3050:  BTFSS  FD8.2
3052:  DECF   77,F
3054:  MOVF   00,W
3056:  MOVWF  77
3058:  MOVLW  2D
305A:  MOVLB  2
305C:  MOVWF  x80
305E:  MOVLB  0
3060:  CALL   0E7C
3064:  MOVF   77,W
3066:  MOVWF  00
3068:  CLRF   77
306A:  MOVF   76,W
306C:  SUBWF  79,W
306E:  BNZ   308A
3070:  MOVF   00,W
3072:  MOVWF  77
3074:  MOVLW  2E
3076:  MOVLB  2
3078:  MOVWF  x80
307A:  MOVLB  0
307C:  CALL   0E7C
3080:  MOVF   77,W
3082:  MOVWF  00
3084:  MOVLW  20
3086:  ANDWF  77,F
3088:  MOVLW  00
308A:  MOVLW  30
308C:  BTFSS  77.5
308E:  BRA    30B0
3090:  BCF    77.5
3092:  MOVF   76,W
3094:  BTFSS  FD8.2
3096:  DECF   77,F
3098:  MOVF   00,W
309A:  MOVWF  77
309C:  MOVLW  2D
309E:  MOVLB  2
30A0:  MOVWF  x80
30A2:  MOVLB  0
30A4:  CALL   0E7C
30A8:  MOVF   77,W
30AA:  MOVWF  00
30AC:  CLRF   77
30AE:  MOVLW  30
30B0:  ADDWF  00,F
30B2:  MOVFF  00,280
30B6:  CALL   0E7C
30BA:  MOVFF  7E,29E
30BE:  MOVFF  7D,29D
30C2:  MOVFF  7C,29C
30C6:  MOVFF  7B,29B
30CA:  MOVLB  2
30CC:  CLRF   xA2
30CE:  CLRF   xA1
30D0:  CLRF   xA0
30D2:  MOVLW  0A
30D4:  MOVWF  x9F
30D6:  MOVLB  0
30D8:  RCALL  2ED2
30DA:  MOVFF  03,7E
30DE:  MOVFF  02,7D
30E2:  MOVFF  01,7C
30E6:  MOVFF  00,7B
30EA:  DECFSZ 79,F
30EC:  BRA    2FEE
30EE:  RETLW  00
*
3416:  MOVF   01,W
3418:  MOVFF  280,282
341C:  MOVLW  64
341E:  MOVLB  2
3420:  MOVWF  x83
3422:  MOVLB  0
3424:  CALL   0ED8
3428:  MOVFF  00,280
342C:  MOVF   01,W
342E:  MOVLW  30
3430:  BNZ   3442
3432:  MOVLB  2
3434:  BTFSS  x81.1
3436:  BRA    3454
3438:  BTFSC  x81.3
343A:  BRA    3454
343C:  BTFSC  x81.4
343E:  MOVLW  20
3440:  BRA    344A
3442:  MOVLB  2
3444:  BCF    x81.3
3446:  BCF    x81.4
3448:  BSF    x81.0
344A:  ADDWF  01,F
344C:  MOVF   01,W
344E:  BTFSS  F9E.4
3450:  BRA    344E
3452:  MOVWF  FAD
3454:  MOVFF  280,282
3458:  MOVLW  0A
345A:  MOVWF  x83
345C:  MOVLB  0
345E:  CALL   0ED8
3462:  MOVFF  00,280
3466:  MOVF   01,W
3468:  MOVLW  30
346A:  BNZ   347C
346C:  MOVLB  2
346E:  BTFSC  x81.3
3470:  BRA    3488
3472:  BTFSS  x81.0
3474:  BRA    3488
3476:  BTFSC  x81.4
3478:  MOVLW  20
347A:  MOVLB  0
347C:  ADDWF  01,F
347E:  MOVF   01,W
3480:  BTFSS  F9E.4
3482:  BRA    3480
3484:  MOVWF  FAD
3486:  MOVLB  2
3488:  MOVLW  30
348A:  ADDWF  x80,F
348C:  MOVF   x80,W
348E:  BTFSS  F9E.4
3490:  BRA    348E
3492:  MOVWF  FAD
3494:  MOVLB  0
3496:  RETLW  00
3498:  MOVF   FE9,W
349A:  MOVLB  2
349C:  MOVWF  x93
349E:  MOVF   x92,W
34A0:  MOVWF  x95
34A2:  BZ    34DC
34A4:  MOVFF  291,29E
34A8:  MOVFF  290,29D
34AC:  MOVFF  28F,29C
34B0:  MOVFF  28E,29B
34B4:  CLRF   xA2
34B6:  CLRF   xA1
34B8:  MOVLW  20
34BA:  MOVWF  xA0
34BC:  MOVLW  82
34BE:  MOVWF  x9F
34C0:  MOVLB  0
34C2:  CALL   14D6
34C6:  MOVFF  03,291
34CA:  MOVFF  02,290
34CE:  MOVFF  01,28F
34D2:  MOVFF  00,28E
34D6:  MOVLB  2
34D8:  DECFSZ x95,F
34DA:  BRA    34A4
34DC:  MOVFF  291,29E
34E0:  MOVFF  290,29D
34E4:  MOVFF  28F,29C
34E8:  MOVFF  28E,29B
34EC:  MOVLB  0
34EE:  RCALL  2E90
34F0:  MOVFF  03,291
34F4:  MOVFF  02,290
34F8:  MOVFF  01,28F
34FC:  MOVFF  00,28E
3500:  MOVLB  2
3502:  BTFSS  x91.7
3504:  BRA    3520
3506:  DECF   x93,F
3508:  BSF    x93.5
350A:  COMF   x8E,F
350C:  COMF   x8F,F
350E:  COMF   x90,F
3510:  COMF   x91,F
3512:  INCF   x8E,F
3514:  BTFSC  FD8.2
3516:  INCF   x8F,F
3518:  BTFSC  FD8.2
351A:  INCF   x90,F
351C:  BTFSC  FD8.2
351E:  INCF   x91,F
3520:  MOVLW  3B
3522:  MOVWF  x9A
3524:  MOVLW  9A
3526:  MOVWF  x99
3528:  MOVLW  CA
352A:  MOVWF  x98
352C:  CLRF   x97
352E:  MOVLW  0A
3530:  MOVWF  x95
3532:  MOVF   x92,W
3534:  BTFSC  FD8.2
3536:  INCF   x93,F
3538:  MOVFF  291,29E
353C:  MOVFF  290,29D
3540:  MOVFF  28F,29C
3544:  MOVFF  28E,29B
3548:  MOVFF  29A,2A2
354C:  MOVFF  299,2A1
3550:  MOVFF  298,2A0
3554:  MOVFF  297,29F
3558:  MOVLB  0
355A:  RCALL  2ED2
355C:  MOVF   01,W
355E:  MOVFF  FEF,28E
3562:  MOVFF  FEC,28F
3566:  MOVFF  FEC,290
356A:  MOVFF  FEC,291
356E:  MOVF   00,F
3570:  BNZ   3598
3572:  MOVLB  2
3574:  INCF   x92,W
3576:  SUBWF  x95,W
3578:  BTFSS  FD8.2
357A:  BRA    3580
357C:  MOVLB  0
357E:  BRA    3598
3580:  MOVF   x93,W
3582:  BZ    359E
3584:  ANDLW  0F
3586:  SUBWF  x95,W
3588:  BZ    358C
358A:  BC    3604
358C:  BTFSC  x93.7
358E:  BRA    3604
3590:  BTFSC  x93.6
3592:  BRA    359E
3594:  MOVLW  20
3596:  BRA    35FA
3598:  MOVLW  20
359A:  MOVLB  2
359C:  ANDWF  x93,F
359E:  BTFSS  x93.5
35A0:  BRA    35BC
35A2:  BCF    x93.5
35A4:  MOVF   x92,W
35A6:  BTFSS  FD8.2
35A8:  DECF   x93,F
35AA:  MOVF   00,W
35AC:  MOVWF  x93
35AE:  MOVLW  2D
35B0:  BTFSS  F9E.4
35B2:  BRA    35B0
35B4:  MOVWF  FAD
35B6:  MOVF   x93,W
35B8:  MOVWF  00
35BA:  CLRF   x93
35BC:  MOVF   x92,W
35BE:  SUBWF  x95,W
35C0:  BNZ   35D8
35C2:  MOVF   00,W
35C4:  MOVWF  x93
35C6:  MOVLW  2E
35C8:  BTFSS  F9E.4
35CA:  BRA    35C8
35CC:  MOVWF  FAD
35CE:  MOVF   x93,W
35D0:  MOVWF  00
35D2:  MOVLW  20
35D4:  ANDWF  x93,F
35D6:  MOVLW  00
35D8:  MOVLW  30
35DA:  BTFSS  x93.5
35DC:  BRA    35FA
35DE:  BCF    x93.5
35E0:  MOVF   x92,W
35E2:  BTFSS  FD8.2
35E4:  DECF   x93,F
35E6:  MOVF   00,W
35E8:  MOVWF  x93
35EA:  MOVLW  2D
35EC:  BTFSS  F9E.4
35EE:  BRA    35EC
35F0:  MOVWF  FAD
35F2:  MOVF   x93,W
35F4:  MOVWF  00
35F6:  CLRF   x93
35F8:  MOVLW  30
35FA:  ADDWF  00,F
35FC:  MOVF   00,W
35FE:  BTFSS  F9E.4
3600:  BRA    35FE
3602:  MOVWF  FAD
3604:  MOVFF  29A,29E
3608:  MOVFF  299,29D
360C:  MOVFF  298,29C
3610:  MOVFF  297,29B
3614:  CLRF   xA2
3616:  CLRF   xA1
3618:  CLRF   xA0
361A:  MOVLW  0A
361C:  MOVWF  x9F
361E:  MOVLB  0
3620:  RCALL  2ED2
3622:  MOVFF  03,29A
3626:  MOVFF  02,299
362A:  MOVFF  01,298
362E:  MOVFF  00,297
3632:  MOVLB  2
3634:  DECFSZ x95,F
3636:  BRA    3538
3638:  MOVLB  0
363A:  RETLW  00
363C:  MOVFF  FEA,288
3640:  MOVFF  FE9,287
3644:  MOVLB  2
3646:  SWAPF  x81,W
3648:  IORLW  F0
364A:  MOVWF  x83
364C:  ADDWF  x83,F
364E:  ADDLW  E2
3650:  MOVWF  x84
3652:  ADDLW  32
3654:  MOVWF  x86
3656:  MOVF   x81,W
3658:  ANDLW  0F
365A:  ADDWF  x84,F
365C:  ADDWF  x84,F
365E:  ADDWF  x86,F
3660:  ADDLW  E9
3662:  MOVWF  x85
3664:  ADDWF  x85,F
3666:  ADDWF  x85,F
3668:  SWAPF  x80,W
366A:  ANDLW  0F
366C:  ADDWF  x85,F
366E:  ADDWF  x86,F
3670:  RLCF   x85,F
3672:  RLCF   x86,F
3674:  COMF   x86,F
3676:  RLCF   x86,F
3678:  MOVF   x80,W
367A:  ANDLW  0F
367C:  ADDWF  x86,F
367E:  RLCF   x83,F
3680:  MOVLW  07
3682:  MOVWF  x82
3684:  MOVLW  0A
3686:  DECF   x85,F
3688:  ADDWF  x86,F
368A:  BNC   3686
368C:  DECF   x84,F
368E:  ADDWF  x85,F
3690:  BNC   368C
3692:  DECF   x83,F
3694:  ADDWF  x84,F
3696:  BNC   3692
3698:  DECF   x82,F
369A:  ADDWF  x83,F
369C:  BNC   3698
369E:  MOVLW  02
36A0:  MOVWF  FEA
36A2:  MOVLW  82
36A4:  MOVWF  FE9
36A6:  MOVLW  07
36A8:  ANDWF  x87,W
36AA:  BCF    x87.6
36AC:  ADDWF  FE9,F
36AE:  MOVLW  86
36B0:  SUBWF  FE9,W
36B2:  BTFSC  FD8.2
36B4:  BSF    x87.6
36B6:  MOVF   FEF,W
36B8:  MOVWF  00
36BA:  BNZ   36CC
36BC:  BTFSC  x87.6
36BE:  BRA    36CC
36C0:  BTFSC  x87.4
36C2:  BRA    36DC
36C4:  BTFSC  x87.3
36C6:  BRA    36CC
36C8:  MOVLW  20
36CA:  BRA    36D2
36CC:  BSF    x87.3
36CE:  BCF    x87.4
36D0:  MOVLW  30
36D2:  ADDWF  00,F
36D4:  MOVF   00,W
36D6:  BTFSS  F9E.4
36D8:  BRA    36D6
36DA:  MOVWF  FAD
36DC:  MOVF   FEE,W
36DE:  BTFSS  x87.6
36E0:  BRA    36AE
36E2:  MOVLB  0
36E4:  RETLW  00
*
5250:  MOVFF  FF2,0E
5254:  BCF    FF2.7
5256:  ADDWF  FE8,W
5258:  ADDLW  75
525A:  MOVWF  FF6
525C:  MOVLW  52
525E:  MOVWF  FF7
5260:  BTFSC  FD8.0
5262:  INCF   FF7,F
5264:  TBLRD*-
5266:  MOVF   FF5,W
5268:  MOVWF  FFA
526A:  TBLRD*
526C:  MOVF   FF5,W
526E:  BTFSC  0E.7
5270:  BSF    FF2.7
5272:  MOVWF  FF9
5274:  DATA D6,44
5276:  DATA 0E,45
5278:  DATA D0,45
527A:  DATA 7E,46
*
52D8:  MOVF   01,W
52DA:  MOVFF  6D,282
52DE:  MOVLW  64
52E0:  MOVLB  2
52E2:  MOVWF  x83
52E4:  MOVLB  0
52E6:  CALL   0ED8
52EA:  MOVFF  00,6D
52EE:  MOVF   01,W
52F0:  MOVLW  30
52F2:  BNZ   5302
52F4:  BTFSS  6E.1
52F6:  BRA    5312
52F8:  BTFSC  6E.3
52FA:  BRA    5312
52FC:  BTFSC  6E.4
52FE:  MOVLW  20
5300:  BRA    5308
5302:  BCF    6E.3
5304:  BCF    6E.4
5306:  BSF    6E.0
5308:  ADDWF  01,F
530A:  MOVFF  01,280
530E:  CALL   0E7C
5312:  MOVFF  6D,282
5316:  MOVLW  0A
5318:  MOVLB  2
531A:  MOVWF  x83
531C:  MOVLB  0
531E:  CALL   0ED8
5322:  MOVFF  00,6D
5326:  MOVF   01,W
5328:  MOVLW  30
532A:  BNZ   5338
532C:  BTFSC  6E.3
532E:  BRA    5342
5330:  BTFSS  6E.0
5332:  BRA    5342
5334:  BTFSC  6E.4
5336:  MOVLW  20
5338:  ADDWF  01,F
533A:  MOVFF  01,280
533E:  CALL   0E7C
5342:  MOVLW  30
5344:  ADDWF  6D,F
5346:  MOVFF  6D,280
534A:  CALL   0E7C
534E:  RETLW  00
....................                   //fijamos que el valor leído esté representado con 8 bits 
....................                   //(es decir de 00 a FF). 
....................                   //Para cambiar el rango de salida usamos: ADC=10 (000 a 3FF) 
....................                   //                                      ó ADC=16 (0000 a FFC0) 
.................... #list 
....................  
.................... #include "proyecto1.h" 
.................... //****************************************** 
.................... //Archivo de cabecera del Proyecto 1 
.................... //****************************************** 
.................... //Author: Julio Navarro Lara         2010 
....................  
.................... //Definimos los puertos del microcontrolador 
.................... #byte port_a = 0xF80 
.................... #byte port_b = 0xF81 
.................... #byte port_c = 0xF82 
.................... #byte port_d = 0xF83 
.................... #byte port_e = 0xF84 
....................  
.................... #bit sistema_encendido = 0xF83.2    //Pin que indica el encendido del sistema con un valor alto 
.................... #bit motor = 0xF83.1                //Pin que indica el encendido del motor de circulación del agua con un valor alto 
.................... #bit caldera_encendida = 0xF83.0    //Pin que indica el encendido de la caldera con un valor alto 
.................... #bit menos =    0xF82.1             //Pines para gestionar la entrada de los pulsadores 
.................... #bit mas   =    0xF82.0             //'' 
.................... #bit si    =    0xF82.2             //'' 
.................... #bit no    =    0xF82.5             //'' 
....................  
.................... //Código para definir el botón NO 
.................... #define NOCODE          100 
....................  
.................... //Parámetros de la pantalla LCD 
.................... #define LCD_ORDEN       0    //Código para enviar un orden 
.................... #define LCD_DATO        1    //Código para enviar un dato 
....................  
.................... #define LCD_CLEAR       0x01  //Orden para borrar la pantalla 
.................... #define LCD_NO_CURSOR   0x0C  //Orden para eliminar el cursor de la pantalla 
.................... #define LCD_CURSOR      0x0E  //Orden para visualizar el cursor en la pantalla 
.................... #define LCD_PARPADEAR   0x0D  //Orden para que parpadee el cursor 
....................  
.................... //Tiempo que se mantienen los mensajes temporales en pantalla (ms) 
.................... #define LCD_T_RETARDO   500 
....................  
.................... //Parámetros del conversor AD 
.................... #define termostato_caldera   3   //Entrada AD que se refiere a la temperatura de referencia de la caldera 
.................... #define temperatura_caldera  2   //Entrada AD que se refiere a la temperatura del agua en la caldera 
.................... #define histeresis_caldera   5   //Diferencia de histéresis para el agua de la caldera 
.................... //Para probar en el PROTEUS, poner una histeresis de 10 ºC (los potenciómetros simulados no tienen más sensibilidad) 
.................... #define t_max_caldera        100  //Temperatura máxima a la que puede regularse la caldera 
.................... #define t_min_caldera        0  //Temperatura mínima a la que puede regularse la caldera 
.................... #define AD_num_valores       255 //Número de valores de escala del conversor (sensibilidad de los potenciómetros) 
....................  
.................... //Parámetros de control de temperatura 
.................... //Datos suministrados por el aparato de aire acondicionado (con bomba de calor) de mi casa 
.................... #define temp_max          32  //Temperatura máxima de regulación del termostato 
.................... #define temp_min          16  //Temperatura mínima de regulación del termostato 
....................  
.................... //Direcciones para la EEPROM 
.................... #define eeprom_termostato        0x00  //Valor del termostato 
.................... #define eeprom_num_intervalos    0x01  //Número de intervalos de programación de los que disponemos 
.................... #define eeprom_num_registros     0x02  //Número de registros de desconexión de los que se disponen 
.................... #define eeprom_anno_actual       0x03  //Año en el que nos encontramos 
.................... #define eeprom_anno_0_to_3       0x04  //Año en el que nos encontramos medido de 0 a 3 (llamado 1_to_3 por razones "históricas") 
.................... #define eeprom_programaciones    0x05  //Posición a partir de la cual se almacenan las programaciones de alarmas 
.................... #define eeprom_registros         0x14  //Posición a partir de la cual se almacenan los registros 
....................                                        //En este caso, por usar la memoria interna del microprocesador, caben sólo 26 registros 
....................  
.................... #fuses HS, NOPROTECT, BROWNOUT, PUT, NOLVP, NOXINST, WDT4096, NOWDT 
.................... //El watchdog-timer salta cada 16.384 segundos, aproximadamente 
.................... #use delay(clock=8000000, restart_wdt) 
*
0D30:  MOVLW  02
0D32:  MOVWF  FEA
0D34:  MOVLW  87
0D36:  MOVWF  FE9
0D38:  MOVF   FEF,W
0D3A:  BZ    0D60
0D3C:  MOVLW  02
0D3E:  MOVWF  01
0D40:  MOVLW  BF
0D42:  MOVWF  00
0D44:  CLRWDT
0D46:  DECFSZ 00,F
0D48:  BRA    0D44
0D4A:  DECFSZ 01,F
0D4C:  BRA    0D40
0D4E:  MOVLW  96
0D50:  MOVWF  00
0D52:  DECFSZ 00,F
0D54:  BRA    0D52
0D56:  NOP   
0D58:  NOP   
0D5A:  CLRWDT
0D5C:  DECFSZ FEF,F
0D5E:  BRA    0D3C
0D60:  RETLW  00
*
0D84:  MOVLW  09
0D86:  MOVLB  2
0D88:  SUBWF  x88,F
0D8A:  BNC   0DA4
0D8C:  MOVLW  02
0D8E:  MOVWF  FEA
0D90:  MOVLW  88
0D92:  MOVWF  FE9
0D94:  BCF    FD8.0
0D96:  RRCF   FEF,F
0D98:  MOVF   FEF,W
0D9A:  BZ    0DA4
0D9C:  BRA    0DA0
0D9E:  CLRWDT
0DA0:  DECFSZ FEF,F
0DA2:  BRA    0D9E
0DA4:  MOVLB  0
0DA6:  RETLW  00
.................... #use rs232(baud=4800, xmit=PIN_C6,rcv=PIN_C7) 
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  (x==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  (x<' ') 
.................... #define isprint(x)  (x>=' ') 
.................... #define isgraph(x)  (x>' ') 
.................... #define ispunct(x)  ((x>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(int *)==1 
.................... #define ptrdiff_t int 
.................... #else 
.................... #define ptrdiff_t long 
.................... #endif 
....................  
.................... #define size_t int 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: float atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... float atof(char * s); 
....................  
.................... /* Standard template: float atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... float atoe(char * s); 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int32 atoi32(char *s); 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, int8 base, char * s); 
....................  
.................... /* Standard template: signed long  atol(char * s) 
....................  * converts the initial portion of the string s to a signed long 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: float strtol(char * s,char *endptr) 
....................  * converts the initial portion of the string s to a float 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... float strtod(char *s,char *endptr); 
....................  
.................... /* Standard template: long strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr,signed int base); 
....................  
.................... /* Standard template: long strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... long strtoul(char *s,char *endptr,signed int base); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... long rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer,signed int denom); 
.................... ldiv_t ldiv(signed long numer,signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(int *)==1 
.................... #define ptrdiff_t int 
.................... #else 
.................... #define ptrdiff_t long 
.................... #endif 
....................  
.................... #define size_t int 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(int *)==1 
.................... #define ptrdiff_t int 
.................... #else 
.................... #define ptrdiff_t long 
.................... #endif 
....................  
.................... #define size_t int 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  (x==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  (x<' ') 
.................... #define isprint(x)  (x>=' ') 
.................... #define isgraph(x)  (x>' ') 
.................... #define ispunct(x)  ((x>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* compiler ignored the name 'strcpy()'; perhaps, it's reserved? 
....................    Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1*/ 
....................  
.................... char *strcopy(char *s1, char *s2) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; *s2 != 0; s++, s2++) { 
.................... 	  *s = *s2; 
....................   } 
....................   *s = *s2; 
....................   return(s1); 
.................... } 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   int n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,int c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, int c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... int *strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, int c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... int *strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
.................... 	 if (*sc2 == '\0') 
.................... 	    return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
.................... 	char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
.................... 	while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && *s == *t; ++s, ++t); 
....................  
.................... 		if (*t == '\0') 
.................... 			return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
.................... 	} 
.................... 	return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(int errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... int *strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer,signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer,signed long denom) 
.................... { 
....................    ldiv_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... float atof(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int sign = 0; 
....................    char c; 
....................    int ptr = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
....................  
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int sign = 0; 
....................    int expsign = 0; 
....................    char c; 
....................    int ptr = 0; 
....................    int i; 
....................    float exp = 1.0; 
....................    int expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... char * itoa(signed int32 num, int8 base, char *s) 
.................... { 
....................      int32 temp=1; 
....................      int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... float strtod(char *s,char *endptr) { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int sign = 0, point = 0; 
....................    char c; 
....................    int ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c=s[ptr++]; 
....................  
....................  
....................    while((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 0) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          point = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 1) { 
....................          pow10 = pow10*10; 
....................          result += (c - '0')/pow10; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '+') { 
....................          c = s[ptr++]; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................          *((char *)endptr)=s+ptr; 
....................       } 
....................       else 
....................          *((char *)endptr)=s; 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... long strtoul(char *s,char *endptr,signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-') 
....................    { 
....................       if (endptr) 
....................       { 
....................         *((char *)endptr)=s; 
....................       } 
....................       return 0; 
....................    } 
....................  
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    { 
....................       if (endptr) 
....................       { 
....................         *((char *)endptr)=s; 
....................       } 
....................       return 0; 
....................    } 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................       if (endptr) 
....................       { 
....................         *((char *)endptr)=s; 
....................       } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................         *((char *)endptr)=sc; 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr,signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    { 
....................       if (endptr) 
....................       { 
....................         *((char *)endptr)=s; 
....................       } 
....................       return 0; 
....................    } 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................       if (endptr) 
....................       { 
....................         *((char *)endptr)=s; 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................         *((char *)endptr)=sc; 
....................    return x; 
.................... } 
....................  
.................... signed int system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed = 1; 
....................  
.................... long rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned long)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... typedef signed int (*_Cmpfun)(char * p1,char * p2); 
....................  
.................... void qsort(char * qdata, int qitems, int qsize, _Cmpfun cmp) { 
....................    int m,j,i,l; 
....................    short done; 
....................    BYTE t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=TRUE; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = FALSE; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include "PCF8583.c" 
.................... // Funciones para el RTC I2c: PCF8583 
.................... // Este código no procede de CCS (no está totalmente verificado) 
.................... // Inluye funciones de conversión BCD-Binario 
.................... // y de lectura/escritura a través de I2C. 
....................  
.................... //Vamos a eliminar todos los casos en los que se habiliten las interrupciones globales 
.................... //Estas sentencias nos impedían utilizar estos métodos en las interrupciones 
....................  
.................... #ifndef PCF8583_SDA 
.................... #define PCF8583_SDA  PIN_C4 
.................... #define PCF8583_SCL  PIN_C3 
.................... #endif 
....................  
.................... #use i2c(master, sda=PCF8583_SDA, scl=PCF8583_SCL) 
*
1238:  MOVLW  08
123A:  MOVWF  01
123C:  NOP   
123E:  NOP   
1240:  NOP   
1242:  BCF    F8B.3
1244:  BCF    F94.3
1246:  NOP   
1248:  NOP   
124A:  NOP   
124C:  RLCF   x80,F
124E:  BCF    F8B.4
1250:  BTFSC  FD8.0
1252:  BSF    F94.4
1254:  BTFSS  FD8.0
1256:  BCF    F94.4
1258:  BSF    F94.3
125A:  BTFSS  F82.3
125C:  BRA    125A
125E:  DECFSZ 01,F
1260:  BRA    123C
1262:  NOP   
1264:  NOP   
1266:  BCF    F8B.3
1268:  BCF    F94.3
126A:  NOP   
126C:  BSF    F94.4
126E:  NOP   
1270:  NOP   
1272:  NOP   
1274:  NOP   
1276:  NOP   
1278:  NOP   
127A:  BSF    F94.3
127C:  BTFSS  F82.3
127E:  BRA    127C
1280:  CLRF   01
1282:  NOP   
1284:  NOP   
1286:  NOP   
1288:  BTFSC  F82.4
128A:  BSF    01.0
128C:  BCF    F8B.3
128E:  BCF    F94.3
1290:  BCF    F8B.4
1292:  BCF    F94.4
1294:  RETLW  00
*
23AE:  MOVLW  08
23B0:  MOVWF  x81
23B2:  MOVFF  00,82
23B6:  BSF    F94.4
23B8:  NOP   
23BA:  NOP   
23BC:  NOP   
23BE:  BSF    F94.3
23C0:  BTFSS  F82.3
23C2:  BRA    23C0
23C4:  BTFSC  F82.4
23C6:  BSF    FD8.0
23C8:  BTFSS  F82.4
23CA:  BCF    FD8.0
23CC:  RLCF   01,F
23CE:  NOP   
23D0:  NOP   
23D2:  BCF    F94.3
23D4:  BCF    F8B.3
23D6:  DECFSZ x81,F
23D8:  BRA    23B6
23DA:  BSF    F94.4
23DC:  NOP   
23DE:  NOP   
23E0:  NOP   
23E2:  BCF    F8B.4
23E4:  MOVF   x82,W
23E6:  BTFSS  FD8.2
23E8:  BCF    F94.4
23EA:  NOP   
23EC:  BSF    F94.3
23EE:  BTFSS  F82.3
23F0:  BRA    23EE
23F2:  NOP   
23F4:  NOP   
23F6:  BCF    F8B.3
23F8:  BCF    F94.3
23FA:  NOP   
23FC:  NOP   
23FE:  NOP   
2400:  BCF    F8B.4
2402:  BCF    F94.4
2404:  RETLW  00
....................  
.................... #ifndef PCF8583_WRITE_ADDRESS 
.................... #define PCF8583_WRITE_ADDRESS 0xA0 
.................... #define PCF8583_READ_ADDRESS  0xA1 
.................... #endif 
....................  
.................... // Register addresses 
.................... #define PCF8583_CTRL_STATUS_REG    0x00 
.................... #define PCF8583_100S_REG           0x01 
.................... #define PCF8583_SECONDS_REG        0x02 
.................... #define PCF8583_MINUTES_REG        0x03 
.................... #define PCF8583_HOURS_REG          0x04 
.................... #define PCF8583_DATE_REG           0x05 
.................... #define PCF8583_MONTHS_REG         0x06 
.................... #define PCF8583_TIMER_REG          0x07 
....................  
.................... #define PCF8583_ALARM_CONTROL_REG  0x08 
.................... #define PCF8583_ALARM_100S_REG     0x09 
.................... #define PCF8583_ALARM_SECS_REG     0x0A 
.................... #define PCF8583_ALARM_MINS_REG     0x0B 
.................... #define PCF8583_ALARM_HOURS_REG    0x0C 
.................... #define PCF8583_ALARM_DATE_REG     0x0D 
.................... #define PCF8583_ALARM_MONTHS_REG   0x0E 
.................... #define PCF8583_ALARM_TIMER_REG    0x0F 
....................  
.................... // Use the first NVRAM address for the year byte. 
.................... #define PCF8583_YEAR_REG           0x10 
....................  
....................  
.................... // Commands for the Control/Status register. 
.................... #define PCF8583_START_COUNTING     0x00 
.................... #define PCF8583_STOP_COUNTING      0x80 
.................... #define PCF8583_ACTIVAR_ALARMA     0b00000100  //Palabra de activación de la alarma 
.................... #define PCF8583_DEFINIR_ALARMA     0b10010000  //Palabra para definir el comportamiento 
....................                                                //de la alarma en su registro 
....................  
.................... #define PCF8583_DESACTIVAR_INT     0b00010000 
....................  
....................  
....................  
....................  
.................... char const weekday_names[7][10] = 
.................... { 
.................... {"DOM"}, 
.................... {"LUN"}, 
.................... {"MAR"}, 
.................... {"MIE"}, 
.................... {"JUE"}, 
.................... {"VIE"}, 
.................... {"SAB"} 
.................... }; 
....................  
.................... // This structure defines the user's date and time data. 
.................... // The values are stored as unsigned integers.  The user 
.................... // should declare a structure of this type in the application 
.................... // program. Then the address of the structure should be 
.................... // passed to the PCF8583 read/write functions in this 
.................... // driver, whenever you want to talk to the chip. 
.................... typedef struct 
.................... { 
.................... int8 seconds;    // 0 to 59 
.................... int8 minutes;    // 0 to 59 
.................... int8 hours;      // 0 to 23  (24-hour time) 
.................... int8 day;        // 1 to 31 
.................... int8 month;      // 1 to 12 
.................... int8 year;       // 00 to 99 
.................... int8 weekday;    // 0 = Sunday, 1 = Monday, etc. 
.................... }date_time_t; 
....................  
....................  
.................... //---------------------------------------------- 
.................... void PCF8583_write_byte(int8 address, int8 data) 
.................... { 
.................... disable_interrupts(GLOBAL); 
*
1296:  BCF    FF2.6
1298:  BCF    FF2.7
129A:  BTFSC  FF2.7
129C:  BRA    1298
.................... i2c_start(); 
129E:  BSF    F94.4
12A0:  NOP   
12A2:  NOP   
12A4:  BSF    F94.3
12A6:  NOP   
12A8:  NOP   
12AA:  NOP   
12AC:  BCF    F8B.4
12AE:  BCF    F94.4
12B0:  NOP   
12B2:  NOP   
12B4:  BCF    F8B.3
12B6:  BCF    F94.3
.................... i2c_write(PCF8583_WRITE_ADDRESS); 
12B8:  MOVLW  A0
12BA:  MOVWF  x80
12BC:  RCALL  1238
.................... i2c_write(address); 
12BE:  MOVFF  7E,80
12C2:  RCALL  1238
.................... i2c_write(data); 
12C4:  MOVFF  7F,80
12C8:  RCALL  1238
.................... i2c_stop(); 
12CA:  BCF    F94.4
12CC:  NOP   
12CE:  BSF    F94.3
12D0:  BTFSS  F82.3
12D2:  BRA    12D0
12D4:  NOP   
12D6:  NOP   
12D8:  NOP   
12DA:  NOP   
12DC:  NOP   
12DE:  BSF    F94.4
12E0:  NOP   
12E2:  NOP   
.................... } 
12E4:  RETLW  00
....................  
.................... //---------------------------------------------- 
.................... int8 PCF8583_read_byte(int8 address) 
.................... { 
.................... int8 retval; 
....................  
.................... disable_interrupts(GLOBAL); 
*
242C:  BCF    FF2.6
242E:  BCF    FF2.7
2430:  BTFSC  FF2.7
2432:  BRA    242E
.................... i2c_start(); 
2434:  BSF    F94.4
2436:  NOP   
2438:  NOP   
243A:  BSF    F94.3
243C:  NOP   
243E:  NOP   
2440:  NOP   
2442:  BCF    F8B.4
2444:  BCF    F94.4
2446:  NOP   
2448:  NOP   
244A:  BCF    F8B.3
244C:  BCF    F94.3
.................... i2c_write(PCF8583_WRITE_ADDRESS); 
244E:  MOVLW  A0
2450:  MOVWF  x80
2452:  CALL   1238
.................... i2c_write(address); 
2456:  MOVFF  7E,80
245A:  CALL   1238
.................... i2c_start(); 
245E:  BSF    F94.4
2460:  NOP   
2462:  NOP   
2464:  BSF    F94.3
2466:  NOP   
2468:  NOP   
246A:  NOP   
246C:  BTFSS  F82.3
246E:  BRA    246C
2470:  BCF    F8B.4
2472:  BCF    F94.4
2474:  NOP   
2476:  NOP   
2478:  BCF    F8B.3
247A:  BCF    F94.3
.................... i2c_write(PCF8583_READ_ADDRESS); 
247C:  MOVLW  A1
247E:  MOVWF  x80
2480:  CALL   1238
.................... retval = i2c_read(0); 
2484:  CLRF   00
2486:  RCALL  23AE
2488:  MOVFF  01,7F
.................... i2c_stop(); 
248C:  BCF    F94.4
248E:  NOP   
2490:  BSF    F94.3
2492:  BTFSS  F82.3
2494:  BRA    2492
2496:  NOP   
2498:  NOP   
249A:  NOP   
249C:  NOP   
249E:  NOP   
24A0:  BSF    F94.4
24A2:  NOP   
24A4:  NOP   
....................  
.................... return(retval); 
24A6:  MOVFF  7F,01
.................... } 
24AA:  GOTO   263A (RETURN)
....................  
....................  
.................... void PCF8583_init(void) 
.................... { 
.................... PCF8583_write_byte(PCF8583_CTRL_STATUS_REG, 
....................                               PCF8583_START_COUNTING); 
.................... } 
....................  
.................... //---------------------------------------------- 
.................... // This function converts an 8 bit binary value 
.................... // to an 8 bit BCD value. 
.................... // The input range must be from 0 to 99. 
....................  
.................... int8 bin2bcd(int8 value) 
.................... { 
.................... char retval; 
....................  
.................... retval = 0; 
*
1218:  CLRF   7C
....................  
.................... while(1) 
....................   { 
....................    // Get the tens digit by doing multiple subtraction 
....................    // of 10 from the binary value. 
....................    if(value >= 10) 
121A:  MOVF   7B,W
121C:  SUBLW  09
121E:  BC    122A
....................      { 
....................       value -= 10; 
1220:  MOVLW  0A
1222:  SUBWF  7B,F
....................       retval += 0x10; 
1224:  MOVLW  10
1226:  ADDWF  7C,F
....................      } 
....................    else // Get the ones digit by adding the remainder. 
1228:  BRA    1230
....................      { 
....................       retval += value; 
122A:  MOVF   7B,W
122C:  ADDWF  7C,F
....................       break; 
122E:  BRA    1232
....................      } 
....................    } 
1230:  BRA    121A
....................  
.................... return(retval); 
1232:  MOVFF  7C,01
.................... } 
1236:  RETLW  00
....................  
.................... //---------------------------------------------- 
.................... // This function converts an 8 bit BCD value to 
.................... // an 8 bit binary value. 
.................... // The input range must be from 00 to 99. 
....................  
.................... char bcd2bin(char bcd_value) 
.................... { 
.................... char temp; 
....................  
.................... temp = bcd_value; 
*
2406:  MOVFF  81,82
....................  
.................... // Shifting the upper digit right by 1 is 
.................... // the same as multiplying it by 8. 
.................... temp >>= 1; 
240A:  BCF    FD8.0
240C:  RRCF   x82,F
....................  
.................... // Isolate the bits for the upper digit. 
.................... temp &= 0x78; 
240E:  MOVLW  78
2410:  ANDWF  x82,F
....................  
.................... // Now return: (Tens * 8) + (Tens * 2) + Ones 
.................... return(temp + (temp >> 2) + (bcd_value & 0x0f)); 
2412:  RRCF   x82,W
2414:  MOVWF  00
2416:  RRCF   00,F
2418:  MOVLW  3F
241A:  ANDWF  00,F
241C:  MOVF   00,W
241E:  ADDWF  x82,W
2420:  MOVWF  x83
2422:  MOVF   x81,W
2424:  ANDLW  0F
2426:  ADDWF  x83,W
2428:  MOVWF  01
....................  
.................... } 
242A:  RETLW  00
....................  
.................... //---------------------------------------------- 
.................... void PCF8583_set_datetime(date_time_t *dt) 
.................... { 
.................... int8 bcd_sec; 
.................... int8 bcd_min; 
.................... int8 bcd_hrs; 
.................... int8 bcd_day; 
.................... int8 bcd_mon; 
....................  
.................... // Convert the input date/time into BCD values 
.................... // that are formatted for the PCF8583 registers. 
.................... bcd_sec = bin2bcd(dt->seconds); 
*
12E6:  MOVF   73,W
12E8:  MOVWF  FE9
12EA:  MOVFF  74,FEA
12EE:  MOVFF  FEF,7A
12F2:  MOVFF  7A,7B
12F6:  RCALL  1218
12F8:  MOVFF  01,75
.................... bcd_min = bin2bcd(dt->minutes); 
12FC:  MOVLW  01
12FE:  ADDWF  73,W
1300:  MOVWF  FE9
1302:  MOVLW  00
1304:  ADDWFC 74,W
1306:  MOVWF  FEA
1308:  MOVFF  FEF,7A
130C:  MOVFF  7A,7B
1310:  RCALL  1218
1312:  MOVFF  01,76
.................... bcd_hrs = bin2bcd(dt->hours); 
1316:  MOVLW  02
1318:  ADDWF  73,W
131A:  MOVWF  FE9
131C:  MOVLW  00
131E:  ADDWFC 74,W
1320:  MOVWF  FEA
1322:  MOVFF  FEF,7A
1326:  MOVFF  7A,7B
132A:  RCALL  1218
132C:  MOVFF  01,77
.................... bcd_day = bin2bcd(dt->day) | (dt->year << 6); 
1330:  MOVLW  03
1332:  ADDWF  73,W
1334:  MOVWF  FE9
1336:  MOVLW  00
1338:  ADDWFC 74,W
133A:  MOVWF  FEA
133C:  MOVFF  FEF,7A
1340:  MOVFF  7A,7B
1344:  RCALL  1218
1346:  MOVLW  05
1348:  ADDWF  73,W
134A:  MOVWF  FE9
134C:  MOVLW  00
134E:  ADDWFC 74,W
1350:  MOVWF  FEA
1352:  SWAPF  FEF,W
1354:  MOVWF  00
1356:  RLCF   00,F
1358:  RLCF   00,F
135A:  MOVLW  C0
135C:  ANDWF  00,F
135E:  MOVF   00,W
1360:  IORWF  01,W
1362:  MOVWF  78
.................... bcd_mon = bin2bcd(dt->month) | (dt->weekday << 5); 
1364:  MOVLW  04
1366:  ADDWF  73,W
1368:  MOVWF  FE9
136A:  MOVLW  00
136C:  ADDWFC 74,W
136E:  MOVWF  FEA
1370:  MOVFF  FEF,7A
1374:  MOVFF  7A,7B
1378:  RCALL  1218
137A:  MOVLW  06
137C:  ADDWF  73,W
137E:  MOVWF  FE9
1380:  MOVLW  00
1382:  ADDWFC 74,W
1384:  MOVWF  FEA
1386:  SWAPF  FEF,W
1388:  MOVWF  00
138A:  RLCF   00,F
138C:  MOVLW  E0
138E:  ANDWF  00,F
1390:  MOVF   00,W
1392:  IORWF  01,W
1394:  MOVWF  79
....................  
.................... // Stop the RTC from counting, before we write to 
.................... // the date and time registers. 
.................... PCF8583_write_byte(PCF8583_CTRL_STATUS_REG, 
....................                               PCF8583_STOP_COUNTING); 
1396:  CLRF   7E
1398:  MOVLW  80
139A:  MOVWF  7F
139C:  RCALL  1296
....................  
.................... // Write to the date and time registers.  Disable interrupts 
.................... // so they can't disrupt the i2c operations. 
.................... disable_interrupts(GLOBAL); 
139E:  BCF    FF2.6
13A0:  BCF    FF2.7
13A2:  BTFSC  FF2.7
13A4:  BRA    13A0
.................... i2c_start(); 
13A6:  BSF    F94.4
13A8:  NOP   
13AA:  NOP   
13AC:  BSF    F94.3
13AE:  NOP   
13B0:  NOP   
13B2:  NOP   
13B4:  BCF    F8B.4
13B6:  BCF    F94.4
13B8:  NOP   
13BA:  NOP   
13BC:  BCF    F8B.3
13BE:  BCF    F94.3
.................... i2c_write(PCF8583_WRITE_ADDRESS); 
13C0:  MOVLW  A0
13C2:  MOVWF  x80
13C4:  RCALL  1238
.................... i2c_write(PCF8583_100S_REG);   // Start at 100's reg. 
13C6:  MOVLW  01
13C8:  MOVWF  x80
13CA:  RCALL  1238
.................... i2c_write(0x00);               // Set 100's reg = 0 
13CC:  CLRF   x80
13CE:  RCALL  1238
.................... i2c_write(bcd_sec); 
13D0:  MOVFF  75,80
13D4:  RCALL  1238
.................... i2c_write(bcd_min); 
13D6:  MOVFF  76,80
13DA:  RCALL  1238
.................... i2c_write(bcd_hrs); 
13DC:  MOVFF  77,80
13E0:  RCALL  1238
.................... i2c_write(bcd_day); 
13E2:  MOVFF  78,80
13E6:  RCALL  1238
.................... i2c_write(bcd_mon); 
13E8:  MOVFF  79,80
13EC:  RCALL  1238
.................... i2c_stop(); 
13EE:  BCF    F94.4
13F0:  NOP   
13F2:  BSF    F94.3
13F4:  BTFSS  F82.3
13F6:  BRA    13F4
13F8:  NOP   
13FA:  NOP   
13FC:  NOP   
13FE:  NOP   
1400:  NOP   
1402:  BSF    F94.4
1404:  NOP   
1406:  NOP   
....................  
.................... // Write the year byte to the first NVRAM location. 
.................... // Leave it in binary format. 
.................... PCF8583_write_byte(PCF8583_YEAR_REG, dt->year); 
1408:  MOVLW  05
140A:  ADDWF  73,W
140C:  MOVWF  FE9
140E:  MOVLW  00
1410:  ADDWFC 74,W
1412:  MOVWF  FEA
1414:  MOVFF  FEF,7A
1418:  MOVLW  10
141A:  MOVWF  7E
141C:  MOVFF  7A,7F
1420:  RCALL  1296
....................  
.................... // Now allow the PCF8583 to start counting again. 
.................... PCF8583_write_byte(PCF8583_CTRL_STATUS_REG, 
....................                               PCF8583_START_COUNTING); 
1422:  CLRF   7E
1424:  CLRF   7F
1426:  RCALL  1296
.................... } 
1428:  GOTO   19FC (RETURN)
....................  
.................... //---------------------------------------------- 
.................... // Read the Date and Time from the hardware registers 
.................... // in the PCF8583.   We don't have to disable counting 
.................... // during read operations, because according to the data 
.................... // sheet, if any of the lower registers (1 to 7) is read, 
.................... // all of them are loaded into "capture" registers. 
.................... // All further reading within that cycle is done from 
.................... // those registers. 
....................  
.................... void PCF8583_read_datetime(date_time_t *dt) 
.................... { 
.................... int8 year_bits; 
.................... int8 year; 
....................  
.................... int8 bcd_sec; 
.................... int8 bcd_min; 
.................... int8 bcd_hrs; 
.................... int8 bcd_day; 
.................... int8 bcd_mon; 
....................  
.................... // Disable interrupts so the i2c process is not disrupted. 
.................... disable_interrupts(GLOBAL); 
*
24AE:  BCF    FF2.6
24B0:  BCF    FF2.7
24B2:  BTFSC  FF2.7
24B4:  BRA    24B0
....................  
.................... // Read the date/time registers inside the PCF8583. 
.................... i2c_start(); 
24B6:  BSF    F94.4
24B8:  NOP   
24BA:  NOP   
24BC:  BSF    F94.3
24BE:  NOP   
24C0:  NOP   
24C2:  NOP   
24C4:  BCF    F8B.4
24C6:  BCF    F94.4
24C8:  NOP   
24CA:  NOP   
24CC:  BCF    F8B.3
24CE:  BCF    F94.3
.................... i2c_write(PCF8583_WRITE_ADDRESS); 
24D0:  MOVLW  A0
24D2:  MOVWF  x80
24D4:  CALL   1238
.................... i2c_write(PCF8583_SECONDS_REG);   // Start at seconds reg. 
24D8:  MOVLW  02
24DA:  MOVWF  x80
24DC:  CALL   1238
.................... i2c_start(); 
24E0:  BSF    F94.4
24E2:  NOP   
24E4:  NOP   
24E6:  BSF    F94.3
24E8:  NOP   
24EA:  NOP   
24EC:  NOP   
24EE:  BTFSS  F82.3
24F0:  BRA    24EE
24F2:  BCF    F8B.4
24F4:  BCF    F94.4
24F6:  NOP   
24F8:  NOP   
24FA:  BCF    F8B.3
24FC:  BCF    F94.3
.................... i2c_write(PCF8583_READ_ADDRESS); 
24FE:  MOVLW  A1
2500:  MOVWF  x80
2502:  CALL   1238
....................  
.................... bcd_sec = i2c_read(); 
2506:  MOVLW  01
2508:  MOVWF  00
250A:  RCALL  23AE
250C:  MOVFF  01,79
.................... bcd_min = i2c_read(); 
2510:  MOVLW  01
2512:  MOVWF  00
2514:  RCALL  23AE
2516:  MOVFF  01,7A
.................... bcd_hrs = i2c_read(); 
251A:  MOVLW  01
251C:  MOVWF  00
251E:  RCALL  23AE
2520:  MOVFF  01,7B
.................... bcd_day = i2c_read(); 
2524:  MOVLW  01
2526:  MOVWF  00
2528:  RCALL  23AE
252A:  MOVFF  01,7C
.................... bcd_mon = i2c_read(0); 
252E:  CLRF   00
2530:  RCALL  23AE
2532:  MOVFF  01,7D
.................... i2c_stop(); 
2536:  BCF    F94.4
2538:  NOP   
253A:  BSF    F94.3
253C:  BTFSS  F82.3
253E:  BRA    253C
2540:  NOP   
2542:  NOP   
2544:  NOP   
2546:  NOP   
2548:  NOP   
254A:  BSF    F94.4
254C:  NOP   
254E:  NOP   
....................  
....................  
.................... // Convert the date/time values from BCD to 
.................... // unsigned 8-bit integers.  Unpack the bits 
.................... // in the PCF8583 registers where required. 
.................... dt->seconds = bcd2bin(bcd_sec); 
2550:  MOVFF  75,01
2554:  MOVFF  76,03
2558:  MOVFF  75,7E
255C:  MOVFF  76,7F
2560:  MOVFF  79,81
2564:  RCALL  2406
2566:  MOVFF  7F,FEA
256A:  MOVFF  7E,FE9
256E:  MOVFF  01,FEF
.................... dt->minutes = bcd2bin(bcd_min); 
2572:  MOVLW  01
2574:  ADDWF  75,W
2576:  MOVWF  01
2578:  MOVLW  00
257A:  ADDWFC 76,W
257C:  MOVWF  03
257E:  MOVFF  01,7E
2582:  MOVWF  7F
2584:  MOVFF  7A,81
2588:  RCALL  2406
258A:  MOVFF  7F,FEA
258E:  MOVFF  7E,FE9
2592:  MOVFF  01,FEF
.................... dt->hours   = bcd2bin(bcd_hrs & 0x3F); 
2596:  MOVLW  02
2598:  ADDWF  75,W
259A:  MOVWF  01
259C:  MOVLW  00
259E:  ADDWFC 76,W
25A0:  MOVWF  03
25A2:  MOVFF  01,7E
25A6:  MOVWF  7F
25A8:  MOVF   7B,W
25AA:  ANDLW  3F
25AC:  MOVWF  x80
25AE:  MOVWF  x81
25B0:  RCALL  2406
25B2:  MOVFF  7F,FEA
25B6:  MOVFF  7E,FE9
25BA:  MOVFF  01,FEF
.................... dt->day     = bcd2bin(bcd_day & 0x3F); 
25BE:  MOVLW  03
25C0:  ADDWF  75,W
25C2:  MOVWF  01
25C4:  MOVLW  00
25C6:  ADDWFC 76,W
25C8:  MOVWF  03
25CA:  MOVFF  01,7E
25CE:  MOVWF  7F
25D0:  MOVF   7C,W
25D2:  ANDLW  3F
25D4:  MOVWF  x80
25D6:  MOVWF  x81
25D8:  RCALL  2406
25DA:  MOVFF  7F,FEA
25DE:  MOVFF  7E,FE9
25E2:  MOVFF  01,FEF
.................... dt->month   = bcd2bin(bcd_mon & 0x1F); 
25E6:  MOVLW  04
25E8:  ADDWF  75,W
25EA:  MOVWF  01
25EC:  MOVLW  00
25EE:  ADDWFC 76,W
25F0:  MOVWF  03
25F2:  MOVFF  01,7E
25F6:  MOVWF  7F
25F8:  MOVF   7D,W
25FA:  ANDLW  1F
25FC:  MOVWF  x80
25FE:  MOVWF  x81
2600:  RCALL  2406
2602:  MOVFF  7F,FEA
2606:  MOVFF  7E,FE9
260A:  MOVFF  01,FEF
.................... dt->weekday = bcd_mon >> 5; 
260E:  MOVLW  06
2610:  ADDWF  75,W
2612:  MOVWF  FE9
2614:  MOVLW  00
2616:  ADDWFC 76,W
2618:  MOVWF  FEA
261A:  SWAPF  7D,W
261C:  MOVWF  00
261E:  RRCF   00,F
2620:  MOVLW  07
2622:  ANDWF  00,F
2624:  MOVFF  00,FEF
.................... year_bits   = bcd_day >> 6; 
2628:  SWAPF  7C,W
262A:  MOVWF  77
262C:  RRCF   77,F
262E:  RRCF   77,F
2630:  MOVLW  03
2632:  ANDWF  77,F
....................  
.................... // Read the year byte from NVRAM. 
.................... // This is an added feature of this driver. 
.................... year = PCF8583_read_byte(PCF8583_YEAR_REG); 
2634:  MOVLW  10
2636:  MOVWF  7E
2638:  BRA    242C
263A:  MOVFF  01,78
....................  
.................... // Check if the two "year bits" were incremented by 
.................... // the PCF8583.  If so, increment the 8-bit year 
.................... // byte (read from NVRAM) by the same amount. 
.................... while(year_bits != (year & 3)) 
....................       year++; 
263E:  MOVF   78,W
2640:  ANDLW  03
2642:  SUBWF  77,W
2644:  BZ    264A
2646:  INCF   78,F
2648:  BRA    263E
....................  
.................... dt->year = year; 
264A:  MOVLW  05
264C:  ADDWF  75,W
264E:  MOVWF  FE9
2650:  MOVLW  00
2652:  ADDWFC 76,W
2654:  MOVWF  FEA
2656:  MOVFF  78,FEF
....................  
.................... // Now update the year byte in the NVRAM 
.................... // inside the PCF8583. 
.................... PCF8583_write_byte(PCF8583_YEAR_REG, year); 
265A:  MOVLW  10
265C:  MOVWF  7E
265E:  MOVFF  78,7F
2662:  CALL   1296
....................  
.................... } 
2666:  RETLW  00
....................  
.................... //Método que permite establecer una alarma, dados horas, minutos y segundos 
.................... //Author: Julio Navarro Lara 
.................... void PCF8583_establecer_alarma(int8 horas, int8 minutos, int8 segundos){ 
....................    int8 bcd_horas; 
....................    int8 bcd_minutos; 
....................    int8 bcd_segundos; 
....................  
....................    //Transformamos a BCD las horas y los minutos introducidos 
....................    bcd_horas = bin2bcd(horas); 
*
2690:  MOVFF  6F,7B
2694:  CALL   1218
2698:  MOVFF  01,72
....................    bcd_minutos = bin2bcd(minutos); 
269C:  MOVFF  70,7B
26A0:  CALL   1218
26A4:  MOVFF  01,73
....................    bcd_segundos = bin2bcd(segundos); 
26A8:  MOVFF  71,7B
26AC:  CALL   1218
26B0:  MOVFF  01,74
....................  
....................    //Paramos de contar el tiempo para escribir los datos 
....................    PCF8583_write_byte(PCF8583_CTRL_STATUS_REG, 
....................                               PCF8583_STOP_COUNTING); 
26B4:  CLRF   7E
26B6:  MOVLW  80
26B8:  MOVWF  7F
26BA:  CALL   1296
....................  
....................    //Definimos las condiciones de la alarma 
....................    PCF8583_write_byte(PCF8583_ALARM_CONTROL_REG, 
....................                               PCF8583_DEFINIR_ALARMA); 
26BE:  MOVLW  08
26C0:  MOVWF  7E
26C2:  MOVLW  90
26C4:  MOVWF  7F
26C6:  CALL   1296
....................  
....................    //Desactivamos las interrupciones para que no interfieran en la escritura i2c 
....................    disable_interrupts(GLOBAL); 
26CA:  BCF    FF2.6
26CC:  BCF    FF2.7
26CE:  BTFSC  FF2.7
26D0:  BRA    26CC
....................    i2c_start(); 
26D2:  BSF    F94.4
26D4:  NOP   
26D6:  NOP   
26D8:  BSF    F94.3
26DA:  NOP   
26DC:  NOP   
26DE:  NOP   
26E0:  BCF    F8B.4
26E2:  BCF    F94.4
26E4:  NOP   
26E6:  NOP   
26E8:  BCF    F8B.3
26EA:  BCF    F94.3
....................    i2c_write(PCF8583_WRITE_ADDRESS); 
26EC:  MOVLW  A0
26EE:  MOVWF  x80
26F0:  CALL   1238
....................    //Escribimos en los registros de hora y minutos 
....................    i2c_write(PCF8583_ALARM_100S_REG); 
26F4:  MOVLW  09
26F6:  MOVWF  x80
26F8:  CALL   1238
....................    i2c_write(0x00); 
26FC:  CLRF   x80
26FE:  CALL   1238
....................    i2c_write(bcd_segundos); 
2702:  MOVFF  74,80
2706:  CALL   1238
....................    i2c_write(bcd_minutos); 
270A:  MOVFF  73,80
270E:  CALL   1238
....................    i2c_write(bcd_horas); 
2712:  MOVFF  72,80
2716:  CALL   1238
....................    i2c_stop(); 
271A:  BCF    F94.4
271C:  NOP   
271E:  BSF    F94.3
2720:  BTFSS  F82.3
2722:  BRA    2720
2724:  NOP   
2726:  NOP   
2728:  NOP   
272A:  NOP   
272C:  NOP   
272E:  BSF    F94.4
2730:  NOP   
2732:  NOP   
....................  
....................    //OJO! No volvemos a activar las interrupciones por si llamamos al método 
....................    //dentro de una rutina de interrupción 
....................  
....................    //Activamos la alarma 
....................    PCF8583_write_byte(PCF8583_CTRL_STATUS_REG, 
....................                               PCF8583_ACTIVAR_ALARMA); 
2734:  CLRF   7E
2736:  MOVLW  04
2738:  MOVWF  7F
273A:  CALL   1296
....................  
....................  
.................... } 
273E:  RETLW  00
....................  
.................... #include "LCDeasy.c" 
.................... ////----------------------------------------------------------------------------//// 
.................... // 	Funciones para la gestion del display LCD de la EasyPIC3 
.................... //	con el compilador de CCS. 
.................... //	Es una adaptación del archivo LCD.c de CCS para las prácticas de la 
.................... //	asignatura, y por tanto no distribuible a usuarios no autorizados. 
.................... //------------------------------------------------------------------------------//// 
....................  
.................... //  lcd_init()   Inicializa el LCD: debe ser llamada antes que las otras funciones. 
.................... // 
.................... //  lcd_putc(c)  Visualiza c en la siguiente posición del display. 
.................... //               Caracteres especiales de control: 
.................... //                      \f  Borrar display 
.................... //                      \n  Saltar a la segunda linea 
.................... //                      \b  Retroceder una posición. 
.................... // 
.................... //  lcd_gotoxy(x,y) Selecciona la nueva posicion de escritura en el display. 
.................... //                  (la esquina superior izquierda es 1,1) 
.................... // 
.................... //  lcd_getc(x,y)   Devuelve el caracter de la posicion x,y del display. 
.................... //			(esta función no va en la EASYPIC3, pues R/W=0) 
.................... // 
.................... //  lcd_send_byte(rs,byte)	escribe byte en el registro de datos(con rs=1) o de 
.................... //				instrucciones (con rs=0). 
.................... //------------------------------------------------------------------------------// 
.................... // Conexion del LCD con el PIC: 
.................... //     RB0 -- 
.................... //     RB1 -- 
.................... //     RB2  rs 
.................... //     RB3  Enable 
.................... //     RB4  D4 
.................... //     RB5  D5 
.................... //     RB6  D6 
.................... //     RB7  D7 
.................... // 
.................... // Los pines D0-D3 del LCD no se usan 
.................... // El pin RB0 del PIC no se usa 
.................... // El pin RB1 no está conectado en la tarjeta, 
.................... // podría ser para r/w 
....................  
.................... // Un-comment the following define to use port B 
.................... #define use_portb_lcd TRUE 		//LINEA DES-COMENTADA---------------- 
....................  
....................  
.................... struct lcd_pin_map {                 // This structure is overlayed 
....................            int unused : 2 ;	//MODIFICADA PARA EASYPIC-------------------- 
.................... 	   //BOOLEAN rw;		//MODIFICADA PARA EASYPIC-------------------- 
.................... 	   BOOLEAN rs;           // on to an I/O port to gain 
....................            BOOLEAN ENABLE;            // access to the LCD pins. 
....................            		           	// The bits are allocated from 
....................            			          // low order up.  ENABLE will 
....................            int     data : 4;         	// be pin B3------------------------- 
....................         } lcd; 
....................  
....................  
.................... #if defined(__PCH__) 
.................... #if defined use_portb_lcd 
....................    #byte lcd = 0xF81                   // This puts the entire structure 
.................... #else 
....................    #byte lcd = 0xF83                   // This puts the entire structure 
.................... #endif 
.................... #else 
.................... #if defined use_portb_lcd 
....................    #byte lcd = 6                  // on to port B (at address 6) 
.................... #else 
....................    #byte lcd = 8                 // on to port D (at address 8) 
.................... #endif 
.................... #endif 
....................  
.................... #if defined use_portb_lcd 
....................    #define set_tris_lcd(x) set_tris_b(x) 
.................... #else 
....................    #define set_tris_lcd(x) set_tris_d(x) 
.................... #endif 
....................  
....................  
.................... #define lcd_type 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #define lcd_line_two 0x40    // LCD RAM address for the second line 
....................  
....................  
.................... BYTE const LCD_INIT_STRING[4] = {0x24 | (lcd_type << 2), 0xF, 1, 6}; 
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................  
....................  
....................                              // The following are used for setting 
....................                              // the I/O port direction register. 
....................  
.................... struct lcd_pin_map const LCD_WRITE = {3,0,0,0}; // For write mode all pins are out 
.................... struct lcd_pin_map const LCD_READ = {3,0,0,15}; // For read mode data pins are in 
....................  
....................  
....................  
.................... BYTE lcd_read_byte() { 
....................       BYTE low,high; 
....................       set_tris_lcd(LCD_READ); 
....................       //////lcd.rw = 1; 
....................       delay_cycles(1); 
....................       lcd.enable = 1; 
....................       delay_cycles(1); 
....................       high = lcd.data; 
....................       lcd.enable = 0; 
....................       delay_cycles(1); 
....................       lcd.enable = 1; 
....................       delay_us(1); 
....................       low = lcd.data; 
....................       lcd.enable = 0; 
....................       set_tris_lcd(LCD_WRITE); 
....................       return( (high<<4) | low); 
.................... } 
....................  
....................  
.................... void lcd_send_nibble( BYTE n ) { 
....................       lcd.data = n; 
*
0D62:  MOVLB  2
0D64:  SWAPF  x88,W
0D66:  ANDLW  F0
0D68:  MOVWF  00
0D6A:  MOVLW  0F
0D6C:  ANDWF  F81,W
0D6E:  IORWF  00,W
0D70:  MOVWF  F81
....................       delay_cycles(1); 
0D72:  NOP   
....................       lcd.enable = 1; 
0D74:  BSF    F81.3
....................       delay_us(2); 
0D76:  CLRWDT
0D78:  NOP   
0D7A:  NOP   
0D7C:  NOP   
....................       lcd.enable = 0; 
0D7E:  BCF    F81.3
.................... } 
0D80:  MOVLB  0
0D82:  RETLW  00
....................  
....................  
.................... void lcd_send_byte( BYTE address, BYTE n ) { 
....................  
....................       lcd.rs = 0; 
*
0DA8:  BCF    F81.2
....................       delay_us(3000); 
0DAA:  CLRWDT
0DAC:  MOVLW  02
0DAE:  MOVLB  2
0DB0:  MOVWF  x87
0DB2:  MOVLB  0
0DB4:  RCALL  0D30
0DB6:  MOVLW  09
0DB8:  MOVLB  2
0DBA:  MOVWF  x87
0DBC:  MOVLW  6D
0DBE:  MOVWF  x88
0DC0:  MOVLB  0
0DC2:  RCALL  0D84
0DC4:  MOVLB  2
0DC6:  DECFSZ x87,F
0DC8:  BRA    0DBC
.................... //      while ( bit_test(lcd_read_byte(),7) ) ; 
....................       lcd.rs = address; 
0DCA:  BTFSS  x85.0
0DCC:  BCF    F81.2
0DCE:  BTFSC  x85.0
0DD0:  BSF    F81.2
....................       delay_cycles(1); 
0DD2:  NOP   
....................       //////////lcd.rw = 0; 
....................       delay_cycles(1); 
0DD4:  NOP   
....................       lcd.enable = 0; 
0DD6:  BCF    F81.3
....................       lcd_send_nibble(n >> 4); 
0DD8:  SWAPF  x86,W
0DDA:  MOVWF  x87
0DDC:  MOVLW  0F
0DDE:  ANDWF  x87,F
0DE0:  MOVFF  287,288
0DE4:  MOVLB  0
0DE6:  RCALL  0D62
....................       lcd_send_nibble(n & 0xf); 
0DE8:  MOVLB  2
0DEA:  MOVF   x86,W
0DEC:  ANDLW  0F
0DEE:  MOVWF  x87
0DF0:  MOVWF  x88
0DF2:  MOVLB  0
0DF4:  RCALL  0D62
.................... } 
0DF6:  RETLW  00
....................  
....................  
.................... void lcd_init() { 
....................     BYTE i; 
....................     set_tris_lcd(LCD_WRITE); 
0DF8:  MOVLW  03
0DFA:  MOVWF  F93
....................     lcd.rs = 0; 
0DFC:  BCF    F81.2
....................     /////lcd.rw = 0; 
....................     lcd.enable = 0; 
0DFE:  BCF    F81.3
....................     delay_ms(50); 
0E00:  MOVLW  32
0E02:  MOVLB  2
0E04:  MOVWF  x87
0E06:  MOVLB  0
0E08:  RCALL  0D30
....................     //for(i=1;i<=3;++i) { 
....................     //   lcd_send_nibble(3); 
....................     //  delay_ms(5); 
....................     //} 
....................     lcd_send_nibble(2); 
0E0A:  MOVLW  02
0E0C:  MOVLB  2
0E0E:  MOVWF  x88
0E10:  MOVLB  0
0E12:  RCALL  0D62
....................     delay_ms(5); 
0E14:  MOVLW  05
0E16:  MOVLB  2
0E18:  MOVWF  x87
0E1A:  MOVLB  0
0E1C:  RCALL  0D30
....................     for(i=0;i<=3;++i) 
0E1E:  CLRF   6D
0E20:  MOVF   6D,W
0E22:  SUBLW  03
0E24:  BNC   0E52
....................        { lcd_send_byte(0,LCD_INIT_STRING[i]); 
0E26:  CLRF   03
0E28:  MOVF   6D,W
0E2A:  MOVFF  FF2,6E
0E2E:  BCF    FF2.7
0E30:  CALL   00A8
0E34:  BTFSC  6E.7
0E36:  BSF    FF2.7
0E38:  MOVWF  6F
0E3A:  MOVLB  2
0E3C:  CLRF   x85
0E3E:  MOVWF  x86
0E40:  MOVLB  0
0E42:  RCALL  0DA8
....................         delay_ms(5); } 
0E44:  MOVLW  05
0E46:  MOVLB  2
0E48:  MOVWF  x87
0E4A:  MOVLB  0
0E4C:  RCALL  0D30
0E4E:  INCF   6D,F
0E50:  BRA    0E20
.................... } 
0E52:  GOTO   5582 (RETURN)
....................  
....................  
.................... void lcd_gotoxy( BYTE x, BYTE y) { 
....................    BYTE address; 
....................  
....................    if(y!=1) 
0E56:  MOVLB  2
0E58:  DECFSZ x82,W
0E5A:  BRA    0E5E
0E5C:  BRA    0E64
....................      address=lcd_line_two; 
0E5E:  MOVLW  40
0E60:  MOVWF  x83
....................    else 
0E62:  BRA    0E66
....................      address=0; 
0E64:  CLRF   x83
....................    address+=x-1; 
0E66:  MOVLW  01
0E68:  SUBWF  x81,W
0E6A:  ADDWF  x83,F
....................    lcd_send_byte(0,0x80|address); 
0E6C:  MOVF   x83,W
0E6E:  IORLW  80
0E70:  MOVWF  x84
0E72:  CLRF   x85
0E74:  MOVWF  x86
0E76:  MOVLB  0
0E78:  RCALL  0DA8
.................... } 
0E7A:  RETLW  00
....................  
.................... void lcd_putc( char c) { 
....................    switch (c) { 
0E7C:  MOVLB  2
0E7E:  MOVF   x80,W
0E80:  XORLW  0C
0E82:  MOVLB  0
0E84:  BZ    0E90
0E86:  XORLW  06
0E88:  BZ    0EA8
0E8A:  XORLW  02
0E8C:  BZ    0EB8
0E8E:  BRA    0EC6
....................      case '\f'   : lcd_send_byte(0,1); 
0E90:  MOVLB  2
0E92:  CLRF   x85
0E94:  MOVLW  01
0E96:  MOVWF  x86
0E98:  MOVLB  0
0E9A:  RCALL  0DA8
....................                    delay_ms(2); 
0E9C:  MOVLW  02
0E9E:  MOVLB  2
0EA0:  MOVWF  x87
0EA2:  MOVLB  0
0EA4:  RCALL  0D30
....................                                            break; 
0EA6:  BRA    0ED6
....................      case '\n'   : lcd_gotoxy(1,2);        break; 
0EA8:  MOVLW  01
0EAA:  MOVLB  2
0EAC:  MOVWF  x81
0EAE:  MOVLW  02
0EB0:  MOVWF  x82
0EB2:  MOVLB  0
0EB4:  RCALL  0E56
0EB6:  BRA    0ED6
....................      case '\b'   : lcd_send_byte(0,0x10);  break; 
0EB8:  MOVLB  2
0EBA:  CLRF   x85
0EBC:  MOVLW  10
0EBE:  MOVWF  x86
0EC0:  MOVLB  0
0EC2:  RCALL  0DA8
0EC4:  BRA    0ED6
....................      default     : lcd_send_byte(1,c);     break; 
0EC6:  MOVLW  01
0EC8:  MOVLB  2
0ECA:  MOVWF  x85
0ECC:  MOVFF  280,286
0ED0:  MOVLB  0
0ED2:  RCALL  0DA8
0ED4:  BRA    0ED6
....................    } 
.................... } 
0ED6:  RETLW  00
....................  
.................... char lcd_getc( BYTE x, BYTE y) { 
....................    char value; 
....................  
....................     lcd_gotoxy(x,y); 
....................     while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................     lcd.rs=1; 
....................     value = lcd_read_byte(); 
....................     lcd.rs=0; 
....................     return(value); 
.................... } 
....................  
.................... #include "1wire.c" 
.................... /***********************1Wire Class***********************/ 
.................... /*Funciones básicas para comunicación con un solo sensor 1wire */ 
.................... /*********************************************************/ 
.................... /*-------1-wire definitions-------*/ 
....................  
.................... #define ONE_WIRE_PIN PIN_A5 //modificar de acuerdo con la tarjeta 
....................  
....................  
.................... /************onewire_reset*************************************************/ 
.................... void onewire_reset()  // OK if just using a single permanently connected device 
.................... { 
....................  output_low(ONE_WIRE_PIN); 
*
1466:  BCF    F92.5
1468:  BCF    F89.5
....................  delay_us( 500 ); // pull 1-wire low for reset pulse 
146A:  CLRWDT
146C:  MOVLW  02
146E:  MOVWF  x83
1470:  MOVLW  F7
1472:  MOVLB  2
1474:  MOVWF  x88
1476:  MOVLB  0
1478:  RCALL  0D84
147A:  DECFSZ x83,F
147C:  BRA    1470
....................  output_float(ONE_WIRE_PIN); // float 1-wire high 
147E:  BSF    F92.5
....................  delay_us( 500 ); // wait-out remaining initialisation window. 
1480:  CLRWDT
1482:  MOVLW  02
1484:  MOVWF  x83
1486:  MOVLW  F7
1488:  MOVLB  2
148A:  MOVWF  x88
148C:  MOVLB  0
148E:  RCALL  0D84
1490:  DECFSZ x83,F
1492:  BRA    1486
....................  output_float(ONE_WIRE_PIN); 
1494:  BSF    F92.5
.................... } 
1496:  RETLW  00
....................  
.................... /*********************** onewire_write() ********************************/ 
.................... /*Esta función escribe un byte en el sensor.*/ 
.................... /* */ 
.................... /*Parametros: byte - el byte a escribir en el 1wire */ 
....................  
.................... void onewire_write(int data) 
.................... { 
....................  int count; 
....................  
....................  for (count=0; count<8; ++count) 
1498:  CLRF   x85
149A:  MOVF   x85,W
149C:  SUBLW  07
149E:  BNC   14D4
....................  { 
....................   output_low(ONE_WIRE_PIN); 
14A0:  BCF    F92.5
14A2:  BCF    F89.5
....................   delay_us( 2 ); // pull 1-wire low to initiate write time-slot. 
14A4:  CLRWDT
14A6:  NOP   
14A8:  NOP   
14AA:  NOP   
....................   output_bit(ONE_WIRE_PIN, shift_right(&data,1,0)); // set output bit on 1-wire 
14AC:  BCF    FD8.0
14AE:  RRCF   x84,F
14B0:  BC    14B6
14B2:  BCF    F89.5
14B4:  BRA    14B8
14B6:  BSF    F89.5
14B8:  BCF    F92.5
....................   delay_us( 60 ); // wait until end of write slot. 
14BA:  CLRWDT
14BC:  MOVLW  27
14BE:  MOVWF  00
14C0:  DECFSZ 00,F
14C2:  BRA    14C0
14C4:  NOP   
....................   output_float(ONE_WIRE_PIN); // set 1-wire high again, 
14C6:  BSF    F92.5
....................   delay_us( 2 ); // for more than 1us minimum. 
14C8:  CLRWDT
14CA:  NOP   
14CC:  NOP   
14CE:  NOP   
....................  } 
14D0:  INCF   x85,F
14D2:  BRA    149A
.................... } 
14D4:  RETLW  00
....................  
.................... /*********************** read1wire() *********************************/ 
.................... /*Esta función lee un dato de 8 bits del sensor.*/ 
.................... /*Devuelve: dato de 8-bit (1-byte)*/ 
....................  
.................... int onewire_read() 
.................... { 
....................  int count, data; 
....................  
....................  for (count=0; count<8; ++count) 
*
1B44:  CLRF   7E
1B46:  MOVF   7E,W
1B48:  SUBLW  07
1B4A:  BNC   1B86
....................  { 
....................   output_low(ONE_WIRE_PIN); 
1B4C:  BCF    F92.5
1B4E:  BCF    F89.5
....................   delay_us( 2 ); // pull 1-wire low to initiate read time-slot. 
1B50:  CLRWDT
1B52:  NOP   
1B54:  NOP   
1B56:  NOP   
....................   output_float(ONE_WIRE_PIN); // now let 1-wire float high, 
1B58:  BSF    F92.5
....................   delay_us( 8 ); // let device state stabilise, 
1B5A:  CLRWDT
1B5C:  MOVLW  04
1B5E:  MOVWF  00
1B60:  DECFSZ 00,F
1B62:  BRA    1B60
1B64:  NOP   
1B66:  NOP   
....................   shift_right(&data,1,input(ONE_WIRE_PIN)); // and load result. 
1B68:  BSF    F92.5
1B6A:  BTFSC  F80.5
1B6C:  BRA    1B72
1B6E:  BCF    FD8.0
1B70:  BRA    1B74
1B72:  BSF    FD8.0
1B74:  RRCF   7F,F
....................   delay_us( 120 ); // wait until end of read slot. 
1B76:  CLRWDT
1B78:  MOVLW  4F
1B7A:  MOVWF  00
1B7C:  DECFSZ 00,F
1B7E:  BRA    1B7C
1B80:  NOP   
....................  } 
1B82:  INCF   7E,F
1B84:  BRA    1B46
....................  
....................  return( data ); 
1B86:  MOVFF  7F,01
.................... } 
1B8A:  RETLW  00
....................  
.................... /////////////////////////////////////////////////////////////////// 
....................  
....................  
....................  
.................... #include "ds1820.c" 
....................  
.................... /***************************************************/ 
.................... /*Driver básico del termómetro/termostato ds1820.c */ 
.................... // 
.................... //Realiza una secuencia completa de incialización, conversión 
.................... //de temperatura, y lectura del (único) sensor de temperatura 
.................... //con alimentación externa (no parásita). 
.................... // 
.................... /***************************************************/ 
....................  
.................... float ds1820_read() 
.................... { 
....................  int8 busy=0, temp1, temp2; 
*
1D38:  CLRF   75
....................  signed int16 temp3; 
....................  float result; 
....................  
....................  onewire_reset();     // Cada acceso al sensor debe iniciarse con reset 
1D3A:  CALL   1466
....................  onewire_write(0xCC); //Instrucción SKIP ROM (selecciona todos los dispositivos del 1wire) 
1D3E:  MOVLW  CC
1D40:  MOVWF  x84
1D42:  CALL   1498
....................  onewire_write(0x44); //Orden de inicio de conversión de temperatura 
1D46:  MOVLW  44
1D48:  MOVWF  x84
1D4A:  CALL   1498
....................  
....................  while (busy == 0) 	//el sensor mantiene la linea a 0 mientras realiza la conversión 
....................   busy = onewire_read(); //y la deja a 1 al completarla 
1D4E:  MOVF   75,F
1D50:  BNZ   1D5A
1D52:  RCALL  1B44
1D54:  MOVFF  01,75
1D58:  BRA    1D4E
....................  
....................  onewire_reset(); 
1D5A:  CALL   1466
....................  onewire_write(0xCC); 
1D5E:  MOVLW  CC
1D60:  MOVWF  x84
1D62:  CALL   1498
....................  onewire_write(0xBE); //Envío de la orden READ SCRATCHPAD (lectura de la memoria temporal) 
1D66:  MOVLW  BE
1D68:  MOVWF  x84
1D6A:  CALL   1498
....................  temp1 = onewire_read(); //lectura del LSB de la temperatura 
1D6E:  RCALL  1B44
1D70:  MOVFF  01,76
....................  temp2 = onewire_read(); //lectura del MSB de la temperatura 
1D74:  RCALL  1B44
1D76:  MOVFF  01,77
....................  
....................  temp3 = make16(temp2, temp1); // 
1D7A:  MOVFF  77,79
1D7E:  MOVFF  76,78
....................  result = (float) temp3 / 2.0;   //Calculation for DS18S20 with 0.5 deg C resolution 
1D82:  MOVFF  79,7F
1D86:  MOVFF  78,7E
1D8A:  BRA    1B8C
1D8C:  MOVFF  00,7E
1D90:  MOVFF  01,7F
1D94:  MOVFF  02,80
1D98:  MOVFF  03,81
1D9C:  MOVFF  03,288
1DA0:  MOVFF  02,287
1DA4:  MOVFF  01,286
1DA8:  MOVFF  00,285
1DAC:  MOVLB  2
1DAE:  CLRF   x8C
1DB0:  CLRF   x8B
1DB2:  CLRF   x8A
1DB4:  MOVLW  80
1DB6:  MOVWF  x89
1DB8:  MOVLB  0
1DBA:  RCALL  1BD8
1DBC:  MOVFF  03,7D
1DC0:  MOVFF  02,7C
1DC4:  MOVFF  01,7B
1DC8:  MOVFF  00,7A
.................... // result = (float) temp3 / 16.0;  //Calculation for DS18B20 with 0.1 deg C resolution 
....................  
....................  delay_ms(200); 
1DCC:  MOVLW  C8
1DCE:  MOVLB  2
1DD0:  MOVWF  x87
1DD2:  MOVLB  0
1DD4:  CALL   0D30
....................  return(result); 
1DD8:  MOVFF  7A,00
1DDC:  MOVFF  7B,01
1DE0:  MOVFF  7C,02
1DE4:  MOVFF  7D,03
.................... } 
1DE8:  RETLW  00
....................  
.................... //Establece la temperatura máxima y mínima para el termostato 
.................... void ds1820_establecer_TH_TL(float th, float tl){ 
....................    float th2, tl2; 
....................    onewire_reset(); 
*
15CE:  RCALL  1466
....................    onewire_write(0xCC); //Accedemos a todos los dispositivos 
15D0:  MOVLW  CC
15D2:  MOVWF  x84
15D4:  RCALL  1498
....................    onewire_write(0x4E); //Envío de la orden Write Scratchpad (escritura en la memoria principal) 
15D6:  MOVLW  4E
15D8:  MOVWF  x84
15DA:  RCALL  1498
....................    th2=2*th; 
15DC:  MOVLB  2
15DE:  CLRF   x9E
15E0:  CLRF   x9D
15E2:  CLRF   x9C
15E4:  MOVLW  80
15E6:  MOVWF  x9B
15E8:  MOVFF  76,2A2
15EC:  MOVFF  75,2A1
15F0:  MOVFF  74,2A0
15F4:  MOVFF  73,29F
15F8:  MOVLB  0
15FA:  RCALL  14D6
15FC:  MOVFF  03,7E
1600:  MOVFF  02,7D
1604:  MOVFF  01,7C
1608:  MOVFF  00,7B
....................    tl2=2*tl; 
160C:  MOVLB  2
160E:  CLRF   x9E
1610:  CLRF   x9D
1612:  CLRF   x9C
1614:  MOVLW  80
1616:  MOVWF  x9B
1618:  MOVFF  7A,2A2
161C:  MOVFF  79,2A1
1620:  MOVFF  78,2A0
1624:  MOVFF  77,29F
1628:  MOVLB  0
162A:  RCALL  14D6
162C:  MOVFF  03,82
1630:  MOVFF  02,81
1634:  MOVFF  01,80
1638:  MOVFF  00,7F
....................    onewire_write((int8)th2); 
163C:  MOVFF  7E,86
1640:  MOVFF  7D,85
1644:  MOVFF  7C,84
1648:  MOVFF  7B,83
164C:  RCALL  142C
164E:  MOVFF  01,83
1652:  MOVFF  01,84
1656:  RCALL  1498
....................    onewire_write((int8)tl2); 
1658:  MOVFF  82,86
165C:  MOVFF  81,85
1660:  MOVFF  80,84
1664:  MOVFF  7F,83
1668:  RCALL  142C
166A:  MOVFF  01,83
166E:  MOVFF  01,84
1672:  RCALL  1498
....................  
....................    //Copiamos los valores en la ROM 
....................    onewire_reset(); 
1674:  RCALL  1466
....................    onewire_write(0xCC); 
1676:  MOVLW  CC
1678:  MOVWF  x84
167A:  RCALL  1498
....................    onewire_write(0x48); 
167C:  MOVLW  48
167E:  MOVWF  x84
1680:  RCALL  1498
....................  
....................    //Dejamos un poco de tiempo para que se escriba en la EEPROM 
....................    //El tiempo ha sido calculado a partir de la simulación en Proteus 
....................    delay_us(10600); 
1682:  CLRWDT
1684:  MOVLW  0A
1686:  MOVLB  2
1688:  MOVWF  x87
168A:  MOVLB  0
168C:  CALL   0D30
1690:  MOVLW  0D
1692:  MOVWF  x83
1694:  MOVLW  2C
1696:  MOVLB  2
1698:  MOVWF  x88
169A:  MOVLB  0
169C:  CALL   0D84
16A0:  DECFSZ x83,F
16A2:  BRA    1694
....................  
.................... } 
16A4:  RETLW  00
....................  
.................... //Intenta buscar la alarma del único sensor conectado por si ha saltado 
.................... //el termostato. Si lo ha hecho, devuelve TRUE, y en caso contrario, FALSE. 
.................... int1 ds1820_termostato(){ 
....................    int busy=0; 
*
1DEA:  CLRF   6D
....................    int1 bit1, bit2; 
....................  
....................    //Primero forzamos la conversión de la temperatura 
....................    onewire_reset(); 
1DEC:  CALL   1466
....................    onewire_write(0xCC); 
1DF0:  MOVLW  CC
1DF2:  MOVWF  x84
1DF4:  CALL   1498
....................    onewire_write(0x44); 
1DF8:  MOVLW  44
1DFA:  MOVWF  x84
1DFC:  CALL   1498
....................  
....................    while(busy == 0) 
....................       busy = onewire_read(); 
1E00:  MOVF   6D,F
1E02:  BNZ   1E0C
1E04:  RCALL  1B44
1E06:  MOVFF  01,6D
1E0A:  BRA    1E00
....................  
....................    onewire_reset(); 
1E0C:  CALL   1466
....................    onewire_write(0xEC); //Buscamos la alarma de algún dispositivo (función ALARM SEARCH) 
1E10:  MOVLW  EC
1E12:  MOVWF  x84
1E14:  CALL   1498
....................  
....................    //Leemos dos bits consecutivos. Si el dispositivo tiene el flag de alarma activado, escribirá 
....................    //en la línea el bit más bajo de su dirección ROM y, después, su complemento. Si no, no hará 
....................    //nada. Por eso, si ambos bits leídos son diferentes, la alarma estará activada, mientras que 
....................    //si son iguales, no lo estarán. No es necesario continuar leyendo toda la dirección del dispositivo. 
....................    output_low(ONE_WIRE_PIN); 
1E18:  BCF    F92.5
1E1A:  BCF    F89.5
....................    delay_us( 2 ); 
1E1C:  CLRWDT
1E1E:  NOP   
1E20:  NOP   
1E22:  NOP   
....................    output_float(ONE_WIRE_PIN); 
1E24:  BSF    F92.5
....................    delay_us( 8 ); 
1E26:  CLRWDT
1E28:  MOVLW  04
1E2A:  MOVWF  00
1E2C:  DECFSZ 00,F
1E2E:  BRA    1E2C
1E30:  NOP   
1E32:  NOP   
....................    bit1 = input(ONE_WIRE_PIN); //Leemos el bit menos significativo de la dirección ROM 
1E34:  BSF    F92.5
1E36:  BCF    6E.0
1E38:  BTFSC  F80.5
1E3A:  BSF    6E.0
....................    delay_us( 120 ); 
1E3C:  CLRWDT
1E3E:  MOVLW  4F
1E40:  MOVWF  00
1E42:  DECFSZ 00,F
1E44:  BRA    1E42
1E46:  NOP   
....................  
....................    output_low(ONE_WIRE_PIN); 
1E48:  BCF    F92.5
1E4A:  BCF    F89.5
....................    delay_us( 2 ); 
1E4C:  CLRWDT
1E4E:  NOP   
1E50:  NOP   
1E52:  NOP   
....................    output_float(ONE_WIRE_PIN); 
1E54:  BSF    F92.5
....................    delay_us( 8 ); 
1E56:  CLRWDT
1E58:  MOVLW  04
1E5A:  MOVWF  00
1E5C:  DECFSZ 00,F
1E5E:  BRA    1E5C
1E60:  NOP   
1E62:  NOP   
....................    bit2 = input(ONE_WIRE_PIN); //Leemos su complemento (si la alarma está activada) 
1E64:  BSF    F92.5
1E66:  BCF    6E.1
1E68:  BTFSC  F80.5
1E6A:  BSF    6E.1
....................    delay_us( 120 ); 
1E6C:  CLRWDT
1E6E:  MOVLW  4F
1E70:  MOVWF  00
1E72:  DECFSZ 00,F
1E74:  BRA    1E72
1E76:  NOP   
....................  
....................    if(bit1 != bit2) 
1E78:  CLRF   00
1E7A:  BTFSC  6E.1
1E7C:  BSF    00.0
1E7E:  MOVF   6E,W
1E80:  XORWF  00,W
1E82:  ANDLW  01
1E84:  BZ    1E8E
....................       return TRUE; 
1E86:  MOVLW  01
1E88:  MOVWF  01
1E8A:  BRA    1E94
....................    else 
1E8C:  BRA    1E94
....................       return FALSE; 
1E8E:  MOVLW  00
1E90:  MOVWF  01
1E92:  BRA    1E94
....................  
....................  
.................... } 
1E94:  RETLW  00
....................  
.................... ////////////////////////////////////////////////////////////////////////////////////// 
....................  
....................  
....................  
....................  
.................... #use fast_io(A) 
.................... #use fast_io(B) 
.................... #use fast_io(C) 
.................... #use fast_io(D) 
....................  
.................... int1 temperatura_caldera_superada; //Control de la histéresis en la caldera 
.................... int1 temp_habitacion_superada;  //Control de la histéresis del ambiente 
.................... int1 encendido_por_alarma; //Indica si la última vez que se encendió fue en respuesta o no a una alarma 
.................... int1 toca_encender; //Indica si la próxima alarma es de encendido o de apagado 
.................... float termostato; //Temperatura límite de la vivienda 
.................... float termostato_provisional; //Valor de termostato provisional para cuando saltan las alarmas 
.................... float temperatura; //Temperatura de la vivienda 
.................... float histeresis_vivienda = 0.5; //Intervalo de histéresis de la vivienda 
....................  
.................... //Estructura de un intervalo de programación 
.................... typedef struct 
.................... { 
....................    unsigned int horas_inicio;    //Hora a la que se inicia el encendido 
....................    unsigned int minutos_inicio;  // 
....................    unsigned int horas_fin;       //Hora a la que se apaga el sistema 
....................    unsigned int minutos_fin;     // 
....................    unsigned int termostato;      //Termostato vigente en ese intervalo 
.................... }programacion; 
....................  
.................... //Vector que incluye todas las programaciones horarias 
.................... //La información se distribuye en grupos de 5: hora_inicio, minutos_inicio, 
.................... //hora_fin, minutos_fin y termostato. 
.................... programacion programaciones[3]; 
....................  
.................... //Programación en curso en este momento 
.................... programacion prg; 
.................... int num_intervalos; //Número de intervalos de programación con los que contamos 
.................... int posicion_alarmas; //Variable que apunta a la posición de la próxima alarma 
....................  
.................... //Estructura para leer el tiempo del reloj 
.................... date_time_t tiempo; 
....................  
.................... //Registro de la hora en la que se enciende el sistema 
.................... int hora_encendido; 
.................... int minutos_encendido; 
....................  
.................... //Registro de la hora en la que se enciende la caldera 
.................... //Se supone que el encendido de la caldera se realiza en intervalos cortos, 
.................... //que se alcanza la temperatura deseada relativamente rápido. 
.................... int hora_caldera; 
.................... int minutos_caldera; 
.................... int segundos_caldera; 
.................... //Tiempo total de encendido de la caldera en cada intervalo de encendido del sistema 
.................... long t_total_caldera; 
....................  
.................... //Variables para el registro en memoria 
.................... unsigned int num_registros;  //Número de registros de fechas almacenados 
.................... int anno_actual;             //Año en el que estamos (de 0 a 99) 
.................... int anno_actual_0_to_3;      //Año en el que estamos (de 0 a 3, a pesar de 
....................                               //que la variable se llame 1_to_3 por razones "históricas") 
....................  
.................... //Flag para activar las interrupciones de interfaz con el teclado y alarma 
.................... int1 lcd_int; 
.................... int1 alarma_int; 
....................  
....................  
.................... //Listado de métodos utilizados 
.................... //***************************** 
.................... //Mostramos aquí una breve explicación de cada uno. El interior de los métodos está 
.................... //descrito después del método main. 
....................  
.................... //comprobar_temperatura() -> Devuelve TRUE si la temperatura de la habitación es menor 
.................... //que la indicada en el termostato, y FALSE en caso contrario. 
.................... int comprobar_temperatura(); 
.................... //comp_caldera() -> Devuelve TRUE si debemos apagar la caldera. Esta función tiene en cuenta 
.................... //cierta histéresis para evitar ciclos continuos de apagado-encendido. 
.................... int comp_caldera(); 
.................... //mostrar_temperatura() -> Muestra en la pantalla LCD la temperatura actual y la hora. 
.................... void mostrar_temperatura(); 
.................... //encender_sistema() -> Realiza todas las operaciones necesarias para el encendido 
.................... //del sistema, como registro del tiempo de inicio. 
.................... void encender_sistema(); 
.................... //apagar_sistema() -> Realiza todas las operaciones necesarias para el apagado 
.................... //del sistema, como el almacenamiento de los datos necesarios en memoria. 
.................... void apagar_sistema(); 
.................... //encender_caldera() -> Enciende la caldera, almacenando el tiempo de encendido en 
.................... //las variables correspondientes. 
.................... void encender_caldera(); 
.................... //apagar_caldera() -> Apaga la caldera, almacenando el tiempo que ha estado encendida. 
.................... void apagar_caldera(); 
.................... //buscar_numero(int led_unidades, int min, int max, int valor_inicial) -> Busca un número introducido con los 
.................... //botones + y - y se va mostrando el valor en la posición led_unidades del display (siempre en la fila 2). El 
.................... //rango de variación del valor está limitado por el intervalo [min,max]. Valor_inicial es el valor con el que 
.................... //se muestra la variable al principio. Si se pulsa SI, se aprueba el valor que aparece, y si aparece NO, se 
.................... //devuelve el código correspondiente. 
.................... int buscar_numero(int led_unidades, int min, int max, int valor_inicial); 
.................... //comprobar_hora(int hora1, int min1, int hora2, int min2) -> Devuelve TRUE 
.................... //si hora1:min1 corresponde a un tiempo menor o igual que hora2:min2. 
.................... int comprobar_hora(int hora1,int min1, int hora2, int min2); 
.................... //ordenar_programaciones -> Ordena las programaciones por orden creciente de hora. 
.................... void ordenar_programaciones(); 
.................... //diferencia_tiempo(int hora1, int min1, int hora2, int min2) -> Calcula la 
.................... //diferencia de tiempo en minutos entre hora1:min1 y hora2:min2. 
.................... //Si hora1:min1 es mayor que hora2:min2, los considera en días consecutivos. 
.................... long diferencia_tiempo(int hora1,int min1, int hora2, int min2); 
.................... //diferencia_tiempo_sec(int hora1, int min1, int sec1, int hora2, int min2, int sec2) -> 
.................... //Calcula la diferencia de tiempo en segundos entre hora1:min1:sec1 y hora2:min2:sec2 
.................... //Si hora1:min1:sec1 es mayor que hora2:min2:sec2, los considera en días consecutivos 
.................... long diferencia_tiempo_sec(int hora1,int min1, int sec1, int hora2, int min2, int sec2); 
.................... //seleccionar_alarma() -> Selecciona la alarma más cercana a la hora en la que nos encontramos, 
.................... //en el caso de que las hubiese. 
.................... void seleccionar_alarma(); 
.................... //programar_proxima_alarma() -> Programa la próxima alarma que tendrá lugar. 
.................... //Siempre se tratará de una alarma para el encendido. 
.................... void programar_proxima_alarma(); 
.................... //grabar_programaciones() -> Graba los datos de las programaciones en la memoria EEPROM. 
.................... void grabar_programaciones(); 
.................... //leer_programaciones() -> Recupera de la memoria los datos de las programaciones. 
.................... void leer_programaciones(); 
.................... //representar_registros() -> Representa la información de los registros en el puerto RS232 
.................... //Nunca guardamos la información de los registros para no saturar la memoria y 
.................... //aprovechamos la representación de los datos para calcular medias y demás y así 
.................... //no tener que realizar un segundo barrido de lectura en memoria. 
.................... void representar_registros(); 
.................... //inicializacion() -> Gestiona la inicialización del sistema por parte del técnico. 
.................... void inicializacion(); 
....................  
.................... //-------------------------------------------------------------------------------- 
....................  
.................... //Gestión de interrupciones de activación de la alarma 
.................... #INT_EXT 
.................... alarma(){ 
....................    clear_interrupt(INT_EXT); 
*
0D1C:  BCF    FF2.1
....................    //Se activa el flag correspondiente 
....................    alarma_int = TRUE; 
0D1E:  BSF    1E.5
.................... } 
....................  
.................... //Gestión de interrupciones de activación de la interfaz de usuario 
0D20:  BCF    FF2.1
0D22:  GOTO   0064
.................... #INT_EXT1 
.................... activacion_led(){ 
....................    clear_interrupt(INT_EXT1); 
0D26:  BCF    FF0.0
....................    //Se activa el flag correspondiente 
....................    lcd_int = TRUE; 
0D28:  BSF    1E.4
.................... } 
....................  
.................... //*********************************************************** 
.................... //Método main 
.................... //*********************************************************** 
0D2A:  BCF    FF0.0
0D2C:  GOTO   0064
.................... main() 
.................... { 
*
5522:  CLRF   FF8
5524:  BCF    FD0.7
5526:  BSF    0D.7
5528:  CLRF   FEA
552A:  CLRF   FE9
552C:  BCF    FB8.3
552E:  MOVLW  19
5530:  MOVWF  FAF
5532:  MOVLW  22
5534:  MOVWF  FAC
5536:  MOVLW  90
5538:  MOVWF  FAB
553A:  MOVF   FC1,W
553C:  ANDLW  C0
553E:  IORLW  0F
5540:  MOVWF  FC1
5542:  MOVLW  07
5544:  MOVWF  FB4
5546:  CLRF   18
5548:  CLRF   19
554A:  MOVLW  01
554C:  MOVWF  1A
554E:  CLRF   1B
5550:  CLRF   1C
5552:  CLRF   1D
5554:  MOVLW  7E
5556:  MOVWF  2B
5558:  CLRF   2C
555A:  CLRF   2D
555C:  CLRF   2E
....................    //Variable auxiliar 
....................    int aux; 
....................  
....................    //Determinamos que las patilla de interrupción se activen al pasar de alta a baja 
....................    ext_int_edge(0, H_TO_L); 
555E:  BCF    FF1.6
....................    ext_int_edge(1, H_TO_L); 
5560:  BCF    FF1.5
....................     
....................    clear_interrupt(INT_EXT); 
5562:  BCF    FF2.1
....................    clear_interrupt(INT_EXT1); 
5564:  BCF    FF0.0
....................  
....................    //Inicializamos salidas 
....................    //Comenzamos con todo apagado (sistema, motor y caldera) 
....................    sistema_encendido = FALSE; 
5566:  BCF    F83.2
....................    motor = FALSE; 
5568:  BCF    F83.1
....................    caldera_encendida = FALSE; 
556A:  BCF    F83.0
....................    encendido_por_alarma = FALSE; 
556C:  BCF    1E.2
....................    t_total_caldera = 0; //El tiempo total de encendido de la caldera también lo ponemos a 0 
556E:  CLRF   52
5570:  CLRF   51
....................  
....................    //Establecemos el estado de los puertos como entradas o salidas 
....................    set_tris_b(0x03); 
5572:  MOVLW  03
5574:  MOVWF  F93
....................    set_tris_d(0x00); 
5576:  MOVLW  00
5578:  MOVWF  F95
....................    set_tris_c(0x27); 
557A:  MOVLW  27
557C:  MOVWF  F94
....................  
....................    //Inicializamos la pantalla lcd 
....................    lcd_init(); 
557E:  GOTO   0DF8
....................  
....................    //----------------------------------------------------------- 
....................    //Rutina de inicialización del sistema por parte del técnico 
....................    //----------------------------------------------------------- 
....................    inicializacion(); 
5582:  GOTO   16A6
....................  
....................    //Mostramos un mensaje de inicio 
....................    lcd_send_byte(LCD_ORDEN, LCD_CLEAR); 
5586:  MOVLB  2
5588:  CLRF   x85
558A:  MOVLW  01
558C:  MOVWF  x86
558E:  MOVLB  0
5590:  CALL   0DA8
....................    lcd_send_byte(LCD_ORDEN, LCD_NO_CURSOR); 
5594:  MOVLB  2
5596:  CLRF   x85
5598:  MOVLW  0C
559A:  MOVWF  x86
559C:  MOVLB  0
559E:  CALL   0DA8
....................    printf(lcd_putc, "Inicializando..."); 
55A2:  CLRF   6D
55A4:  MOVF   6D,W
55A6:  CALL   00C6
55AA:  IORLW  00
55AC:  BZ    55BC
55AE:  INCF   6D,F
55B0:  MOVLB  2
55B2:  MOVWF  x80
55B4:  MOVLB  0
55B6:  CALL   0E7C
55BA:  BRA    55A4
....................  
....................    //Propiedades de conversión analógico digital 
....................    //Caracterizamos los puertos A0 a A3 como entradas analógicas 
....................    setup_adc_ports(AN0_TO_AN3); 
55BC:  MOVF   FC1,W
55BE:  ANDLW  C0
55C0:  IORLW  0B
55C2:  MOVWF  FC1
....................    //Definimos el reloj de conversión 
....................    setup_adc(adc_clock_div_32); 
55C4:  MOVF   FC0,W
55C6:  ANDLW  C0
55C8:  IORLW  02
55CA:  MOVWF  FC0
55CC:  BCF    FC0.7
55CE:  BSF    FC2.0
....................  
....................    /* 
....................    //El siguiente fragmento de código se descomentaría en el caso de que quiera obviarse la fase 
....................    //de inicialización del sistema y quieran leerse datos conservados en memoria, si, por ejemplo, 
....................    //ya tenemos el reloj configurado. 
....................    //******************************************************************************** 
....................  
....................    //Recuperación de datos de la memoria 
....................    //Recuperamos a partir de la dirección eeprom_termostato los datos en 
....................    //el siguiente orden: termostato, número de intervalos de alarma, número de registros 
....................    //de encendido de la caldera, año actual en valores de 0 a 99 y año actual en valores de 0 a 3. 
....................    termostato = read_eeprom(eeprom_termostato); 
....................    num_intervalos = read_eeprom(eeprom_num_intervalos); 
....................    num_registros = read_eeprom(eeprom_num_registros); 
....................    anno_actual = read_eeprom(eeprom_anno_actual); 
....................    anno_actual_0_to_3 = read_eeprom(eeprom_anno_0_to_3); 
....................  
....................  
....................    //Lee las programaciones de alarmas guardadas en memoria 
....................    leer_programaciones(); 
....................  
....................  
....................    //Comprobamos si hay alarmas programadas en memoria 
....................    if(num_intervalos!=0) 
....................    { 
....................       //Si las hay, seleccionamos la siguiente y programamos su activación 
....................       seleccionar_alarma(); 
....................       programar_proxima_alarma(); 
....................       toca_encender = TRUE; 
....................    }else 
....................    { 
....................       //Si no, simplemente iniciamos la cuenta del reloj 
....................       PCF8583_write_byte(PCF8583_CTRL_STATUS_REG, 
....................                               PCF8583_START_COUNTING); 
....................    } 
....................  
....................    */ 
....................  
....................  
....................    //Leemos la temperatura 
....................    temperatura = ds1820_read(); 
55D0:  CALL   1D38
55D4:  MOVFF  03,2A
55D8:  MOVFF  02,29
55DC:  MOVFF  01,28
55E0:  MOVFF  00,27
....................    if(!ds1820_termostato()) 
55E4:  CALL   1DEA
55E8:  MOVF   01,F
55EA:  BNZ   5646
....................    { 
....................       //Si supera el valor del termostato, lo indicamos con el flag 
....................       temp_habitacion_superada = TRUE; 
55EC:  BSF    1E.1
....................       //Tendremos que establecer un nuevo termostato teniendo en cuenta la histéresis de la temperatura 
....................       termostato = termostato - histeresis_vivienda; 
55EE:  BSF    FD8.1
55F0:  MOVFF  22,282
55F4:  MOVFF  21,281
55F8:  MOVFF  20,280
55FC:  MOVFF  1F,27F
5600:  MOVFF  2E,286
5604:  MOVFF  2D,285
5608:  MOVFF  2C,284
560C:  MOVFF  2B,283
5610:  CALL   1E96
5614:  MOVFF  03,22
5618:  MOVFF  02,21
561C:  MOVFF  01,20
5620:  MOVFF  00,1F
....................       //Guardamos el dato en el sensor 
....................       //La TH la configuramos con un valor muy alto (127.5ºC) 
....................       ds1820_establecer_TH_TL(127.5, termostato); 
5624:  CLRF   76
5626:  CLRF   75
5628:  MOVLW  7F
562A:  MOVWF  74
562C:  MOVLW  85
562E:  MOVWF  73
5630:  MOVFF  22,7A
5634:  MOVFF  21,79
5638:  MOVFF  20,78
563C:  MOVFF  1F,77
5640:  CALL   15CE
....................    }else 
5644:  BRA    5648
....................       //Si no se supera, se indica también 
....................       temp_habitacion_superada = FALSE; 
5646:  BCF    1E.1
....................  
....................  
....................    //Asumimos que en principio la temperatura de la caldera no ha sido superada 
....................    temperatura_caldera_superada = FALSE; 
5648:  BCF    1E.0
....................    if(comp_caldera()) 
564A:  CALL   21BE
564E:  MOVF   01,F
5650:  BZ    5654
....................       //Si la temperatura del agua en la caldera supera el termostato, activamos el flag 
....................       temperatura_caldera_superada = TRUE; 
5652:  BSF    1E.0
....................  
....................    //Desactivamos los flag de las interrupciones 
....................    alarma_int = lcd_int = FALSE; 
5654:  BCF    1E.4
5656:  BCF    1E.5
....................  
....................  
....................  
....................    //Activamos las interrupciones del puerto B0 y B1 
....................    enable_interrupts(INT_EXT); 
5658:  BSF    FF2.4
....................    enable_interrupts(INT_EXT1); 
565A:  BSF    FF0.3
....................    enable_interrupts(GLOBAL); 
565C:  MOVLW  C0
565E:  IORWF  FF2,F
....................  
....................    //Repetimos la siguiente rutina hasta que se desconecte el micro 
....................    while(1){ 
....................       inicio: 
....................       //Inhabilitamos el perro guardián para que no interfiera con las gestión de interrupciones y 
....................       //con la medida de la temperatura 
....................       setup_wdt(WDT_OFF); 
5660:  BCF    FD1.0
....................        
....................       clear_interrupt(INT_EXT); 
5662:  BCF    FF2.1
....................       clear_interrupt(INT_EXT1); 
5664:  BCF    FF0.0
....................  
....................       //Si la interrupción de alarma se activa, gestionamos el proceso 
....................       if(alarma_int) 
5666:  BTFSS  1E.5
5668:  BRA    581C
....................       { 
....................          //Variables para almacenar el tiempo 
....................          int hora, minutos; 
....................  
....................          //Desactivamos interrupciones 
....................          disable_interrupts(GLOBAL); 
566A:  BCF    FF2.6
566C:  BCF    FF2.7
566E:  BTFSC  FF2.7
5670:  BRA    566C
....................          clear_interrupt(INT_EXT); 
5672:  BCF    FF2.1
....................  
....................          //Desactivamos el flag de la alarma en el PCF8583 
....................          PCF8583_write_byte(PCF8583_CTRL_STATUS_REG, 
....................                                  PCF8583_START_COUNTING); 
5674:  CLRF   7E
5676:  CLRF   7F
5678:  CALL   1296
....................  
....................          if(toca_encender) 
567C:  BTFSS  1E.3
567E:  BRA    578A
....................          { 
....................             if(!sistema_encendido) 
5680:  BTFSC  F83.2
5682:  BRA    576C
....................             { 
....................                //Ejecutamos esto si se trata de una alarma de encendido y el sistema 
....................                //está apagado. 
....................                //Actualizamos el termostato, guardando el valor que había ya (teniendo 
....................                //en cuenta la histéresis) 
....................                if(temp_habitacion_superada) 
5684:  BTFSS  1E.1
5686:  BRA    56C0
....................                   termostato_provisional = termostato + histeresis_vivienda; 
5688:  BCF    FD8.1
568A:  MOVFF  22,282
568E:  MOVFF  21,281
5692:  MOVFF  20,280
5696:  MOVFF  1F,27F
569A:  MOVFF  2E,286
569E:  MOVFF  2D,285
56A2:  MOVFF  2C,284
56A6:  MOVFF  2B,283
56AA:  CALL   1E96
56AE:  MOVFF  03,26
56B2:  MOVFF  02,25
56B6:  MOVFF  01,24
56BA:  MOVFF  00,23
....................                else 
56BE:  BRA    56D0
....................                   termostato_provisional = termostato; 
56C0:  MOVFF  22,26
56C4:  MOVFF  21,25
56C8:  MOVFF  20,24
56CC:  MOVFF  1F,23
....................                termostato = prg.termostato; 
56D0:  MOVLB  2
56D2:  CLRF   x86
56D4:  MOVFF  42,285
56D8:  MOVLB  0
56DA:  CALL   2110
56DE:  MOVFF  03,22
56E2:  MOVFF  02,21
56E6:  MOVFF  01,20
56EA:  MOVFF  00,1F
....................                //Grabamos el termostato en el sensor como valor TL 
....................                ds1820_establecer_TH_TL(127.5, termostato); 
56EE:  CLRF   76
56F0:  CLRF   75
56F2:  MOVLW  7F
56F4:  MOVWF  74
56F6:  MOVLW  85
56F8:  MOVWF  73
56FA:  MOVFF  22,7A
56FE:  MOVFF  21,79
5702:  MOVFF  20,78
5706:  MOVFF  1F,77
570A:  CALL   15CE
....................  
....................                //Si la temperatura no está superada, desactivamos el flag por si acaso 
....................                //lo estaba con el otro valor de termostato. 
....................                if(ds1820_termostato()) 
570E:  CALL   1DEA
5712:  MOVF   01,F
5714:  BZ    5718
....................                   temp_habitacion_superada = FALSE; 
5716:  BCF    1E.1
....................  
....................                //Determinamos la próxima alarma como de apagado 
....................                toca_encender = FALSE; 
5718:  BCF    1E.3
....................  
....................                //Activamos el flag de sistema encendido por alarma 
....................                encendido_por_alarma = TRUE; 
571A:  BSF    1E.2
....................                //Mostramos un mensaje 
....................                lcd_send_byte(LCD_ORDEN,LCD_CLEAR); 
571C:  MOVLB  2
571E:  CLRF   x85
5720:  MOVLW  01
5722:  MOVWF  x86
5724:  MOVLB  0
5726:  CALL   0DA8
....................                printf(lcd_putc, "  Encendiendo\n  sistema..."); 
572A:  CLRF   6D
572C:  MOVF   6D,W
572E:  CALL   00F2
5732:  IORLW  00
5734:  BZ    5744
5736:  INCF   6D,F
5738:  MOVLB  2
573A:  MOVWF  x80
573C:  MOVLB  0
573E:  CALL   0E7C
5742:  BRA    572C
....................                //Encendemos el sistema 
....................                encender_sistema(); 
5744:  CALL   2668
....................  
....................                //Recogemos el tiempo en el que debe de saltar la alarma de apagado. 
....................                //Lo hacemos mediante variables auxiliares para dividir mejor las tareas 
....................                //y no condensar todo en una línea. 
....................                hora = prg.horas_fin; 
5748:  MOVFF  40,57
....................                minutos = prg.minutos_fin; 
574C:  MOVFF  41,58
....................  
....................                delay_ms(250); //Retraso para evitar solapamiento de alarmas 
5750:  MOVLW  FA
5752:  MOVLB  2
5754:  MOVWF  x87
5756:  MOVLB  0
5758:  CALL   0D30
....................                               //(que salte una dos veces seguidas o algo así) 
....................  
....................                //Establecemos la alarma de apagado del sistema (segundos=0) 
....................                PCF8583_establecer_alarma(hora, minutos, 0); 
575C:  MOVFF  57,6F
5760:  MOVFF  58,70
5764:  CLRF   71
5766:  CALL   2690
....................  
....................  
....................             }else 
576A:  BRA    5788
....................             { 
....................                //Si se trata de una alarma de encendido y el sistema está encendido 
....................                delay_ms(250); //Retraso para evitar solapamiento de alarmas 
576C:  MOVLW  FA
576E:  MOVLB  2
5770:  MOVWF  x87
5772:  MOVLB  0
5774:  CALL   0D30
....................  
....................                //Nos vamos a la siguiente alarma 
....................                posicion_alarmas++; 
5778:  INCF   44,F
....................                //Si hemos llegado al final de la lista, volvemos al principio 
....................                if(posicion_alarmas==num_intervalos) 
577A:  MOVF   43,W
577C:  SUBWF  44,W
577E:  BNZ   5782
....................                   posicion_alarmas = 0; 
5780:  CLRF   44
....................  
....................                //Programamos la próxima alarma de encendido 
....................                programar_proxima_alarma(); 
5782:  CALL   2740
....................  
....................                //Determinamos que la siguiente es de encendido 
....................                toca_encender = TRUE; 
5786:  BSF    1E.3
....................             } 
....................          }else 
5788:  BRA    580C
....................          { 
....................             //Si se trata de una alarma de apagado 
....................  
....................             delay_ms(250); //Retraso para evitar el solapamiento de alarmas 
578A:  MOVLW  FA
578C:  MOVLB  2
578E:  MOVWF  x87
5790:  MOVLB  0
5792:  CALL   0D30
....................  
....................             if(sistema_encendido && encendido_por_alarma) 
5796:  BTFSS  F83.2
5798:  BRA    57FC
579A:  BTFSS  1E.2
579C:  BRA    57FC
....................             { 
....................                //Si el sistema está encendido y se trata de un encendido por alarma: 
....................                //Restauramos el valor del termostato que había antes de la alarma 
....................                termostato=termostato_provisional; 
579E:  MOVFF  26,22
57A2:  MOVFF  25,21
57A6:  MOVFF  24,20
57AA:  MOVFF  23,1F
....................                //Grabamos la información en el sensor 
....................                ds1820_establecer_TH_TL(127.5, termostato); 
57AE:  CLRF   76
57B0:  CLRF   75
57B2:  MOVLW  7F
57B4:  MOVWF  74
57B6:  MOVLW  85
57B8:  MOVWF  73
57BA:  MOVFF  22,7A
57BE:  MOVFF  21,79
57C2:  MOVFF  20,78
57C6:  MOVFF  1F,77
57CA:  CALL   15CE
....................                //Determinamos que la próxima vez que se encienda no sea por alarma 
....................                encendido_por_alarma = FALSE; 
57CE:  BCF    1E.2
....................                //Mostramos un mensaje 
....................                lcd_send_byte(LCD_ORDEN,LCD_CLEAR); 
57D0:  MOVLB  2
57D2:  CLRF   x85
57D4:  MOVLW  01
57D6:  MOVWF  x86
57D8:  MOVLB  0
57DA:  CALL   0DA8
....................                printf(lcd_putc, "  Apagando\n  sistema..."); 
57DE:  CLRF   6D
57E0:  MOVF   6D,W
57E2:  CALL   0128
57E6:  IORLW  00
57E8:  BZ    57F8
57EA:  INCF   6D,F
57EC:  MOVLB  2
57EE:  MOVWF  x80
57F0:  MOVLB  0
57F2:  CALL   0E7C
57F6:  BRA    57E0
....................                //Apagamos el sistema 
....................                apagar_sistema(); 
57F8:  CALL   2A5E
....................             } 
....................  
....................             //Nos vamos a la siguiente alarma 
....................             posicion_alarmas++; 
57FC:  INCF   44,F
....................             //Si llegamos al final de la lista, volvemos al principio 
....................             if(posicion_alarmas==num_intervalos) 
57FE:  MOVF   43,W
5800:  SUBWF  44,W
5802:  BNZ   5806
....................                posicion_alarmas = 0; 
5804:  CLRF   44
....................  
....................             //Programamos la próxima alarma de encendido 
....................             programar_proxima_alarma(); 
5806:  CALL   2740
....................  
....................             //Y activamos que, efectivamente, se trata de una alarma de encendido 
....................             toca_encender = TRUE; 
580A:  BSF    1E.3
....................          } 
....................  
....................          //Activamos de nuevo la alarma 
....................          PCF8583_write_byte(PCF8583_CTRL_STATUS_REG, 
....................                                  PCF8583_ACTIVAR_ALARMA); 
580C:  CLRF   7E
580E:  MOVLW  04
5810:  MOVWF  7F
5812:  CALL   1296
....................  
....................          //Desactivamos el flag de interrupción 
....................          alarma_int = FALSE; 
5816:  BCF    1E.5
....................  
....................          //Activamos de nuevo las interrupciones 
....................          enable_interrupts(GLOBAL); 
5818:  MOVLW  C0
581A:  IORWF  FF2,F
....................       } 
....................  
....................  
....................       //Si se activa la interrupción de interfaz con el usuario, se gestiona el proceso 
....................       if(lcd_int) 
581C:  BTFSS  1E.4
581E:  GOTO   6292
....................       { 
....................          //Contadores y valores auxiliares 
....................          int contador, contador2, valor, input; 
....................          //Variable para almacenar el nuevo valor del termostato 
....................          float term; 
....................          //Variable para la conversión de los valores de teclado 
....................          long numero; 
....................          //Variables provisionales para buscar en la lista de programaciones 
....................          programacion pr, pr2; 
....................  
....................          //Desactivamos interrupciones 
....................          disable_interrupts(GLOBAL); 
5822:  BCF    FF2.6
5824:  BCF    FF2.7
5826:  BTFSC  FF2.7
5828:  BRA    5824
....................  
....................          //Mostramos un mensaje al usuario para que elija su opción 
....................          lcd_send_byte(LCD_ORDEN,LCD_CLEAR); 
582A:  MOVLB  2
582C:  CLRF   x85
582E:  MOVLW  01
5830:  MOVWF  x86
5832:  MOVLB  0
5834:  CALL   0DA8
....................          printf(lcd_putc, "  Indique la \n  operacion   1"); 
5838:  CLRF   6D
583A:  MOVF   6D,W
583C:  CALL   015A
5840:  IORLW  00
5842:  BZ    5852
5844:  INCF   6D,F
5846:  MOVLB  2
5848:  MOVWF  x80
584A:  MOVLB  0
584C:  CALL   0E7C
5850:  BRA    583A
....................          lcd_gotoxy(15,2); 
5852:  MOVLW  0F
5854:  MOVLB  2
5856:  MOVWF  x81
5858:  MOVLW  02
585A:  MOVWF  x82
585C:  MOVLB  0
585E:  CALL   0E56
....................          lcd_send_byte(LCD_ORDEN,LCD_CURSOR); //Activamos el parpadeo del cursor 
5862:  MOVLB  2
5864:  CLRF   x85
5866:  MOVLW  0E
5868:  MOVWF  x86
586A:  MOVLB  0
586C:  CALL   0DA8
....................  
....................          input = 1; 
5870:  MOVLW  01
5872:  MOVWF  5C
....................          //Mientras que no se pulse SI o NO, esperamos a que el usuario introduzca un número con los cursores 
....................          while(1) 
....................          { 
....................             if(!mas) 
5874:  BTFSC  F82.0
5876:  BRA    58A8
....................             { 
....................                //Si se pulsa el botón de +, se aumenta el valor de input 
....................                input++; 
5878:  INCF   5C,F
....................                //Si llegamos al límite de las opciones, reseteamos 
....................                if(input>4) 
587A:  MOVF   5C,W
587C:  SUBLW  04
587E:  BC    5884
....................                   input = 1; 
5880:  MOVLW  01
5882:  MOVWF  5C
....................                //Se muestra por pantalla 
....................                printf(lcd_putc,"%i",input); 
5884:  MOVFF  5C,7C
5888:  MOVLW  1F
588A:  MOVWF  7D
588C:  CALL   0F04
....................                //Regresamos el cursor a su posición 
....................                lcd_gotoxy(15,2); 
5890:  MOVLW  0F
5892:  MOVLB  2
5894:  MOVWF  x81
5896:  MOVLW  02
5898:  MOVWF  x82
589A:  MOVLB  0
589C:  CALL   0E56
....................                //Esperamos a que se levante la tecla 
....................                while(!mas){} 
58A0:  BTFSC  F82.0
58A2:  BRA    58A6
58A4:  BRA    58A0
....................                continue; 
58A6:  BRA    5874
....................             } 
....................             if(!menos) 
58A8:  BTFSC  F82.1
58AA:  BRA    58DA
....................             { 
....................                //Si se pulsa el botón de -, se decrementa el valor de input 
....................                input--; 
58AC:  DECF   5C,F
....................                //Si llegamos al límite de las opciones, reseteamos 
....................                if(input<1) 
58AE:  MOVF   5C,F
58B0:  BNZ   58B6
....................                   input = 4; 
58B2:  MOVLW  04
58B4:  MOVWF  5C
....................                //Se muestra por pantalla 
....................                printf(lcd_putc,"%i",input); 
58B6:  MOVFF  5C,7C
58BA:  MOVLW  1F
58BC:  MOVWF  7D
58BE:  CALL   0F04
....................                //Regresamos el cursor a su posición 
....................                lcd_gotoxy(15,2); 
58C2:  MOVLW  0F
58C4:  MOVLB  2
58C6:  MOVWF  x81
58C8:  MOVLW  02
58CA:  MOVWF  x82
58CC:  MOVLB  0
58CE:  CALL   0E56
....................                //Esperamos a que se levante la tecla 
....................                while(!menos){} 
58D2:  BTFSC  F82.1
58D4:  BRA    58D8
58D6:  BRA    58D2
....................                continue; 
58D8:  BRA    5874
....................             } 
....................             if(!si) 
58DA:  BTFSC  F82.2
58DC:  BRA    58E6
....................             { 
....................                //Si se pulsa Si, nos quedamos con el valor seleccionado 
....................                //Esperamos a que se suelte la tecla 
....................                while(!si){} 
58DE:  BTFSC  F82.2
58E0:  BRA    58E4
58E2:  BRA    58DE
....................                break; 
58E4:  BRA    5940
....................             } 
....................             if(!no) 
58E6:  BTFSC  F82.5
58E8:  BRA    593E
....................             { 
....................                //Si se pulsa No, salimos 
....................                //Esperamos... 
....................                while(!no){} 
58EA:  BTFSC  F82.5
58EC:  BRA    58F0
58EE:  BRA    58EA
....................                //Se muestra un mensaje de finalización 
....................                lcd_send_byte(LCD_ORDEN,LCD_CLEAR); 
58F0:  MOVLB  2
58F2:  CLRF   x85
58F4:  MOVLW  01
58F6:  MOVWF  x86
58F8:  MOVLB  0
58FA:  CALL   0DA8
....................                lcd_send_byte(LCD_ORDEN,LCD_NO_CURSOR); 
58FE:  MOVLB  2
5900:  CLRF   x85
5902:  MOVLW  0C
5904:  MOVWF  x86
5906:  MOVLB  0
5908:  CALL   0DA8
....................                printf(lcd_putc, "  Anulando\n  operacion..."); 
590C:  CLRF   6D
590E:  MOVF   6D,W
5910:  CALL   0192
5914:  IORLW  00
5916:  BZ    5926
5918:  INCF   6D,F
591A:  MOVLB  2
591C:  MOVWF  x80
591E:  MOVLB  0
5920:  CALL   0E7C
5924:  BRA    590E
....................                delay_ms(LCD_T_RETARDO); 
5926:  MOVLW  02
5928:  MOVWF  6D
592A:  MOVLW  FA
592C:  MOVLB  2
592E:  MOVWF  x87
5930:  MOVLB  0
5932:  CALL   0D30
5936:  DECFSZ 6D,F
5938:  BRA    592A
....................                lcd_int = FALSE; //Desactivamos el flag de interrupción 
593A:  BCF    1E.4
....................                goto inicio; 
593C:  BRA    5660
....................             } 
....................          } 
593E:  BRA    5874
....................  
....................          lcd_send_byte(LCD_ORDEN, LCD_NO_CURSOR); 
5940:  MOVLB  2
5942:  CLRF   x85
5944:  MOVLW  0C
5946:  MOVWF  x86
5948:  MOVLB  0
594A:  CALL   0DA8
....................  
....................          //Se elige la opción pertinente 
....................          switch(input) 
....................          { 
594E:  MOVF   5C,W
5950:  XORLW  01
5952:  BZ    596A
5954:  XORLW  03
5956:  BZ    5A08
5958:  XORLW  01
595A:  BTFSC  FD8.2
595C:  BRA    5D28
595E:  XORLW  07
5960:  BTFSC  FD8.2
5962:  GOTO   61EA
5966:  GOTO   6242
....................             //Si es 1, entramos en la opción de apagado y encendido manual del sistema 
....................             case 1: 
....................                      //Si el sistema está apagado, lo encendemos 
....................                      if(!sistema_encendido) 
596A:  BTFSC  F83.2
596C:  BRA    599C
....................                      { 
....................                         lcd_send_byte(LCD_ORDEN,LCD_CLEAR); 
596E:  MOVLB  2
5970:  CLRF   x85
5972:  MOVLW  01
5974:  MOVWF  x86
5976:  MOVLB  0
5978:  CALL   0DA8
....................                         printf(lcd_putc, "  Encendiendo\n  sistema..."); 
597C:  CLRF   6D
597E:  MOVF   6D,W
5980:  CALL   00F2
5984:  IORLW  00
5986:  BZ    5996
5988:  INCF   6D,F
598A:  MOVLB  2
598C:  MOVWF  x80
598E:  MOVLB  0
5990:  CALL   0E7C
5994:  BRA    597E
....................                         encender_sistema(); 
5996:  CALL   2668
....................                      }else 
599A:  BRA    5A04
....................                      //Si está encendido, lo apagamos 
....................                      { 
....................                         lcd_send_byte(LCD_ORDEN,LCD_CLEAR); 
599C:  MOVLB  2
599E:  CLRF   x85
59A0:  MOVLW  01
59A2:  MOVWF  x86
59A4:  MOVLB  0
59A6:  CALL   0DA8
....................                         printf(lcd_putc, "  Apagando\n  sistema..."); 
59AA:  CLRF   6D
59AC:  MOVF   6D,W
59AE:  CALL   0128
59B2:  IORLW  00
59B4:  BZ    59C4
59B6:  INCF   6D,F
59B8:  MOVLB  2
59BA:  MOVWF  x80
59BC:  MOVLB  0
59BE:  CALL   0E7C
59C2:  BRA    59AC
....................                         apagar_sistema(); 
59C4:  CALL   2A5E
....................                         //Si el motor estaba en marcha, debemos apagarlo 
....................                         if(motor) 
59C8:  BTFSS  F83.1
59CA:  BRA    59CE
....................                            motor = FALSE; 
59CC:  BCF    F83.1
....................  
....................                         //Si estaba encendido por alguna alarma debemos indicarlo 
....................                         if(encendido_por_alarma) 
59CE:  BTFSS  1E.2
59D0:  BRA    5A04
....................                         { 
....................                            //Recuperamos el valor del termostato 
....................                            termostato=termostato_provisional; 
59D2:  MOVFF  26,22
59D6:  MOVFF  25,21
59DA:  MOVFF  24,20
59DE:  MOVFF  23,1F
....................                            //Almacenamos el valor en el sensor 
....................                            ds1820_establecer_TH_TL(127.5, termostato); 
59E2:  CLRF   76
59E4:  CLRF   75
59E6:  MOVLW  7F
59E8:  MOVWF  74
59EA:  MOVLW  85
59EC:  MOVWF  73
59EE:  MOVFF  22,7A
59F2:  MOVFF  21,79
59F6:  MOVFF  20,78
59FA:  MOVFF  1F,77
59FE:  CALL   15CE
....................  
....................                            encendido_por_alarma = FALSE; 
5A02:  BCF    1E.2
....................                         } 
....................                      } 
....................                      break; 
5A04:  GOTO   628C
....................  
....................  
....................             //Si es 2, entramos en la opción de configuración del termostato 
....................             case 2: 
....................  
....................                      //Mostramos el valor del termostato actual 
....................                      lcd_send_byte(LCD_ORDEN, LCD_CLEAR); 
5A08:  MOVLB  2
5A0A:  CLRF   x85
5A0C:  MOVLW  01
5A0E:  MOVWF  x86
5A10:  MOVLB  0
5A12:  CALL   0DA8
....................                      //Para considerar el valor del termostato hay que tener en cuenta el valor de la histéresis. 
....................                      //Extraemos la parte entera del termostato para así poder trabajar con la función buscar_numero(). 
....................                      //Tampoco es una limitación trabajar con valores enteros del termostato, pues nuestro cuerpo no notará 
....................                      //demasiado la diferencia. 
....................                      if(temp_habitacion_superada) 
5A16:  BTFSS  1E.1
5A18:  BRA    5ADC
....................                      { 
....................                         valor = (int)(termostato+histeresis_vivienda); 
5A1A:  BCF    FD8.1
5A1C:  MOVFF  22,282
5A20:  MOVFF  21,281
5A24:  MOVFF  20,280
5A28:  MOVFF  1F,27F
5A2C:  MOVFF  2E,286
5A30:  MOVFF  2D,285
5A34:  MOVFF  2C,284
5A38:  MOVFF  2B,283
5A3C:  CALL   1E96
5A40:  MOVFF  03,86
5A44:  MOVFF  02,85
5A48:  MOVFF  01,84
5A4C:  MOVFF  00,83
5A50:  CALL   142C
5A54:  MOVFF  01,5B
....................                         printf(lcd_putc, "Modificar\ntermostato %.0f%cC",termostato+histeresis_vivienda,223); 
5A58:  BCF    FD8.1
5A5A:  MOVFF  22,282
5A5E:  MOVFF  21,281
5A62:  MOVFF  20,280
5A66:  MOVFF  1F,27F
5A6A:  MOVFF  2E,286
5A6E:  MOVFF  2D,285
5A72:  MOVFF  2C,284
5A76:  MOVFF  2B,283
5A7A:  CALL   1E96
5A7E:  MOVFF  00,6D
5A82:  MOVFF  01,6E
5A86:  MOVFF  02,6F
5A8A:  MOVFF  03,70
5A8E:  CLRF   71
5A90:  MOVF   71,W
5A92:  CALL   01C6
5A96:  INCF   71,F
5A98:  MOVWF  00
5A9A:  MOVFF  FE8,280
5A9E:  CALL   0E7C
5AA2:  MOVLW  15
5AA4:  SUBWF  71,W
5AA6:  BNZ   5A90
5AA8:  MOVLW  89
5AAA:  MOVWF  FE9
5AAC:  MOVFF  70,75
5AB0:  MOVFF  6F,74
5AB4:  MOVFF  6E,73
5AB8:  MOVFF  6D,72
5ABC:  CLRF   76
5ABE:  CALL   2F54
5AC2:  MOVLW  DF
5AC4:  MOVLB  2
5AC6:  MOVWF  x80
5AC8:  MOVLB  0
5ACA:  CALL   0E7C
5ACE:  MOVLW  43
5AD0:  MOVLB  2
5AD2:  MOVWF  x80
5AD4:  MOVLB  0
5AD6:  CALL   0E7C
....................                      } 
....................                      else 
5ADA:  BRA    5B40
....................                      { 
....................                         valor = (int)termostato; 
5ADC:  MOVFF  22,86
5AE0:  MOVFF  21,85
5AE4:  MOVFF  20,84
5AE8:  MOVFF  1F,83
5AEC:  CALL   142C
5AF0:  MOVFF  01,5B
....................                         printf(lcd_putc, "Modificar\ntermostato %.0f%cC",termostato,223); 
5AF4:  CLRF   6D
5AF6:  MOVF   6D,W
5AF8:  CALL   01C6
5AFC:  INCF   6D,F
5AFE:  MOVWF  00
5B00:  MOVFF  FE8,280
5B04:  CALL   0E7C
5B08:  MOVLW  15
5B0A:  SUBWF  6D,W
5B0C:  BNZ   5AF6
5B0E:  MOVLW  89
5B10:  MOVWF  FE9
5B12:  MOVFF  22,75
5B16:  MOVFF  21,74
5B1A:  MOVFF  20,73
5B1E:  MOVFF  1F,72
5B22:  CLRF   76
5B24:  CALL   2F54
5B28:  MOVLW  DF
5B2A:  MOVLB  2
5B2C:  MOVWF  x80
5B2E:  MOVLB  0
5B30:  CALL   0E7C
5B34:  MOVLW  43
5B36:  MOVLB  2
5B38:  MOVWF  x80
5B3A:  MOVLB  0
5B3C:  CALL   0E7C
....................                      } 
....................  
....................                      //Retardamos cierto tiempo para que el usuario vea correctamente los datos de la pantalla 
....................                      delay_ms(LCD_T_RETARDO*2); 
5B40:  MOVLW  04
5B42:  MOVWF  6D
5B44:  MOVLW  FA
5B46:  MOVLB  2
5B48:  MOVWF  x87
5B4A:  MOVLB  0
5B4C:  CALL   0D30
5B50:  DECFSZ 6D,F
5B52:  BRA    5B44
....................  
....................                      //Pedimos la introducción de nuevo valor 
....................                      lcd_send_byte(LCD_ORDEN, LCD_CLEAR); 
5B54:  MOVLB  2
5B56:  CLRF   x85
5B58:  MOVLW  01
5B5A:  MOVWF  x86
5B5C:  MOVLB  0
5B5E:  CALL   0DA8
....................                      printf(lcd_putc, "Nuevo valor:\n       %cC",223); 
5B62:  CLRF   6D
5B64:  MOVF   6D,W
5B66:  CALL   01FE
5B6A:  INCF   6D,F
5B6C:  MOVWF  00
5B6E:  MOVFF  FE8,280
5B72:  CALL   0E7C
5B76:  MOVLW  0D
5B78:  SUBWF  6D,W
5B7A:  BNZ   5B64
5B7C:  MOVLW  07
5B7E:  MOVWF  6E
5B80:  MOVLW  20
5B82:  MOVLB  2
5B84:  MOVWF  x80
5B86:  MOVLB  0
5B88:  CALL   0E7C
5B8C:  DECFSZ 6E,F
5B8E:  BRA    5B80
5B90:  MOVLW  DF
5B92:  MOVLB  2
5B94:  MOVWF  x80
5B96:  MOVLB  0
5B98:  CALL   0E7C
5B9C:  MOVLW  43
5B9E:  MOVLB  2
5BA0:  MOVWF  x80
5BA2:  MOVLB  0
5BA4:  CALL   0E7C
....................  
....................                      //Recogemos el número de dos cifras introducido por el teclado 
....................                      term=(float)buscar_numero(6, temp_min, temp_max, valor); 
5BA8:  MOVLW  06
5BAA:  MOVWF  73
5BAC:  MOVLW  10
5BAE:  MOVWF  74
5BB0:  MOVLW  20
5BB2:  MOVWF  75
5BB4:  MOVFF  5B,76
5BB8:  CALL   0FD4
5BBC:  MOVLB  2
5BBE:  CLRF   x86
5BC0:  MOVFF  01,285
5BC4:  MOVLB  0
5BC6:  CALL   2110
5BCA:  MOVFF  03,60
5BCE:  MOVFF  02,5F
5BD2:  MOVFF  01,5E
5BD6:  MOVFF  00,5D
....................  
....................                      //Si se pulsa la tecla SI o NO, salimos 
....................                      if(term==NOCODE) 
5BDA:  MOVFF  60,78
5BDE:  MOVFF  5F,77
5BE2:  MOVFF  5E,76
5BE6:  MOVFF  5D,75
5BEA:  CLRF   7C
5BEC:  CLRF   7B
5BEE:  MOVLW  48
5BF0:  MOVWF  7A
5BF2:  MOVLW  85
5BF4:  MOVWF  79
5BF6:  CALL   2148
5BFA:  BNZ   5C00
....................                         goto salir; 
5BFC:  BRA    6242
....................                      else 
5BFE:  BRA    5D26
....................                      { 
....................                         //Retardamos cierto tiempo para permitir al usuario visualizar el valor que ha introducido 
....................                         delay_ms(LCD_T_RETARDO); 
5C00:  MOVLW  02
5C02:  MOVWF  6D
5C04:  MOVLW  FA
5C06:  MOVLB  2
5C08:  MOVWF  x87
5C0A:  MOVLB  0
5C0C:  CALL   0D30
5C10:  DECFSZ 6D,F
5C12:  BRA    5C04
....................  
....................                         //Mostramos un mensaje de aplicación de cambios 
....................                         lcd_send_byte(LCD_ORDEN, LCD_CLEAR); 
5C14:  MOVLB  2
5C16:  CLRF   x85
5C18:  MOVLW  01
5C1A:  MOVWF  x86
5C1C:  MOVLB  0
5C1E:  CALL   0DA8
....................                         printf(lcd_putc, "  Aplicando\n  cambios..."); 
5C22:  CLRF   6D
5C24:  MOVF   6D,W
5C26:  CALL   022A
5C2A:  IORLW  00
5C2C:  BZ    5C3C
5C2E:  INCF   6D,F
5C30:  MOVLB  2
5C32:  MOVWF  x80
5C34:  MOVLB  0
5C36:  CALL   0E7C
5C3A:  BRA    5C24
....................  
....................                         //Aquí, a diferencia que con el teclado matricial, no es necesario comprobar los límites de temperatura después 
....................  
....................                         //Leemos la temperatura 
....................                         temperatura = ds1820_read(); 
5C3C:  CALL   1D38
5C40:  MOVFF  03,2A
5C44:  MOVFF  02,29
5C48:  MOVFF  01,28
5C4C:  MOVFF  00,27
....................                         if(temperatura >= term) 
5C50:  MOVFF  60,78
5C54:  MOVFF  5F,77
5C58:  MOVFF  5E,76
5C5C:  MOVFF  5D,75
5C60:  MOVFF  2A,7C
5C64:  MOVFF  29,7B
5C68:  MOVFF  28,7A
5C6C:  MOVFF  27,79
5C70:  CALL   2148
5C74:  BC    5C78
5C76:  BNZ   5CB2
....................                         { 
....................                            //Si supera el valor del termostato, lo indicamos con el flag 
....................                            temp_habitacion_superada = TRUE; 
5C78:  BSF    1E.1
....................                            //Guardamos el termostato nuevo teniendo en cuenta la histeresis de la vivienda 
....................                            termostato = term - histeresis_vivienda; 
5C7A:  BSF    FD8.1
5C7C:  MOVFF  60,282
5C80:  MOVFF  5F,281
5C84:  MOVFF  5E,280
5C88:  MOVFF  5D,27F
5C8C:  MOVFF  2E,286
5C90:  MOVFF  2D,285
5C94:  MOVFF  2C,284
5C98:  MOVFF  2B,283
5C9C:  CALL   1E96
5CA0:  MOVFF  03,22
5CA4:  MOVFF  02,21
5CA8:  MOVFF  01,20
5CAC:  MOVFF  00,1F
....................                         }else 
5CB0:  BRA    5CC4
....................                         { 
....................                            //Si no se supera, se indica también 
....................                            temp_habitacion_superada = FALSE; 
5CB2:  BCF    1E.1
....................                            //Se guarda el valor tal cual 
....................                            termostato = term; 
5CB4:  MOVFF  60,22
5CB8:  MOVFF  5F,21
5CBC:  MOVFF  5E,20
5CC0:  MOVFF  5D,1F
....................                         } 
....................  
....................                         //Escribimos en el sensor el nuevo valor del termostato 
....................                         ds1820_establecer_TH_TL(127.5, termostato); 
5CC4:  CLRF   76
5CC6:  CLRF   75
5CC8:  MOVLW  7F
5CCA:  MOVWF  74
5CCC:  MOVLW  85
5CCE:  MOVWF  73
5CD0:  MOVFF  22,7A
5CD4:  MOVFF  21,79
5CD8:  MOVFF  20,78
5CDC:  MOVFF  1F,77
5CE0:  CALL   15CE
....................  
....................                         //Guardamos el nuevo valor del termostato en memoria 
....................                         write_eeprom(eeprom_termostato, (int)term); 
5CE4:  MOVFF  60,86
5CE8:  MOVFF  5F,85
5CEC:  MOVFF  5E,84
5CF0:  MOVFF  5D,83
5CF4:  CALL   142C
5CF8:  MOVFF  01,6D
5CFC:  CLRF   FA9
5CFE:  MOVFF  01,FA8
5D02:  BCF    FA6.6
5D04:  BCF    FA6.7
5D06:  BSF    FA6.2
5D08:  MOVFF  FF2,00
5D0C:  BCF    FF2.7
5D0E:  MOVLB  F
5D10:  MOVLW  55
5D12:  MOVWF  FA7
5D14:  MOVLW  AA
5D16:  MOVWF  FA7
5D18:  BSF    FA6.1
5D1A:  BTFSC  FA6.1
5D1C:  BRA    5D1A
5D1E:  BCF    FA6.2
5D20:  MOVF   00,W
5D22:  IORWF  FF2,F
5D24:  MOVLB  0
....................  
....................  
....................                      } 
....................  
....................                      break; 
5D26:  BRA    628C
....................  
....................  
....................             //Si es 3, entramos en la opción de configuración de las alarmas 
....................             case 3: 
....................  
....................                      //Mostramos el encabezamiento de la operación 
....................                      lcd_send_byte(LCD_ORDEN, LCD_CLEAR); 
5D28:  MOVLB  2
5D2A:  CLRF   x85
5D2C:  MOVLW  01
5D2E:  MOVWF  x86
5D30:  MOVLB  0
5D32:  CALL   0DA8
....................                      printf(lcd_putc," Programar\n sistema"); 
5D36:  CLRF   6D
5D38:  MOVF   6D,W
5D3A:  CALL   025E
5D3E:  IORLW  00
5D40:  BZ    5D50
5D42:  INCF   6D,F
5D44:  MOVLB  2
5D46:  MOVWF  x80
5D48:  MOVLB  0
5D4A:  CALL   0E7C
5D4E:  BRA    5D38
....................                      delay_ms(LCD_T_RETARDO); 
5D50:  MOVLW  02
5D52:  MOVWF  6D
5D54:  MOVLW  FA
5D56:  MOVLB  2
5D58:  MOVWF  x87
5D5A:  MOVLB  0
5D5C:  CALL   0D30
5D60:  DECFSZ 6D,F
5D62:  BRA    5D54
....................  
....................                      //Tenemos la posibilidad de introducir 5 intervalos de alarma. 
....................                      //Se va guiando al usuario por la configuración de cada intervalo mediante el siguiente bucle 
....................                      for(contador=0; contador<3; contador++) 
5D64:  CLRF   59
5D66:  MOVF   59,W
5D68:  SUBLW  02
5D6A:  BTFSS  FD8.0
5D6C:  BRA    61CA
....................                      { 
....................                         //Se muestra el intervalo a configurar 
....................                         lcd_send_byte(LCD_ORDEN, LCD_CLEAR); 
5D6E:  MOVLB  2
5D70:  CLRF   x85
5D72:  MOVLW  01
5D74:  MOVWF  x86
5D76:  MOVLB  0
5D78:  CALL   0DA8
....................                         printf(lcd_putc, " INTERVALO %i\n   :      :",contador+1); 
5D7C:  MOVLW  01
5D7E:  ADDWF  59,W
5D80:  MOVWF  6D
5D82:  CLRF   6E
5D84:  MOVF   6E,W
5D86:  CALL   028C
5D8A:  INCF   6E,F
5D8C:  MOVWF  00
5D8E:  MOVFF  FE8,280
5D92:  CALL   0E7C
5D96:  MOVLW  0B
5D98:  SUBWF  6E,W
5D9A:  BNZ   5D84
5D9C:  MOVFF  6D,7C
5DA0:  MOVLW  1F
5DA2:  MOVWF  7D
5DA4:  CALL   0F04
5DA8:  MOVLW  0A
5DAA:  MOVLB  2
5DAC:  MOVWF  x80
5DAE:  MOVLB  0
5DB0:  CALL   0E7C
5DB4:  MOVLW  03
5DB6:  MOVWF  6F
5DB8:  MOVLW  20
5DBA:  MOVLB  2
5DBC:  MOVWF  x80
5DBE:  MOVLB  0
5DC0:  CALL   0E7C
5DC4:  DECFSZ 6F,F
5DC6:  BRA    5DB8
5DC8:  MOVLW  3A
5DCA:  MOVLB  2
5DCC:  MOVWF  x80
5DCE:  MOVLB  0
5DD0:  CALL   0E7C
5DD4:  MOVLW  06
5DD6:  MOVWF  70
5DD8:  MOVLW  20
5DDA:  MOVLB  2
5DDC:  MOVWF  x80
5DDE:  MOVLB  0
5DE0:  CALL   0E7C
5DE4:  DECFSZ 70,F
5DE6:  BRA    5DD8
5DE8:  MOVLW  3A
5DEA:  MOVLB  2
5DEC:  MOVWF  x80
5DEE:  MOVLB  0
5DF0:  CALL   0E7C
....................  
....................                         //Se pide al usuario el valor de hora de inicio de la alarma 
....................                         pr.horas_inicio = buscar_numero(2, 0, 23, 0); 
5DF4:  MOVLW  02
5DF6:  MOVWF  73
5DF8:  CLRF   74
5DFA:  MOVLW  17
5DFC:  MOVWF  75
5DFE:  CLRF   76
5E00:  CALL   0FD4
5E04:  MOVFF  01,63
....................  
....................                         //Si se pulsa No, se indica que no quieren introducirse más alarmas. 
....................                         //En el otro código esto se gestionaba pulsando sí y con no simplemente se salía, 
....................                         //pero aquí debemos hacerlo así por falta de botones... 
....................                         if(pr.horas_inicio==NOCODE) 
5E08:  MOVF   63,W
5E0A:  SUBLW  64
5E0C:  BNZ   5E20
....................                         { 
....................                            //Si era la primera alarma que se gestionaba, se interpreta como que 
....................                            //no se quiere activar ninguna alarma 
....................                            if(contador==0) 
5E0E:  MOVF   59,F
5E10:  BNZ   5E1E
....................                            { 
....................                               //Desactivamos las alarmas 
....................                               PCF8583_write_byte(PCF8583_CTRL_STATUS_REG, 
....................                                     PCF8583_START_COUNTING); 
5E12:  CLRF   7E
5E14:  CLRF   7F
5E16:  CALL   1296
....................                               //Salimos 
....................                               goto salir; 
5E1A:  BRA    6242
....................                            } 
....................                            else 
5E1C:  BRA    5E20
....................                               //Salimos simplemente del bucle 
....................                               break; 
5E1E:  BRA    61CA
....................                         } 
....................  
....................                         //Se pide al usuario el valor de los minutos de inicio 
....................                         pr.minutos_inicio = buscar_numero(5, 0, 59, 0); 
5E20:  MOVLW  05
5E22:  MOVWF  73
5E24:  CLRF   74
5E26:  MOVLW  3B
5E28:  MOVWF  75
5E2A:  CLRF   76
5E2C:  CALL   0FD4
5E30:  MOVFF  01,64
....................  
....................                         //Si se pulsa NO, interrumpimos la introducción de alarmas 
....................                         if(pr.minutos_inicio==NOCODE) 
5E34:  MOVF   64,W
5E36:  SUBLW  64
5E38:  BNZ   5E4C
....................                         { 
....................                            //Si es el primer intervalo, interpretamos como que el usuario 
....................                            //no quiere programar alarmas 
....................                            if(contador==0) 
5E3A:  MOVF   59,F
5E3C:  BNZ   5E4A
....................                            { 
....................                               //Desactivamos las alarmas 
....................                               PCF8583_write_byte(PCF8583_CTRL_STATUS_REG, 
....................                                     PCF8583_START_COUNTING); 
5E3E:  CLRF   7E
5E40:  CLRF   7F
5E42:  CALL   1296
....................                               goto salir; 
5E46:  BRA    6242
....................                            } 
....................                            else 
5E48:  BRA    5E4C
....................                               //Salimos del bucle 
....................                               break; 
5E4A:  BRA    61CA
....................                         } 
....................  
....................                         //Al contrario que ocurría en el Proyecto 1 que contaba con teclado matricial, 
....................                         //en este caso comprobamos que la hora final sea posterior a la inicial en el momento. 
....................                         //Para ello debemos establecer el límite inferior de la hora de fin correctamente. 
....................  
....................                         //Si la hora de inicio corresponde a la última hora del día, no podrá programarse nada 
....................                         if(pr.horas_inicio==23 && pr.minutos_inicio==59) 
5E4C:  MOVF   63,W
5E4E:  SUBLW  17
5E50:  BNZ   5E98
5E52:  MOVF   64,W
5E54:  SUBLW  3B
5E56:  BNZ   5E98
....................                         { 
....................                            //Si se produce un error de este tipo, se indica 
....................                            lcd_send_byte(LCD_ORDEN, LCD_CLEAR); 
5E58:  MOVLB  2
5E5A:  CLRF   x85
5E5C:  MOVLW  01
5E5E:  MOVWF  x86
5E60:  MOVLB  0
5E62:  CALL   0DA8
....................                            printf(lcd_putc, "   Valores\n   incorrectos"); 
5E66:  CLRF   6D
5E68:  MOVF   6D,W
5E6A:  CALL   02B8
5E6E:  IORLW  00
5E70:  BZ    5E80
5E72:  INCF   6D,F
5E74:  MOVLB  2
5E76:  MOVWF  x80
5E78:  MOVLB  0
5E7A:  CALL   0E7C
5E7E:  BRA    5E68
....................                            delay_ms(LCD_T_RETARDO); 
5E80:  MOVLW  02
5E82:  MOVWF  6D
5E84:  MOVLW  FA
5E86:  MOVLB  2
5E88:  MOVWF  x87
5E8A:  MOVLB  0
5E8C:  CALL   0D30
5E90:  DECFSZ 6D,F
5E92:  BRA    5E84
....................                            //Se repite la última iteración del bloque 
....................                            contador--; 
5E94:  DECF   59,F
....................                            continue; 
5E96:  BRA    61C6
....................                         } 
....................  
....................                         //Si los minutos son 59, tendremos que irnos a la siguiente hora 
....................                         if(pr.minutos_inicio==59) 
5E98:  MOVF   64,W
5E9A:  SUBLW  3B
5E9C:  BNZ   5EC4
....................                         { 
....................                            pr.horas_fin = buscar_numero(9, pr.horas_inicio+1, 23, pr.horas_inicio+1); 
5E9E:  MOVLW  01
5EA0:  ADDWF  63,W
5EA2:  MOVWF  6D
5EA4:  MOVLW  01
5EA6:  ADDWF  63,W
5EA8:  MOVWF  6E
5EAA:  MOVLW  09
5EAC:  MOVWF  73
5EAE:  MOVFF  6D,74
5EB2:  MOVLW  17
5EB4:  MOVWF  75
5EB6:  MOVFF  6E,76
5EBA:  CALL   0FD4
5EBE:  MOVFF  01,65
....................                         }else 
5EC2:  BRA    5EDC
....................                         { 
....................                            pr.horas_fin = buscar_numero(9, pr.horas_inicio, 23, pr.horas_inicio); 
5EC4:  MOVLW  09
5EC6:  MOVWF  73
5EC8:  MOVFF  63,74
5ECC:  MOVLW  17
5ECE:  MOVWF  75
5ED0:  MOVFF  63,76
5ED4:  CALL   0FD4
5ED8:  MOVFF  01,65
....................                         } 
....................  
....................                         if(pr.horas_fin==NOCODE) 
5EDC:  MOVF   65,W
5EDE:  SUBLW  64
5EE0:  BNZ   5EF4
....................                         { 
....................                            if(contador==0) 
5EE2:  MOVF   59,F
5EE4:  BNZ   5EF2
....................                            { 
....................                               PCF8583_write_byte(PCF8583_CTRL_STATUS_REG, 
....................                                     PCF8583_START_COUNTING); 
5EE6:  CLRF   7E
5EE8:  CLRF   7F
5EEA:  CALL   1296
....................                               goto salir; 
5EEE:  BRA    6242
....................                            } 
....................                            else 
5EF0:  BRA    5EF4
....................                               break; 
5EF2:  BRA    61CA
....................                         } 
....................  
....................                         //Si las horas de inicio y fin son las mismas, habrá que limitar que los minutos de finalización 
....................                         //tengan un valor mayor 
....................                         if(pr.horas_inicio == pr.horas_fin) 
5EF4:  MOVF   65,W
5EF6:  SUBWF  63,W
5EF8:  BNZ   5F20
....................                            pr.minutos_fin = buscar_numero(12, pr.minutos_inicio+1, 59, pr.minutos_inicio+1); 
5EFA:  MOVLW  01
5EFC:  ADDWF  64,W
5EFE:  MOVWF  6D
5F00:  MOVLW  01
5F02:  ADDWF  64,W
5F04:  MOVWF  6E
5F06:  MOVLW  0C
5F08:  MOVWF  73
5F0A:  MOVFF  6D,74
5F0E:  MOVLW  3B
5F10:  MOVWF  75
5F12:  MOVFF  6E,76
5F16:  CALL   0FD4
5F1A:  MOVFF  01,66
....................                         else 
5F1E:  BRA    5F34
....................                            pr.minutos_fin = buscar_numero(12, 0, 59, 0); 
5F20:  MOVLW  0C
5F22:  MOVWF  73
5F24:  CLRF   74
5F26:  MOVLW  3B
5F28:  MOVWF  75
5F2A:  CLRF   76
5F2C:  CALL   0FD4
5F30:  MOVFF  01,66
....................  
....................                         if(pr.minutos_fin==NOCODE) 
5F34:  MOVF   66,W
5F36:  SUBLW  64
5F38:  BNZ   5F4C
....................                         { 
....................                            if(contador==0) 
5F3A:  MOVF   59,F
5F3C:  BNZ   5F4A
....................                            { 
....................                               PCF8583_write_byte(PCF8583_CTRL_STATUS_REG, 
....................                                     PCF8583_START_COUNTING); 
5F3E:  CLRF   7E
5F40:  CLRF   7F
5F42:  CALL   1296
....................                               goto salir; 
5F46:  BRA    6242
....................                            } 
....................                            else 
5F48:  BRA    5F4C
....................                               break; 
5F4A:  BRA    61CA
....................                         } 
....................  
....................                         //Introducimos cierto retardo para que el usuario pueda visualizar los valores introducidos en la pantalla 
....................                         delay_ms(LCD_T_RETARDO); 
5F4C:  MOVLW  02
5F4E:  MOVWF  6D
5F50:  MOVLW  FA
5F52:  MOVLB  2
5F54:  MOVWF  x87
5F56:  MOVLB  0
5F58:  CALL   0D30
5F5C:  DECFSZ 6D,F
5F5E:  BRA    5F50
....................  
....................                         //No puede haber un intervalo de encendido de más de 4 horas. 
....................                         //Esto deriva de un problema propio de almacenamiento de números enteros, pero es perfectamente lógico 
....................                         //que un sistema de calefacción tenga un tiempo máximo de encendido para regular el uso abusivo del sistema 
....................                         //y evitar averías por un funcionamiento muy prolongado. 
....................                         if(diferencia_tiempo(pr.horas_inicio, pr.minutos_inicio, pr.horas_fin, pr.minutos_fin)>240) 
5F60:  MOVFF  63,75
5F64:  MOVFF  64,76
5F68:  MOVFF  65,77
5F6C:  MOVFF  66,78
5F70:  CALL   27DA
5F74:  MOVFF  02,6E
5F78:  MOVFF  01,6D
5F7C:  MOVF   6E,F
5F7E:  BNZ   5F86
5F80:  MOVF   6D,W
5F82:  SUBLW  F0
5F84:  BC    5FC6
....................                         { 
....................                            //Mostramos un aviso 
....................                            lcd_send_byte(LCD_ORDEN, LCD_CLEAR); 
5F86:  MOVLB  2
5F88:  CLRF   x85
5F8A:  MOVLW  01
5F8C:  MOVWF  x86
5F8E:  MOVLB  0
5F90:  CALL   0DA8
....................                            printf(lcd_putc, "Intervalo limite\nde 4 horas"); 
5F94:  CLRF   6D
5F96:  MOVF   6D,W
5F98:  CALL   02EC
5F9C:  IORLW  00
5F9E:  BZ    5FAE
5FA0:  INCF   6D,F
5FA2:  MOVLB  2
5FA4:  MOVWF  x80
5FA6:  MOVLB  0
5FA8:  CALL   0E7C
5FAC:  BRA    5F96
....................                            delay_ms(LCD_T_RETARDO); 
5FAE:  MOVLW  02
5FB0:  MOVWF  6D
5FB2:  MOVLW  FA
5FB4:  MOVLB  2
5FB6:  MOVWF  x87
5FB8:  MOVLB  0
5FBA:  CALL   0D30
5FBE:  DECFSZ 6D,F
5FC0:  BRA    5FB2
....................                            //Se repite la última iteración del bloque 
....................                            contador--; 
5FC2:  DECF   59,F
....................                            continue; 
5FC4:  BRA    61C6
....................  
....................                         } 
....................  
....................                         //El usuario debe ahora introducir el valor del temostato para ese periodo de encendido 
....................                         lcd_send_byte(LCD_ORDEN, LCD_CLEAR); 
5FC6:  MOVLB  2
5FC8:  CLRF   x85
5FCA:  MOVLW  01
5FCC:  MOVWF  x86
5FCE:  MOVLB  0
5FD0:  CALL   0DA8
....................                         printf(lcd_putc, "Termostato %i\n      %cC", contador+1, 223); 
5FD4:  MOVLW  01
5FD6:  ADDWF  59,W
5FD8:  MOVWF  6D
5FDA:  CLRF   6E
5FDC:  MOVF   6E,W
5FDE:  CALL   0322
5FE2:  INCF   6E,F
5FE4:  MOVWF  00
5FE6:  MOVFF  FE8,280
5FEA:  CALL   0E7C
5FEE:  MOVLW  0B
5FF0:  SUBWF  6E,W
5FF2:  BNZ   5FDC
5FF4:  MOVFF  6D,7C
5FF8:  MOVLW  1F
5FFA:  MOVWF  7D
5FFC:  CALL   0F04
6000:  MOVLW  0A
6002:  MOVLB  2
6004:  MOVWF  x80
6006:  MOVLB  0
6008:  CALL   0E7C
600C:  MOVLW  06
600E:  MOVWF  6F
6010:  MOVLW  20
6012:  MOVLB  2
6014:  MOVWF  x80
6016:  MOVLB  0
6018:  CALL   0E7C
601C:  DECFSZ 6F,F
601E:  BRA    6010
6020:  MOVLW  DF
6022:  MOVLB  2
6024:  MOVWF  x80
6026:  MOVLB  0
6028:  CALL   0E7C
602C:  MOVLW  43
602E:  MOVLB  2
6030:  MOVWF  x80
6032:  MOVLB  0
6034:  CALL   0E7C
....................  
....................                         //Recogemos el número introducido por el usuario 
....................                         pr.termostato = buscar_numero(4, temp_min, temp_max, 20); 
6038:  MOVLW  04
603A:  MOVWF  73
603C:  MOVLW  10
603E:  MOVWF  74
6040:  MOVLW  20
6042:  MOVWF  75
6044:  MOVLW  14
6046:  MOVWF  76
6048:  CALL   0FD4
604C:  MOVFF  01,67
....................  
....................                         //Retardamos para que el usuario pueda ver el valor que ha introducido 
....................                         delay_ms(LCD_T_RETARDO); 
6050:  MOVLW  02
6052:  MOVWF  6D
6054:  MOVLW  FA
6056:  MOVLB  2
6058:  MOVWF  x87
605A:  MOVLB  0
605C:  CALL   0D30
6060:  DECFSZ 6D,F
6062:  BRA    6054
....................  
....................                         //Comprobamos que los intervalos sean correctos respecto a los otros, es decir, 
....................                         //que no haya solapamiento entre los distintos intervalos programados. 
....................                         for(contador2=0; contador2<contador; contador2++) 
6064:  CLRF   5A
6066:  MOVF   59,W
6068:  SUBWF  5A,W
606A:  BTFSC  FD8.0
606C:  BRA    61A2
....................                         { 
....................                            //Tomamos las programaciones almacenadas anteriormente 
....................                            pr2 = programaciones[contador2]; 
606E:  MOVF   5A,W
6070:  MULLW  05
6072:  MOVF   FF3,W
6074:  CLRF   03
6076:  ADDLW  2F
6078:  MOVWF  01
607A:  MOVLW  00
607C:  ADDWFC 03,F
607E:  MOVFF  01,6D
6082:  MOVFF  03,6E
6086:  CLRF   FEA
6088:  MOVLW  68
608A:  MOVWF  FE9
608C:  MOVFF  03,FE2
6090:  MOVFF  01,FE1
6094:  MOVLW  05
6096:  MOVWF  01
6098:  MOVFF  FE6,FEE
609C:  DECFSZ 01,F
609E:  BRA    6098
....................  
....................                            //Controlamos todas las posibilidades de solapamiento 
....................                            if( 
....................                               (comprobar_hora(pr2.horas_inicio, pr2.minutos_inicio, pr.horas_fin, pr.minutos_fin) && 
....................                               !comprobar_hora(pr2.horas_inicio, pr2.minutos_inicio, pr.horas_inicio, pr.minutos_inicio)) 
....................  
....................                               ||(comprobar_hora(pr2.horas_fin, pr2.minutos_fin, pr.horas_fin, pr.minutos_fin) && 
....................                                 !comprobar_hora(pr2.horas_fin, pr2.minutos_fin, pr.horas_inicio, pr.minutos_inicio)) 
....................  
....................                               ||(comprobar_hora(pr.horas_inicio, pr.minutos_inicio, pr2.horas_fin, pr2.minutos_fin) && 
....................                                 !comprobar_hora(pr.horas_inicio, pr.minutos_inicio, pr2.horas_inicio, pr2.minutos_inicio)) 
....................  
....................                               ||(comprobar_hora(pr.horas_fin, pr.minutos_fin, pr2.horas_fin, pr2.minutos_fin) && 
....................                                 !comprobar_hora(pr.horas_fin, pr.minutos_fin, pr2.horas_inicio, pr2.minutos_inicio)) 
....................                            ) 
60A0:  MOVFF  68,7F
60A4:  MOVFF  69,80
60A8:  MOVFF  65,81
60AC:  MOVFF  66,82
60B0:  CALL   2788
60B4:  MOVF   01,F
60B6:  BZ    60D0
60B8:  MOVFF  68,7F
60BC:  MOVFF  69,80
60C0:  MOVFF  63,81
60C4:  MOVFF  64,82
60C8:  CALL   2788
60CC:  MOVF   01,F
60CE:  BZ    6160
60D0:  MOVFF  6A,7F
60D4:  MOVFF  6B,80
60D8:  MOVFF  65,81
60DC:  MOVFF  66,82
60E0:  CALL   2788
60E4:  MOVF   01,F
60E6:  BZ    6100
60E8:  MOVFF  6A,7F
60EC:  MOVFF  6B,80
60F0:  MOVFF  63,81
60F4:  MOVFF  64,82
60F8:  CALL   2788
60FC:  MOVF   01,F
60FE:  BZ    6160
6100:  MOVFF  63,7F
6104:  MOVFF  64,80
6108:  MOVFF  6A,81
610C:  MOVFF  6B,82
6110:  CALL   2788
6114:  MOVF   01,F
6116:  BZ    6130
6118:  MOVFF  63,7F
611C:  MOVFF  64,80
6120:  MOVFF  68,81
6124:  MOVFF  69,82
6128:  CALL   2788
612C:  MOVF   01,F
612E:  BZ    6160
6130:  MOVFF  65,7F
6134:  MOVFF  66,80
6138:  MOVFF  6A,81
613C:  MOVFF  6B,82
6140:  CALL   2788
6144:  MOVF   01,F
6146:  BZ    619E
6148:  MOVFF  65,7F
614C:  MOVFF  66,80
6150:  MOVFF  68,81
6154:  MOVFF  69,82
6158:  CALL   2788
615C:  MOVF   01,F
615E:  BNZ   619E
....................                            { 
....................                               //Si hay solapamiento, mostramos un mensaje de error y salimos 
....................                               lcd_send_byte(LCD_ORDEN, LCD_CLEAR); 
6160:  MOVLB  2
6162:  CLRF   x85
6164:  MOVLW  01
6166:  MOVWF  x86
6168:  MOVLB  0
616A:  CALL   0DA8
....................                               printf(lcd_putc, "Solapamiento\nde intervalos!"); 
616E:  CLRF   6D
6170:  MOVF   6D,W
6172:  CALL   034E
6176:  IORLW  00
6178:  BZ    6188
617A:  INCF   6D,F
617C:  MOVLB  2
617E:  MOVWF  x80
6180:  MOVLB  0
6182:  CALL   0E7C
6186:  BRA    6170
....................                               delay_ms(LCD_T_RETARDO*2); 
6188:  MOVLW  04
618A:  MOVWF  6D
618C:  MOVLW  FA
618E:  MOVLB  2
6190:  MOVWF  x87
6192:  MOVLB  0
6194:  CALL   0D30
6198:  DECFSZ 6D,F
619A:  BRA    618C
....................                               goto salir; 
619C:  BRA    6242
....................                            } 
....................                         } 
619E:  INCF   5A,F
61A0:  BRA    6066
....................  
....................                         //Añadimos esta programación a la lista de programaciones 
....................                         programaciones[contador]=pr; 
61A2:  MOVF   59,W
61A4:  MULLW  05
61A6:  MOVF   FF3,W
61A8:  CLRF   03
61AA:  ADDLW  2F
61AC:  MOVWF  FE9
61AE:  MOVLW  00
61B0:  ADDWFC 03,W
61B2:  MOVWF  FEA
61B4:  CLRF   FE2
61B6:  MOVLW  63
61B8:  MOVWF  FE1
61BA:  MOVLW  05
61BC:  MOVWF  01
61BE:  MOVFF  FE6,FEE
61C2:  DECFSZ 01,F
61C4:  BRA    61BE
....................                      } 
61C6:  INCF   59,F
61C8:  BRA    5D66
....................  
....................                      //Habilitamos la alarma 
....................                      PCF8583_write_byte(PCF8583_CTRL_STATUS_REG, 
....................                                  PCF8583_ACTIVAR_ALARMA); 
61CA:  CLRF   7E
61CC:  MOVLW  04
61CE:  MOVWF  7F
61D0:  CALL   1296
....................  
....................                      //Guardamos el número de intervalos configurados 
....................                      num_intervalos = contador; 
61D4:  MOVFF  59,43
....................  
....................                      //Ordenamos las programaciones por orden de hora de inicio 
....................                      ordenar_programaciones(); 
61D8:  GOTO   30F0
....................  
....................                      //Seleccionamos la próxima alarma a ejecutar 
....................                      seleccionar_alarma(); 
61DC:  GOTO   3228
....................  
....................                      //Programamos la próxima alarma para que salte el reloj en el momento indicado 
....................                      programar_proxima_alarma(); 
61E0:  CALL   2740
....................  
....................                      //Indicamos que se trata de una alarma de encendido 
....................                      toca_encender = TRUE; 
61E4:  BSF    1E.3
....................  
....................                      //Guardamos las programaciones introducidas 
....................                      grabar_programaciones(); 
61E6:  GOTO   32AA
....................  
....................                      break; 
....................  
....................  
....................             //Si es 4, entramos en el modo de revisión y obtención de datos históricos 
....................             case 4: 
....................  
....................                      //Solicitamos la introducción de una clave. 
....................                      //Al contrario de lo que ocurría cuando disponíamos de teclado matricial, 
....................                      //en este caso la clave es una combinación de botones: {+,-,-,SI} 
....................                      lcd_send_byte(LCD_ORDEN, LCD_CLEAR); 
61EA:  MOVLB  2
61EC:  CLRF   x85
61EE:  MOVLW  01
61F0:  MOVWF  x86
61F2:  MOVLB  0
61F4:  CALL   0DA8
....................                      printf(lcd_putc, "  Introduzca\n  clave"); 
61F8:  CLRF   6D
61FA:  MOVF   6D,W
61FC:  CALL   0384
6200:  IORLW  00
6202:  BZ    6212
6204:  INCF   6D,F
6206:  MOVLB  2
6208:  MOVWF  x80
620A:  MOVLB  0
620C:  CALL   0E7C
6210:  BRA    61FA
.................... /* 
....................                      //Realizamos todo el proceso de comprobación de clave correcta según los botones pulsados 
....................                      while(1) 
....................                      { 
....................                         if(!mas) 
....................                         { 
....................                            while(!mas){} 
....................                            while(1) 
....................                            { 
....................                               if(!menos) 
....................                               { 
....................                                  while(!menos){} 
....................                                  while(1) 
....................                                  { 
....................                                     if(!menos) 
....................                                     { 
....................                                        while(!menos){} 
....................                                        while(1) 
....................                                        { 
....................                                           if(!si) 
....................                                           { 
....................                                              while(!si){} 
....................                                              goto clave_correcta; 
....................                                           } 
....................                                           if(!mas || !menos || !no) 
....................                                           { 
....................                                              while(!mas || !menos || !no){} 
....................                                              goto clave_incorrecta; 
....................                                           } 
....................                                        } 
....................                                     } 
....................                                     if(!mas || !si || !no) 
....................                                     { 
....................                                        while(!mas || !si || !no){} 
....................                                        goto clave_incorrecta; 
....................                                     } 
....................                                  } 
....................                               } 
....................                               if(!mas || !si || !no) 
....................                               { 
....................                                  while(!mas || !si || !no){} 
....................                                  goto clave_incorrecta; 
....................                               } 
....................                            } 
....................                         } 
....................                         if(!menos || !si || !no) 
....................                         { 
....................                            while(!menos || !si || !no){} 
....................                            goto clave_incorrecta; 
....................                         } 
....................                      } 
....................  
....................                      clave_incorrecta: 
....................  
....................                      //Si la clave es incorrecta, lo indicamos y salimos 
....................                      lcd_send_byte(LCD_ORDEN, LCD_CLEAR); 
....................                      printf(lcd_putc, "  Clave\n  incorrecta"); 
....................                      delay_ms(LCD_T_RETARDO); 
....................                      goto salir; 
.................... */ 
....................                      clave_correcta: 
....................  
....................                      //Si la clave es correcta, entramos en el modo revisión 
....................                      lcd_send_byte(LCD_ORDEN, LCD_CLEAR); 
6212:  MOVLB  2
6214:  CLRF   x85
6216:  MOVLW  01
6218:  MOVWF  x86
621A:  MOVLB  0
621C:  CALL   0DA8
....................                      printf(lcd_putc, "  Modo\n  revision"); 
6220:  CLRF   6D
6222:  MOVF   6D,W
6224:  CALL   03B4
6228:  IORLW  00
622A:  BZ    623A
622C:  INCF   6D,F
622E:  MOVLB  2
6230:  MOVWF  x80
6232:  MOVLB  0
6234:  CALL   0E7C
6238:  BRA    6222
....................  
....................                      //Dejamos la pantalla lcd fija 
....................                      set_tris_d(0xFF); 
623A:  MOVLW  FF
623C:  MOVWF  F95
....................  
....................                      //Representamos el contenido de los registros y activamos la interfaz RS-232 
....................                      representar_registros(); 
623E:  GOTO   36E6
....................  
....................  
....................                      break; 
....................  
....................               default: 
....................  
....................                         //Aquí confluyen todas las salidas de la rutina de interfaz con el usuario 
....................                         salir: 
....................                         //Se muestra un mensaje de finalización 
....................                         lcd_send_byte(LCD_ORDEN,LCD_CLEAR); 
6242:  MOVLB  2
6244:  CLRF   x85
6246:  MOVLW  01
6248:  MOVWF  x86
624A:  MOVLB  0
624C:  CALL   0DA8
....................                         lcd_send_byte(LCD_ORDEN,LCD_NO_CURSOR); 
6250:  MOVLB  2
6252:  CLRF   x85
6254:  MOVLW  0C
6256:  MOVWF  x86
6258:  MOVLB  0
625A:  CALL   0DA8
....................                         printf(lcd_putc, "  Anulando\n  operacion..."); 
625E:  CLRF   6D
6260:  MOVF   6D,W
6262:  CALL   0192
6266:  IORLW  00
6268:  BZ    6278
626A:  INCF   6D,F
626C:  MOVLB  2
626E:  MOVWF  x80
6270:  MOVLB  0
6272:  CALL   0E7C
6276:  BRA    6260
....................                         delay_ms(LCD_T_RETARDO); 
6278:  MOVLW  02
627A:  MOVWF  6D
627C:  MOVLW  FA
627E:  MOVLB  2
6280:  MOVWF  x87
6282:  MOVLB  0
6284:  CALL   0D30
6288:  DECFSZ 6D,F
628A:  BRA    627C
....................  
....................          } 
....................  
....................          //Se desactiva el flag de indicación de la interrupción 
....................          lcd_int = FALSE; 
628C:  BCF    1E.4
....................  
....................          //Volvemos a activar las interrupciones 
....................          enable_interrupts(GLOBAL); 
628E:  MOVLW  C0
6290:  IORWF  FF2,F
....................       } 
....................  
....................       //Comenzamos el bloque de comprobación de parámetros y activación de los procesos necesarios. 
....................  
....................       //Comparamos primero la temperatura del agua en la caldera. Esta comprobación se 
....................       //realiza siempre, independientemente de que el sistema esté o no encendido. 
....................       if(!comp_caldera()) 
6292:  CALL   21BE
6296:  MOVF   01,F
6298:  BNZ   62AA
....................       { 
....................          //Entramos aquí si la temperatura de la caldera es menor que la necesaria 
....................          if(temperatura_caldera_superada) 
629A:  BTFSS  1E.0
629C:  BRA    62A0
....................            //Si el flag estaba activado, lo desactivamos 
....................            temperatura_caldera_superada = FALSE; 
629E:  BCF    1E.0
....................          if(!caldera_encendida) 
62A0:  BTFSC  F83.0
62A2:  BRA    62A8
....................             //Si no estaba encendida, la encendemos 
....................             encender_caldera(); 
62A4:  GOTO   527C
....................       } 
....................       else 
62A8:  BRA    62B8
....................       { 
....................          //Si la temperatura de la caldera es mayor que la necesaria, apagamos la caldera si está encendida 
....................          //y activamos el flag correspondiente 
....................          if(!temperatura_caldera_superada) 
62AA:  BTFSC  1E.0
62AC:  BRA    62B0
....................             temperatura_caldera_superada = TRUE; 
62AE:  BSF    1E.0
....................          if(caldera_encendida) 
62B0:  BTFSS  F83.0
62B2:  BRA    62B8
....................             apagar_caldera(); 
62B4:  GOTO   5298
....................       } 
....................  
....................       //Comprobamos la temperatura y almacenamos el resultado en una variable 
....................       aux = comprobar_temperatura(); 
62B8:  GOTO   543A
62BC:  MOVFF  01,56
....................  
....................       //Comprobamos que el sistema no lleve encendido más de 4 horas, ya que en ese caso hay riesgo de avería 
....................       //(en realidad esta limitación deriva de un problema propio de representación en memoria). 
....................       //Ya leimos el tiempo en comprobar_temperatura(), así que no necesitamos leerlo de nuevo. 
....................       if(sistema_encendido && diferencia_tiempo(hora_encendido, minutos_encendido, tiempo.hours, tiempo.minutes)>240) 
62C0:  BTFSS  F83.2
62C2:  BRA    6392
62C4:  MOVFF  4C,75
62C8:  MOVFF  4D,76
62CC:  MOVFF  47,77
62D0:  MOVFF  46,78
62D4:  CALL   27DA
62D8:  MOVFF  02,6E
62DC:  MOVFF  01,6D
62E0:  MOVF   6E,F
62E2:  BNZ   62EA
62E4:  MOVF   6D,W
62E6:  SUBLW  F0
62E8:  BC    6392
....................       { 
....................          //Si la diferencia de tiempo es mayor que 4 horas, lo indicamos y apagamos el motor y el sistema 
....................          lcd_send_byte(LCD_ORDEN,LCD_CLEAR); 
62EA:  MOVLB  2
62EC:  CLRF   x85
62EE:  MOVLW  01
62F0:  MOVWF  x86
62F2:  MOVLB  0
62F4:  CALL   0DA8
....................          printf(lcd_putc, "Demasiado tiempo\nencendido!"); 
62F8:  CLRF   6D
62FA:  MOVF   6D,W
62FC:  CALL   03E0
6300:  IORLW  00
6302:  BZ    6312
6304:  INCF   6D,F
6306:  MOVLB  2
6308:  MOVWF  x80
630A:  MOVLB  0
630C:  CALL   0E7C
6310:  BRA    62FA
....................          delay_ms(2*LCD_T_RETARDO); 
6312:  MOVLW  04
6314:  MOVWF  6D
6316:  MOVLW  FA
6318:  MOVLB  2
631A:  MOVWF  x87
631C:  MOVLB  0
631E:  CALL   0D30
6322:  DECFSZ 6D,F
6324:  BRA    6316
....................          lcd_send_byte(LCD_ORDEN,LCD_CLEAR); 
6326:  MOVLB  2
6328:  CLRF   x85
632A:  MOVLW  01
632C:  MOVWF  x86
632E:  MOVLB  0
6330:  CALL   0DA8
....................          printf(lcd_putc, "  Apagando\n  sistema..."); 
6334:  CLRF   6D
6336:  MOVF   6D,W
6338:  CALL   0128
633C:  IORLW  00
633E:  BZ    634E
6340:  INCF   6D,F
6342:  MOVLB  2
6344:  MOVWF  x80
6346:  MOVLB  0
6348:  CALL   0E7C
634C:  BRA    6336
....................          apagar_sistema(); 
634E:  CALL   2A5E
....................  
....................          if(motor) 
6352:  BTFSS  F83.1
6354:  BRA    6358
....................            motor = FALSE; 
6356:  BCF    F83.1
....................  
....................          //Si estaba encendido por alguna alarma, recuperamos el termostato anterior. 
....................          if(encendido_por_alarma) 
6358:  BTFSS  1E.2
635A:  BRA    638E
....................          { 
....................             termostato = termostato_provisional; 
635C:  MOVFF  26,22
6360:  MOVFF  25,21
6364:  MOVFF  24,20
6368:  MOVFF  23,1F
....................             //Almacenamos el valor en el sensor 
....................             ds1820_establecer_TH_TL(127.5, termostato); 
636C:  CLRF   76
636E:  CLRF   75
6370:  MOVLW  7F
6372:  MOVWF  74
6374:  MOVLW  85
6376:  MOVWF  73
6378:  MOVFF  22,7A
637C:  MOVFF  21,79
6380:  MOVFF  20,78
6384:  MOVFF  1F,77
6388:  CALL   15CE
....................             encendido_por_alarma = FALSE; 
638C:  BCF    1E.2
....................          } 
....................  
....................          goto inicio; 
638E:  GOTO   5660
....................  
....................       } 
....................  
....................       //Comprobamos ahora la temperatura de la vivienda. Esto se realiza sólo si el sistema está encendido 
....................       if(aux && sistema_encendido && temperatura_caldera_superada) 
6392:  MOVF   56,F
6394:  BZ    63A6
6396:  BTFSS  F83.2
6398:  BRA    63A6
639A:  BTFSS  1E.0
639C:  BRA    63A6
....................       { 
....................          //Si la temperatura es menor que la necesaria, el sistema está encendido y la temperatura del 
....................          //agua en la caldera es la adecuada, encendemos el motor de circulación del agua 
....................          if(!motor) 
639E:  BTFSC  F83.1
63A0:  BRA    63A4
....................             motor = TRUE; 
63A2:  BSF    F83.1
....................  
....................       } 
....................       else if(motor) 
63A4:  BRA    63AC
63A6:  BTFSS  F83.1
63A8:  BRA    63AC
....................          //Si no se cumplen las condiciones, apagamos el motor si está encendido 
....................          motor = FALSE; 
63AA:  BCF    F83.1
....................  
....................       //Activamos el perro guardián 
....................       setup_wdt(WDT_ON); 
63AC:  BSF    FD1.0
....................  
....................       //Ponemos a "dormir" al microcontrolador para que el gasto de energía sea menor 
....................       //Esto lo hacemos sólo si no se han levantado los flags de interrupción en estos segundos, 
....................       //ya que esto provocaría que se aplazase la gestión de la interrupción hasta que saltase el 
....................       //perro guardián. 
....................       if(!alarma_int && !lcd_int) 
63AE:  BTFSC  1E.5
63B0:  BRA    63B8
63B2:  BTFSC  1E.4
63B4:  BRA    63B8
....................          sleep(); 
63B6:  SLEEP 
....................  
....................    } 
63B8:  GOTO   5660
....................  
.................... } 
....................  
.................... //********************************************* 
.................... //    Descripción de los métodos utilizados 
.................... //********************************************* 
.................... //Puede verse una explicación general de la función de cada método al principio del programa 
....................  
.................... int1 comprobar_temperatura() 
.................... { 
63BC:  SLEEP 
....................    //Leemos la temperatura 
....................    temperatura = ds1820_read(); 
*
543A:  CALL   1D38
543E:  MOVFF  03,2A
5442:  MOVFF  02,29
5446:  MOVFF  01,28
544A:  MOVFF  00,27
....................  
....................    //Mostramos la información en la pantalla lcd 
....................    mostrar_temperatura(); 
544E:  BRA    5350
....................  
....................    if(ds1820_termostato()) 
5450:  CALL   1DEA
5454:  MOVF   01,F
5456:  BZ    54BC
....................    { 
....................       //Si la temperatura es menor que la del termostato, devolvemos TRUE 
....................       if(temp_habitacion_superada) 
5458:  BTFSS  1E.1
545A:  BRA    54B4
....................       { 
....................          //Si la temperatura antes era mayor, indicamos el cambio en el flag 
....................          temp_habitacion_superada = FALSE; 
545C:  BCF    1E.1
....................          //Tenemos en cuenta la histéresis para el nuevo valor del termostato 
....................          termostato = termostato + histeresis_vivienda; 
545E:  BCF    FD8.1
5460:  MOVFF  22,282
5464:  MOVFF  21,281
5468:  MOVFF  20,280
546C:  MOVFF  1F,27F
5470:  MOVFF  2E,286
5474:  MOVFF  2D,285
5478:  MOVFF  2C,284
547C:  MOVFF  2B,283
5480:  CALL   1E96
5484:  MOVFF  03,22
5488:  MOVFF  02,21
548C:  MOVFF  01,20
5490:  MOVFF  00,1F
....................          //Guardamos la información también en el sensor de temperatura 
....................          //Ponemos como TH una temperatura muy grande (127.5ºC) 
....................          ds1820_establecer_TH_TL(127.5, termostato); 
5494:  CLRF   76
5496:  CLRF   75
5498:  MOVLW  7F
549A:  MOVWF  74
549C:  MOVLW  85
549E:  MOVWF  73
54A0:  MOVFF  22,7A
54A4:  MOVFF  21,79
54A8:  MOVFF  20,78
54AC:  MOVFF  1F,77
54B0:  CALL   15CE
....................       } 
....................       return TRUE; 
54B4:  MOVLW  01
54B6:  MOVWF  01
54B8:  BRA    551E
....................    } 
....................    else 
54BA:  BRA    551E
....................    { 
....................       //Si la temperatura es mayor que la del termostato, devolvemos FALSE 
....................       if(!temp_habitacion_superada) 
54BC:  BTFSC  1E.1
54BE:  BRA    5518
....................       { 
....................          //Si antes era menor, cambiamos el flag 
....................          temp_habitacion_superada = TRUE; 
54C0:  BSF    1E.1
....................          //Guardamos el nuevo valor del termostato teniendo en cuenta la histéresis 
....................          termostato = termostato - histeresis_vivienda; 
54C2:  BSF    FD8.1
54C4:  MOVFF  22,282
54C8:  MOVFF  21,281
54CC:  MOVFF  20,280
54D0:  MOVFF  1F,27F
54D4:  MOVFF  2E,286
54D8:  MOVFF  2D,285
54DC:  MOVFF  2C,284
54E0:  MOVFF  2B,283
54E4:  CALL   1E96
54E8:  MOVFF  03,22
54EC:  MOVFF  02,21
54F0:  MOVFF  01,20
54F4:  MOVFF  00,1F
....................          //Guardamos la información también en el sensor de temperatura 
....................          //Ponemos como TH una temperatura muy grande (127.5ºC) 
....................          ds1820_establecer_TH_TL(127.5, termostato); 
54F8:  CLRF   76
54FA:  CLRF   75
54FC:  MOVLW  7F
54FE:  MOVWF  74
5500:  MOVLW  85
5502:  MOVWF  73
5504:  MOVFF  22,7A
5508:  MOVFF  21,79
550C:  MOVFF  20,78
5510:  MOVFF  1F,77
5514:  CALL   15CE
....................       } 
....................       return FALSE; 
5518:  MOVLW  00
551A:  MOVWF  01
551C:  BRA    551E
....................    } 
.................... } 
551E:  GOTO   62BC (RETURN)
....................  
....................  
.................... int comp_caldera() 
.................... { 
....................    //Suponemos una variación de la temperatura del agua en la caldera de t_max_calderaºC 
....................    //a t_min_calderaºC, con una precisión que depende del potenciómetro. 
....................  
....................    //Variables para registrar el termostato y la temperatura de la caldera 
....................    float termo, temp; 
....................  
....................    //Establecemos como entrada analógica a analizar la del termostato 
....................    set_adc_channel(termostato_caldera); 
*
21BE:  MOVLW  0C
21C0:  MOVWF  01
21C2:  MOVF   FC2,W
21C4:  ANDLW  C3
21C6:  IORWF  01,W
21C8:  MOVWF  FC2
....................    delay_us(10);  //Retraso para posibilitar la lectura 
21CA:  CLRWDT
21CC:  MOVLW  06
21CE:  MOVWF  00
21D0:  DECFSZ 00,F
21D2:  BRA    21D0
....................    //Transformamos el valor analógico leído en la escala utilizada por el termostato 
....................    termo = t_min_caldera + ((t_max_caldera-t_min_caldera)*(float)read_adc())/AD_num_valores; 
21D4:  BSF    FC2.1
21D6:  BTFSC  FC2.1
21D8:  BRA    21D6
21DA:  MOVF   FC4,W
21DC:  MOVLB  2
21DE:  CLRF   x86
21E0:  MOVWF  x85
21E2:  MOVLB  0
21E4:  RCALL  2110
21E6:  MOVLB  2
21E8:  CLRF   x9E
21EA:  CLRF   x9D
21EC:  MOVLW  48
21EE:  MOVWF  x9C
21F0:  MOVLW  85
21F2:  MOVWF  x9B
21F4:  MOVFF  03,2A2
21F8:  MOVFF  02,2A1
21FC:  MOVFF  01,2A0
2200:  MOVFF  00,29F
2204:  MOVLB  0
2206:  CALL   14D6
220A:  MOVFF  00,75
220E:  MOVFF  01,76
2212:  MOVFF  02,77
2216:  MOVFF  03,78
221A:  MOVFF  03,288
221E:  MOVFF  02,287
2222:  MOVFF  01,286
2226:  MOVFF  00,285
222A:  MOVLB  2
222C:  CLRF   x8C
222E:  CLRF   x8B
2230:  MOVLW  7F
2232:  MOVWF  x8A
2234:  MOVLW  86
2236:  MOVWF  x89
2238:  MOVLB  0
223A:  RCALL  1BD8
223C:  BCF    FD8.1
223E:  MOVLB  2
2240:  CLRF   x82
2242:  CLRF   x81
2244:  CLRF   x80
2246:  CLRF   x7F
2248:  MOVFF  03,286
224C:  MOVFF  02,285
2250:  MOVFF  01,284
2254:  MOVFF  00,283
2258:  MOVLB  0
225A:  RCALL  1E96
225C:  MOVFF  03,70
2260:  MOVFF  02,6F
2264:  MOVFF  01,6E
2268:  MOVFF  00,6D
....................  
....................    //Establecemos como entrada analógica a analizar la de la temperatura del agua 
....................    set_adc_channel(temperatura_caldera); 
226C:  MOVLW  08
226E:  MOVWF  01
2270:  MOVF   FC2,W
2272:  ANDLW  C3
2274:  IORWF  01,W
2276:  MOVWF  FC2
....................    delay_us(10); //Retraso para posibilitar la lectura 
2278:  CLRWDT
227A:  MOVLW  06
227C:  MOVWF  00
227E:  DECFSZ 00,F
2280:  BRA    227E
....................    //Transformamos el valor analógico leído a la escala utlizada en la temperatura 
....................    temp = t_min_caldera + ((t_max_caldera-t_min_caldera)*(float)read_adc())/AD_num_valores; 
2282:  BSF    FC2.1
2284:  BTFSC  FC2.1
2286:  BRA    2284
2288:  MOVF   FC4,W
228A:  MOVLB  2
228C:  CLRF   x86
228E:  MOVWF  x85
2290:  MOVLB  0
2292:  RCALL  2110
2294:  MOVLB  2
2296:  CLRF   x9E
2298:  CLRF   x9D
229A:  MOVLW  48
229C:  MOVWF  x9C
229E:  MOVLW  85
22A0:  MOVWF  x9B
22A2:  MOVFF  03,2A2
22A6:  MOVFF  02,2A1
22AA:  MOVFF  01,2A0
22AE:  MOVFF  00,29F
22B2:  MOVLB  0
22B4:  CALL   14D6
22B8:  MOVFF  00,75
22BC:  MOVFF  01,76
22C0:  MOVFF  02,77
22C4:  MOVFF  03,78
22C8:  MOVFF  03,288
22CC:  MOVFF  02,287
22D0:  MOVFF  01,286
22D4:  MOVFF  00,285
22D8:  MOVLB  2
22DA:  CLRF   x8C
22DC:  CLRF   x8B
22DE:  MOVLW  7F
22E0:  MOVWF  x8A
22E2:  MOVLW  86
22E4:  MOVWF  x89
22E6:  MOVLB  0
22E8:  RCALL  1BD8
22EA:  BCF    FD8.1
22EC:  MOVLB  2
22EE:  CLRF   x82
22F0:  CLRF   x81
22F2:  CLRF   x80
22F4:  CLRF   x7F
22F6:  MOVFF  03,286
22FA:  MOVFF  02,285
22FE:  MOVFF  01,284
2302:  MOVFF  00,283
2306:  MOVLB  0
2308:  RCALL  1E96
230A:  MOVFF  03,74
230E:  MOVFF  02,73
2312:  MOVFF  01,72
2316:  MOVFF  00,71
....................  
....................    //Comparamos ambas temperaturas teniendo en cuenta la histéresis de la caldera 
....................    if(temperatura_caldera_superada) 
231A:  BTFSS  1E.0
231C:  BRA    2378
....................    { 
....................       if(temp >= termo-histeresis_caldera) 
231E:  BSF    FD8.1
2320:  MOVFF  70,282
2324:  MOVFF  6F,281
2328:  MOVFF  6E,280
232C:  MOVFF  6D,27F
2330:  MOVLB  2
2332:  CLRF   x86
2334:  CLRF   x85
2336:  MOVLW  20
2338:  MOVWF  x84
233A:  MOVLW  81
233C:  MOVWF  x83
233E:  MOVLB  0
2340:  RCALL  1E96
2342:  MOVFF  03,78
2346:  MOVFF  02,77
234A:  MOVFF  01,76
234E:  MOVFF  00,75
2352:  MOVFF  74,7C
2356:  MOVFF  73,7B
235A:  MOVFF  72,7A
235E:  MOVFF  71,79
2362:  RCALL  2148
2364:  BC    2368
2366:  BNZ   2370
....................          return TRUE; 
2368:  MOVLW  01
236A:  MOVWF  01
236C:  BRA    23AC
....................       else 
236E:  BRA    2376
....................          return FALSE; 
2370:  MOVLW  00
2372:  MOVWF  01
2374:  BRA    23AC
....................    }else 
2376:  BRA    23AC
....................    { 
....................       if(temp >= termo) 
2378:  MOVFF  70,78
237C:  MOVFF  6F,77
2380:  MOVFF  6E,76
2384:  MOVFF  6D,75
2388:  MOVFF  74,7C
238C:  MOVFF  73,7B
2390:  MOVFF  72,7A
2394:  MOVFF  71,79
2398:  RCALL  2148
239A:  BC    239E
239C:  BNZ   23A6
....................          return TRUE; 
239E:  MOVLW  01
23A0:  MOVWF  01
23A2:  BRA    23AC
....................       else 
23A4:  BRA    23AC
....................          return FALSE; 
23A6:  MOVLW  00
23A8:  MOVWF  01
23AA:  BRA    23AC
....................    } 
.................... } 
23AC:  RETLW  00
....................  
....................  
.................... void mostrar_temperatura() 
.................... { 
....................    //Leemos el tiempo y lo guardamos en la variable tiempo 
....................    PCF8583_read_datetime(&tiempo); 
*
5350:  CLRF   76
5352:  MOVLW  45
5354:  MOVWF  75
5356:  CALL   24AE
....................    //Activamos las interrupciones, que se desactivan dentro del método 
....................    enable_interrupts(GLOBAL); 
535A:  MOVLW  C0
535C:  IORWF  FF2,F
....................  
....................    //Mostramos la temperatura registrada 
....................    lcd_send_byte(LCD_ORDEN, LCD_CLEAR); 
535E:  MOVLB  2
5360:  CLRF   x85
5362:  MOVLW  01
5364:  MOVWF  x86
5366:  MOVLB  0
5368:  CALL   0DA8
....................    printf(lcd_putc, "TEMP - %3.1f %cC\nHORA - ", temperatura, 223); 
536C:  CLRF   6D
536E:  MOVF   6D,W
5370:  CALL   0416
5374:  INCF   6D,F
5376:  MOVWF  00
5378:  MOVFF  FE8,280
537C:  CALL   0E7C
5380:  MOVLW  07
5382:  SUBWF  6D,W
5384:  BNZ   536E
5386:  MOVLW  02
5388:  MOVWF  FE9
538A:  MOVFF  2A,75
538E:  MOVFF  29,74
5392:  MOVFF  28,73
5396:  MOVFF  27,72
539A:  MOVLW  01
539C:  MOVWF  76
539E:  CALL   2F54
53A2:  MOVLW  20
53A4:  MOVLB  2
53A6:  MOVWF  x80
53A8:  MOVLB  0
53AA:  CALL   0E7C
53AE:  MOVLW  DF
53B0:  MOVLB  2
53B2:  MOVWF  x80
53B4:  MOVLB  0
53B6:  CALL   0E7C
53BA:  MOVLW  0F
53BC:  MOVWF  6E
53BE:  MOVF   6E,W
53C0:  CALL   0416
53C4:  INCF   6E,F
53C6:  MOVWF  00
53C8:  MOVFF  FE8,280
53CC:  CALL   0E7C
53D0:  MOVLW  18
53D2:  SUBWF  6E,W
53D4:  BNZ   53BE
....................  
....................    //Mostramos la hora 
....................    //Comprobamos si los valores son menores que 10 para añadir un cero 
....................    //delante y que queden los valores alineados 
....................    if(tiempo.hours < 10) 
53D6:  MOVF   47,W
53D8:  SUBLW  09
53DA:  BNC   53F6
....................       printf(lcd_putc, "0"); 
53DC:  CLRF   6D
53DE:  MOVF   6D,W
53E0:  CALL   044A
53E4:  IORLW  00
53E6:  BZ    53F6
53E8:  INCF   6D,F
53EA:  MOVLB  2
53EC:  MOVWF  x80
53EE:  MOVLB  0
53F0:  CALL   0E7C
53F4:  BRA    53DE
....................    printf(lcd_putc, "%u:", tiempo.hours); 
53F6:  MOVFF  47,6D
53FA:  MOVLW  1B
53FC:  MOVWF  6E
53FE:  RCALL  52D8
5400:  MOVLW  3A
5402:  MOVLB  2
5404:  MOVWF  x80
5406:  MOVLB  0
5408:  CALL   0E7C
....................    if(tiempo.minutes < 10) 
540C:  MOVF   46,W
540E:  SUBLW  09
5410:  BNC   542C
....................       printf(lcd_putc, "0"); 
5412:  CLRF   6D
5414:  MOVF   6D,W
5416:  CALL   044A
541A:  IORLW  00
541C:  BZ    542C
541E:  INCF   6D,F
5420:  MOVLB  2
5422:  MOVWF  x80
5424:  MOVLB  0
5426:  CALL   0E7C
542A:  BRA    5414
....................    printf(lcd_putc, "%u", tiempo.minutes); 
542C:  MOVFF  46,6D
5430:  MOVLW  1B
5432:  MOVWF  6E
5434:  RCALL  52D8
.................... } 
5436:  GOTO   5450 (RETURN)
....................  
....................  
.................... void encender_sistema() 
.................... { 
....................    //Leemos el tiempo actual 
....................    PCF8583_read_datetime(&tiempo); 
*
2668:  CLRF   76
266A:  MOVLW  45
266C:  MOVWF  75
266E:  RCALL  24AE
....................  
....................    //Registramos la hora y minutos en los que se enciende el sistema 
....................    hora_encendido    = tiempo.hours; 
2670:  MOVFF  47,4C
....................    minutos_encendido = tiempo.minutes; 
2674:  MOVFF  46,4D
....................  
....................    //Inicializamos a 0 el tiempo total que está encendida la caldera 
....................    t_total_caldera = 0; 
2678:  CLRF   52
267A:  CLRF   51
....................  
....................    //Si la caldera está encendida, inicializamos el instante de encendido a 
....................    //éste. 
....................    if(caldera_encendida) 
267C:  BTFSS  F83.0
267E:  BRA    268C
....................    { 
....................       hora_caldera = tiempo.hours; 
2680:  MOVFF  47,4E
....................       minutos_caldera = tiempo.minutes; 
2684:  MOVFF  46,4F
....................       segundos_caldera = tiempo.seconds; 
2688:  MOVFF  45,50
....................    } 
....................  
....................    //Encendemos el sistema 
....................    sistema_encendido = TRUE; 
268C:  BSF    F83.2
.................... } 
268E:  RETLW  00
....................  
....................  
.................... void apagar_sistema() 
.................... { 
....................    long minutos_trans;  //Minutos transcurridos desde el encendido del sistema 
....................    int t_entera, t_decimal; //Temperatura del hogar en ese momento (parte entera y decimal) 
....................    float temperatura;  //Temperatura leída 
....................  
....................  
....................    //Si llegamos al límite de la memoria, se resetea el indicador 
....................    //Por utilizar la memoria del PIC sólo contamos con 26 registros de fecha 
....................    if(num_registros > 26) 
*
2A5E:  MOVF   53,W
2A60:  SUBLW  1A
2A62:  BC    2A66
....................       num_registros = 0; 
2A64:  CLRF   53
....................  
....................    //Leemos el tiempo actual 
....................    PCF8583_read_datetime(&tiempo); 
2A66:  CLRF   76
2A68:  MOVLW  45
2A6A:  MOVWF  75
2A6C:  RCALL  24AE
....................  
....................    //Calculamos los minutos transcurridos desde el encendido como una diferencia de tiempos 
....................    minutos_trans = diferencia_tiempo(hora_encendido, minutos_encendido, tiempo.hours, tiempo.minutes); 
2A6E:  MOVFF  4C,75
2A72:  MOVFF  4D,76
2A76:  MOVFF  47,77
2A7A:  MOVFF  46,78
2A7E:  RCALL  27DA
2A80:  MOVFF  02,6E
2A84:  MOVFF  01,6D
....................  
....................    //Leemos la temperatura en ese momento 
....................    temperatura = ds1820_read(); 
2A88:  CALL   1D38
2A8C:  MOVFF  03,74
2A90:  MOVFF  02,73
2A94:  MOVFF  01,72
2A98:  MOVFF  00,71
....................  
....................    //Descomponemos la temperatura en su parte entera y parte decimal para almacenarla 
....................    t_entera = (int)temperatura; 
2A9C:  MOVFF  74,86
2AA0:  MOVFF  73,85
2AA4:  MOVFF  72,84
2AA8:  MOVFF  71,83
2AAC:  CALL   142C
2AB0:  MOVFF  01,6F
....................    t_decimal = (int)((temperatura-t_entera)*100); 
2AB4:  MOVLB  2
2AB6:  CLRF   x86
2AB8:  MOVFF  6F,285
2ABC:  MOVLB  0
2ABE:  CALL   2110
2AC2:  BSF    FD8.1
2AC4:  MOVFF  74,282
2AC8:  MOVFF  73,281
2ACC:  MOVFF  72,280
2AD0:  MOVFF  71,27F
2AD4:  MOVFF  03,286
2AD8:  MOVFF  02,285
2ADC:  MOVFF  01,284
2AE0:  MOVFF  00,283
2AE4:  CALL   1E96
2AE8:  MOVFF  00,75
2AEC:  MOVFF  01,76
2AF0:  MOVFF  02,77
2AF4:  MOVFF  03,78
2AF8:  MOVFF  03,29E
2AFC:  MOVFF  02,29D
2B00:  MOVFF  01,29C
2B04:  MOVFF  00,29B
2B08:  MOVLB  2
2B0A:  CLRF   xA2
2B0C:  CLRF   xA1
2B0E:  MOVLW  48
2B10:  MOVWF  xA0
2B12:  MOVLW  85
2B14:  MOVWF  x9F
2B16:  MOVLB  0
2B18:  CALL   14D6
2B1C:  MOVFF  03,86
2B20:  MOVFF  02,85
2B24:  MOVFF  01,84
2B28:  MOVFF  00,83
2B2C:  CALL   142C
2B30:  MOVFF  01,70
....................  
....................    //Si la caldera estaba encendida, sumamos el último intervalo de encendido al tiempo total 
....................    if(caldera_encendida) 
2B34:  BTFSS  F83.0
2B36:  BRA    2B5A
....................       t_total_caldera = t_total_caldera + diferencia_tiempo_sec(hora_caldera, minutos_caldera, segundos_caldera, tiempo.hours, tiempo.minutes, tiempo.seconds); 
2B38:  MOVFF  4E,75
2B3C:  MOVFF  4F,76
2B40:  MOVFF  50,77
2B44:  MOVFF  47,78
2B48:  MOVFF  46,79
2B4C:  MOVFF  45,7A
2B50:  RCALL  28C6
2B52:  MOVF   01,W
2B54:  ADDWF  51,F
2B56:  MOVF   02,W
2B58:  ADDWFC 52,F
....................  
....................    //Calculamos el año en el que nos encontramos 
....................    if(anno_actual_0_to_3 != tiempo.year) 
2B5A:  MOVF   4A,W
2B5C:  SUBWF  55,W
2B5E:  BZ    2BB8
....................    { 
....................       //Si el año que teníamos almacenado no es igual que el que marca el reloj, 
....................       //debemos de actualizar las variables correspondientes. 
....................       //Suponemos que al menos se conecta el sistema una vez al año 
....................       anno_actual++; 
2B60:  INCF   54,F
....................       anno_actual_0_to_3++; 
2B62:  INCF   55,F
....................  
....................       //Guardamos los valores en memoria 
....................       write_eeprom(eeprom_anno_actual, anno_actual); 
2B64:  MOVLW  03
2B66:  MOVWF  FA9
2B68:  MOVFF  54,FA8
2B6C:  BCF    FA6.6
2B6E:  BCF    FA6.7
2B70:  BSF    FA6.2
2B72:  MOVFF  FF2,00
2B76:  BCF    FF2.7
2B78:  MOVLB  F
2B7A:  MOVLW  55
2B7C:  MOVWF  FA7
2B7E:  MOVLW  AA
2B80:  MOVWF  FA7
2B82:  BSF    FA6.1
2B84:  BTFSC  FA6.1
2B86:  BRA    2B84
2B88:  BCF    FA6.2
2B8A:  MOVF   00,W
2B8C:  IORWF  FF2,F
....................       write_eeprom(eeprom_anno_0_to_3, anno_actual_0_to_3); 
2B8E:  MOVLW  04
2B90:  MOVWF  FA9
2B92:  MOVFF  55,FA8
2B96:  BCF    FA6.6
2B98:  BCF    FA6.7
2B9A:  BSF    FA6.2
2B9C:  MOVFF  FF2,00
2BA0:  BCF    FF2.7
2BA2:  MOVLW  55
2BA4:  MOVWF  FA7
2BA6:  MOVLW  AA
2BA8:  MOVWF  FA7
2BAA:  BSF    FA6.1
2BAC:  BTFSC  FA6.1
2BAE:  BRA    2BAC
2BB0:  BCF    FA6.2
2BB2:  MOVF   00,W
2BB4:  IORWF  FF2,F
2BB6:  MOVLB  0
....................    } 
....................  
....................  
....................    //Almacenamos todos los datos requeridos 
....................    write_eeprom(eeprom_registros + (num_registros)*10    , tiempo.day);                  //Día de desconexión 
2BB8:  MOVF   53,W
2BBA:  MULLW  0A
2BBC:  MOVF   FF3,W
2BBE:  ADDLW  14
2BC0:  MOVWF  75
2BC2:  MOVWF  FA9
2BC4:  MOVFF  48,FA8
2BC8:  BCF    FA6.6
2BCA:  BCF    FA6.7
2BCC:  BSF    FA6.2
2BCE:  MOVFF  FF2,00
2BD2:  BCF    FF2.7
2BD4:  MOVLB  F
2BD6:  MOVLW  55
2BD8:  MOVWF  FA7
2BDA:  MOVLW  AA
2BDC:  MOVWF  FA7
2BDE:  BSF    FA6.1
2BE0:  BTFSC  FA6.1
2BE2:  BRA    2BE0
2BE4:  BCF    FA6.2
2BE6:  MOVF   00,W
2BE8:  IORWF  FF2,F
....................    write_eeprom(eeprom_registros + (num_registros)*10 + 1, tiempo.month);                //Mes de desconexión 
2BEA:  MOVF   53,W
2BEC:  MULLW  0A
2BEE:  MOVF   FF3,W
2BF0:  ADDLW  14
2BF2:  ADDLW  01
2BF4:  MOVWF  76
2BF6:  MOVWF  FA9
2BF8:  MOVFF  49,FA8
2BFC:  BCF    FA6.6
2BFE:  BCF    FA6.7
2C00:  BSF    FA6.2
2C02:  MOVFF  FF2,00
2C06:  BCF    FF2.7
2C08:  MOVLW  55
2C0A:  MOVWF  FA7
2C0C:  MOVLW  AA
2C0E:  MOVWF  FA7
2C10:  BSF    FA6.1
2C12:  BTFSC  FA6.1
2C14:  BRA    2C12
2C16:  BCF    FA6.2
2C18:  MOVF   00,W
2C1A:  IORWF  FF2,F
....................    write_eeprom(eeprom_registros + (num_registros)*10 + 2, anno_actual);                 //Año de desconexión 
2C1C:  MOVF   53,W
2C1E:  MULLW  0A
2C20:  MOVF   FF3,W
2C22:  ADDLW  14
2C24:  ADDLW  02
2C26:  MOVWF  76
2C28:  MOVWF  FA9
2C2A:  MOVFF  54,FA8
2C2E:  BCF    FA6.6
2C30:  BCF    FA6.7
2C32:  BSF    FA6.2
2C34:  MOVFF  FF2,00
2C38:  BCF    FF2.7
2C3A:  MOVLW  55
2C3C:  MOVWF  FA7
2C3E:  MOVLW  AA
2C40:  MOVWF  FA7
2C42:  BSF    FA6.1
2C44:  BTFSC  FA6.1
2C46:  BRA    2C44
2C48:  BCF    FA6.2
2C4A:  MOVF   00,W
2C4C:  IORWF  FF2,F
....................    write_eeprom(eeprom_registros + (num_registros)*10 + 3, tiempo.hours);                //Hora de desconexión 
2C4E:  MOVF   53,W
2C50:  MULLW  0A
2C52:  MOVF   FF3,W
2C54:  ADDLW  14
2C56:  ADDLW  03
2C58:  MOVWF  76
2C5A:  MOVWF  FA9
2C5C:  MOVFF  47,FA8
2C60:  BCF    FA6.6
2C62:  BCF    FA6.7
2C64:  BSF    FA6.2
2C66:  MOVFF  FF2,00
2C6A:  BCF    FF2.7
2C6C:  MOVLW  55
2C6E:  MOVWF  FA7
2C70:  MOVLW  AA
2C72:  MOVWF  FA7
2C74:  BSF    FA6.1
2C76:  BTFSC  FA6.1
2C78:  BRA    2C76
2C7A:  BCF    FA6.2
2C7C:  MOVF   00,W
2C7E:  IORWF  FF2,F
....................    write_eeprom(eeprom_registros + (num_registros)*10 + 4, tiempo.minutes);              //Minutos de desconexión 
2C80:  MOVF   53,W
2C82:  MULLW  0A
2C84:  MOVF   FF3,W
2C86:  ADDLW  14
2C88:  ADDLW  04
2C8A:  MOVWF  76
2C8C:  MOVWF  FA9
2C8E:  MOVFF  46,FA8
2C92:  BCF    FA6.6
2C94:  BCF    FA6.7
2C96:  BSF    FA6.2
2C98:  MOVFF  FF2,00
2C9C:  BCF    FF2.7
2C9E:  MOVLW  55
2CA0:  MOVWF  FA7
2CA2:  MOVLW  AA
2CA4:  MOVWF  FA7
2CA6:  BSF    FA6.1
2CA8:  BTFSC  FA6.1
2CAA:  BRA    2CA8
2CAC:  BCF    FA6.2
2CAE:  MOVF   00,W
2CB0:  IORWF  FF2,F
....................    write_eeprom(eeprom_registros + (num_registros)*10 + 5, t_entera);                    //Valor entero de última temperatura medida 
2CB2:  MOVF   53,W
2CB4:  MULLW  0A
2CB6:  MOVF   FF3,W
2CB8:  ADDLW  14
2CBA:  ADDLW  05
2CBC:  MOVWF  76
2CBE:  MOVWF  FA9
2CC0:  MOVFF  6F,FA8
2CC4:  BCF    FA6.6
2CC6:  BCF    FA6.7
2CC8:  BSF    FA6.2
2CCA:  MOVFF  FF2,00
2CCE:  BCF    FF2.7
2CD0:  MOVLW  55
2CD2:  MOVWF  FA7
2CD4:  MOVLW  AA
2CD6:  MOVWF  FA7
2CD8:  BSF    FA6.1
2CDA:  BTFSC  FA6.1
2CDC:  BRA    2CDA
2CDE:  BCF    FA6.2
2CE0:  MOVF   00,W
2CE2:  IORWF  FF2,F
....................    write_eeprom(eeprom_registros + (num_registros)*10 + 6, t_decimal);                   //Valor decimal de última temperatura medida 
2CE4:  MOVF   53,W
2CE6:  MULLW  0A
2CE8:  MOVF   FF3,W
2CEA:  ADDLW  14
2CEC:  ADDLW  06
2CEE:  MOVWF  76
2CF0:  MOVWF  FA9
2CF2:  MOVFF  70,FA8
2CF6:  BCF    FA6.6
2CF8:  BCF    FA6.7
2CFA:  BSF    FA6.2
2CFC:  MOVFF  FF2,00
2D00:  BCF    FF2.7
2D02:  MOVLW  55
2D04:  MOVWF  FA7
2D06:  MOVLW  AA
2D08:  MOVWF  FA7
2D0A:  BSF    FA6.1
2D0C:  BTFSC  FA6.1
2D0E:  BRA    2D0C
2D10:  BCF    FA6.2
2D12:  MOVF   00,W
2D14:  IORWF  FF2,F
....................    write_eeprom(eeprom_registros + (num_registros)*10 + 7, (unsigned int)minutos_trans);          //Minutos transcurridos desde el encendido 
2D16:  MOVF   53,W
2D18:  MULLW  0A
2D1A:  MOVF   FF3,W
2D1C:  ADDLW  14
2D1E:  ADDLW  07
2D20:  MOVWF  76
2D22:  MOVWF  FA9
2D24:  MOVFF  6D,FA8
2D28:  BCF    FA6.6
2D2A:  BCF    FA6.7
2D2C:  BSF    FA6.2
2D2E:  MOVFF  FF2,00
2D32:  BCF    FF2.7
2D34:  MOVLW  55
2D36:  MOVWF  FA7
2D38:  MOVLW  AA
2D3A:  MOVWF  FA7
2D3C:  BSF    FA6.1
2D3E:  BTFSC  FA6.1
2D40:  BRA    2D3E
2D42:  BCF    FA6.2
2D44:  MOVF   00,W
2D46:  IORWF  FF2,F
....................    write_eeprom(eeprom_registros + (num_registros)*10 + 8, (unsigned int)(t_total_caldera/60));   //Tiempo total que ha estado encendida la caldera 
2D48:  MOVF   53,W
2D4A:  MULLW  0A
2D4C:  MOVF   FF3,W
2D4E:  ADDLW  14
2D50:  ADDLW  08
2D52:  MOVWF  76
2D54:  MOVFF  52,78
2D58:  MOVFF  51,77
2D5C:  CLRF   7A
2D5E:  MOVLW  3C
2D60:  MOVWF  79
2D62:  MOVLB  0
2D64:  BRA    2A18
2D66:  MOVFF  01,77
2D6A:  MOVFF  76,FA9
2D6E:  MOVFF  01,FA8
2D72:  BCF    FA6.6
2D74:  BCF    FA6.7
2D76:  BSF    FA6.2
2D78:  MOVFF  FF2,00
2D7C:  BCF    FF2.7
2D7E:  MOVLB  F
2D80:  MOVLW  55
2D82:  MOVWF  FA7
2D84:  MOVLW  AA
2D86:  MOVWF  FA7
2D88:  BSF    FA6.1
2D8A:  BTFSC  FA6.1
2D8C:  BRA    2D8A
2D8E:  BCF    FA6.2
2D90:  MOVF   00,W
2D92:  IORWF  FF2,F
....................                                                                                                  //en este intervalo (en minutos) 
....................  
....................    //Guardamos también el último valor del termostato, teniendo en cuenta la histéresis del sistema 
....................    if(temp_habitacion_superada) 
2D94:  BTFSS  1E.1
2D96:  BRA    2E10
....................       write_eeprom(eeprom_registros + (num_registros)*10 + 9, (unsigned int)(termostato+histeresis_vivienda)); 
2D98:  MOVF   53,W
2D9A:  MULLW  0A
2D9C:  MOVF   FF3,W
2D9E:  ADDLW  14
2DA0:  ADDLW  09
2DA2:  MOVWF  76
2DA4:  BCF    FD8.1
2DA6:  MOVFF  22,282
2DAA:  MOVFF  21,281
2DAE:  MOVFF  20,280
2DB2:  MOVFF  1F,27F
2DB6:  MOVFF  2E,286
2DBA:  MOVFF  2D,285
2DBE:  MOVFF  2C,284
2DC2:  MOVFF  2B,283
2DC6:  MOVLB  0
2DC8:  CALL   1E96
2DCC:  MOVFF  03,86
2DD0:  MOVFF  02,85
2DD4:  MOVFF  01,84
2DD8:  MOVFF  00,83
2DDC:  CALL   142C
2DE0:  MOVFF  01,77
2DE4:  MOVFF  76,FA9
2DE8:  MOVFF  01,FA8
2DEC:  BCF    FA6.6
2DEE:  BCF    FA6.7
2DF0:  BSF    FA6.2
2DF2:  MOVFF  FF2,00
2DF6:  BCF    FF2.7
2DF8:  MOVLB  F
2DFA:  MOVLW  55
2DFC:  MOVWF  FA7
2DFE:  MOVLW  AA
2E00:  MOVWF  FA7
2E02:  BSF    FA6.1
2E04:  BTFSC  FA6.1
2E06:  BRA    2E04
2E08:  BCF    FA6.2
2E0A:  MOVF   00,W
2E0C:  IORWF  FF2,F
....................    else 
2E0E:  BRA    2E60
....................       write_eeprom(eeprom_registros + (num_registros)*10 + 9, (unsigned int)termostato); 
2E10:  MOVF   53,W
2E12:  MULLW  0A
2E14:  MOVF   FF3,W
2E16:  ADDLW  14
2E18:  ADDLW  09
2E1A:  MOVWF  76
2E1C:  MOVFF  22,86
2E20:  MOVFF  21,85
2E24:  MOVFF  20,84
2E28:  MOVFF  1F,83
2E2C:  MOVLB  0
2E2E:  CALL   142C
2E32:  MOVFF  01,77
2E36:  MOVFF  76,FA9
2E3A:  MOVFF  01,FA8
2E3E:  BCF    FA6.6
2E40:  BCF    FA6.7
2E42:  BSF    FA6.2
2E44:  MOVFF  FF2,00
2E48:  BCF    FF2.7
2E4A:  MOVLB  F
2E4C:  MOVLW  55
2E4E:  MOVWF  FA7
2E50:  MOVLW  AA
2E52:  MOVWF  FA7
2E54:  BSF    FA6.1
2E56:  BTFSC  FA6.1
2E58:  BRA    2E56
2E5A:  BCF    FA6.2
2E5C:  MOVF   00,W
2E5E:  IORWF  FF2,F
....................  
....................    //Aumentamos en uno el número de registros 
....................    num_registros++; 
2E60:  INCF   53,F
....................  
....................    //Guardamos el número de registros en memoria 
....................    write_eeprom(eeprom_num_registros, num_registros); 
2E62:  MOVLW  02
2E64:  MOVWF  FA9
2E66:  MOVFF  53,FA8
2E6A:  BCF    FA6.6
2E6C:  BCF    FA6.7
2E6E:  BSF    FA6.2
2E70:  MOVFF  FF2,00
2E74:  BCF    FF2.7
2E76:  MOVLW  55
2E78:  MOVWF  FA7
2E7A:  MOVLW  AA
2E7C:  MOVWF  FA7
2E7E:  BSF    FA6.1
2E80:  BTFSC  FA6.1
2E82:  BRA    2E80
2E84:  BCF    FA6.2
2E86:  MOVF   00,W
2E88:  IORWF  FF2,F
....................  
....................    //Finalmente, apagamos el sistema 
....................    sistema_encendido = FALSE; 
2E8A:  BCF    F83.2
.................... } 
2E8C:  MOVLB  0
2E8E:  RETLW  00
....................  
....................  
.................... void encender_caldera() 
.................... { 
....................    //Leemos el tiempo actual 
....................    PCF8583_read_datetime(&tiempo); 
*
527C:  CLRF   76
527E:  MOVLW  45
5280:  MOVWF  75
5282:  CALL   24AE
....................  
....................    //Guardamos los datos en las variables correspondientes 
....................    hora_caldera = tiempo.hours; 
5286:  MOVFF  47,4E
....................    minutos_caldera = tiempo.minutes; 
528A:  MOVFF  46,4F
....................    segundos_caldera = tiempo.seconds; 
528E:  MOVFF  45,50
....................  
....................    //Encendemos la caldera 
....................    caldera_encendida = TRUE; 
5292:  BSF    F83.0
.................... } 
5294:  GOTO   62A8 (RETURN)
....................  
....................  
.................... void apagar_caldera() 
.................... { 
....................    int hora, minutos, segundos; //Variables para el tiempo 
....................  
....................    //Leemos el tiempo 
....................    PCF8583_read_datetime(&tiempo); 
5298:  CLRF   76
529A:  MOVLW  45
529C:  MOVWF  75
529E:  CALL   24AE
....................  
....................    //Copiamos en las variables 
....................    hora = tiempo.hours; 
52A2:  MOVFF  47,6D
....................    minutos = tiempo.minutes; 
52A6:  MOVFF  46,6E
....................    segundos = tiempo.seconds; 
52AA:  MOVFF  45,6F
....................  
....................    //Sumamos al tiempo total de encendido de la caldera el tiempo que ha estado encendida esta vez 
....................    t_total_caldera = t_total_caldera + diferencia_tiempo_sec(hora_caldera, minutos_caldera, segundos_caldera, hora, minutos, segundos); 
52AE:  MOVFF  4E,75
52B2:  MOVFF  4F,76
52B6:  MOVFF  50,77
52BA:  MOVFF  6D,78
52BE:  MOVFF  6E,79
52C2:  MOVFF  6F,7A
52C6:  CALL   28C6
52CA:  MOVF   01,W
52CC:  ADDWF  51,F
52CE:  MOVF   02,W
52D0:  ADDWFC 52,F
....................  
....................    //Apagamos la caldera 
....................    caldera_encendida = FALSE; 
52D2:  BCF    F83.0
.................... } 
52D4:  GOTO   62B8 (RETURN)
....................  
....................  
....................  
.................... int buscar_numero(int led_unidades, int min, int max, int valor_inicial){ 
....................    signed int input; 
....................    unsigned int32 contador; 
....................  
....................    //Iniciamos al valor indicado 
....................    input = valor_inicial; 
*
0FD4:  MOVFF  76,77
....................  
....................    //Activamos el cursor de la pantalla 
....................    lcd_send_byte(LCD_ORDEN, LCD_CURSOR); 
0FD8:  MOVLB  2
0FDA:  CLRF   x85
0FDC:  MOVLW  0E
0FDE:  MOVWF  x86
0FE0:  MOVLB  0
0FE2:  RCALL  0DA8
....................  
....................    //Se muestra por pantalla 
....................    lcd_gotoxy(led_unidades,2); 
0FE4:  MOVFF  73,281
0FE8:  MOVLW  02
0FEA:  MOVLB  2
0FEC:  MOVWF  x82
0FEE:  MOVLB  0
0FF0:  RCALL  0E56
....................    //Si el número es menor que 10, le añadimos antes un 0 
....................    if(input<10) 
0FF2:  BTFSC  77.7
0FF4:  BRA    0FFC
0FF6:  MOVF   77,W
0FF8:  SUBLW  09
0FFA:  BNC   1014
....................       printf(lcd_putc, "0"); 
0FFC:  CLRF   7C
0FFE:  MOVF   7C,W
1000:  CALL   044A
1004:  IORLW  00
1006:  BZ    1014
1008:  INCF   7C,F
100A:  MOVLB  2
100C:  MOVWF  x80
100E:  MOVLB  0
1010:  RCALL  0E7C
1012:  BRA    0FFE
....................    printf(lcd_putc,"%i",input); 
1014:  MOVFF  77,7C
1018:  MOVLW  1F
101A:  MOVWF  7D
101C:  RCALL  0F04
....................    //Regresamos el cursor a su posición 
....................    lcd_gotoxy(led_unidades,2); 
101E:  MOVFF  73,281
1022:  MOVLW  02
1024:  MOVLB  2
1026:  MOVWF  x82
1028:  MOVLB  0
102A:  RCALL  0E56
....................  
....................    while(1) 
....................    { 
....................       if(!mas) 
102C:  BTFSC  F82.0
102E:  BRA    110A
....................       { 
....................          //Si se pulsa el botón de +, se aumenta el valor de input 
....................          input++; 
1030:  INCF   77,F
....................          //Si llegamos al límite de los valores, reseteamos 
....................          if(input>max) 
1032:  BTFSC  77.7
1034:  BRA    1040
1036:  MOVF   77,W
1038:  SUBWF  75,W
103A:  BC    1040
....................             input = min; 
103C:  MOVFF  74,77
....................          //Si es un número menor que 10, añadimos un 0 antes 
....................          if(input<10) 
1040:  BTFSC  77.7
1042:  BRA    104A
1044:  MOVF   77,W
1046:  SUBLW  09
1048:  BNC   1062
....................             printf(lcd_putc,"0"); 
104A:  CLRF   7C
104C:  MOVF   7C,W
104E:  CALL   044A
1052:  IORLW  00
1054:  BZ    1062
1056:  INCF   7C,F
1058:  MOVLB  2
105A:  MOVWF  x80
105C:  MOVLB  0
105E:  RCALL  0E7C
1060:  BRA    104C
....................          //Se muestra por pantalla 
....................          printf(lcd_putc,"%i",input); 
1062:  MOVFF  77,7C
1066:  MOVLW  1F
1068:  MOVWF  7D
106A:  RCALL  0F04
....................          //Regresamos el cursor a su posición 
....................          lcd_gotoxy(led_unidades,2); 
106C:  MOVFF  73,281
1070:  MOVLW  02
1072:  MOVLB  2
1074:  MOVWF  x82
1076:  MOVLB  0
1078:  RCALL  0E56
....................          //Esperamos a que se levante la tecla 
....................          //Además introducimos un mecanismo de avance rápido que permite pasar de un 
....................          //valor a otro rápidamente sin más que mantener pulsada la tecla 
....................          contador = 1; 
107A:  CLRF   7B
107C:  CLRF   7A
107E:  CLRF   79
1080:  MOVLW  01
1082:  MOVWF  78
....................          while(!mas) 
....................          { 
1084:  BTFSC  F82.0
1086:  BRA    1108
....................           if(contador>40000) 
1088:  MOVF   7B,F
108A:  BNZ   10A0
108C:  MOVF   7A,F
108E:  BNZ   10A0
1090:  MOVF   79,W
1092:  SUBLW  9B
1094:  BC    10F6
1096:  XORLW  FF
1098:  BNZ   10A0
109A:  MOVF   78,W
109C:  SUBLW  40
109E:  BC    10F6
....................           { 
....................             input++; 
10A0:  INCF   77,F
....................             //Si llegamos al límite de los valores, reseteamos 
....................             if(input>max) 
10A2:  BTFSC  77.7
10A4:  BRA    10B0
10A6:  MOVF   77,W
10A8:  SUBWF  75,W
10AA:  BC    10B0
....................                input = min; 
10AC:  MOVFF  74,77
....................             //Si es un número menor que 10, añadimos un 0 antes 
....................             if(input<10) 
10B0:  BTFSC  77.7
10B2:  BRA    10BA
10B4:  MOVF   77,W
10B6:  SUBLW  09
10B8:  BNC   10D2
....................                printf(lcd_putc,"0"); 
10BA:  CLRF   7C
10BC:  MOVF   7C,W
10BE:  CALL   044A
10C2:  IORLW  00
10C4:  BZ    10D2
10C6:  INCF   7C,F
10C8:  MOVLB  2
10CA:  MOVWF  x80
10CC:  MOVLB  0
10CE:  RCALL  0E7C
10D0:  BRA    10BC
....................             //Se muestra por pantalla 
....................             printf(lcd_putc,"%i",input); 
10D2:  MOVFF  77,7C
10D6:  MOVLW  1F
10D8:  MOVWF  7D
10DA:  RCALL  0F04
....................             //Regresamos el cursor a su posición 
....................             lcd_gotoxy(led_unidades,2); 
10DC:  MOVFF  73,281
10E0:  MOVLW  02
10E2:  MOVLB  2
10E4:  MOVWF  x82
10E6:  MOVLB  0
10E8:  RCALL  0E56
....................             //Introducimos un poco de retraso 
....................             delay_ms(200); 
10EA:  MOVLW  C8
10EC:  MOVLB  2
10EE:  MOVWF  x87
10F0:  MOVLB  0
10F2:  RCALL  0D30
....................           }else 
10F4:  BRA    1106
....................             contador++; 
10F6:  MOVLW  01
10F8:  ADDWF  78,F
10FA:  BTFSC  FD8.0
10FC:  INCF   79,F
10FE:  BTFSC  FD8.2
1100:  INCF   7A,F
1102:  BTFSC  FD8.2
1104:  INCF   7B,F
....................          } 
1106:  BRA    1084
....................          continue; 
1108:  BRA    102C
....................       } 
....................       if(!menos) 
110A:  BTFSC  F82.1
110C:  BRA    11E8
....................       { 
....................          //Si se pulsa el botón de -, se decrementa el valor de input 
....................          input--; 
110E:  DECF   77,F
....................          //Si llegamos al límite de las opciones, reseteamos 
....................          if(input<min) 
1110:  BTFSC  77.7
1112:  BRA    111A
1114:  MOVF   74,W
1116:  SUBWF  77,W
1118:  BC    111E
....................             input = max; 
111A:  MOVFF  75,77
....................          //Si es un número menor que 10, añadimos un 0 antes 
....................          if(input<10) 
111E:  BTFSC  77.7
1120:  BRA    1128
1122:  MOVF   77,W
1124:  SUBLW  09
1126:  BNC   1140
....................             printf(lcd_putc,"0"); 
1128:  CLRF   7C
112A:  MOVF   7C,W
112C:  CALL   044A
1130:  IORLW  00
1132:  BZ    1140
1134:  INCF   7C,F
1136:  MOVLB  2
1138:  MOVWF  x80
113A:  MOVLB  0
113C:  RCALL  0E7C
113E:  BRA    112A
....................          //Se muestra por pantalla 
....................          printf(lcd_putc,"%i",input); 
1140:  MOVFF  77,7C
1144:  MOVLW  1F
1146:  MOVWF  7D
1148:  RCALL  0F04
....................          //Regresamos el cursor a su posición 
....................          lcd_gotoxy(led_unidades,2); 
114A:  MOVFF  73,281
114E:  MOVLW  02
1150:  MOVLB  2
1152:  MOVWF  x82
1154:  MOVLB  0
1156:  RCALL  0E56
....................          //Esperamos a que se levante la tecla 
....................          //Además introducimos un mecanismo de avance rápido que permite pasar de un 
....................          //valor a otro rápidamente sin más que mantener pulsada la tecla 
....................          contador = 1; 
1158:  CLRF   7B
115A:  CLRF   7A
115C:  CLRF   79
115E:  MOVLW  01
1160:  MOVWF  78
....................          while(!menos){ 
1162:  BTFSC  F82.1
1164:  BRA    11E6
....................           if(contador>40000) 
1166:  MOVF   7B,F
1168:  BNZ   117E
116A:  MOVF   7A,F
116C:  BNZ   117E
116E:  MOVF   79,W
1170:  SUBLW  9B
1172:  BC    11D4
1174:  XORLW  FF
1176:  BNZ   117E
1178:  MOVF   78,W
117A:  SUBLW  40
117C:  BC    11D4
....................           { 
....................             input--; 
117E:  DECF   77,F
....................             //Si llegamos al límite de las opciones, reseteamos 
....................             if(input<min) 
1180:  BTFSC  77.7
1182:  BRA    118A
1184:  MOVF   74,W
1186:  SUBWF  77,W
1188:  BC    118E
....................                input = max; 
118A:  MOVFF  75,77
....................             //Si es un número menor que 10, añadimos un 0 antes 
....................             if(input<10) 
118E:  BTFSC  77.7
1190:  BRA    1198
1192:  MOVF   77,W
1194:  SUBLW  09
1196:  BNC   11B0
....................                printf(lcd_putc,"0"); 
1198:  CLRF   7C
119A:  MOVF   7C,W
119C:  CALL   044A
11A0:  IORLW  00
11A2:  BZ    11B0
11A4:  INCF   7C,F
11A6:  MOVLB  2
11A8:  MOVWF  x80
11AA:  MOVLB  0
11AC:  RCALL  0E7C
11AE:  BRA    119A
....................             //Se muestra por pantalla 
....................             printf(lcd_putc,"%i",input); 
11B0:  MOVFF  77,7C
11B4:  MOVLW  1F
11B6:  MOVWF  7D
11B8:  RCALL  0F04
....................             //Regresamos el cursor a su posición 
....................             lcd_gotoxy(led_unidades,2); 
11BA:  MOVFF  73,281
11BE:  MOVLW  02
11C0:  MOVLB  2
11C2:  MOVWF  x82
11C4:  MOVLB  0
11C6:  RCALL  0E56
....................             //Introducimos un poco de retraso 
....................             delay_ms(200); 
11C8:  MOVLW  C8
11CA:  MOVLB  2
11CC:  MOVWF  x87
11CE:  MOVLB  0
11D0:  RCALL  0D30
....................           }else 
11D2:  BRA    11E4
....................             contador++; 
11D4:  MOVLW  01
11D6:  ADDWF  78,F
11D8:  BTFSC  FD8.0
11DA:  INCF   79,F
11DC:  BTFSC  FD8.2
11DE:  INCF   7A,F
11E0:  BTFSC  FD8.2
11E2:  INCF   7B,F
....................          } 
11E4:  BRA    1162
....................          continue; 
11E6:  BRA    102C
....................       } 
....................       if(!si) 
11E8:  BTFSC  F82.2
11EA:  BRA    11F4
....................       { 
....................          //Esperamos a que se suelte la tecla 
....................          while(!si){} 
11EC:  BTFSC  F82.2
11EE:  BRA    11F2
11F0:  BRA    11EC
....................          break; 
11F2:  BRA    1206
....................       } 
....................       if(!no) 
11F4:  BTFSC  F82.5
11F6:  BRA    1204
....................       { 
....................          //Si se pulsa No, devolvemos el valor correspondiente 
....................          input = NOCODE; 
11F8:  MOVLW  64
11FA:  MOVWF  77
....................          //Esperamos... 
....................          while(!no){} 
11FC:  BTFSC  F82.5
11FE:  BRA    1202
1200:  BRA    11FC
....................          break; 
1202:  BRA    1206
....................       } 
....................  
....................    } 
1204:  BRA    102C
....................  
....................    //Inhabilitamos el cursor de nuevo 
....................    lcd_send_byte(LCD_ORDEN, LCD_NO_CURSOR); 
1206:  MOVLB  2
1208:  CLRF   x85
120A:  MOVLW  0C
120C:  MOVWF  x86
120E:  MOVLB  0
1210:  RCALL  0DA8
....................  
....................    //Devolvemos el valor correspondiente 
....................    return input; 
1212:  MOVFF  77,01
....................  
.................... } 
1216:  RETLW  00
....................  
....................  
.................... int comprobar_hora(int hora1, int min1, int hora2, int min2) 
.................... { 
....................    //Si hora1 es menor, devolvemos TRUE 
....................    if(hora1 < hora2) 
*
2788:  MOVF   x81,W
278A:  SUBWF  7F,W
278C:  BC    2794
....................       return TRUE; 
278E:  MOVLW  01
2790:  MOVWF  01
2792:  BRA    27BA
....................    //Si hora1 es mayor, devolvemos FALSE 
....................    if(hora1 > hora2) 
2794:  MOVF   7F,W
2796:  SUBWF  x81,W
2798:  BC    27A0
....................       return FALSE; 
279A:  MOVLW  00
279C:  MOVWF  01
279E:  BRA    27BA
....................    //Si las horas coinciden habrá que comparar los minutos 
....................    if(hora1==hora2) 
27A0:  MOVF   x81,W
27A2:  SUBWF  7F,W
27A4:  BNZ   27BA
....................    { 
....................       //Se sigue el mismo criterio de antes con la comparación 
....................       //de los minutos. 
....................       if(min1 <= min2) 
27A6:  MOVF   x80,W
27A8:  SUBWF  x82,W
27AA:  BNC   27B4
....................          return TRUE; 
27AC:  MOVLW  01
27AE:  MOVWF  01
27B0:  BRA    27BA
....................       else 
27B2:  BRA    27BA
....................          return FALSE; 
27B4:  MOVLW  00
27B6:  MOVWF  01
27B8:  BRA    27BA
....................    } 
.................... } 
27BA:  RETLW  00
....................  
....................  
.................... void ordenar_programaciones() 
.................... { 
....................    //Variables temporales y contadores auxiliares 
....................    programacion *pr1; 
....................    programacion *pr2; 
....................    int contador1, contador2; 
....................    int h_inicio_1, min_inicio_1, h_inicio_2, min_inicio_2; 
....................  
....................    //Ambos punteros comienzan apuntando al principio de programaciones 
....................    pr1 = programaciones; 
*
30F0:  CLRF   6E
30F2:  MOVLW  2F
30F4:  MOVWF  6D
....................    pr2 = programaciones; 
30F6:  CLRF   70
30F8:  MOVWF  6F
....................  
....................  
....................    //Algoritmo de la burbuja 
....................    for(contador1=0; contador1 < num_intervalos; contador1++) 
30FA:  CLRF   71
30FC:  MOVF   43,W
30FE:  SUBWF  71,W
3100:  BTFSC  FD8.0
3102:  BRA    3224
....................    { 
....................       //Apuntamos a las dos últimas posiciones del vector 
....................       pr1 = programaciones+num_intervalos-2; 
3104:  MOVF   43,W
3106:  MULLW  05
3108:  MOVF   FF3,W
310A:  ADDLW  2F
310C:  MOVWF  7C
310E:  CLRF   7D
3110:  BTFSC  FD8.0
3112:  INCF   7D,F
3114:  MOVLW  0A
3116:  SUBWF  7C,W
3118:  MOVWF  6D
311A:  MOVLW  00
311C:  SUBWFB 7D,W
311E:  MOVWF  6E
....................       pr2 = programaciones+num_intervalos-1; 
3120:  MOVF   43,W
3122:  MULLW  05
3124:  MOVF   FF3,W
3126:  ADDLW  2F
3128:  MOVWF  7C
312A:  CLRF   7D
312C:  BTFSC  FD8.0
312E:  INCF   7D,F
3130:  MOVLW  05
3132:  SUBWF  7C,W
3134:  MOVWF  6F
3136:  MOVLW  00
3138:  SUBWFB 7D,W
313A:  MOVWF  70
....................  
....................       //Iteramos hasta llegar a la zona ordenada del vector 
....................       for(contador2=0; contador2 < num_intervalos-contador1-1; contador2++) 
313C:  CLRF   72
313E:  MOVF   71,W
3140:  SUBWF  43,W
3142:  ADDLW  FF
3144:  SUBWF  72,W
3146:  BC    3220
....................       { 
....................          //Tomamos para la comparación los instantes de inicio 
....................          h_inicio_1   = (*pr1).horas_inicio; 
3148:  MOVFF  6D,FE9
314C:  MOVFF  6E,FEA
3150:  MOVFF  FEF,73
....................          min_inicio_1 = (*pr1).minutos_inicio; 
3154:  MOVLW  01
3156:  ADDWF  6D,W
3158:  MOVWF  FE9
315A:  MOVLW  00
315C:  ADDWFC 6E,W
315E:  MOVWF  FEA
3160:  MOVFF  FEF,74
....................          h_inicio_2   = (*pr2).horas_inicio; 
3164:  MOVFF  6F,FE9
3168:  MOVFF  70,FEA
316C:  MOVFF  FEF,75
....................          min_inicio_2 = (*pr2).minutos_inicio; 
3170:  MOVLW  01
3172:  ADDWF  6F,W
3174:  MOVWF  FE9
3176:  MOVLW  00
3178:  ADDWFC 70,W
317A:  MOVWF  FEA
317C:  MOVFF  FEF,76
....................  
....................          //Si la hora de pr2 es menor que la de pr1, habrá que intercambiar los 
....................          //valores para mover la menor a una posición más baja 
....................          if(comprobar_hora(h_inicio_2, min_inicio_2, h_inicio_1, min_inicio_1)) 
3180:  MOVFF  75,7F
3184:  MOVFF  76,80
3188:  MOVFF  73,81
318C:  MOVFF  74,82
3190:  CALL   2788
3194:  MOVF   01,F
3196:  BZ    320C
....................          { 
....................             programacion temporal; 
....................             temporal = *pr1; 
3198:  MOVFF  6E,03
319C:  MOVFF  6D,7C
31A0:  MOVFF  6E,7D
31A4:  CLRF   FEA
31A6:  MOVLW  77
31A8:  MOVWF  FE9
31AA:  MOVFF  6E,FE2
31AE:  MOVFF  6D,FE1
31B2:  MOVLW  05
31B4:  MOVWF  01
31B6:  MOVFF  FE6,FEE
31BA:  DECFSZ 01,F
31BC:  BRA    31B6
....................             *pr1 = *pr2; 
31BE:  MOVFF  6D,7E
31C2:  MOVFF  6E,7F
31C6:  MOVFF  70,03
31CA:  MOVFF  6F,80
31CE:  MOVFF  70,81
31D2:  MOVFF  6E,FEA
31D6:  MOVFF  6D,FE9
31DA:  MOVFF  70,FE2
31DE:  MOVFF  6F,FE1
31E2:  MOVLW  05
31E4:  MOVWF  01
31E6:  MOVFF  FE6,FEE
31EA:  DECFSZ 01,F
31EC:  BRA    31E6
....................             *pr2 = temporal; 
31EE:  MOVFF  70,03
31F2:  MOVFF  6F,FE9
31F6:  MOVFF  03,FEA
31FA:  CLRF   FE2
31FC:  MOVLW  77
31FE:  MOVWF  FE1
3200:  MOVLW  05
3202:  MOVWF  01
3204:  MOVFF  FE6,FEE
3208:  DECFSZ 01,F
320A:  BRA    3204
....................          } 
....................  
....................          //Pasamos a la siguiente posición y repetimos el proceso 
....................          pr1--; 
320C:  MOVLW  FB
320E:  ADDWF  6D,F
3210:  BTFSS  FD8.0
3212:  DECF   6E,F
....................          pr2--; 
3214:  MOVLW  FB
3216:  ADDWF  6F,F
3218:  BTFSS  FD8.0
321A:  DECF   70,F
....................       } 
321C:  INCF   72,F
321E:  BRA    313E
....................  
....................    } 
3220:  INCF   71,F
3222:  BRA    30FC
....................  
.................... } 
3224:  GOTO   61DC (RETURN)
....................  
....................  
.................... long diferencia_tiempo(int hora1, int min1, int hora2, int min2) 
.................... { 
....................    long dif; 
....................  
....................    //Si hora1:min1 es menor que hora2:min2, devolvemos simplemente la diferencia en minutos 
....................    if(comprobar_hora(hora1,min1,hora2,min2)) 
*
27DA:  MOVFF  75,7F
27DE:  MOVFF  76,80
27E2:  MOVFF  77,81
27E6:  MOVFF  78,82
27EA:  RCALL  2788
27EC:  MOVF   01,F
27EE:  BZ    2850
....................       dif = ((long)hora2*60 + (long)min2) - ((long)hora1*60 + (long)min1); 
27F0:  CLRF   7C
27F2:  MOVFF  77,7B
27F6:  MOVFF  7C,87
27FA:  MOVFF  77,86
27FE:  CLRF   x89
2800:  MOVLW  3C
2802:  MOVWF  x88
2804:  RCALL  27BC
2806:  MOVFF  02,7D
280A:  MOVFF  01,7C
280E:  CLRF   03
2810:  MOVF   78,W
2812:  ADDWF  01,W
2814:  MOVWF  7E
2816:  MOVF   03,W
2818:  ADDWFC 02,W
281A:  MOVWF  7F
281C:  CLRF   x81
281E:  MOVFF  75,80
2822:  MOVFF  81,87
2826:  MOVFF  75,86
282A:  CLRF   x89
282C:  MOVLW  3C
282E:  MOVWF  x88
2830:  RCALL  27BC
2832:  MOVFF  01,81
2836:  CLRF   03
2838:  MOVF   76,W
283A:  ADDWF  01,W
283C:  MOVWF  01
283E:  MOVF   02,W
2840:  ADDWFC 03,F
2842:  MOVF   01,W
2844:  SUBWF  7E,W
2846:  MOVWF  79
2848:  MOVF   03,W
284A:  SUBWFB 7F,W
284C:  MOVWF  7A
....................    //Si no es así, habrá que tener en cuenta que hora1:min1 se encuentra en el día anterior 
....................    //al de hora2:min2 
....................    else 
284E:  BRA    28BC
....................       dif = (24*60-((long)hora1*60 + (long)min1)) + (long)hora2*60 + (long)min2; 
2850:  CLRF   7C
2852:  MOVFF  75,7B
2856:  MOVFF  7C,87
285A:  MOVFF  75,86
285E:  CLRF   x89
2860:  MOVLW  3C
2862:  MOVWF  x88
2864:  RCALL  27BC
2866:  MOVFF  02,7D
286A:  MOVFF  01,7C
286E:  CLRF   03
2870:  MOVF   76,W
2872:  ADDWF  01,W
2874:  MOVWF  01
2876:  MOVF   02,W
2878:  ADDWFC 03,F
287A:  MOVF   01,W
287C:  XORLW  FF
287E:  ADDLW  A1
2880:  MOVWF  7E
2882:  MOVLW  05
2884:  SUBFWB 03,W
2886:  MOVWF  7F
2888:  CLRF   x81
288A:  MOVFF  77,80
288E:  MOVFF  81,87
2892:  MOVFF  77,86
2896:  CLRF   x89
2898:  MOVLW  3C
289A:  MOVWF  x88
289C:  RCALL  27BC
289E:  MOVFF  02,03
28A2:  MOVF   01,W
28A4:  ADDWF  7E,W
28A6:  MOVWF  x81
28A8:  MOVF   02,W
28AA:  ADDWFC 7F,W
28AC:  MOVWF  x82
28AE:  CLRF   03
28B0:  MOVF   78,W
28B2:  ADDWF  x81,W
28B4:  MOVWF  79
28B6:  MOVF   03,W
28B8:  ADDWFC x82,W
28BA:  MOVWF  7A
....................  
....................    //Devolvemos el resultado 
....................    return dif; 
28BC:  MOVFF  79,01
28C0:  MOVFF  7A,02
.................... } 
28C4:  RETLW  00
....................  
....................  
.................... long diferencia_tiempo_sec(int hora1, int min1, int sec1, int hora2, int min2, int sec2) 
.................... { 
....................    unsigned long dif; 
....................    unsigned long dif2; 
....................  
....................    //Si hora1:min1 es menor que hora2:min2, ambas horas están en el mismo día 
....................    if(comprobar_hora(hora1,min1,hora2,min2)) 
28C6:  MOVFF  75,7F
28CA:  MOVFF  76,80
28CE:  MOVFF  78,81
28D2:  MOVFF  79,82
28D6:  RCALL  2788
28D8:  MOVF   01,F
28DA:  BZ    297A
....................    { 
....................       //Si la hora y los minutos son iguales, devolvemos simplemente la diferencia en segundos 
....................       if(hora1==hora2 && min1==min2) 
28DC:  MOVF   78,W
28DE:  SUBWF  75,W
28E0:  BNZ   28F2
28E2:  MOVF   79,W
28E4:  SUBWF  76,W
28E6:  BNZ   28F2
....................          dif = abs(sec2-sec1); 
28E8:  MOVF   77,W
28EA:  SUBWF  7A,W
28EC:  CLRF   7C
28EE:  MOVWF  7B
....................       else 
28F0:  BRA    2978
....................       { 
....................          //Si no habrá que tener en cuenta también la diferencia entre horas y minutos 
....................          dif2 = ((long)hora2*60 + (long)min2) - ((long)hora1*60 + (long)min1); 
28F2:  CLRF   x80
28F4:  MOVFF  78,7F
28F8:  MOVFF  80,87
28FC:  MOVFF  78,86
2900:  CLRF   x89
2902:  MOVLW  3C
2904:  MOVWF  x88
2906:  RCALL  27BC
2908:  MOVFF  02,81
290C:  MOVFF  01,80
2910:  CLRF   03
2912:  MOVF   79,W
2914:  ADDWF  01,W
2916:  MOVWF  x82
2918:  MOVF   03,W
291A:  ADDWFC 02,W
291C:  MOVWF  x83
291E:  CLRF   x85
2920:  MOVFF  75,84
2924:  MOVFF  85,87
2928:  MOVFF  75,86
292C:  CLRF   x89
292E:  MOVLW  3C
2930:  MOVWF  x88
2932:  RCALL  27BC
2934:  MOVFF  01,85
2938:  CLRF   03
293A:  MOVF   76,W
293C:  ADDWF  01,W
293E:  MOVWF  01
2940:  MOVF   02,W
2942:  ADDWFC 03,F
2944:  MOVF   01,W
2946:  SUBWF  x82,W
2948:  MOVWF  7D
294A:  MOVF   03,W
294C:  SUBWFB x83,W
294E:  MOVWF  7E
....................          //No hacemos la diferencia en segundos directamente porque el long no da de sí 
....................          dif = dif2*60 + sec2 - sec1; 
2950:  MOVFF  7E,87
2954:  MOVFF  7D,86
2958:  CLRF   x89
295A:  MOVLW  3C
295C:  MOVWF  x88
295E:  RCALL  27BC
2960:  MOVF   7A,W
2962:  ADDWF  01,W
2964:  MOVWF  x81
2966:  MOVLW  00
2968:  ADDWFC 02,W
296A:  MOVWF  x82
296C:  MOVF   77,W
296E:  SUBWF  x81,W
2970:  MOVWF  7B
2972:  MOVLW  00
2974:  SUBWFB x82,W
2976:  MOVWF  7C
....................       } 
....................    } 
....................    else{ 
2978:  BRA    2A0E
....................       //Si no, simplemente tenemos en cuenta que están en días diferentes y luego le añadimos la 
....................       //diferencia en segundos 
....................       dif2 = (24*60-((long)hora1*60 + (long)min1)) + (long)hora2*60 + (long)min2; 
297A:  CLRF   x80
297C:  MOVFF  75,7F
2980:  MOVFF  80,87
2984:  MOVFF  75,86
2988:  CLRF   x89
298A:  MOVLW  3C
298C:  MOVWF  x88
298E:  RCALL  27BC
2990:  MOVFF  02,81
2994:  MOVFF  01,80
2998:  CLRF   03
299A:  MOVF   76,W
299C:  ADDWF  01,W
299E:  MOVWF  01
29A0:  MOVF   02,W
29A2:  ADDWFC 03,F
29A4:  MOVF   01,W
29A6:  XORLW  FF
29A8:  ADDLW  A1
29AA:  MOVWF  x82
29AC:  MOVLW  05
29AE:  SUBFWB 03,W
29B0:  MOVWF  x83
29B2:  CLRF   x85
29B4:  MOVFF  78,84
29B8:  MOVFF  85,87
29BC:  MOVFF  78,86
29C0:  CLRF   x89
29C2:  MOVLW  3C
29C4:  MOVWF  x88
29C6:  RCALL  27BC
29C8:  MOVFF  02,03
29CC:  MOVF   01,W
29CE:  ADDWF  x82,W
29D0:  MOVWF  x85
29D2:  MOVF   02,W
29D4:  ADDWFC x83,W
29D6:  MOVWF  x86
29D8:  CLRF   03
29DA:  MOVF   79,W
29DC:  ADDWF  x85,W
29DE:  MOVWF  7D
29E0:  MOVF   03,W
29E2:  ADDWFC x86,W
29E4:  MOVWF  7E
....................       dif = dif2*60 + sec2 - sec1; 
29E6:  MOVFF  7E,87
29EA:  MOVFF  7D,86
29EE:  CLRF   x89
29F0:  MOVLW  3C
29F2:  MOVWF  x88
29F4:  RCALL  27BC
29F6:  MOVF   7A,W
29F8:  ADDWF  01,W
29FA:  MOVWF  x81
29FC:  MOVLW  00
29FE:  ADDWFC 02,W
2A00:  MOVWF  x82
2A02:  MOVF   77,W
2A04:  SUBWF  x81,W
2A06:  MOVWF  7B
2A08:  MOVLW  00
2A0A:  SUBWFB x82,W
2A0C:  MOVWF  7C
....................    } 
....................  
....................    //Devolvemos el resultado 
....................    return dif; 
2A0E:  MOVFF  7B,01
2A12:  MOVFF  7C,02
.................... } 
2A16:  RETLW  00
....................  
....................  
.................... void seleccionar_alarma() 
.................... { 
....................    //Contador y variables auxiliares 
....................    int contador; 
....................    int hora, minutos, hora_p, min_p; 
....................  
....................    //Ponemos la posición en el vector de alarmas incialmente a 0 
....................    posicion_alarmas = 0; 
*
3228:  CLRF   44
....................  
....................    //Leemos el tiempo actual 
....................    PCF8583_read_datetime(&tiempo); 
322A:  CLRF   76
322C:  MOVLW  45
322E:  MOVWF  75
3230:  CALL   24AE
....................    hora = tiempo.hours; 
3234:  MOVFF  47,6E
....................    minutos = tiempo.minutes; 
3238:  MOVFF  46,6F
....................  
....................    //Recorremos todas las programaciones 
....................    for(contador=0; contador<num_intervalos; contador++) 
323C:  CLRF   6D
323E:  MOVF   43,W
3240:  SUBWF  6D,W
3242:  BC    32A6
....................    { 
....................        hora_p = programaciones[contador].horas_inicio; 
3244:  MOVF   6D,W
3246:  MULLW  05
3248:  MOVF   FF3,W
324A:  CLRF   73
324C:  MOVWF  72
324E:  MOVLW  2F
3250:  ADDWF  72,W
3252:  MOVWF  FE9
3254:  MOVLW  00
3256:  ADDWFC 73,W
3258:  MOVWF  FEA
325A:  MOVFF  FEF,70
....................        min_p  = programaciones[contador].minutos_inicio; 
325E:  MOVF   6D,W
3260:  MULLW  05
3262:  MOVF   FF3,W
3264:  CLRF   73
3266:  MOVWF  72
3268:  MOVLW  01
326A:  ADDWF  72,W
326C:  MOVWF  01
326E:  MOVLW  00
3270:  ADDWFC 73,W
3272:  MOVWF  03
3274:  MOVF   01,W
3276:  ADDLW  2F
3278:  MOVWF  FE9
327A:  MOVLW  00
327C:  ADDWFC 03,W
327E:  MOVWF  FEA
3280:  MOVFF  FEF,71
....................  
....................        //Comprobamos las horas y tomamos la primera programación que tenga una 
....................        //hora mayor que la actual 
....................        if(!comprobar_hora(hora_p, min_p, hora, minutos)) 
3284:  MOVFF  70,7F
3288:  MOVFF  71,80
328C:  MOVFF  6E,81
3290:  MOVFF  6F,82
3294:  CALL   2788
3298:  MOVF   01,F
329A:  BNZ   32A2
....................        { 
....................            //Guardamos la posición de esta programación y salimos 
....................            posicion_alarmas = contador; 
329C:  MOVFF  6D,44
....................            break; 
32A0:  BRA    32A6
....................        } 
....................    } 
32A2:  INCF   6D,F
32A4:  BRA    323E
.................... } 
32A6:  GOTO   61E0 (RETURN)
....................  
....................  
.................... void programar_proxima_alarma() 
.................... { 
....................    //Variables auxiliares 
....................    int hora, minutos; 
....................  
....................    //Recuperamos los datos de inicio de la alarma actual 
....................    prg=programaciones[posicion_alarmas]; 
*
2740:  MOVF   44,W
2742:  MULLW  05
2744:  MOVF   FF3,W
2746:  CLRF   03
2748:  ADDLW  2F
274A:  MOVWF  01
274C:  MOVLW  00
274E:  ADDWFC 03,F
2750:  MOVFF  01,6F
2754:  MOVFF  03,70
2758:  CLRF   FEA
275A:  MOVLW  3E
275C:  MOVWF  FE9
275E:  MOVFF  03,FE2
2762:  MOVFF  01,FE1
2766:  MOVLW  05
2768:  MOVWF  01
276A:  MOVFF  FE6,FEE
276E:  DECFSZ 01,F
2770:  BRA    276A
....................    hora = prg.horas_inicio; 
2772:  MOVFF  3E,6D
....................    minutos = prg.minutos_inicio; 
2776:  MOVFF  3F,6E
....................  
....................    //Establecemos la alarma a ese tiempo 
....................    PCF8583_establecer_alarma(hora, minutos, 0); 
277A:  MOVFF  6D,6F
277E:  MOVFF  6E,70
2782:  CLRF   71
2784:  RCALL  2690
.................... } 
2786:  RETLW  00
....................  
....................  
.................... void grabar_programaciones() 
.................... { 
....................  
....................    int datos[5];   //Vector para contener los datos a grabar 
....................    programacion pr; //Variable temporal de programacion 
....................    int contador;   //Contador para el bucle 
....................  
....................    //Recorremos todo el vector de programaciones (hasta el número de programaciones que tengamos) 
....................    for(contador=0; contador<num_intervalos; contador++) 
*
32AA:  CLRF   77
32AC:  MOVF   43,W
32AE:  SUBWF  77,W
32B0:  BTFSC  FD8.0
32B2:  BRA    33E6
....................    { 
....................       //Seleccionamos la programación 
....................       pr = programaciones[contador]; 
32B4:  MOVF   77,W
32B6:  MULLW  05
32B8:  MOVF   FF3,W
32BA:  CLRF   03
32BC:  ADDLW  2F
32BE:  MOVWF  01
32C0:  MOVLW  00
32C2:  ADDWFC 03,F
32C4:  MOVFF  01,78
32C8:  MOVFF  03,79
32CC:  CLRF   FEA
32CE:  MOVLW  72
32D0:  MOVWF  FE9
32D2:  MOVFF  03,FE2
32D6:  MOVFF  01,FE1
32DA:  MOVLW  05
32DC:  MOVWF  01
32DE:  MOVFF  FE6,FEE
32E2:  DECFSZ 01,F
32E4:  BRA    32DE
....................  
....................       //Guardamos en la memoria EEPROM dato a dato 
....................       write_eeprom(eeprom_programaciones + (contador)*5    , pr.horas_inicio); 
32E6:  MOVF   77,W
32E8:  MULLW  05
32EA:  MOVF   FF3,W
32EC:  ADDLW  05
32EE:  MOVWF  78
32F0:  MOVWF  FA9
32F2:  MOVFF  72,FA8
32F6:  BCF    FA6.6
32F8:  BCF    FA6.7
32FA:  BSF    FA6.2
32FC:  MOVFF  FF2,00
3300:  BCF    FF2.7
3302:  MOVLB  F
3304:  MOVLW  55
3306:  MOVWF  FA7
3308:  MOVLW  AA
330A:  MOVWF  FA7
330C:  BSF    FA6.1
330E:  BTFSC  FA6.1
3310:  BRA    330E
3312:  BCF    FA6.2
3314:  MOVF   00,W
3316:  IORWF  FF2,F
....................       write_eeprom(eeprom_programaciones + (contador)*5 + 1, pr.minutos_inicio); 
3318:  MOVF   77,W
331A:  MULLW  05
331C:  MOVF   FF3,W
331E:  ADDLW  05
3320:  ADDLW  01
3322:  MOVWF  79
3324:  MOVWF  FA9
3326:  MOVFF  73,FA8
332A:  BCF    FA6.6
332C:  BCF    FA6.7
332E:  BSF    FA6.2
3330:  MOVFF  FF2,00
3334:  BCF    FF2.7
3336:  MOVLW  55
3338:  MOVWF  FA7
333A:  MOVLW  AA
333C:  MOVWF  FA7
333E:  BSF    FA6.1
3340:  BTFSC  FA6.1
3342:  BRA    3340
3344:  BCF    FA6.2
3346:  MOVF   00,W
3348:  IORWF  FF2,F
....................       write_eeprom(eeprom_programaciones + (contador)*5 + 2, pr.horas_fin); 
334A:  MOVF   77,W
334C:  MULLW  05
334E:  MOVF   FF3,W
3350:  ADDLW  05
3352:  ADDLW  02
3354:  MOVWF  79
3356:  MOVWF  FA9
3358:  MOVFF  74,FA8
335C:  BCF    FA6.6
335E:  BCF    FA6.7
3360:  BSF    FA6.2
3362:  MOVFF  FF2,00
3366:  BCF    FF2.7
3368:  MOVLW  55
336A:  MOVWF  FA7
336C:  MOVLW  AA
336E:  MOVWF  FA7
3370:  BSF    FA6.1
3372:  BTFSC  FA6.1
3374:  BRA    3372
3376:  BCF    FA6.2
3378:  MOVF   00,W
337A:  IORWF  FF2,F
....................       write_eeprom(eeprom_programaciones + (contador)*5 + 3, pr.minutos_fin); 
337C:  MOVF   77,W
337E:  MULLW  05
3380:  MOVF   FF3,W
3382:  ADDLW  05
3384:  ADDLW  03
3386:  MOVWF  79
3388:  MOVWF  FA9
338A:  MOVFF  75,FA8
338E:  BCF    FA6.6
3390:  BCF    FA6.7
3392:  BSF    FA6.2
3394:  MOVFF  FF2,00
3398:  BCF    FF2.7
339A:  MOVLW  55
339C:  MOVWF  FA7
339E:  MOVLW  AA
33A0:  MOVWF  FA7
33A2:  BSF    FA6.1
33A4:  BTFSC  FA6.1
33A6:  BRA    33A4
33A8:  BCF    FA6.2
33AA:  MOVF   00,W
33AC:  IORWF  FF2,F
....................       write_eeprom(eeprom_programaciones + (contador)*5 + 4, pr.termostato); 
33AE:  MOVF   77,W
33B0:  MULLW  05
33B2:  MOVF   FF3,W
33B4:  ADDLW  05
33B6:  ADDLW  04
33B8:  MOVWF  79
33BA:  MOVWF  FA9
33BC:  MOVFF  76,FA8
33C0:  BCF    FA6.6
33C2:  BCF    FA6.7
33C4:  BSF    FA6.2
33C6:  MOVFF  FF2,00
33CA:  BCF    FF2.7
33CC:  MOVLW  55
33CE:  MOVWF  FA7
33D0:  MOVLW  AA
33D2:  MOVWF  FA7
33D4:  BSF    FA6.1
33D6:  BTFSC  FA6.1
33D8:  BRA    33D6
33DA:  BCF    FA6.2
33DC:  MOVF   00,W
33DE:  IORWF  FF2,F
....................    } 
33E0:  INCF   77,F
33E2:  MOVLB  0
33E4:  BRA    32AC
....................  
....................    //Guardamos en la EEPROM en el número de intervalos 
....................    write_eeprom(eeprom_num_intervalos, num_intervalos); 
33E6:  MOVLW  01
33E8:  MOVWF  FA9
33EA:  MOVFF  43,FA8
33EE:  BCF    FA6.6
33F0:  BCF    FA6.7
33F2:  BSF    FA6.2
33F4:  MOVFF  FF2,00
33F8:  BCF    FF2.7
33FA:  MOVLB  F
33FC:  MOVLW  55
33FE:  MOVWF  FA7
3400:  MOVLW  AA
3402:  MOVWF  FA7
3404:  BSF    FA6.1
3406:  BTFSC  FA6.1
3408:  BRA    3406
340A:  BCF    FA6.2
340C:  MOVF   00,W
340E:  IORWF  FF2,F
....................  
.................... } 
3410:  MOVLB  0
3412:  GOTO   628C (RETURN)
....................  
....................  
.................... void leer_programaciones(){ 
....................    programacion pr;  //Variable temporal para guardar la programación 
....................    int contador;    //Contador del bucle 
....................  
....................    //Se supone que antes ha sido recuperado el número de intervalos 
....................    //Recorremos todas las programaciones guardadas 
....................    for(contador=0; contador<num_intervalos; contador++) 
....................    { 
....................       //Leemos de memoria y vamos guardando los datos correspondientes 
....................       pr.horas_inicio   = read_eeprom(eeprom_programaciones + (contador)*5); 
....................       pr.minutos_inicio = read_eeprom(eeprom_programaciones + (contador)*5 + 1); 
....................       pr.horas_fin      = read_eeprom(eeprom_programaciones + (contador)*5 + 2); 
....................       pr.minutos_fin    = read_eeprom(eeprom_programaciones + (contador)*5 + 3); 
....................       pr.termostato     = read_eeprom(eeprom_programaciones + (contador)*5 + 4); 
....................  
....................       //Guardamos la programación en el vector correspondiente 
....................       programaciones[contador] = pr; 
....................  
....................    } 
.................... } 
....................  
....................  
.................... void representar_registros() 
.................... { 
....................    //Contadores para los bucles 
....................    unsigned int contador, contador2; 
....................    //Lista de variables recuperadas 
....................    unsigned int dia, mes, anno, horas, minutos, temp_int, temp_dec, t_sistema, t_caldera, term; 
....................  
....................    float media_dia_mes[12];         //Tiempos medios en minutos que se enciende el sistema en cada mes 
....................    int dias_meses[12];              //Número de dias que tiene cada mes 
....................    float media_dia_caldera;         //Tiempo medio que se enciende la caldera cada día 
....................    float valor;                     //Tiempo medio en minutos que se enciende el sistema por día 
....................    float media_dia_mes_caldera[12]; //Tiempo medio que se enciende la caldera en cada mes 
....................  
....................    unsigned long valor_total;  //Tiempo total de encendido de la caldera 
....................    unsigned long valor_total_caldera; //Tiempo total de encendido del sistema 
....................  
....................    //Capacidad para 4 años de datos 
....................    //Vectores de almacenamiento de los datos anuales 
....................    float media_annos[4][12]; 
....................    float media_annos_caldera[4][12]; 
....................    //Número de años de los que se tienen datos 
....................    int num_annos; 
....................    //Años correspondientes 
....................    int annos[4]; 
....................  
....................    //Variables para almacenar valores provisionales 
....................    long tiempo_x_dia;         //Tiempo que se enciende cada día el sistema (minutos) 
....................    long tiempo_x_dia_caldera; //Tiempo que se enciende cada día la caldera (minutos) 
....................    int fecha[3];             //Día con el que estamos trabajando (día/mes/año) 
....................    long num_dias;             //Número de días que llevamos analizados 
....................  
....................    //dias_meses = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}; 
....................    dias_meses[0] = dias_meses[2] = dias_meses[4] = dias_meses[6] = dias_meses[7] = dias_meses[9] = dias_meses[11] = 31; 
*
36E6:  MOVLW  1F
36E8:  MOVWF  xB4
36EA:  MOVFF  B4,B2
36EE:  MOVFF  B2,B0
36F2:  MOVFF  B0,AF
36F6:  MOVFF  AF,AD
36FA:  MOVFF  AD,AB
36FE:  MOVFF  AB,A9
....................    dias_meses[1] = 28; 
3702:  MOVLW  1C
3704:  MOVWF  xAA
....................    dias_meses[3] = dias_meses[5] = dias_meses[8] = dias_meses[10] = 30; 
3706:  MOVLW  1E
3708:  MOVWF  xB3
370A:  MOVFF  B3,B1
370E:  MOVFF  B1,AE
3712:  MOVFF  AE,AC
....................  
....................    //Inicializamos los vectores a 0 
....................    for(contador=0; contador<12;contador++) 
3716:  CLRF   6D
3718:  MOVF   6D,W
371A:  SUBLW  0B
371C:  BNC   373C
....................    { 
....................       media_dia_mes[contador]=0; 
371E:  MOVF   6D,W
3720:  MULLW  04
3722:  MOVF   FF3,W
3724:  CLRF   03
3726:  ADDLW  79
3728:  MOVWF  FE9
372A:  MOVLW  00
372C:  ADDWFC 03,W
372E:  MOVWF  FEA
3730:  CLRF   FEF
3732:  CLRF   FEC
3734:  CLRF   FEC
3736:  CLRF   FEC
....................    } 
3738:  INCF   6D,F
373A:  BRA    3718
....................  
....................    for(contador=0; contador<12;contador++) 
373C:  CLRF   6D
373E:  MOVF   6D,W
3740:  SUBLW  0B
3742:  BNC   3762
....................    { 
....................       media_dia_mes_caldera[contador]=0; 
3744:  MOVF   6D,W
3746:  MULLW  04
3748:  MOVF   FF3,W
374A:  CLRF   03
374C:  ADDLW  BD
374E:  MOVWF  FE9
3750:  MOVLW  00
3752:  ADDWFC 03,W
3754:  MOVWF  FEA
3756:  CLRF   FEF
3758:  CLRF   FEC
375A:  CLRF   FEC
375C:  CLRF   FEC
....................    } 
375E:  INCF   6D,F
3760:  BRA    373E
....................  
....................    for(contador=0; contador<4 ;contador++) 
3762:  CLRF   6D
3764:  MOVF   6D,W
3766:  SUBLW  03
3768:  BNC   37AC
....................    { 
....................       for(contador2=0; contador2<12 ;contador2++) 
376A:  CLRF   6E
376C:  MOVF   6E,W
376E:  SUBLW  0B
3770:  BNC   37A8
....................       { 
....................          media_annos[contador][contador2]=0; 
3772:  MOVF   6D,W
3774:  MULLW  30
3776:  MOVF   FF3,W
3778:  MOVLB  2
377A:  CLRF   x80
377C:  MOVWF  x7F
377E:  MOVF   6E,W
3780:  MULLW  04
3782:  MOVF   FF3,W
3784:  CLRF   03
3786:  ADDWF  x7F,W
3788:  MOVWF  01
378A:  MOVF   x80,W
378C:  ADDWFC 03,F
378E:  MOVF   01,W
3790:  ADDLW  F1
3792:  MOVWF  FE9
3794:  MOVLW  00
3796:  ADDWFC 03,W
3798:  MOVWF  FEA
379A:  CLRF   FEF
379C:  CLRF   FEC
379E:  CLRF   FEC
37A0:  CLRF   FEC
....................       } 
37A2:  INCF   6E,F
37A4:  MOVLB  0
37A6:  BRA    376C
....................    } 
37A8:  INCF   6D,F
37AA:  BRA    3764
....................  
....................    for(contador=0; contador<4 ;contador++) 
37AC:  CLRF   6D
37AE:  MOVF   6D,W
37B0:  SUBLW  03
37B2:  BNC   37F6
....................    { 
....................       for(contador2=0; contador2<12 ;contador2++) 
37B4:  CLRF   6E
37B6:  MOVF   6E,W
37B8:  SUBLW  0B
37BA:  BNC   37F2
....................       { 
....................          media_annos_caldera[contador][contador2]=0; 
37BC:  MOVF   6D,W
37BE:  MULLW  30
37C0:  MOVF   FF3,W
37C2:  MOVLB  2
37C4:  CLRF   x80
37C6:  MOVWF  x7F
37C8:  MOVF   6E,W
37CA:  MULLW  04
37CC:  MOVF   FF3,W
37CE:  CLRF   03
37D0:  ADDWF  x7F,W
37D2:  MOVWF  01
37D4:  MOVF   x80,W
37D6:  ADDWFC 03,F
37D8:  MOVF   01,W
37DA:  ADDLW  B1
37DC:  MOVWF  FE9
37DE:  MOVLW  01
37E0:  ADDWFC 03,W
37E2:  MOVWF  FEA
37E4:  CLRF   FEF
37E6:  CLRF   FEC
37E8:  CLRF   FEC
37EA:  CLRF   FEC
....................       } 
37EC:  INCF   6E,F
37EE:  MOVLB  0
37F0:  BRA    37B6
....................    } 
37F2:  INCF   6D,F
37F4:  BRA    37AE
....................  
....................    //Iniciamos a cero las otras variables 
....................    fecha[0] = fecha[1] = fecha[2] = 0; 
37F6:  MOVLB  2
37F8:  CLRF   x7C
37FA:  MOVFF  27C,27B
37FE:  MOVFF  27B,27A
....................    num_dias = 0; 
3802:  CLRF   x7E
3804:  CLRF   x7D
....................    num_annos = 0; 
3806:  CLRF   x71
....................  
....................    media_dia_caldera = 0; 
3808:  MOVLB  0
380A:  CLRF   xB8
380C:  CLRF   xB7
380E:  CLRF   xB6
3810:  CLRF   xB5
....................    valor = 0; 
3812:  CLRF   xBC
3814:  CLRF   xBB
3816:  CLRF   xBA
3818:  CLRF   xB9
....................    valor_total = 0; 
381A:  CLRF   xEE
381C:  CLRF   xED
....................    valor_total_caldera = 0; 
381E:  CLRF   xF0
3820:  CLRF   xEF
....................  
....................    //Imprimimos el encabezamiento 
....................    printf("REGISTRO DE EVENTOS\r"); 
3822:  MOVLB  2
3824:  CLRF   x7F
3826:  MOVF   x7F,W
3828:  MOVLB  0
382A:  CALL   0466
382E:  IORLW  00
3830:  BZ    3840
3832:  MOVLB  2
3834:  INCF   x7F,F
3836:  BTFSS  F9E.4
3838:  BRA    3836
383A:  MOVWF  FAD
383C:  BRA    3826
383E:  MOVLB  0
....................    printf("*******************\r"); 
3840:  MOVLB  2
3842:  CLRF   x7F
3844:  MOVF   x7F,W
3846:  MOVLB  0
3848:  CALL   0496
384C:  IORLW  00
384E:  BZ    385E
3850:  MOVLB  2
3852:  INCF   x7F,F
3854:  BTFSS  F9E.4
3856:  BRA    3854
3858:  MOVWF  FAD
385A:  BRA    3844
385C:  MOVLB  0
....................    printf("Momento de apagado     Temperatura        Termostato        Minutos encendido       Minutos caldera\r"); 
385E:  MOVLB  2
3860:  CLRF   x7F
3862:  MOVF   x7F,W
3864:  MOVLB  0
3866:  CALL   04C6
386A:  IORLW  00
386C:  BZ    387C
386E:  MOVLB  2
3870:  INCF   x7F,F
3872:  BTFSS  F9E.4
3874:  BRA    3872
3876:  MOVWF  FAD
3878:  BRA    3862
387A:  MOVLB  0
....................    printf("======================================================================================================\r"); 
387C:  MOVLB  2
387E:  CLRF   x7F
3880:  MOVF   x7F,W
3882:  MOVLB  0
3884:  CALL   0546
3888:  IORLW  00
388A:  BZ    389A
388C:  MOVLB  2
388E:  INCF   x7F,F
3890:  BTFSS  F9E.4
3892:  BRA    3890
3894:  MOVWF  FAD
3896:  BRA    3880
3898:  MOVLB  0
....................  
....................    //Recorremos todos los registros almacenados 
....................    for(contador=0; contador<num_registros; contador++) 
389A:  CLRF   6D
389C:  MOVF   53,W
389E:  SUBWF  6D,W
38A0:  BTFSC  FD8.0
38A2:  GOTO   4040
....................    { 
....................       //Comenzamos leyendo los datos de memoria 
....................       dia         =  read_eeprom(eeprom_registros + contador*10); 
38A6:  MOVF   6D,W
38A8:  MULLW  0A
38AA:  MOVF   FF3,W
38AC:  ADDLW  14
38AE:  MOVLB  2
38B0:  MOVFF  FF2,280
38B4:  BCF    FF2.7
38B6:  MOVWF  FA9
38B8:  BCF    FA6.6
38BA:  BCF    FA6.7
38BC:  BSF    FA6.0
38BE:  MOVF   FA8,W
38C0:  BTFSC  x80.7
38C2:  BSF    FF2.7
38C4:  MOVWF  6F
....................       mes         =  read_eeprom(eeprom_registros + contador*10 + 1); 
38C6:  MOVF   6D,W
38C8:  MULLW  0A
38CA:  MOVF   FF3,W
38CC:  ADDLW  14
38CE:  ADDLW  01
38D0:  MOVFF  FF2,281
38D4:  BCF    FF2.7
38D6:  MOVWF  FA9
38D8:  BCF    FA6.6
38DA:  BCF    FA6.7
38DC:  BSF    FA6.0
38DE:  MOVF   FA8,W
38E0:  BTFSC  x81.7
38E2:  BSF    FF2.7
38E4:  MOVWF  70
....................       anno        =  read_eeprom(eeprom_registros + contador*10 + 2); 
38E6:  MOVF   6D,W
38E8:  MULLW  0A
38EA:  MOVF   FF3,W
38EC:  ADDLW  14
38EE:  ADDLW  02
38F0:  MOVFF  FF2,281
38F4:  BCF    FF2.7
38F6:  MOVWF  FA9
38F8:  BCF    FA6.6
38FA:  BCF    FA6.7
38FC:  BSF    FA6.0
38FE:  MOVF   FA8,W
3900:  BTFSC  x81.7
3902:  BSF    FF2.7
3904:  MOVWF  71
....................       horas       =  read_eeprom(eeprom_registros + contador*10 + 3); 
3906:  MOVF   6D,W
3908:  MULLW  0A
390A:  MOVF   FF3,W
390C:  ADDLW  14
390E:  ADDLW  03
3910:  MOVFF  FF2,281
3914:  BCF    FF2.7
3916:  MOVWF  FA9
3918:  BCF    FA6.6
391A:  BCF    FA6.7
391C:  BSF    FA6.0
391E:  MOVF   FA8,W
3920:  BTFSC  x81.7
3922:  BSF    FF2.7
3924:  MOVWF  72
....................       minutos     =  read_eeprom(eeprom_registros + contador*10 + 4); 
3926:  MOVF   6D,W
3928:  MULLW  0A
392A:  MOVF   FF3,W
392C:  ADDLW  14
392E:  ADDLW  04
3930:  MOVFF  FF2,281
3934:  BCF    FF2.7
3936:  MOVWF  FA9
3938:  BCF    FA6.6
393A:  BCF    FA6.7
393C:  BSF    FA6.0
393E:  MOVF   FA8,W
3940:  BTFSC  x81.7
3942:  BSF    FF2.7
3944:  MOVWF  73
....................       temp_int    =  read_eeprom(eeprom_registros + contador*10 + 5); 
3946:  MOVF   6D,W
3948:  MULLW  0A
394A:  MOVF   FF3,W
394C:  ADDLW  14
394E:  ADDLW  05
3950:  MOVFF  FF2,281
3954:  BCF    FF2.7
3956:  MOVWF  FA9
3958:  BCF    FA6.6
395A:  BCF    FA6.7
395C:  BSF    FA6.0
395E:  MOVF   FA8,W
3960:  BTFSC  x81.7
3962:  BSF    FF2.7
3964:  MOVWF  74
....................       temp_dec    =  read_eeprom(eeprom_registros + contador*10 + 6); 
3966:  MOVF   6D,W
3968:  MULLW  0A
396A:  MOVF   FF3,W
396C:  ADDLW  14
396E:  ADDLW  06
3970:  MOVFF  FF2,281
3974:  BCF    FF2.7
3976:  MOVWF  FA9
3978:  BCF    FA6.6
397A:  BCF    FA6.7
397C:  BSF    FA6.0
397E:  MOVF   FA8,W
3980:  BTFSC  x81.7
3982:  BSF    FF2.7
3984:  MOVWF  75
....................       t_sistema   =  read_eeprom(eeprom_registros + contador*10 + 7); 
3986:  MOVF   6D,W
3988:  MULLW  0A
398A:  MOVF   FF3,W
398C:  ADDLW  14
398E:  ADDLW  07
3990:  MOVFF  FF2,281
3994:  BCF    FF2.7
3996:  MOVWF  FA9
3998:  BCF    FA6.6
399A:  BCF    FA6.7
399C:  BSF    FA6.0
399E:  MOVF   FA8,W
39A0:  BTFSC  x81.7
39A2:  BSF    FF2.7
39A4:  MOVWF  76
....................       t_caldera   =  read_eeprom(eeprom_registros + contador*10 + 8); 
39A6:  MOVF   6D,W
39A8:  MULLW  0A
39AA:  MOVF   FF3,W
39AC:  ADDLW  14
39AE:  ADDLW  08
39B0:  MOVFF  FF2,281
39B4:  BCF    FF2.7
39B6:  MOVWF  FA9
39B8:  BCF    FA6.6
39BA:  BCF    FA6.7
39BC:  BSF    FA6.0
39BE:  MOVF   FA8,W
39C0:  BTFSC  x81.7
39C2:  BSF    FF2.7
39C4:  MOVWF  77
....................       term        =  read_eeprom(eeprom_registros + contador*10 + 9); 
39C6:  MOVF   6D,W
39C8:  MULLW  0A
39CA:  MOVF   FF3,W
39CC:  ADDLW  14
39CE:  ADDLW  09
39D0:  MOVFF  FF2,281
39D4:  BCF    FF2.7
39D6:  MOVWF  FA9
39D8:  BCF    FA6.6
39DA:  BCF    FA6.7
39DC:  BSF    FA6.0
39DE:  MOVF   FA8,W
39E0:  BTFSC  x81.7
39E2:  BSF    FF2.7
39E4:  MOVWF  78
....................  
....................       //Si cambiamos de día debemos gestionar los datos del nuevo día y almacenar los del anterior 
....................       if(fecha[0]!=dia || fecha[1]!=mes || fecha[2]!=anno) 
39E6:  MOVF   6F,W
39E8:  SUBWF  x7A,W
39EA:  BNZ   39FA
39EC:  MOVF   70,W
39EE:  SUBWF  x7B,W
39F0:  BNZ   39FA
39F2:  MOVF   71,W
39F4:  SUBWF  x7C,W
39F6:  BTFSC  FD8.2
39F8:  BRA    3D56
....................       { 
....................          //Lógicamente, no tenemos en cuenta para la media los días en los que no se enciende: 
....................          //días de verano, calurosos, etc. Esta información puede visualizarse en la media 
....................          //por meses. 
....................          //Guardamos los datos del día anterior si el día no es el primero 
....................          if(fecha[0]!=0) 
39FA:  MOVF   x7A,F
39FC:  BZ    3AD2
....................          { 
....................             //En la media de tiempo por día, acumulamos el tiempo que ha estado encendido el último día 
....................             valor = valor + (float)tiempo_x_dia; 
39FE:  MOVFF  277,286
3A02:  MOVFF  276,285
3A06:  MOVLB  0
3A08:  CALL   2110
3A0C:  BCF    FD8.1
3A0E:  MOVFF  BC,282
3A12:  MOVFF  BB,281
3A16:  MOVFF  BA,280
3A1A:  MOVFF  B9,27F
3A1E:  MOVFF  03,286
3A22:  MOVFF  02,285
3A26:  MOVFF  01,284
3A2A:  MOVFF  00,283
3A2E:  CALL   1E96
3A32:  MOVFF  03,BC
3A36:  MOVFF  02,BB
3A3A:  MOVFF  01,BA
3A3E:  MOVFF  00,B9
....................             //Guardamos también este valor en el registro del año 
....................             media_dia_mes[fecha[1]-1] = valor; 
3A42:  MOVLW  01
3A44:  MOVLB  2
3A46:  SUBWF  x7B,W
3A48:  MULLW  04
3A4A:  MOVF   FF3,W
3A4C:  CLRF   03
3A4E:  ADDLW  79
3A50:  MOVWF  FE9
3A52:  MOVLW  00
3A54:  ADDWFC 03,W
3A56:  MOVWF  FEA
3A58:  MOVFF  B9,FEF
3A5C:  MOVFF  BA,FEC
3A60:  MOVFF  BB,FEC
3A64:  MOVFF  BC,FEC
....................             //Realizamos la misma operación con la media de encendido de la caldera 
....................             media_dia_caldera = media_dia_caldera + (float)tiempo_x_dia_caldera; 
3A68:  MOVFF  279,286
3A6C:  MOVFF  278,285
3A70:  MOVLB  0
3A72:  CALL   2110
3A76:  BCF    FD8.1
3A78:  MOVFF  B8,282
3A7C:  MOVFF  B7,281
3A80:  MOVFF  B6,280
3A84:  MOVFF  B5,27F
3A88:  MOVFF  03,286
3A8C:  MOVFF  02,285
3A90:  MOVFF  01,284
3A94:  MOVFF  00,283
3A98:  CALL   1E96
3A9C:  MOVFF  03,B8
3AA0:  MOVFF  02,B7
3AA4:  MOVFF  01,B6
3AA8:  MOVFF  00,B5
....................             media_dia_mes_caldera[fecha[1]-1] = media_dia_caldera; 
3AAC:  MOVLW  01
3AAE:  MOVLB  2
3AB0:  SUBWF  x7B,W
3AB2:  MULLW  04
3AB4:  MOVF   FF3,W
3AB6:  CLRF   03
3AB8:  ADDLW  BD
3ABA:  MOVWF  FE9
3ABC:  MOVLW  00
3ABE:  ADDWFC 03,W
3AC0:  MOVWF  FEA
3AC2:  MOVFF  B5,FEF
3AC6:  MOVFF  B6,FEC
3ACA:  MOVFF  B7,FEC
3ACE:  MOVFF  B8,FEC
....................          } 
....................          //La sumatoria podría alcanzar un valor muy alto. El sistema no está preparado para estas eventualidades 
....................          //y debería ser reseteado cada cierto tiempo. Si el sistema va a utilizarse mucho (zonas muy frías o mal 
....................          //aisladas), el usuario debería informar al fabricante para aumentar la memoria de almacenamiento y el 
....................          //tamaño de las variables 
....................  
....................          //Si cambiamos de año, habrá que guardar los datos anuales 
....................          if(fecha[2]!=anno) 
3AD2:  MOVF   71,W
3AD4:  SUBWF  x7C,W
3AD6:  BTFSC  FD8.2
3AD8:  BRA    3D3C
....................          { 
....................             //Comprobamos que no nos encontrabamos en el año introducido por defecto 
....................             if(fecha[2]!=0) 
3ADA:  MOVF   x7C,F
3ADC:  BTFSC  FD8.2
3ADE:  BRA    3D26
....................             { 
....................                //En ese caso, guardamos los datos de todo el año 
....................                for(contador2=0; contador2<12; contador2++) 
3AE0:  CLRF   6E
3AE2:  MOVF   6E,W
3AE4:  SUBLW  0B
3AE6:  BTFSS  FD8.0
3AE8:  BRA    3D12
....................                { 
....................                   media_dia_mes[contador2] = media_dia_mes[contador2]/(float)dias_meses[contador2]; 
3AEA:  MOVF   6E,W
3AEC:  MULLW  04
3AEE:  MOVF   FF3,W
3AF0:  CLRF   03
3AF2:  ADDLW  79
3AF4:  MOVWF  01
3AF6:  MOVLW  00
3AF8:  ADDWFC 03,F
3AFA:  MOVFF  01,27F
3AFE:  MOVFF  03,280
3B02:  MOVF   6E,W
3B04:  MULLW  04
3B06:  MOVF   FF3,W
3B08:  CLRF   03
3B0A:  ADDLW  79
3B0C:  MOVWF  FE9
3B0E:  MOVLW  00
3B10:  ADDWFC 03,W
3B12:  MOVWF  FEA
3B14:  MOVFF  FEF,281
3B18:  MOVFF  FEC,282
3B1C:  MOVFF  FEC,283
3B20:  MOVFF  FEC,284
3B24:  CLRF   03
3B26:  MOVF   6E,W
3B28:  ADDLW  A9
3B2A:  MOVWF  FE9
3B2C:  MOVLW  00
3B2E:  ADDWFC 03,W
3B30:  MOVWF  FEA
3B32:  MOVF   FEF,W
3B34:  CLRF   x86
3B36:  MOVWF  x85
3B38:  MOVLB  0
3B3A:  CALL   2110
3B3E:  MOVFF  284,288
3B42:  MOVFF  283,287
3B46:  MOVFF  282,286
3B4A:  MOVFF  281,285
3B4E:  MOVFF  03,28C
3B52:  MOVFF  02,28B
3B56:  MOVFF  01,28A
3B5A:  MOVFF  00,289
3B5E:  CALL   1BD8
3B62:  MOVFF  280,FEA
3B66:  MOVFF  27F,FE9
3B6A:  MOVFF  00,FEF
3B6E:  MOVFF  01,FEC
3B72:  MOVFF  02,FEC
3B76:  MOVFF  03,FEC
....................                   media_dia_mes_caldera[contador2] = media_dia_mes_caldera[contador2]/(float)dias_meses[contador2]; 
3B7A:  MOVF   6E,W
3B7C:  MULLW  04
3B7E:  MOVF   FF3,W
3B80:  CLRF   03
3B82:  ADDLW  BD
3B84:  MOVWF  01
3B86:  MOVLW  00
3B88:  ADDWFC 03,F
3B8A:  MOVFF  01,27F
3B8E:  MOVLB  2
3B90:  MOVFF  03,280
3B94:  MOVF   6E,W
3B96:  MULLW  04
3B98:  MOVF   FF3,W
3B9A:  CLRF   03
3B9C:  ADDLW  BD
3B9E:  MOVWF  FE9
3BA0:  MOVLW  00
3BA2:  ADDWFC 03,W
3BA4:  MOVWF  FEA
3BA6:  MOVFF  FEF,281
3BAA:  MOVFF  FEC,282
3BAE:  MOVFF  FEC,283
3BB2:  MOVFF  FEC,284
3BB6:  CLRF   03
3BB8:  MOVF   6E,W
3BBA:  ADDLW  A9
3BBC:  MOVWF  FE9
3BBE:  MOVLW  00
3BC0:  ADDWFC 03,W
3BC2:  MOVWF  FEA
3BC4:  MOVF   FEF,W
3BC6:  CLRF   x86
3BC8:  MOVWF  x85
3BCA:  MOVLB  0
3BCC:  CALL   2110
3BD0:  MOVFF  284,288
3BD4:  MOVFF  283,287
3BD8:  MOVFF  282,286
3BDC:  MOVFF  281,285
3BE0:  MOVFF  03,28C
3BE4:  MOVFF  02,28B
3BE8:  MOVFF  01,28A
3BEC:  MOVFF  00,289
3BF0:  CALL   1BD8
3BF4:  MOVFF  280,FEA
3BF8:  MOVFF  27F,FE9
3BFC:  MOVFF  00,FEF
3C00:  MOVFF  01,FEC
3C04:  MOVFF  02,FEC
3C08:  MOVFF  03,FEC
....................                   media_annos[num_annos][contador2] = media_dia_mes[contador2]; 
3C0C:  MOVLB  2
3C0E:  MOVF   x71,W
3C10:  MULLW  30
3C12:  MOVF   FF3,W
3C14:  CLRF   x80
3C16:  MOVWF  x7F
3C18:  MOVF   6E,W
3C1A:  MULLW  04
3C1C:  MOVF   FF3,W
3C1E:  CLRF   03
3C20:  ADDWF  x7F,W
3C22:  MOVWF  01
3C24:  MOVF   x80,W
3C26:  ADDWFC 03,F
3C28:  MOVF   01,W
3C2A:  ADDLW  F1
3C2C:  MOVWF  01
3C2E:  MOVLW  00
3C30:  ADDWFC 03,F
3C32:  MOVFF  01,281
3C36:  MOVFF  03,282
3C3A:  MOVF   6E,W
3C3C:  MULLW  04
3C3E:  MOVF   FF3,W
3C40:  CLRF   03
3C42:  ADDLW  79
3C44:  MOVWF  FE9
3C46:  MOVLW  00
3C48:  ADDWFC 03,W
3C4A:  MOVWF  FEA
3C4C:  MOVFF  FEF,00
3C50:  MOVFF  FEC,01
3C54:  MOVFF  FEC,02
3C58:  MOVFF  FEC,03
3C5C:  MOVFF  282,FEA
3C60:  MOVFF  281,FE9
3C64:  MOVFF  00,FEF
3C68:  MOVFF  01,FEC
3C6C:  MOVFF  02,FEC
3C70:  MOVFF  03,FEC
....................                   media_annos_caldera[num_annos][contador2] = media_dia_mes_caldera[contador2]; 
3C74:  MOVF   x71,W
3C76:  MULLW  30
3C78:  MOVF   FF3,W
3C7A:  CLRF   x80
3C7C:  MOVWF  x7F
3C7E:  MOVF   6E,W
3C80:  MULLW  04
3C82:  MOVF   FF3,W
3C84:  CLRF   03
3C86:  ADDWF  x7F,W
3C88:  MOVWF  01
3C8A:  MOVF   x80,W
3C8C:  ADDWFC 03,F
3C8E:  MOVF   01,W
3C90:  ADDLW  B1
3C92:  MOVWF  01
3C94:  MOVLW  01
3C96:  ADDWFC 03,F
3C98:  MOVFF  01,281
3C9C:  MOVFF  03,282
3CA0:  MOVF   6E,W
3CA2:  MULLW  04
3CA4:  MOVF   FF3,W
3CA6:  CLRF   03
3CA8:  ADDLW  BD
3CAA:  MOVWF  FE9
3CAC:  MOVLW  00
3CAE:  ADDWFC 03,W
3CB0:  MOVWF  FEA
3CB2:  MOVFF  FEF,00
3CB6:  MOVFF  FEC,01
3CBA:  MOVFF  FEC,02
3CBE:  MOVFF  FEC,03
3CC2:  MOVFF  282,FEA
3CC6:  MOVFF  281,FE9
3CCA:  MOVFF  00,FEF
3CCE:  MOVFF  01,FEC
3CD2:  MOVFF  02,FEC
3CD6:  MOVFF  03,FEC
....................                   //Inicializamos de nuevo los vectores que almacenan los datos del año actual 
....................                   media_dia_mes[contador2]=0; 
3CDA:  MOVF   6E,W
3CDC:  MULLW  04
3CDE:  MOVF   FF3,W
3CE0:  CLRF   03
3CE2:  ADDLW  79
3CE4:  MOVWF  FE9
3CE6:  MOVLW  00
3CE8:  ADDWFC 03,W
3CEA:  MOVWF  FEA
3CEC:  CLRF   FEF
3CEE:  CLRF   FEC
3CF0:  CLRF   FEC
3CF2:  CLRF   FEC
....................                   media_dia_mes_caldera[contador2]=0; 
3CF4:  MOVF   6E,W
3CF6:  MULLW  04
3CF8:  MOVF   FF3,W
3CFA:  CLRF   03
3CFC:  ADDLW  BD
3CFE:  MOVWF  FE9
3D00:  MOVLW  00
3D02:  ADDWFC 03,W
3D04:  MOVWF  FEA
3D06:  CLRF   FEF
3D08:  CLRF   FEC
3D0A:  CLRF   FEC
3D0C:  CLRF   FEC
....................                } 
3D0E:  INCF   6E,F
3D10:  BRA    3AE2
....................  
....................                //Guardamos el año del que se trata 
....................                annos[num_annos]=fecha[2]; 
3D12:  CLRF   03
3D14:  MOVF   x71,W
3D16:  ADDLW  72
3D18:  MOVWF  FE9
3D1A:  MOVLW  02
3D1C:  ADDWFC 03,W
3D1E:  MOVWF  FEA
3D20:  MOVFF  27C,FEF
....................  
....................                //Aumentamos en 1 el número de años 
....................                num_annos++; 
3D24:  INCF   x71,F
....................             } 
....................  
....................             //COMPROBAR BISIESTO 
....................             //En realidad, un año será bisiesto si es divisible por 4 y no lo es por 100, 
....................             //excepto si este último lo es por 400. Sin embargo, dado que trabajamos con las 
....................             //dos últimas cifras y que el próximo año divisible por 4 que no lo es por 100 
....................             //es el 2100, mejor nos limitaremos a la divisibilidad por 4. 
....................             //Dependiendo si el año es bisiesto o no, le damos a febrero 29 o 28 días. 
....................             if(anno%4 == 0) 
3D26:  MOVF   71,W
3D28:  ANDLW  03
3D2A:  BNZ   3D34
....................                dias_meses[1] = 29; 
3D2C:  MOVLW  1D
3D2E:  MOVLB  0
3D30:  MOVWF  xAA
....................             else 
3D32:  BRA    3D3A
....................                dias_meses[1] = 28; 
3D34:  MOVLW  1C
3D36:  MOVLB  0
3D38:  MOVWF  xAA
3D3A:  MOVLB  2
....................          } 
....................  
....................          //Modificamos la información del día 
....................          fecha[0] = dia; 
3D3C:  MOVFF  6F,27A
....................          fecha[1] = mes; 
3D40:  MOVFF  70,27B
....................          fecha[2] = anno; 
3D44:  MOVFF  71,27C
....................  
....................          //Aumentamos en 1 el número de días 
....................          num_dias++; 
3D48:  INCF   x7D,F
3D4A:  BTFSC  FD8.2
3D4C:  INCF   x7E,F
....................  
....................          //Reseteamos las variables acumulativas de tiempo por día 
....................          tiempo_x_dia = 0; 
3D4E:  CLRF   x77
3D50:  CLRF   x76
....................          tiempo_x_dia_caldera = 0; 
3D52:  CLRF   x79
3D54:  CLRF   x78
....................       } 
....................  
....................       //Le sumamos al tiempo de encendido de sistema y caldera el correspondiente de este registro 
....................       tiempo_x_dia = tiempo_x_dia + t_sistema; 
3D56:  MOVF   76,W
3D58:  ADDWF  x76,F
3D5A:  MOVLW  00
3D5C:  ADDWFC x77,F
....................       tiempo_x_dia_caldera = tiempo_x_dia_caldera + t_caldera; 
3D5E:  MOVF   77,W
3D60:  ADDWF  x78,F
3D62:  MOVLW  00
3D64:  ADDWFC x79,F
....................       //También incrementamos los tiempos totales 
....................       valor_total = valor_total + t_sistema; 
3D66:  MOVF   76,W
3D68:  MOVLB  0
3D6A:  ADDWF  xED,F
3D6C:  MOVLW  00
3D6E:  ADDWFC xEE,F
....................       valor_total_caldera = valor_total_caldera + t_caldera; 
3D70:  MOVF   77,W
3D72:  ADDWF  xEF,F
3D74:  MOVLW  00
3D76:  ADDWFC xF0,F
....................  
....................       //Representamos todos los datos, teniendo en cuenta algunos requisitos representativos 
....................       //para que los datos queden alineados (número menores que 10, que 100, etc). 
....................       if(dia<10) 
3D78:  MOVF   6F,W
3D7A:  SUBLW  09
3D7C:  BNC   3D9C
....................          printf(" "); 
3D7E:  MOVLB  2
3D80:  CLRF   x7F
3D82:  MOVF   x7F,W
3D84:  MOVLB  0
3D86:  CALL   05C8
3D8A:  IORLW  00
3D8C:  BZ    3D9C
3D8E:  MOVLB  2
3D90:  INCF   x7F,F
3D92:  BTFSS  F9E.4
3D94:  BRA    3D92
3D96:  MOVWF  FAD
3D98:  BRA    3D82
3D9A:  MOVLB  0
....................  
....................       printf("%u/", dia); 
3D9C:  MOVFF  6F,280
3DA0:  MOVLW  1B
3DA2:  MOVLB  2
3DA4:  MOVWF  x81
3DA6:  MOVLB  0
3DA8:  CALL   3416
3DAC:  MOVLW  2F
3DAE:  BTFSS  F9E.4
3DB0:  BRA    3DAE
3DB2:  MOVWF  FAD
....................  
....................       if(mes<10) 
3DB4:  MOVF   70,W
3DB6:  SUBLW  09
3DB8:  BNC   3DD8
....................          printf("0"); 
3DBA:  MOVLB  2
3DBC:  CLRF   x7F
3DBE:  MOVF   x7F,W
3DC0:  MOVLB  0
3DC2:  CALL   044A
3DC6:  IORLW  00
3DC8:  BZ    3DD8
3DCA:  MOVLB  2
3DCC:  INCF   x7F,F
3DCE:  BTFSS  F9E.4
3DD0:  BRA    3DCE
3DD2:  MOVWF  FAD
3DD4:  BRA    3DBE
3DD6:  MOVLB  0
....................  
....................       printf("%u/", mes); 
3DD8:  MOVFF  70,280
3DDC:  MOVLW  1B
3DDE:  MOVLB  2
3DE0:  MOVWF  x81
3DE2:  MOVLB  0
3DE4:  CALL   3416
3DE8:  MOVLW  2F
3DEA:  BTFSS  F9E.4
3DEC:  BRA    3DEA
3DEE:  MOVWF  FAD
....................  
....................       if(anno<10) 
3DF0:  MOVF   71,W
3DF2:  SUBLW  09
3DF4:  BNC   3E14
....................          printf("0"); 
3DF6:  MOVLB  2
3DF8:  CLRF   x7F
3DFA:  MOVF   x7F,W
3DFC:  MOVLB  0
3DFE:  CALL   044A
3E02:  IORLW  00
3E04:  BZ    3E14
3E06:  MOVLB  2
3E08:  INCF   x7F,F
3E0A:  BTFSS  F9E.4
3E0C:  BRA    3E0A
3E0E:  MOVWF  FAD
3E10:  BRA    3DFA
3E12:  MOVLB  0
....................  
....................       printf("%u  ", anno); 
3E14:  MOVFF  71,280
3E18:  MOVLW  1B
3E1A:  MOVLB  2
3E1C:  MOVWF  x81
3E1E:  MOVLB  0
3E20:  CALL   3416
3E24:  MOVLW  20
3E26:  BTFSS  F9E.4
3E28:  BRA    3E26
3E2A:  MOVWF  FAD
3E2C:  MOVLW  20
3E2E:  BTFSS  F9E.4
3E30:  BRA    3E2E
3E32:  MOVWF  FAD
....................  
....................       if(horas<10) 
3E34:  MOVF   72,W
3E36:  SUBLW  09
3E38:  BNC   3E58
....................          printf("0"); 
3E3A:  MOVLB  2
3E3C:  CLRF   x7F
3E3E:  MOVF   x7F,W
3E40:  MOVLB  0
3E42:  CALL   044A
3E46:  IORLW  00
3E48:  BZ    3E58
3E4A:  MOVLB  2
3E4C:  INCF   x7F,F
3E4E:  BTFSS  F9E.4
3E50:  BRA    3E4E
3E52:  MOVWF  FAD
3E54:  BRA    3E3E
3E56:  MOVLB  0
....................  
....................       printf("%u:", horas); 
3E58:  MOVFF  72,280
3E5C:  MOVLW  1B
3E5E:  MOVLB  2
3E60:  MOVWF  x81
3E62:  MOVLB  0
3E64:  CALL   3416
3E68:  MOVLW  3A
3E6A:  BTFSS  F9E.4
3E6C:  BRA    3E6A
3E6E:  MOVWF  FAD
....................  
....................       if(minutos<10) 
3E70:  MOVF   73,W
3E72:  SUBLW  09
3E74:  BNC   3E94
....................          printf("0"); 
3E76:  MOVLB  2
3E78:  CLRF   x7F
3E7A:  MOVF   x7F,W
3E7C:  MOVLB  0
3E7E:  CALL   044A
3E82:  IORLW  00
3E84:  BZ    3E94
3E86:  MOVLB  2
3E88:  INCF   x7F,F
3E8A:  BTFSS  F9E.4
3E8C:  BRA    3E8A
3E8E:  MOVWF  FAD
3E90:  BRA    3E7A
3E92:  MOVLB  0
....................  
....................       printf("%u          ", minutos); 
3E94:  MOVFF  73,280
3E98:  MOVLW  1B
3E9A:  MOVLB  2
3E9C:  MOVWF  x81
3E9E:  MOVLB  0
3EA0:  CALL   3416
3EA4:  MOVLW  0A
3EA6:  MOVLB  2
3EA8:  MOVWF  x7F
3EAA:  MOVLW  20
3EAC:  BTFSS  F9E.4
3EAE:  BRA    3EAC
3EB0:  MOVWF  FAD
3EB2:  DECFSZ x7F,F
3EB4:  BRA    3EAA
....................  
....................       if(temp_int<10) 
3EB6:  MOVF   74,W
3EB8:  SUBLW  09
3EBA:  BNC   3ED6
....................          printf(" "); 
3EBC:  CLRF   x7F
3EBE:  MOVF   x7F,W
3EC0:  MOVLB  0
3EC2:  CALL   05C8
3EC6:  IORLW  00
3EC8:  BZ    3ED8
3ECA:  MOVLB  2
3ECC:  INCF   x7F,F
3ECE:  BTFSS  F9E.4
3ED0:  BRA    3ECE
3ED2:  MOVWF  FAD
3ED4:  BRA    3EBE
3ED6:  MOVLB  0
....................  
....................       printf("%u.", temp_int); 
3ED8:  MOVFF  74,280
3EDC:  MOVLW  1B
3EDE:  MOVLB  2
3EE0:  MOVWF  x81
3EE2:  MOVLB  0
3EE4:  CALL   3416
3EE8:  MOVLW  2E
3EEA:  BTFSS  F9E.4
3EEC:  BRA    3EEA
3EEE:  MOVWF  FAD
....................  
....................       if(temp_dec<10) 
3EF0:  MOVF   75,W
3EF2:  SUBLW  09
3EF4:  BNC   3F14
....................          printf("0"); 
3EF6:  MOVLB  2
3EF8:  CLRF   x7F
3EFA:  MOVF   x7F,W
3EFC:  MOVLB  0
3EFE:  CALL   044A
3F02:  IORLW  00
3F04:  BZ    3F14
3F06:  MOVLB  2
3F08:  INCF   x7F,F
3F0A:  BTFSS  F9E.4
3F0C:  BRA    3F0A
3F0E:  MOVWF  FAD
3F10:  BRA    3EFA
3F12:  MOVLB  0
....................  
....................       printf("%u%cC              %u%cC                 ", temp_dec, 223, term, 223); 
3F14:  MOVFF  75,280
3F18:  MOVLW  1B
3F1A:  MOVLB  2
3F1C:  MOVWF  x81
3F1E:  MOVLB  0
3F20:  CALL   3416
3F24:  MOVLW  DF
3F26:  BTFSS  F9E.4
3F28:  BRA    3F26
3F2A:  MOVWF  FAD
3F2C:  MOVLW  43
3F2E:  BTFSS  F9E.4
3F30:  BRA    3F2E
3F32:  MOVWF  FAD
3F34:  MOVLW  0E
3F36:  MOVLB  2
3F38:  MOVWF  x7F
3F3A:  MOVLW  20
3F3C:  BTFSS  F9E.4
3F3E:  BRA    3F3C
3F40:  MOVWF  FAD
3F42:  DECFSZ x7F,F
3F44:  BRA    3F3A
3F46:  MOVFF  78,280
3F4A:  MOVLW  1B
3F4C:  MOVWF  x81
3F4E:  MOVLB  0
3F50:  CALL   3416
3F54:  MOVLW  DF
3F56:  BTFSS  F9E.4
3F58:  BRA    3F56
3F5A:  MOVWF  FAD
3F5C:  MOVLW  43
3F5E:  BTFSS  F9E.4
3F60:  BRA    3F5E
3F62:  MOVWF  FAD
3F64:  MOVLW  11
3F66:  MOVLB  2
3F68:  MOVWF  x80
3F6A:  MOVLW  20
3F6C:  BTFSS  F9E.4
3F6E:  BRA    3F6C
3F70:  MOVWF  FAD
3F72:  DECFSZ x80,F
3F74:  BRA    3F6A
....................  
....................       if(t_sistema<100) 
3F76:  MOVF   76,W
3F78:  SUBLW  63
3F7A:  BNC   3F96
....................          printf(" "); 
3F7C:  CLRF   x7F
3F7E:  MOVF   x7F,W
3F80:  MOVLB  0
3F82:  CALL   05C8
3F86:  IORLW  00
3F88:  BZ    3F98
3F8A:  MOVLB  2
3F8C:  INCF   x7F,F
3F8E:  BTFSS  F9E.4
3F90:  BRA    3F8E
3F92:  MOVWF  FAD
3F94:  BRA    3F7E
3F96:  MOVLB  0
....................       if(t_sistema<10) 
3F98:  MOVF   76,W
3F9A:  SUBLW  09
3F9C:  BNC   3FBC
....................          printf(" "); 
3F9E:  MOVLB  2
3FA0:  CLRF   x7F
3FA2:  MOVF   x7F,W
3FA4:  MOVLB  0
3FA6:  CALL   05C8
3FAA:  IORLW  00
3FAC:  BZ    3FBC
3FAE:  MOVLB  2
3FB0:  INCF   x7F,F
3FB2:  BTFSS  F9E.4
3FB4:  BRA    3FB2
3FB6:  MOVWF  FAD
3FB8:  BRA    3FA2
3FBA:  MOVLB  0
....................  
....................       printf("%u                   ", t_sistema); 
3FBC:  MOVFF  76,280
3FC0:  MOVLW  1B
3FC2:  MOVLB  2
3FC4:  MOVWF  x81
3FC6:  MOVLB  0
3FC8:  CALL   3416
3FCC:  MOVLW  13
3FCE:  MOVLB  2
3FD0:  MOVWF  x7F
3FD2:  MOVLW  20
3FD4:  BTFSS  F9E.4
3FD6:  BRA    3FD4
3FD8:  MOVWF  FAD
3FDA:  DECFSZ x7F,F
3FDC:  BRA    3FD2
....................  
....................       if(t_caldera<100) 
3FDE:  MOVF   77,W
3FE0:  SUBLW  63
3FE2:  BNC   3FFE
....................          printf(" "); 
3FE4:  CLRF   x7F
3FE6:  MOVF   x7F,W
3FE8:  MOVLB  0
3FEA:  CALL   05C8
3FEE:  IORLW  00
3FF0:  BZ    4000
3FF2:  MOVLB  2
3FF4:  INCF   x7F,F
3FF6:  BTFSS  F9E.4
3FF8:  BRA    3FF6
3FFA:  MOVWF  FAD
3FFC:  BRA    3FE6
3FFE:  MOVLB  0
....................       if(t_caldera<10) 
4000:  MOVF   77,W
4002:  SUBLW  09
4004:  BNC   4024
....................          printf(" "); 
4006:  MOVLB  2
4008:  CLRF   x7F
400A:  MOVF   x7F,W
400C:  MOVLB  0
400E:  CALL   05C8
4012:  IORLW  00
4014:  BZ    4024
4016:  MOVLB  2
4018:  INCF   x7F,F
401A:  BTFSS  F9E.4
401C:  BRA    401A
401E:  MOVWF  FAD
4020:  BRA    400A
4022:  MOVLB  0
....................  
....................       printf("%u\r", t_caldera); 
4024:  MOVFF  77,280
4028:  MOVLW  1B
402A:  MOVLB  2
402C:  MOVWF  x81
402E:  MOVLB  0
4030:  CALL   3416
4034:  MOVLW  0D
4036:  BTFSS  F9E.4
4038:  BRA    4036
403A:  MOVWF  FAD
....................  
....................    } 
403C:  INCF   6D,F
403E:  BRA    389C
....................  
....................    //Debemos realizar la operación de guardado para el último día. El proceso es el mismo 
....................    //que hemos seguido arriba. 
....................    if(fecha[0]!=0) 
4040:  MOVLB  2
4042:  MOVF   x7A,F
4044:  BZ    411A
....................    { 
....................       valor = valor + (float)tiempo_x_dia; 
4046:  MOVFF  277,286
404A:  MOVFF  276,285
404E:  MOVLB  0
4050:  CALL   2110
4054:  BCF    FD8.1
4056:  MOVFF  BC,282
405A:  MOVFF  BB,281
405E:  MOVFF  BA,280
4062:  MOVFF  B9,27F
4066:  MOVFF  03,286
406A:  MOVFF  02,285
406E:  MOVFF  01,284
4072:  MOVFF  00,283
4076:  CALL   1E96
407A:  MOVFF  03,BC
407E:  MOVFF  02,BB
4082:  MOVFF  01,BA
4086:  MOVFF  00,B9
....................       media_dia_mes[fecha[1]-1] = valor; 
408A:  MOVLW  01
408C:  MOVLB  2
408E:  SUBWF  x7B,W
4090:  MULLW  04
4092:  MOVF   FF3,W
4094:  CLRF   03
4096:  ADDLW  79
4098:  MOVWF  FE9
409A:  MOVLW  00
409C:  ADDWFC 03,W
409E:  MOVWF  FEA
40A0:  MOVFF  B9,FEF
40A4:  MOVFF  BA,FEC
40A8:  MOVFF  BB,FEC
40AC:  MOVFF  BC,FEC
....................       media_dia_caldera = media_dia_caldera + (float)tiempo_x_dia_caldera; 
40B0:  MOVFF  279,286
40B4:  MOVFF  278,285
40B8:  MOVLB  0
40BA:  CALL   2110
40BE:  BCF    FD8.1
40C0:  MOVFF  B8,282
40C4:  MOVFF  B7,281
40C8:  MOVFF  B6,280
40CC:  MOVFF  B5,27F
40D0:  MOVFF  03,286
40D4:  MOVFF  02,285
40D8:  MOVFF  01,284
40DC:  MOVFF  00,283
40E0:  CALL   1E96
40E4:  MOVFF  03,B8
40E8:  MOVFF  02,B7
40EC:  MOVFF  01,B6
40F0:  MOVFF  00,B5
....................       media_dia_mes_caldera[fecha[1]-1] = media_dia_caldera; 
40F4:  MOVLW  01
40F6:  MOVLB  2
40F8:  SUBWF  x7B,W
40FA:  MULLW  04
40FC:  MOVF   FF3,W
40FE:  CLRF   03
4100:  ADDLW  BD
4102:  MOVWF  FE9
4104:  MOVLW  00
4106:  ADDWFC 03,W
4108:  MOVWF  FEA
410A:  MOVFF  B5,FEF
410E:  MOVFF  B6,FEC
4112:  MOVFF  B7,FEC
4116:  MOVFF  B8,FEC
....................    } 
....................  
....................    //Comprobamos que no nos encontrabamos en el año introducido por defecto 
....................    if(fecha[2]!=0) 
411A:  MOVF   x7C,F
411C:  BTFSC  FD8.2
411E:  BRA    4332
....................    { 
....................       for(contador2=0; contador2<12; contador2++) 
4120:  CLRF   6E
4122:  MOVF   6E,W
4124:  SUBLW  0B
4126:  BTFSS  FD8.0
4128:  BRA    431E
....................       { 
....................          media_dia_mes[contador2] = media_dia_mes[contador2]/(float)dias_meses[contador2]; 
412A:  MOVF   6E,W
412C:  MULLW  04
412E:  MOVF   FF3,W
4130:  CLRF   03
4132:  ADDLW  79
4134:  MOVWF  01
4136:  MOVLW  00
4138:  ADDWFC 03,F
413A:  MOVFF  01,27F
413E:  MOVFF  03,280
4142:  MOVF   6E,W
4144:  MULLW  04
4146:  MOVF   FF3,W
4148:  CLRF   03
414A:  ADDLW  79
414C:  MOVWF  FE9
414E:  MOVLW  00
4150:  ADDWFC 03,W
4152:  MOVWF  FEA
4154:  MOVFF  FEF,281
4158:  MOVFF  FEC,282
415C:  MOVFF  FEC,283
4160:  MOVFF  FEC,284
4164:  CLRF   03
4166:  MOVF   6E,W
4168:  ADDLW  A9
416A:  MOVWF  FE9
416C:  MOVLW  00
416E:  ADDWFC 03,W
4170:  MOVWF  FEA
4172:  MOVF   FEF,W
4174:  CLRF   x86
4176:  MOVWF  x85
4178:  MOVLB  0
417A:  CALL   2110
417E:  MOVFF  284,288
4182:  MOVFF  283,287
4186:  MOVFF  282,286
418A:  MOVFF  281,285
418E:  MOVFF  03,28C
4192:  MOVFF  02,28B
4196:  MOVFF  01,28A
419A:  MOVFF  00,289
419E:  CALL   1BD8
41A2:  MOVFF  280,FEA
41A6:  MOVFF  27F,FE9
41AA:  MOVFF  00,FEF
41AE:  MOVFF  01,FEC
41B2:  MOVFF  02,FEC
41B6:  MOVFF  03,FEC
....................          media_dia_mes_caldera[contador2] = media_dia_mes_caldera[contador2]/(float)dias_meses[contador2]; 
41BA:  MOVF   6E,W
41BC:  MULLW  04
41BE:  MOVF   FF3,W
41C0:  CLRF   03
41C2:  ADDLW  BD
41C4:  MOVWF  01
41C6:  MOVLW  00
41C8:  ADDWFC 03,F
41CA:  MOVFF  01,27F
41CE:  MOVLB  2
41D0:  MOVFF  03,280
41D4:  MOVF   6E,W
41D6:  MULLW  04
41D8:  MOVF   FF3,W
41DA:  CLRF   03
41DC:  ADDLW  BD
41DE:  MOVWF  FE9
41E0:  MOVLW  00
41E2:  ADDWFC 03,W
41E4:  MOVWF  FEA
41E6:  MOVFF  FEF,281
41EA:  MOVFF  FEC,282
41EE:  MOVFF  FEC,283
41F2:  MOVFF  FEC,284
41F6:  CLRF   03
41F8:  MOVF   6E,W
41FA:  ADDLW  A9
41FC:  MOVWF  FE9
41FE:  MOVLW  00
4200:  ADDWFC 03,W
4202:  MOVWF  FEA
4204:  MOVF   FEF,W
4206:  CLRF   x86
4208:  MOVWF  x85
420A:  MOVLB  0
420C:  CALL   2110
4210:  MOVFF  284,288
4214:  MOVFF  283,287
4218:  MOVFF  282,286
421C:  MOVFF  281,285
4220:  MOVFF  03,28C
4224:  MOVFF  02,28B
4228:  MOVFF  01,28A
422C:  MOVFF  00,289
4230:  CALL   1BD8
4234:  MOVFF  280,FEA
4238:  MOVFF  27F,FE9
423C:  MOVFF  00,FEF
4240:  MOVFF  01,FEC
4244:  MOVFF  02,FEC
4248:  MOVFF  03,FEC
....................          media_annos[num_annos][contador2] = media_dia_mes[contador2]; 
424C:  MOVLB  2
424E:  MOVF   x71,W
4250:  MULLW  30
4252:  MOVF   FF3,W
4254:  CLRF   x80
4256:  MOVWF  x7F
4258:  MOVF   6E,W
425A:  MULLW  04
425C:  MOVF   FF3,W
425E:  CLRF   03
4260:  ADDWF  x7F,W
4262:  MOVWF  01
4264:  MOVF   x80,W
4266:  ADDWFC 03,F
4268:  MOVF   01,W
426A:  ADDLW  F1
426C:  MOVWF  01
426E:  MOVLW  00
4270:  ADDWFC 03,F
4272:  MOVFF  01,281
4276:  MOVFF  03,282
427A:  MOVF   6E,W
427C:  MULLW  04
427E:  MOVF   FF3,W
4280:  CLRF   03
4282:  ADDLW  79
4284:  MOVWF  FE9
4286:  MOVLW  00
4288:  ADDWFC 03,W
428A:  MOVWF  FEA
428C:  MOVFF  FEF,00
4290:  MOVFF  FEC,01
4294:  MOVFF  FEC,02
4298:  MOVFF  FEC,03
429C:  MOVFF  282,FEA
42A0:  MOVFF  281,FE9
42A4:  MOVFF  00,FEF
42A8:  MOVFF  01,FEC
42AC:  MOVFF  02,FEC
42B0:  MOVFF  03,FEC
....................          media_annos_caldera[num_annos][contador2] = media_dia_mes_caldera[contador2]; 
42B4:  MOVF   x71,W
42B6:  MULLW  30
42B8:  MOVF   FF3,W
42BA:  CLRF   x80
42BC:  MOVWF  x7F
42BE:  MOVF   6E,W
42C0:  MULLW  04
42C2:  MOVF   FF3,W
42C4:  CLRF   03
42C6:  ADDWF  x7F,W
42C8:  MOVWF  01
42CA:  MOVF   x80,W
42CC:  ADDWFC 03,F
42CE:  MOVF   01,W
42D0:  ADDLW  B1
42D2:  MOVWF  01
42D4:  MOVLW  01
42D6:  ADDWFC 03,F
42D8:  MOVFF  01,281
42DC:  MOVFF  03,282
42E0:  MOVF   6E,W
42E2:  MULLW  04
42E4:  MOVF   FF3,W
42E6:  CLRF   03
42E8:  ADDLW  BD
42EA:  MOVWF  FE9
42EC:  MOVLW  00
42EE:  ADDWFC 03,W
42F0:  MOVWF  FEA
42F2:  MOVFF  FEF,00
42F6:  MOVFF  FEC,01
42FA:  MOVFF  FEC,02
42FE:  MOVFF  FEC,03
4302:  MOVFF  282,FEA
4306:  MOVFF  281,FE9
430A:  MOVFF  00,FEF
430E:  MOVFF  01,FEC
4312:  MOVFF  02,FEC
4316:  MOVFF  03,FEC
....................       } 
431A:  INCF   6E,F
431C:  BRA    4122
....................  
....................       annos[num_annos]=fecha[2]; 
431E:  CLRF   03
4320:  MOVF   x71,W
4322:  ADDLW  72
4324:  MOVWF  FE9
4326:  MOVLW  02
4328:  ADDWFC 03,W
432A:  MOVWF  FEA
432C:  MOVFF  27C,FEF
....................  
....................       num_annos++; 
4330:  INCF   x71,F
....................    } 
....................  
....................    //Calculamos la media como el cociente entre los valore de tiempo calculados y el número de 
....................    //días en los que se ha encendido la caldera 
....................    valor = valor/(float)num_dias; 
4332:  MOVFF  27E,286
4336:  MOVFF  27D,285
433A:  MOVLB  0
433C:  CALL   2110
4340:  MOVFF  BC,288
4344:  MOVFF  BB,287
4348:  MOVFF  BA,286
434C:  MOVFF  B9,285
4350:  MOVFF  03,28C
4354:  MOVFF  02,28B
4358:  MOVFF  01,28A
435C:  MOVFF  00,289
4360:  CALL   1BD8
4364:  MOVFF  03,BC
4368:  MOVFF  02,BB
436C:  MOVFF  01,BA
4370:  MOVFF  00,B9
....................    media_dia_caldera = media_dia_caldera/(float)num_dias; 
4374:  MOVFF  27E,286
4378:  MOVFF  27D,285
437C:  CALL   2110
4380:  MOVFF  B8,288
4384:  MOVFF  B7,287
4388:  MOVFF  B6,286
438C:  MOVFF  B5,285
4390:  MOVFF  03,28C
4394:  MOVFF  02,28B
4398:  MOVFF  01,28A
439C:  MOVFF  00,289
43A0:  CALL   1BD8
43A4:  MOVFF  03,B8
43A8:  MOVFF  02,B7
43AC:  MOVFF  01,B6
43B0:  MOVFF  00,B5
....................  
....................    repetir: 
....................    //Menú para mostrar los datos 
....................    printf("======================================================================================================\r"); 
43B4:  MOVLB  2
43B6:  CLRF   x7F
43B8:  MOVF   x7F,W
43BA:  MOVLB  0
43BC:  CALL   0546
43C0:  IORLW  00
43C2:  BZ    43D2
43C4:  MOVLB  2
43C6:  INCF   x7F,F
43C8:  BTFSS  F9E.4
43CA:  BRA    43C8
43CC:  MOVWF  FAD
43CE:  BRA    43B8
43D0:  MOVLB  0
....................    printf("¿Que operacion desea realizar?\r"); 
43D2:  MOVLB  2
43D4:  CLRF   x7F
43D6:  MOVF   x7F,W
43D8:  MOVLB  0
43DA:  CALL   05E4
43DE:  IORLW  00
43E0:  BZ    43F0
43E2:  MOVLB  2
43E4:  INCF   x7F,F
43E6:  BTFSS  F9E.4
43E8:  BRA    43E6
43EA:  MOVWF  FAD
43EC:  BRA    43D6
43EE:  MOVLB  0
....................    printf(" -. Salir\r"); 
43F0:  MOVLB  2
43F2:  CLRF   x7F
43F4:  MOVF   x7F,W
43F6:  MOVLB  0
43F8:  CALL   061E
43FC:  IORLW  00
43FE:  BZ    440E
4400:  MOVLB  2
4402:  INCF   x7F,F
4404:  BTFSS  F9E.4
4406:  BRA    4404
4408:  MOVWF  FAD
440A:  BRA    43F4
440C:  MOVLB  0
....................    printf(" +. Extraer tiempos medios por dia\r"); 
440E:  MOVLB  2
4410:  CLRF   x7F
4412:  MOVF   x7F,W
4414:  MOVLB  0
4416:  CALL   0644
441A:  IORLW  00
441C:  BZ    442C
441E:  MOVLB  2
4420:  INCF   x7F,F
4422:  BTFSS  F9E.4
4424:  BRA    4422
4426:  MOVWF  FAD
4428:  BRA    4412
442A:  MOVLB  0
....................    printf("SI. Extraer tiempos totales\r"); 
442C:  MOVLB  2
442E:  CLRF   x7F
4430:  MOVF   x7F,W
4432:  MOVLB  0
4434:  CALL   0682
4438:  IORLW  00
443A:  BZ    444A
443C:  MOVLB  2
443E:  INCF   x7F,F
4440:  BTFSS  F9E.4
4442:  BRA    4440
4444:  MOVWF  FAD
4446:  BRA    4430
4448:  MOVLB  0
....................    printf("NO. Extraer datos mensuales\r"); 
444A:  MOVLB  2
444C:  CLRF   x7F
444E:  MOVF   x7F,W
4450:  MOVLB  0
4452:  CALL   06BA
4456:  IORLW  00
4458:  BZ    4468
445A:  MOVLB  2
445C:  INCF   x7F,F
445E:  BTFSS  F9E.4
4460:  BRA    445E
4462:  MOVWF  FAD
4464:  BRA    444E
4466:  MOVLB  0
....................    printf("======================================================================================================\r"); 
4468:  MOVLB  2
446A:  CLRF   x7F
446C:  MOVF   x7F,W
446E:  MOVLB  0
4470:  CALL   0546
4474:  IORLW  00
4476:  BZ    4486
4478:  MOVLB  2
447A:  INCF   x7F,F
447C:  BTFSS  F9E.4
447E:  BRA    447C
4480:  MOVWF  FAD
4482:  BRA    446C
4484:  MOVLB  0
....................  
....................    //Esperamos la introducción de una de las opciones por parte del técnico. 
....................    //Cuando se pulse uno de los botones, asignamos a la variable contador2 el valor correspondiente 
....................    //y esperamos a que se suelte la pulsación, saliendo después del bucle. 
....................    while(1){ 
....................       if(!menos) 
4486:  BTFSC  F82.1
4488:  BRA    4494
....................       { 
....................          contador2 = 0; 
448A:  CLRF   6E
....................          while(!menos){} 
448C:  BTFSC  F82.1
448E:  BRA    4492
4490:  BRA    448C
....................          break; 
4492:  BRA    44C6
....................       } 
....................       if(!mas) 
4494:  BTFSC  F82.0
4496:  BRA    44A4
....................       { 
....................          contador2 = 1; 
4498:  MOVLW  01
449A:  MOVWF  6E
....................          while(!mas){} 
449C:  BTFSC  F82.0
449E:  BRA    44A2
44A0:  BRA    449C
....................          break; 
44A2:  BRA    44C6
....................       } 
....................       if(!si) 
44A4:  BTFSC  F82.2
44A6:  BRA    44B4
....................       { 
....................          contador2 = 2; 
44A8:  MOVLW  02
44AA:  MOVWF  6E
....................          while(!si){} 
44AC:  BTFSC  F82.2
44AE:  BRA    44B2
44B0:  BRA    44AC
....................          break; 
44B2:  BRA    44C6
....................       } 
....................       if(!no) 
44B4:  BTFSC  F82.5
44B6:  BRA    44C4
....................       { 
....................          contador2 = 3; 
44B8:  MOVLW  03
44BA:  MOVWF  6E
....................          while(!no){} 
44BC:  BTFSC  F82.5
44BE:  BRA    44C2
44C0:  BRA    44BC
....................          break; 
44C2:  BRA    44C6
....................       } 
....................  
....................    } 
44C4:  BRA    4486
....................  
....................    switch(contador2) 
....................    { 
44C6:  MOVF   6E,W
44C8:  ADDLW  FC
44CA:  BTFSC  FD8.0
44CC:  GOTO   524C
44D0:  ADDLW  04
44D2:  GOTO   5250
....................       //En el caso 0, se sale del sistema 
....................       case 0: 
....................                set_tris_d(0x03); 
44D6:  MOVLW  03
44D8:  MOVWF  F95
....................                //Se indica por pantalla la salida 
....................                lcd_send_byte(LCD_ORDEN, LCD_CLEAR); 
44DA:  MOVLB  2
44DC:  CLRF   x85
44DE:  MOVLW  01
44E0:  MOVWF  x86
44E2:  MOVLB  0
44E4:  CALL   0DA8
....................                printf(lcd_putc, "  Saliendo..."); 
44E8:  MOVLB  2
44EA:  CLRF   x7F
44EC:  MOVF   x7F,W
44EE:  MOVLB  0
44F0:  CALL   06F2
44F4:  IORLW  00
44F6:  BZ    450A
44F8:  MOVLB  2
44FA:  INCF   x7F,F
44FC:  MOVWF  x80
44FE:  MOVLB  0
4500:  CALL   0E7C
4504:  MOVLB  2
4506:  BRA    44EC
4508:  MOVLB  0
....................                break; 
450A:  GOTO   524C
....................  
....................       //En el caso 1, se muestran los valores medios 
....................       case 1: 
....................                printf("\rTiempo medio de encendido del sistema por dia: %3.2f minutos\r\r", valor); 
450E:  MOVLB  2
4510:  CLRF   x7F
4512:  MOVF   x7F,W
4514:  MOVLB  0
4516:  CALL   071A
451A:  MOVLB  2
451C:  INCF   x7F,F
451E:  MOVWF  00
4520:  MOVF   00,W
4522:  BTFSS  F9E.4
4524:  BRA    4522
4526:  MOVWF  FAD
4528:  MOVLW  30
452A:  SUBWF  x7F,W
452C:  BNZ   4512
452E:  MOVLW  02
4530:  MOVWF  FE9
4532:  MOVFF  BC,291
4536:  MOVFF  BB,290
453A:  MOVFF  BA,28F
453E:  MOVFF  B9,28E
4542:  MOVWF  x92
4544:  MOVLB  0
4546:  CALL   3498
454A:  MOVLW  35
454C:  MOVLB  2
454E:  MOVWF  x80
4550:  MOVF   x80,W
4552:  MOVLB  0
4554:  CALL   071A
4558:  MOVLB  2
455A:  INCF   x80,F
455C:  MOVWF  00
455E:  MOVF   00,W
4560:  BTFSS  F9E.4
4562:  BRA    4560
4564:  MOVWF  FAD
4566:  MOVLW  3F
4568:  SUBWF  x80,W
456A:  BNZ   4550
....................                printf("Tiempo medio de encendido de la caldera por dia: %3.2f minutos\r\r", media_dia_caldera); 
456C:  CLRF   x7F
456E:  MOVF   x7F,W
4570:  MOVLB  0
4572:  CALL   0774
4576:  MOVLB  2
4578:  INCF   x7F,F
457A:  MOVWF  00
457C:  MOVF   00,W
457E:  BTFSS  F9E.4
4580:  BRA    457E
4582:  MOVWF  FAD
4584:  MOVLW  31
4586:  SUBWF  x7F,W
4588:  BNZ   456E
458A:  MOVLW  02
458C:  MOVWF  FE9
458E:  MOVFF  B8,291
4592:  MOVFF  B7,290
4596:  MOVFF  B6,28F
459A:  MOVFF  B5,28E
459E:  MOVWF  x92
45A0:  MOVLB  0
45A2:  CALL   3498
45A6:  MOVLW  36
45A8:  MOVLB  2
45AA:  MOVWF  x80
45AC:  MOVF   x80,W
45AE:  MOVLB  0
45B0:  CALL   0774
45B4:  MOVLB  2
45B6:  INCF   x80,F
45B8:  MOVWF  00
45BA:  MOVF   00,W
45BC:  BTFSS  F9E.4
45BE:  BRA    45BC
45C0:  MOVWF  FAD
45C2:  MOVLW  40
45C4:  SUBWF  x80,W
45C6:  BNZ   45AC
....................                goto repetir; 
45C8:  MOVLB  0
45CA:  BRA    43B4
....................                break; 
45CC:  GOTO   524C
....................  
....................       //En el caso 2, se muestran los valores totales 
....................       case 2: 
....................                printf("\rTiempo total de encendido del sistema: %lu minutos\r\r", valor_total); 
45D0:  MOVLB  2
45D2:  CLRF   x7F
45D4:  MOVF   x7F,W
45D6:  MOVLB  0
45D8:  CALL   07D0
45DC:  MOVLB  2
45DE:  INCF   x7F,F
45E0:  MOVWF  00
45E2:  MOVF   00,W
45E4:  BTFSS  F9E.4
45E6:  BRA    45E4
45E8:  MOVWF  FAD
45EA:  MOVLW  28
45EC:  SUBWF  x7F,W
45EE:  BNZ   45D4
45F0:  MOVLW  10
45F2:  MOVWF  FE9
45F4:  MOVFF  EE,281
45F8:  MOVFF  ED,280
45FC:  MOVLB  0
45FE:  CALL   363C
4602:  MOVLW  2B
4604:  MOVLB  2
4606:  MOVWF  x80
4608:  MOVF   x80,W
460A:  MOVLB  0
460C:  CALL   07D0
4610:  MOVLB  2
4612:  INCF   x80,F
4614:  MOVWF  00
4616:  MOVF   00,W
4618:  BTFSS  F9E.4
461A:  BRA    4618
461C:  MOVWF  FAD
461E:  MOVLW  35
4620:  SUBWF  x80,W
4622:  BNZ   4608
....................                printf("Tiempo total de encendido de la caldera: %lu minutos\r\r", valor_total_caldera); 
4624:  CLRF   x7F
4626:  MOVF   x7F,W
4628:  MOVLB  0
462A:  CALL   0820
462E:  MOVLB  2
4630:  INCF   x7F,F
4632:  MOVWF  00
4634:  MOVF   00,W
4636:  BTFSS  F9E.4
4638:  BRA    4636
463A:  MOVWF  FAD
463C:  MOVLW  29
463E:  SUBWF  x7F,W
4640:  BNZ   4626
4642:  MOVLW  10
4644:  MOVWF  FE9
4646:  MOVFF  F0,281
464A:  MOVFF  EF,280
464E:  MOVLB  0
4650:  CALL   363C
4654:  MOVLW  2C
4656:  MOVLB  2
4658:  MOVWF  x80
465A:  MOVF   x80,W
465C:  MOVLB  0
465E:  CALL   0820
4662:  MOVLB  2
4664:  INCF   x80,F
4666:  MOVWF  00
4668:  MOVF   00,W
466A:  BTFSS  F9E.4
466C:  BRA    466A
466E:  MOVWF  FAD
4670:  MOVLW  36
4672:  SUBWF  x80,W
4674:  BNZ   465A
....................                goto repetir; 
4676:  MOVLB  0
4678:  BRA    43B4
....................                break; 
467A:  GOTO   524C
....................  
....................       //En el caso 3, se muestran todos los valores medios por meses y años 
....................       case 3: 
....................                //Se representan todos los años de los que se tiene registro 
....................                for(contador=0; contador<num_annos; contador++) 
467E:  CLRF   6D
4680:  MOVLB  2
4682:  MOVF   x71,W
4684:  SUBWF  6D,W
4686:  BTFSC  FD8.0
4688:  GOTO   5244
....................                { 
....................                   //Imprimimos el año en el que nos encontramos 
....................                   printf("\r20"); 
468C:  CLRF   x7F
468E:  MOVF   x7F,W
4690:  MOVLB  0
4692:  CALL   0872
4696:  IORLW  00
4698:  BZ    46A8
469A:  MOVLB  2
469C:  INCF   x7F,F
469E:  BTFSS  F9E.4
46A0:  BRA    469E
46A2:  MOVWF  FAD
46A4:  BRA    468E
46A6:  MOVLB  0
....................                   if(annos[contador]<10) 
46A8:  CLRF   03
46AA:  MOVF   6D,W
46AC:  ADDLW  72
46AE:  MOVWF  FE9
46B0:  MOVLW  02
46B2:  ADDWFC 03,W
46B4:  MOVWF  FEA
46B6:  MOVF   FEF,W
46B8:  SUBLW  09
46BA:  BNC   46DA
....................                      printf("0"); 
46BC:  MOVLB  2
46BE:  CLRF   x7F
46C0:  MOVF   x7F,W
46C2:  MOVLB  0
46C4:  CALL   044A
46C8:  IORLW  00
46CA:  BZ    46DA
46CC:  MOVLB  2
46CE:  INCF   x7F,F
46D0:  BTFSS  F9E.4
46D2:  BRA    46D0
46D4:  MOVWF  FAD
46D6:  BRA    46C0
46D8:  MOVLB  0
....................                   printf("%u\r", annos[contador]); 
46DA:  CLRF   03
46DC:  MOVF   6D,W
46DE:  ADDLW  72
46E0:  MOVWF  FE9
46E2:  MOVLW  02
46E4:  ADDWFC 03,W
46E6:  MOVWF  FEA
46E8:  MOVFF  FEF,27F
46EC:  MOVFF  27F,280
46F0:  MOVLW  1B
46F2:  MOVLB  2
46F4:  MOVWF  x81
46F6:  MOVLB  0
46F8:  CALL   3416
46FC:  MOVLW  0D
46FE:  BTFSS  F9E.4
4700:  BRA    46FE
4702:  MOVWF  FAD
....................                   printf("--------------------------------------------------------------------------------------------------------------------\r"); 
4704:  MOVLB  2
4706:  CLRF   x7F
4708:  MOVF   x7F,W
470A:  MOVLB  0
470C:  CALL   0890
4710:  IORLW  00
4712:  BZ    4722
4714:  MOVLB  2
4716:  INCF   x7F,F
4718:  BTFSS  F9E.4
471A:  BRA    4718
471C:  MOVWF  FAD
471E:  BRA    4708
4720:  MOVLB  0
....................                   printf("              Tiempo medio de encendido del sistema (min/dia)      Tiempo medio de encendido de la caldera (min/dia)\r"); 
4722:  MOVLB  2
4724:  CLRF   x7F
4726:  MOVF   x7F,W
4728:  MOVLB  0
472A:  CALL   0920
472E:  IORLW  00
4730:  BZ    4740
4732:  MOVLB  2
4734:  INCF   x7F,F
4736:  BTFSS  F9E.4
4738:  BRA    4736
473A:  MOVWF  FAD
473C:  BRA    4726
473E:  MOVLB  0
....................                   printf("ENERO                              %f                                                     %f\r", media_annos[contador][0], media_annos_caldera[contador][0]); 
4740:  MOVF   6D,W
4742:  MULLW  30
4744:  MOVF   FF3,W
4746:  MOVLB  2
4748:  CLRF   x80
474A:  MOVWF  x7F
474C:  MOVLW  F1
474E:  ADDWF  x7F,W
4750:  MOVWF  FE9
4752:  MOVLW  00
4754:  ADDWFC x80,W
4756:  MOVWF  FEA
4758:  MOVFF  FEF,281
475C:  MOVFF  FEC,282
4760:  MOVFF  FEC,283
4764:  MOVFF  FEC,284
4768:  MOVF   6D,W
476A:  MULLW  30
476C:  MOVF   FF3,W
476E:  CLRF   x86
4770:  MOVWF  x85
4772:  MOVLW  B1
4774:  ADDWF  x85,W
4776:  MOVWF  FE9
4778:  MOVLW  01
477A:  ADDWFC x86,W
477C:  MOVWF  FEA
477E:  MOVFF  FEF,287
4782:  MOVFF  FEC,288
4786:  MOVFF  FEC,289
478A:  MOVFF  FEC,28A
478E:  CLRF   x8B
4790:  MOVF   x8B,W
4792:  MOVLB  0
4794:  CALL   09B0
4798:  MOVLB  2
479A:  INCF   x8B,F
479C:  MOVWF  00
479E:  MOVF   00,W
47A0:  BTFSS  F9E.4
47A2:  BRA    47A0
47A4:  MOVWF  FAD
47A6:  MOVLW  05
47A8:  SUBWF  x8B,W
47AA:  BNZ   4790
47AC:  MOVLW  1E
47AE:  MOVWF  x8C
47B0:  MOVLW  20
47B2:  BTFSS  F9E.4
47B4:  BRA    47B2
47B6:  MOVWF  FAD
47B8:  DECFSZ x8C,F
47BA:  BRA    47B0
47BC:  MOVLW  89
47BE:  MOVWF  FE9
47C0:  MOVFF  284,291
47C4:  MOVFF  283,290
47C8:  MOVFF  282,28F
47CC:  MOVFF  281,28E
47D0:  MOVLW  06
47D2:  MOVWF  x92
47D4:  MOVLB  0
47D6:  CALL   3498
47DA:  MOVLW  35
47DC:  MOVLB  2
47DE:  MOVWF  x8D
47E0:  MOVLW  20
47E2:  BTFSS  F9E.4
47E4:  BRA    47E2
47E6:  MOVWF  FAD
47E8:  DECFSZ x8D,F
47EA:  BRA    47E0
47EC:  MOVLW  89
47EE:  MOVWF  FE9
47F0:  MOVFF  28A,291
47F4:  MOVFF  289,290
47F8:  MOVFF  288,28F
47FC:  MOVFF  287,28E
4800:  MOVLW  06
4802:  MOVWF  x92
4804:  MOVLB  0
4806:  CALL   3498
480A:  MOVLW  0D
480C:  BTFSS  F9E.4
480E:  BRA    480C
4810:  MOVWF  FAD
....................                   printf("FEBRERO                            %f                                                     %f\r", media_annos[contador][1], media_annos_caldera[contador][1]); 
4812:  MOVF   6D,W
4814:  MULLW  30
4816:  MOVF   FF3,W
4818:  MOVLB  2
481A:  CLRF   x80
481C:  MOVWF  x7F
481E:  MOVLW  04
4820:  ADDWF  x7F,W
4822:  MOVWF  01
4824:  MOVLW  00
4826:  ADDWFC x80,W
4828:  MOVWF  03
482A:  MOVF   01,W
482C:  ADDLW  F1
482E:  MOVWF  FE9
4830:  MOVLW  00
4832:  ADDWFC 03,W
4834:  MOVWF  FEA
4836:  MOVFF  FEF,281
483A:  MOVFF  FEC,282
483E:  MOVFF  FEC,283
4842:  MOVFF  FEC,284
4846:  MOVF   6D,W
4848:  MULLW  30
484A:  MOVF   FF3,W
484C:  CLRF   x86
484E:  MOVWF  x85
4850:  MOVLW  04
4852:  ADDWF  x85,W
4854:  MOVWF  01
4856:  MOVLW  00
4858:  ADDWFC x86,W
485A:  MOVWF  03
485C:  MOVF   01,W
485E:  ADDLW  B1
4860:  MOVWF  FE9
4862:  MOVLW  01
4864:  ADDWFC 03,W
4866:  MOVWF  FEA
4868:  MOVFF  FEF,287
486C:  MOVFF  FEC,288
4870:  MOVFF  FEC,289
4874:  MOVFF  FEC,28A
4878:  CLRF   x8B
487A:  MOVF   x8B,W
487C:  MOVLB  0
487E:  CALL   09D6
4882:  MOVLB  2
4884:  INCF   x8B,F
4886:  MOVWF  00
4888:  MOVF   00,W
488A:  BTFSS  F9E.4
488C:  BRA    488A
488E:  MOVWF  FAD
4890:  MOVLW  07
4892:  SUBWF  x8B,W
4894:  BNZ   487A
4896:  MOVLW  1C
4898:  MOVWF  x8C
489A:  MOVLW  20
489C:  BTFSS  F9E.4
489E:  BRA    489C
48A0:  MOVWF  FAD
48A2:  DECFSZ x8C,F
48A4:  BRA    489A
48A6:  MOVLW  89
48A8:  MOVWF  FE9
48AA:  MOVFF  284,291
48AE:  MOVFF  283,290
48B2:  MOVFF  282,28F
48B6:  MOVFF  281,28E
48BA:  MOVLW  06
48BC:  MOVWF  x92
48BE:  MOVLB  0
48C0:  CALL   3498
48C4:  MOVLW  35
48C6:  MOVLB  2
48C8:  MOVWF  x8D
48CA:  MOVLW  20
48CC:  BTFSS  F9E.4
48CE:  BRA    48CC
48D0:  MOVWF  FAD
48D2:  DECFSZ x8D,F
48D4:  BRA    48CA
48D6:  MOVLW  89
48D8:  MOVWF  FE9
48DA:  MOVFF  28A,291
48DE:  MOVFF  289,290
48E2:  MOVFF  288,28F
48E6:  MOVFF  287,28E
48EA:  MOVLW  06
48EC:  MOVWF  x92
48EE:  MOVLB  0
48F0:  CALL   3498
48F4:  MOVLW  0D
48F6:  BTFSS  F9E.4
48F8:  BRA    48F6
48FA:  MOVWF  FAD
....................                   printf("MARZO                              %f                                                     %f\r", media_annos[contador][2], media_annos_caldera[contador][2]); 
48FC:  MOVF   6D,W
48FE:  MULLW  30
4900:  MOVF   FF3,W
4902:  MOVLB  2
4904:  CLRF   x80
4906:  MOVWF  x7F
4908:  MOVLW  08
490A:  ADDWF  x7F,W
490C:  MOVWF  01
490E:  MOVLW  00
4910:  ADDWFC x80,W
4912:  MOVWF  03
4914:  MOVF   01,W
4916:  ADDLW  F1
4918:  MOVWF  FE9
491A:  MOVLW  00
491C:  ADDWFC 03,W
491E:  MOVWF  FEA
4920:  MOVFF  FEF,281
4924:  MOVFF  FEC,282
4928:  MOVFF  FEC,283
492C:  MOVFF  FEC,284
4930:  MOVF   6D,W
4932:  MULLW  30
4934:  MOVF   FF3,W
4936:  CLRF   x86
4938:  MOVWF  x85
493A:  MOVLW  08
493C:  ADDWF  x85,W
493E:  MOVWF  01
4940:  MOVLW  00
4942:  ADDWFC x86,W
4944:  MOVWF  03
4946:  MOVF   01,W
4948:  ADDLW  B1
494A:  MOVWF  FE9
494C:  MOVLW  01
494E:  ADDWFC 03,W
4950:  MOVWF  FEA
4952:  MOVFF  FEF,287
4956:  MOVFF  FEC,288
495A:  MOVFF  FEC,289
495E:  MOVFF  FEC,28A
4962:  CLRF   x8B
4964:  MOVF   x8B,W
4966:  MOVLB  0
4968:  CALL   09FE
496C:  MOVLB  2
496E:  INCF   x8B,F
4970:  MOVWF  00
4972:  MOVF   00,W
4974:  BTFSS  F9E.4
4976:  BRA    4974
4978:  MOVWF  FAD
497A:  MOVLW  05
497C:  SUBWF  x8B,W
497E:  BNZ   4964
4980:  MOVLW  1E
4982:  MOVWF  x8C
4984:  MOVLW  20
4986:  BTFSS  F9E.4
4988:  BRA    4986
498A:  MOVWF  FAD
498C:  DECFSZ x8C,F
498E:  BRA    4984
4990:  MOVLW  89
4992:  MOVWF  FE9
4994:  MOVFF  284,291
4998:  MOVFF  283,290
499C:  MOVFF  282,28F
49A0:  MOVFF  281,28E
49A4:  MOVLW  06
49A6:  MOVWF  x92
49A8:  MOVLB  0
49AA:  CALL   3498
49AE:  MOVLW  35
49B0:  MOVLB  2
49B2:  MOVWF  x8D
49B4:  MOVLW  20
49B6:  BTFSS  F9E.4
49B8:  BRA    49B6
49BA:  MOVWF  FAD
49BC:  DECFSZ x8D,F
49BE:  BRA    49B4
49C0:  MOVLW  89
49C2:  MOVWF  FE9
49C4:  MOVFF  28A,291
49C8:  MOVFF  289,290
49CC:  MOVFF  288,28F
49D0:  MOVFF  287,28E
49D4:  MOVLW  06
49D6:  MOVWF  x92
49D8:  MOVLB  0
49DA:  CALL   3498
49DE:  MOVLW  0D
49E0:  BTFSS  F9E.4
49E2:  BRA    49E0
49E4:  MOVWF  FAD
....................                   printf("ABRIL                              %f                                                     %f\r", media_annos[contador][3], media_annos_caldera[contador][3]); 
49E6:  MOVF   6D,W
49E8:  MULLW  30
49EA:  MOVF   FF3,W
49EC:  MOVLB  2
49EE:  CLRF   x80
49F0:  MOVWF  x7F
49F2:  MOVLW  0C
49F4:  ADDWF  x7F,W
49F6:  MOVWF  01
49F8:  MOVLW  00
49FA:  ADDWFC x80,W
49FC:  MOVWF  03
49FE:  MOVF   01,W
4A00:  ADDLW  F1
4A02:  MOVWF  FE9
4A04:  MOVLW  00
4A06:  ADDWFC 03,W
4A08:  MOVWF  FEA
4A0A:  MOVFF  FEF,281
4A0E:  MOVFF  FEC,282
4A12:  MOVFF  FEC,283
4A16:  MOVFF  FEC,284
4A1A:  MOVF   6D,W
4A1C:  MULLW  30
4A1E:  MOVF   FF3,W
4A20:  CLRF   x86
4A22:  MOVWF  x85
4A24:  MOVLW  0C
4A26:  ADDWF  x85,W
4A28:  MOVWF  01
4A2A:  MOVLW  00
4A2C:  ADDWFC x86,W
4A2E:  MOVWF  03
4A30:  MOVF   01,W
4A32:  ADDLW  B1
4A34:  MOVWF  FE9
4A36:  MOVLW  01
4A38:  ADDWFC 03,W
4A3A:  MOVWF  FEA
4A3C:  MOVFF  FEF,287
4A40:  MOVFF  FEC,288
4A44:  MOVFF  FEC,289
4A48:  MOVFF  FEC,28A
4A4C:  CLRF   x8B
4A4E:  MOVF   x8B,W
4A50:  MOVLB  0
4A52:  CALL   0A24
4A56:  MOVLB  2
4A58:  INCF   x8B,F
4A5A:  MOVWF  00
4A5C:  MOVF   00,W
4A5E:  BTFSS  F9E.4
4A60:  BRA    4A5E
4A62:  MOVWF  FAD
4A64:  MOVLW  05
4A66:  SUBWF  x8B,W
4A68:  BNZ   4A4E
4A6A:  MOVLW  1E
4A6C:  MOVWF  x8C
4A6E:  MOVLW  20
4A70:  BTFSS  F9E.4
4A72:  BRA    4A70
4A74:  MOVWF  FAD
4A76:  DECFSZ x8C,F
4A78:  BRA    4A6E
4A7A:  MOVLW  89
4A7C:  MOVWF  FE9
4A7E:  MOVFF  284,291
4A82:  MOVFF  283,290
4A86:  MOVFF  282,28F
4A8A:  MOVFF  281,28E
4A8E:  MOVLW  06
4A90:  MOVWF  x92
4A92:  MOVLB  0
4A94:  CALL   3498
4A98:  MOVLW  35
4A9A:  MOVLB  2
4A9C:  MOVWF  x8D
4A9E:  MOVLW  20
4AA0:  BTFSS  F9E.4
4AA2:  BRA    4AA0
4AA4:  MOVWF  FAD
4AA6:  DECFSZ x8D,F
4AA8:  BRA    4A9E
4AAA:  MOVLW  89
4AAC:  MOVWF  FE9
4AAE:  MOVFF  28A,291
4AB2:  MOVFF  289,290
4AB6:  MOVFF  288,28F
4ABA:  MOVFF  287,28E
4ABE:  MOVLW  06
4AC0:  MOVWF  x92
4AC2:  MOVLB  0
4AC4:  CALL   3498
4AC8:  MOVLW  0D
4ACA:  BTFSS  F9E.4
4ACC:  BRA    4ACA
4ACE:  MOVWF  FAD
....................                   printf("MAYO                               %f                                                     %f\r", media_annos[contador][4], media_annos_caldera[contador][4]); 
4AD0:  MOVF   6D,W
4AD2:  MULLW  30
4AD4:  MOVF   FF3,W
4AD6:  MOVLB  2
4AD8:  CLRF   x80
4ADA:  MOVWF  x7F
4ADC:  MOVLW  10
4ADE:  ADDWF  x7F,W
4AE0:  MOVWF  01
4AE2:  MOVLW  00
4AE4:  ADDWFC x80,W
4AE6:  MOVWF  03
4AE8:  MOVF   01,W
4AEA:  ADDLW  F1
4AEC:  MOVWF  FE9
4AEE:  MOVLW  00
4AF0:  ADDWFC 03,W
4AF2:  MOVWF  FEA
4AF4:  MOVFF  FEF,281
4AF8:  MOVFF  FEC,282
4AFC:  MOVFF  FEC,283
4B00:  MOVFF  FEC,284
4B04:  MOVF   6D,W
4B06:  MULLW  30
4B08:  MOVF   FF3,W
4B0A:  CLRF   x86
4B0C:  MOVWF  x85
4B0E:  MOVLW  10
4B10:  ADDWF  x85,W
4B12:  MOVWF  01
4B14:  MOVLW  00
4B16:  ADDWFC x86,W
4B18:  MOVWF  03
4B1A:  MOVF   01,W
4B1C:  ADDLW  B1
4B1E:  MOVWF  FE9
4B20:  MOVLW  01
4B22:  ADDWFC 03,W
4B24:  MOVWF  FEA
4B26:  MOVFF  FEF,287
4B2A:  MOVFF  FEC,288
4B2E:  MOVFF  FEC,289
4B32:  MOVFF  FEC,28A
4B36:  CLRF   x8B
4B38:  MOVF   x8B,W
4B3A:  MOVLB  0
4B3C:  CALL   0A4A
4B40:  MOVLB  2
4B42:  INCF   x8B,F
4B44:  MOVWF  00
4B46:  MOVF   00,W
4B48:  BTFSS  F9E.4
4B4A:  BRA    4B48
4B4C:  MOVWF  FAD
4B4E:  MOVLW  04
4B50:  SUBWF  x8B,W
4B52:  BNZ   4B38
4B54:  MOVLW  1F
4B56:  MOVWF  x8C
4B58:  MOVLW  20
4B5A:  BTFSS  F9E.4
4B5C:  BRA    4B5A
4B5E:  MOVWF  FAD
4B60:  DECFSZ x8C,F
4B62:  BRA    4B58
4B64:  MOVLW  89
4B66:  MOVWF  FE9
4B68:  MOVFF  284,291
4B6C:  MOVFF  283,290
4B70:  MOVFF  282,28F
4B74:  MOVFF  281,28E
4B78:  MOVLW  06
4B7A:  MOVWF  x92
4B7C:  MOVLB  0
4B7E:  CALL   3498
4B82:  MOVLW  35
4B84:  MOVLB  2
4B86:  MOVWF  x8D
4B88:  MOVLW  20
4B8A:  BTFSS  F9E.4
4B8C:  BRA    4B8A
4B8E:  MOVWF  FAD
4B90:  DECFSZ x8D,F
4B92:  BRA    4B88
4B94:  MOVLW  89
4B96:  MOVWF  FE9
4B98:  MOVFF  28A,291
4B9C:  MOVFF  289,290
4BA0:  MOVFF  288,28F
4BA4:  MOVFF  287,28E
4BA8:  MOVLW  06
4BAA:  MOVWF  x92
4BAC:  MOVLB  0
4BAE:  CALL   3498
4BB2:  MOVLW  0D
4BB4:  BTFSS  F9E.4
4BB6:  BRA    4BB4
4BB8:  MOVWF  FAD
....................                   printf("JUNIO                              %f                                                     %f\r", media_annos[contador][5], media_annos_caldera[contador][5]); 
4BBA:  MOVF   6D,W
4BBC:  MULLW  30
4BBE:  MOVF   FF3,W
4BC0:  MOVLB  2
4BC2:  CLRF   x80
4BC4:  MOVWF  x7F
4BC6:  MOVLW  14
4BC8:  ADDWF  x7F,W
4BCA:  MOVWF  01
4BCC:  MOVLW  00
4BCE:  ADDWFC x80,W
4BD0:  MOVWF  03
4BD2:  MOVF   01,W
4BD4:  ADDLW  F1
4BD6:  MOVWF  FE9
4BD8:  MOVLW  00
4BDA:  ADDWFC 03,W
4BDC:  MOVWF  FEA
4BDE:  MOVFF  FEF,281
4BE2:  MOVFF  FEC,282
4BE6:  MOVFF  FEC,283
4BEA:  MOVFF  FEC,284
4BEE:  MOVF   6D,W
4BF0:  MULLW  30
4BF2:  MOVF   FF3,W
4BF4:  CLRF   x86
4BF6:  MOVWF  x85
4BF8:  MOVLW  14
4BFA:  ADDWF  x85,W
4BFC:  MOVWF  01
4BFE:  MOVLW  00
4C00:  ADDWFC x86,W
4C02:  MOVWF  03
4C04:  MOVF   01,W
4C06:  ADDLW  B1
4C08:  MOVWF  FE9
4C0A:  MOVLW  01
4C0C:  ADDWFC 03,W
4C0E:  MOVWF  FEA
4C10:  MOVFF  FEF,287
4C14:  MOVFF  FEC,288
4C18:  MOVFF  FEC,289
4C1C:  MOVFF  FEC,28A
4C20:  CLRF   x8B
4C22:  MOVF   x8B,W
4C24:  MOVLB  0
4C26:  CALL   0A6E
4C2A:  MOVLB  2
4C2C:  INCF   x8B,F
4C2E:  MOVWF  00
4C30:  MOVF   00,W
4C32:  BTFSS  F9E.4
4C34:  BRA    4C32
4C36:  MOVWF  FAD
4C38:  MOVLW  05
4C3A:  SUBWF  x8B,W
4C3C:  BNZ   4C22
4C3E:  MOVLW  1E
4C40:  MOVWF  x8C
4C42:  MOVLW  20
4C44:  BTFSS  F9E.4
4C46:  BRA    4C44
4C48:  MOVWF  FAD
4C4A:  DECFSZ x8C,F
4C4C:  BRA    4C42
4C4E:  MOVLW  89
4C50:  MOVWF  FE9
4C52:  MOVFF  284,291
4C56:  MOVFF  283,290
4C5A:  MOVFF  282,28F
4C5E:  MOVFF  281,28E
4C62:  MOVLW  06
4C64:  MOVWF  x92
4C66:  MOVLB  0
4C68:  CALL   3498
4C6C:  MOVLW  35
4C6E:  MOVLB  2
4C70:  MOVWF  x8D
4C72:  MOVLW  20
4C74:  BTFSS  F9E.4
4C76:  BRA    4C74
4C78:  MOVWF  FAD
4C7A:  DECFSZ x8D,F
4C7C:  BRA    4C72
4C7E:  MOVLW  89
4C80:  MOVWF  FE9
4C82:  MOVFF  28A,291
4C86:  MOVFF  289,290
4C8A:  MOVFF  288,28F
4C8E:  MOVFF  287,28E
4C92:  MOVLW  06
4C94:  MOVWF  x92
4C96:  MOVLB  0
4C98:  CALL   3498
4C9C:  MOVLW  0D
4C9E:  BTFSS  F9E.4
4CA0:  BRA    4C9E
4CA2:  MOVWF  FAD
....................                   printf("JULIO                              %f                                                     %f\r", media_annos[contador][6], media_annos_caldera[contador][6]); 
4CA4:  MOVF   6D,W
4CA6:  MULLW  30
4CA8:  MOVF   FF3,W
4CAA:  MOVLB  2
4CAC:  CLRF   x80
4CAE:  MOVWF  x7F
4CB0:  MOVLW  18
4CB2:  ADDWF  x7F,W
4CB4:  MOVWF  01
4CB6:  MOVLW  00
4CB8:  ADDWFC x80,W
4CBA:  MOVWF  03
4CBC:  MOVF   01,W
4CBE:  ADDLW  F1
4CC0:  MOVWF  FE9
4CC2:  MOVLW  00
4CC4:  ADDWFC 03,W
4CC6:  MOVWF  FEA
4CC8:  MOVFF  FEF,281
4CCC:  MOVFF  FEC,282
4CD0:  MOVFF  FEC,283
4CD4:  MOVFF  FEC,284
4CD8:  MOVF   6D,W
4CDA:  MULLW  30
4CDC:  MOVF   FF3,W
4CDE:  CLRF   x86
4CE0:  MOVWF  x85
4CE2:  MOVLW  18
4CE4:  ADDWF  x85,W
4CE6:  MOVWF  01
4CE8:  MOVLW  00
4CEA:  ADDWFC x86,W
4CEC:  MOVWF  03
4CEE:  MOVF   01,W
4CF0:  ADDLW  B1
4CF2:  MOVWF  FE9
4CF4:  MOVLW  01
4CF6:  ADDWFC 03,W
4CF8:  MOVWF  FEA
4CFA:  MOVFF  FEF,287
4CFE:  MOVFF  FEC,288
4D02:  MOVFF  FEC,289
4D06:  MOVFF  FEC,28A
4D0A:  CLRF   x8B
4D0C:  MOVF   x8B,W
4D0E:  MOVLB  0
4D10:  CALL   0A94
4D14:  MOVLB  2
4D16:  INCF   x8B,F
4D18:  MOVWF  00
4D1A:  MOVF   00,W
4D1C:  BTFSS  F9E.4
4D1E:  BRA    4D1C
4D20:  MOVWF  FAD
4D22:  MOVLW  05
4D24:  SUBWF  x8B,W
4D26:  BNZ   4D0C
4D28:  MOVLW  1E
4D2A:  MOVWF  x8C
4D2C:  MOVLW  20
4D2E:  BTFSS  F9E.4
4D30:  BRA    4D2E
4D32:  MOVWF  FAD
4D34:  DECFSZ x8C,F
4D36:  BRA    4D2C
4D38:  MOVLW  89
4D3A:  MOVWF  FE9
4D3C:  MOVFF  284,291
4D40:  MOVFF  283,290
4D44:  MOVFF  282,28F
4D48:  MOVFF  281,28E
4D4C:  MOVLW  06
4D4E:  MOVWF  x92
4D50:  MOVLB  0
4D52:  CALL   3498
4D56:  MOVLW  35
4D58:  MOVLB  2
4D5A:  MOVWF  x8D
4D5C:  MOVLW  20
4D5E:  BTFSS  F9E.4
4D60:  BRA    4D5E
4D62:  MOVWF  FAD
4D64:  DECFSZ x8D,F
4D66:  BRA    4D5C
4D68:  MOVLW  89
4D6A:  MOVWF  FE9
4D6C:  MOVFF  28A,291
4D70:  MOVFF  289,290
4D74:  MOVFF  288,28F
4D78:  MOVFF  287,28E
4D7C:  MOVLW  06
4D7E:  MOVWF  x92
4D80:  MOVLB  0
4D82:  CALL   3498
4D86:  MOVLW  0D
4D88:  BTFSS  F9E.4
4D8A:  BRA    4D88
4D8C:  MOVWF  FAD
....................                   printf("AGOSTO                             %f                                                     %f\r", media_annos[contador][7], media_annos_caldera[contador][7]); 
4D8E:  MOVF   6D,W
4D90:  MULLW  30
4D92:  MOVF   FF3,W
4D94:  MOVLB  2
4D96:  CLRF   x80
4D98:  MOVWF  x7F
4D9A:  MOVLW  1C
4D9C:  ADDWF  x7F,W
4D9E:  MOVWF  01
4DA0:  MOVLW  00
4DA2:  ADDWFC x80,W
4DA4:  MOVWF  03
4DA6:  MOVF   01,W
4DA8:  ADDLW  F1
4DAA:  MOVWF  FE9
4DAC:  MOVLW  00
4DAE:  ADDWFC 03,W
4DB0:  MOVWF  FEA
4DB2:  MOVFF  FEF,281
4DB6:  MOVFF  FEC,282
4DBA:  MOVFF  FEC,283
4DBE:  MOVFF  FEC,284
4DC2:  MOVF   6D,W
4DC4:  MULLW  30
4DC6:  MOVF   FF3,W
4DC8:  CLRF   x86
4DCA:  MOVWF  x85
4DCC:  MOVLW  1C
4DCE:  ADDWF  x85,W
4DD0:  MOVWF  01
4DD2:  MOVLW  00
4DD4:  ADDWFC x86,W
4DD6:  MOVWF  03
4DD8:  MOVF   01,W
4DDA:  ADDLW  B1
4DDC:  MOVWF  FE9
4DDE:  MOVLW  01
4DE0:  ADDWFC 03,W
4DE2:  MOVWF  FEA
4DE4:  MOVFF  FEF,287
4DE8:  MOVFF  FEC,288
4DEC:  MOVFF  FEC,289
4DF0:  MOVFF  FEC,28A
4DF4:  CLRF   x8B
4DF6:  MOVF   x8B,W
4DF8:  MOVLB  0
4DFA:  CALL   0ABA
4DFE:  MOVLB  2
4E00:  INCF   x8B,F
4E02:  MOVWF  00
4E04:  MOVF   00,W
4E06:  BTFSS  F9E.4
4E08:  BRA    4E06
4E0A:  MOVWF  FAD
4E0C:  MOVLW  06
4E0E:  SUBWF  x8B,W
4E10:  BNZ   4DF6
4E12:  MOVLW  1D
4E14:  MOVWF  x8C
4E16:  MOVLW  20
4E18:  BTFSS  F9E.4
4E1A:  BRA    4E18
4E1C:  MOVWF  FAD
4E1E:  DECFSZ x8C,F
4E20:  BRA    4E16
4E22:  MOVLW  89
4E24:  MOVWF  FE9
4E26:  MOVFF  284,291
4E2A:  MOVFF  283,290
4E2E:  MOVFF  282,28F
4E32:  MOVFF  281,28E
4E36:  MOVLW  06
4E38:  MOVWF  x92
4E3A:  MOVLB  0
4E3C:  CALL   3498
4E40:  MOVLW  35
4E42:  MOVLB  2
4E44:  MOVWF  x8D
4E46:  MOVLW  20
4E48:  BTFSS  F9E.4
4E4A:  BRA    4E48
4E4C:  MOVWF  FAD
4E4E:  DECFSZ x8D,F
4E50:  BRA    4E46
4E52:  MOVLW  89
4E54:  MOVWF  FE9
4E56:  MOVFF  28A,291
4E5A:  MOVFF  289,290
4E5E:  MOVFF  288,28F
4E62:  MOVFF  287,28E
4E66:  MOVLW  06
4E68:  MOVWF  x92
4E6A:  MOVLB  0
4E6C:  CALL   3498
4E70:  MOVLW  0D
4E72:  BTFSS  F9E.4
4E74:  BRA    4E72
4E76:  MOVWF  FAD
....................                   printf("SEPTIEMBRE                         %f                                                     %f\r", media_annos[contador][8], media_annos_caldera[contador][8]); 
4E78:  MOVF   6D,W
4E7A:  MULLW  30
4E7C:  MOVF   FF3,W
4E7E:  MOVLB  2
4E80:  CLRF   x80
4E82:  MOVWF  x7F
4E84:  MOVLW  20
4E86:  ADDWF  x7F,W
4E88:  MOVWF  01
4E8A:  MOVLW  00
4E8C:  ADDWFC x80,W
4E8E:  MOVWF  03
4E90:  MOVF   01,W
4E92:  ADDLW  F1
4E94:  MOVWF  FE9
4E96:  MOVLW  00
4E98:  ADDWFC 03,W
4E9A:  MOVWF  FEA
4E9C:  MOVFF  FEF,281
4EA0:  MOVFF  FEC,282
4EA4:  MOVFF  FEC,283
4EA8:  MOVFF  FEC,284
4EAC:  MOVF   6D,W
4EAE:  MULLW  30
4EB0:  MOVF   FF3,W
4EB2:  CLRF   x86
4EB4:  MOVWF  x85
4EB6:  MOVLW  20
4EB8:  ADDWF  x85,W
4EBA:  MOVWF  01
4EBC:  MOVLW  00
4EBE:  ADDWFC x86,W
4EC0:  MOVWF  03
4EC2:  MOVF   01,W
4EC4:  ADDLW  B1
4EC6:  MOVWF  FE9
4EC8:  MOVLW  01
4ECA:  ADDWFC 03,W
4ECC:  MOVWF  FEA
4ECE:  MOVFF  FEF,287
4ED2:  MOVFF  FEC,288
4ED6:  MOVFF  FEC,289
4EDA:  MOVFF  FEC,28A
4EDE:  CLRF   x8B
4EE0:  MOVF   x8B,W
4EE2:  MOVLB  0
4EE4:  CALL   0AE0
4EE8:  MOVLB  2
4EEA:  INCF   x8B,F
4EEC:  MOVWF  00
4EEE:  MOVF   00,W
4EF0:  BTFSS  F9E.4
4EF2:  BRA    4EF0
4EF4:  MOVWF  FAD
4EF6:  MOVLW  0A
4EF8:  SUBWF  x8B,W
4EFA:  BNZ   4EE0
4EFC:  MOVLW  19
4EFE:  MOVWF  x8C
4F00:  MOVLW  20
4F02:  BTFSS  F9E.4
4F04:  BRA    4F02
4F06:  MOVWF  FAD
4F08:  DECFSZ x8C,F
4F0A:  BRA    4F00
4F0C:  MOVLW  89
4F0E:  MOVWF  FE9
4F10:  MOVFF  284,291
4F14:  MOVFF  283,290
4F18:  MOVFF  282,28F
4F1C:  MOVFF  281,28E
4F20:  MOVLW  06
4F22:  MOVWF  x92
4F24:  MOVLB  0
4F26:  CALL   3498
4F2A:  MOVLW  35
4F2C:  MOVLB  2
4F2E:  MOVWF  x8D
4F30:  MOVLW  20
4F32:  BTFSS  F9E.4
4F34:  BRA    4F32
4F36:  MOVWF  FAD
4F38:  DECFSZ x8D,F
4F3A:  BRA    4F30
4F3C:  MOVLW  89
4F3E:  MOVWF  FE9
4F40:  MOVFF  28A,291
4F44:  MOVFF  289,290
4F48:  MOVFF  288,28F
4F4C:  MOVFF  287,28E
4F50:  MOVLW  06
4F52:  MOVWF  x92
4F54:  MOVLB  0
4F56:  CALL   3498
4F5A:  MOVLW  0D
4F5C:  BTFSS  F9E.4
4F5E:  BRA    4F5C
4F60:  MOVWF  FAD
....................                   printf("OCTUBRE                            %f                                                     %f\r", media_annos[contador][9], media_annos_caldera[contador][9]); 
4F62:  MOVF   6D,W
4F64:  MULLW  30
4F66:  MOVF   FF3,W
4F68:  MOVLB  2
4F6A:  CLRF   x80
4F6C:  MOVWF  x7F
4F6E:  MOVLW  24
4F70:  ADDWF  x7F,W
4F72:  MOVWF  01
4F74:  MOVLW  00
4F76:  ADDWFC x80,W
4F78:  MOVWF  03
4F7A:  MOVF   01,W
4F7C:  ADDLW  F1
4F7E:  MOVWF  FE9
4F80:  MOVLW  00
4F82:  ADDWFC 03,W
4F84:  MOVWF  FEA
4F86:  MOVFF  FEF,281
4F8A:  MOVFF  FEC,282
4F8E:  MOVFF  FEC,283
4F92:  MOVFF  FEC,284
4F96:  MOVF   6D,W
4F98:  MULLW  30
4F9A:  MOVF   FF3,W
4F9C:  CLRF   x86
4F9E:  MOVWF  x85
4FA0:  MOVLW  24
4FA2:  ADDWF  x85,W
4FA4:  MOVWF  01
4FA6:  MOVLW  00
4FA8:  ADDWFC x86,W
4FAA:  MOVWF  03
4FAC:  MOVF   01,W
4FAE:  ADDLW  B1
4FB0:  MOVWF  FE9
4FB2:  MOVLW  01
4FB4:  ADDWFC 03,W
4FB6:  MOVWF  FEA
4FB8:  MOVFF  FEF,287
4FBC:  MOVFF  FEC,288
4FC0:  MOVFF  FEC,289
4FC4:  MOVFF  FEC,28A
4FC8:  CLRF   x8B
4FCA:  MOVF   x8B,W
4FCC:  MOVLB  0
4FCE:  CALL   0B0A
4FD2:  MOVLB  2
4FD4:  INCF   x8B,F
4FD6:  MOVWF  00
4FD8:  MOVF   00,W
4FDA:  BTFSS  F9E.4
4FDC:  BRA    4FDA
4FDE:  MOVWF  FAD
4FE0:  MOVLW  07
4FE2:  SUBWF  x8B,W
4FE4:  BNZ   4FCA
4FE6:  MOVLW  1C
4FE8:  MOVWF  x8C
4FEA:  MOVLW  20
4FEC:  BTFSS  F9E.4
4FEE:  BRA    4FEC
4FF0:  MOVWF  FAD
4FF2:  DECFSZ x8C,F
4FF4:  BRA    4FEA
4FF6:  MOVLW  89
4FF8:  MOVWF  FE9
4FFA:  MOVFF  284,291
4FFE:  MOVFF  283,290
5002:  MOVFF  282,28F
5006:  MOVFF  281,28E
500A:  MOVLW  06
500C:  MOVWF  x92
500E:  MOVLB  0
5010:  CALL   3498
5014:  MOVLW  35
5016:  MOVLB  2
5018:  MOVWF  x8D
501A:  MOVLW  20
501C:  BTFSS  F9E.4
501E:  BRA    501C
5020:  MOVWF  FAD
5022:  DECFSZ x8D,F
5024:  BRA    501A
5026:  MOVLW  89
5028:  MOVWF  FE9
502A:  MOVFF  28A,291
502E:  MOVFF  289,290
5032:  MOVFF  288,28F
5036:  MOVFF  287,28E
503A:  MOVLW  06
503C:  MOVWF  x92
503E:  MOVLB  0
5040:  CALL   3498
5044:  MOVLW  0D
5046:  BTFSS  F9E.4
5048:  BRA    5046
504A:  MOVWF  FAD
....................                   printf("NOVIEMBRE                          %f                                                     %f\r", media_annos[contador][10], media_annos_caldera[contador][10]); 
504C:  MOVF   6D,W
504E:  MULLW  30
5050:  MOVF   FF3,W
5052:  MOVLB  2
5054:  CLRF   x80
5056:  MOVWF  x7F
5058:  MOVLW  28
505A:  ADDWF  x7F,W
505C:  MOVWF  01
505E:  MOVLW  00
5060:  ADDWFC x80,W
5062:  MOVWF  03
5064:  MOVF   01,W
5066:  ADDLW  F1
5068:  MOVWF  FE9
506A:  MOVLW  00
506C:  ADDWFC 03,W
506E:  MOVWF  FEA
5070:  MOVFF  FEF,281
5074:  MOVFF  FEC,282
5078:  MOVFF  FEC,283
507C:  MOVFF  FEC,284
5080:  MOVF   6D,W
5082:  MULLW  30
5084:  MOVF   FF3,W
5086:  CLRF   x86
5088:  MOVWF  x85
508A:  MOVLW  28
508C:  ADDWF  x85,W
508E:  MOVWF  01
5090:  MOVLW  00
5092:  ADDWFC x86,W
5094:  MOVWF  03
5096:  MOVF   01,W
5098:  ADDLW  B1
509A:  MOVWF  FE9
509C:  MOVLW  01
509E:  ADDWFC 03,W
50A0:  MOVWF  FEA
50A2:  MOVFF  FEF,287
50A6:  MOVFF  FEC,288
50AA:  MOVFF  FEC,289
50AE:  MOVFF  FEC,28A
50B2:  CLRF   x8B
50B4:  MOVF   x8B,W
50B6:  MOVLB  0
50B8:  CALL   0B32
50BC:  MOVLB  2
50BE:  INCF   x8B,F
50C0:  MOVWF  00
50C2:  MOVF   00,W
50C4:  BTFSS  F9E.4
50C6:  BRA    50C4
50C8:  MOVWF  FAD
50CA:  MOVLW  09
50CC:  SUBWF  x8B,W
50CE:  BNZ   50B4
50D0:  MOVLW  1A
50D2:  MOVWF  x8C
50D4:  MOVLW  20
50D6:  BTFSS  F9E.4
50D8:  BRA    50D6
50DA:  MOVWF  FAD
50DC:  DECFSZ x8C,F
50DE:  BRA    50D4
50E0:  MOVLW  89
50E2:  MOVWF  FE9
50E4:  MOVFF  284,291
50E8:  MOVFF  283,290
50EC:  MOVFF  282,28F
50F0:  MOVFF  281,28E
50F4:  MOVLW  06
50F6:  MOVWF  x92
50F8:  MOVLB  0
50FA:  CALL   3498
50FE:  MOVLW  35
5100:  MOVLB  2
5102:  MOVWF  x8D
5104:  MOVLW  20
5106:  BTFSS  F9E.4
5108:  BRA    5106
510A:  MOVWF  FAD
510C:  DECFSZ x8D,F
510E:  BRA    5104
5110:  MOVLW  89
5112:  MOVWF  FE9
5114:  MOVFF  28A,291
5118:  MOVFF  289,290
511C:  MOVFF  288,28F
5120:  MOVFF  287,28E
5124:  MOVLW  06
5126:  MOVWF  x92
5128:  MOVLB  0
512A:  CALL   3498
512E:  MOVLW  0D
5130:  BTFSS  F9E.4
5132:  BRA    5130
5134:  MOVWF  FAD
....................                   printf("DICIEMBRE                          %f                                                     %f\r", media_annos[contador][11], media_annos_caldera[contador][11]); 
5136:  MOVF   6D,W
5138:  MULLW  30
513A:  MOVF   FF3,W
513C:  MOVLB  2
513E:  CLRF   x80
5140:  MOVWF  x7F
5142:  MOVLW  2C
5144:  ADDWF  x7F,W
5146:  MOVWF  01
5148:  MOVLW  00
514A:  ADDWFC x80,W
514C:  MOVWF  03
514E:  MOVF   01,W
5150:  ADDLW  F1
5152:  MOVWF  FE9
5154:  MOVLW  00
5156:  ADDWFC 03,W
5158:  MOVWF  FEA
515A:  MOVFF  FEF,281
515E:  MOVFF  FEC,282
5162:  MOVFF  FEC,283
5166:  MOVFF  FEC,284
516A:  MOVF   6D,W
516C:  MULLW  30
516E:  MOVF   FF3,W
5170:  CLRF   x86
5172:  MOVWF  x85
5174:  MOVLW  2C
5176:  ADDWF  x85,W
5178:  MOVWF  01
517A:  MOVLW  00
517C:  ADDWFC x86,W
517E:  MOVWF  03
5180:  MOVF   01,W
5182:  ADDLW  B1
5184:  MOVWF  FE9
5186:  MOVLW  01
5188:  ADDWFC 03,W
518A:  MOVWF  FEA
518C:  MOVFF  FEF,287
5190:  MOVFF  FEC,288
5194:  MOVFF  FEC,289
5198:  MOVFF  FEC,28A
519C:  CLRF   x8B
519E:  MOVF   x8B,W
51A0:  MOVLB  0
51A2:  CALL   0B5C
51A6:  MOVLB  2
51A8:  INCF   x8B,F
51AA:  MOVWF  00
51AC:  MOVF   00,W
51AE:  BTFSS  F9E.4
51B0:  BRA    51AE
51B2:  MOVWF  FAD
51B4:  MOVLW  09
51B6:  SUBWF  x8B,W
51B8:  BNZ   519E
51BA:  MOVLW  1A
51BC:  MOVWF  x8C
51BE:  MOVLW  20
51C0:  BTFSS  F9E.4
51C2:  BRA    51C0
51C4:  MOVWF  FAD
51C6:  DECFSZ x8C,F
51C8:  BRA    51BE
51CA:  MOVLW  89
51CC:  MOVWF  FE9
51CE:  MOVFF  284,291
51D2:  MOVFF  283,290
51D6:  MOVFF  282,28F
51DA:  MOVFF  281,28E
51DE:  MOVLW  06
51E0:  MOVWF  x92
51E2:  MOVLB  0
51E4:  CALL   3498
51E8:  MOVLW  35
51EA:  MOVLB  2
51EC:  MOVWF  x8D
51EE:  MOVLW  20
51F0:  BTFSS  F9E.4
51F2:  BRA    51F0
51F4:  MOVWF  FAD
51F6:  DECFSZ x8D,F
51F8:  BRA    51EE
51FA:  MOVLW  89
51FC:  MOVWF  FE9
51FE:  MOVFF  28A,291
5202:  MOVFF  289,290
5206:  MOVFF  288,28F
520A:  MOVFF  287,28E
520E:  MOVLW  06
5210:  MOVWF  x92
5212:  MOVLB  0
5214:  CALL   3498
5218:  MOVLW  0D
521A:  BTFSS  F9E.4
521C:  BRA    521A
521E:  MOVWF  FAD
....................                   printf("--------------------------------------------------------------------------------------------------------------------\r"); 
5220:  MOVLB  2
5222:  CLRF   x7F
5224:  MOVF   x7F,W
5226:  MOVLB  0
5228:  CALL   0890
522C:  IORLW  00
522E:  BZ    523E
5230:  MOVLB  2
5232:  INCF   x7F,F
5234:  BTFSS  F9E.4
5236:  BRA    5234
5238:  MOVWF  FAD
523A:  BRA    5224
523C:  MOVLB  0
....................                } 
523E:  INCF   6D,F
5240:  GOTO   4680
....................  
....................                goto repetir; 
5244:  MOVLB  0
5246:  GOTO   43B4
....................                break; 
524A:  BRA    524C
....................  
....................       //En los tres casos, vuelve a mostrarse el menú tras imprimir las estadísticas 
....................    } 
.................... } 
524C:  GOTO   628C (RETURN)
....................  
.................... void inicializacion() 
.................... { 
....................    //Variables para introducir los datos de fecha y hora 
....................    int weekday, dia, mes, anno, horas, minutos; 
....................  
....................    //Comenzamos pidiendo la introducción de la fecha 
....................    e1: 
....................    lcd_send_byte(LCD_ORDEN, LCD_CLEAR); 
*
16A6:  MOVLB  2
16A8:  CLRF   x85
16AA:  MOVLW  01
16AC:  MOVWF  x86
16AE:  MOVLB  0
16B0:  CALL   0DA8
....................    lcd_send_byte(LCD_ORDEN, LCD_CURSOR); 
16B4:  MOVLB  2
16B6:  CLRF   x85
16B8:  MOVLW  0E
16BA:  MOVWF  x86
16BC:  MOVLB  0
16BE:  CALL   0DA8
....................    printf(lcd_putc, " FECHA:\n LUN 01/01/2009"); 
16C2:  CLRF   73
16C4:  MOVF   73,W
16C6:  CALL   0B86
16CA:  IORLW  00
16CC:  BZ    16DC
16CE:  INCF   73,F
16D0:  MOVLB  2
16D2:  MOVWF  x80
16D4:  MOVLB  0
16D6:  CALL   0E7C
16DA:  BRA    16C4
....................  
....................    //Leemos el día de la semana 
....................    weekday = 0; 
16DC:  CLRF   6D
....................    lcd_gotoxy(2,2); 
16DE:  MOVLW  02
16E0:  MOVLB  2
16E2:  MOVWF  x81
16E4:  MOVWF  x82
16E6:  MOVLB  0
16E8:  CALL   0E56
....................  
....................    while(1){ 
....................       //Si pulsamos los botones + y -, cambiamos de día 
....................       if(!mas || !menos) 
16EC:  BTFSS  F82.0
16EE:  BRA    16F4
16F0:  BTFSC  F82.1
16F2:  BRA    17FA
....................       { 
....................          if(!mas) 
16F4:  BTFSC  F82.0
16F6:  BRA    1708
....................          { 
....................             //Si es +, aumentamos en 1 el número de día 
....................             weekday++; 
16F8:  INCF   6D,F
....................             //Si llegamos al final de la semana, volvemos al principio 
....................             if(weekday == 7) 
16FA:  MOVF   6D,W
16FC:  SUBLW  07
16FE:  BNZ   1702
....................                weekday = 0; 
1700:  CLRF   6D
....................             //Esperamos a que el botón se suelte 
....................             while(!mas){}; 
1702:  BTFSC  F82.0
1704:  BRA    1708
1706:  BRA    1702
....................          } 
....................          if(!menos) 
1708:  BTFSC  F82.1
170A:  BRA    171C
....................          { 
....................             //Si es -, disminuimos en 1 el número de día 
....................             weekday--; 
170C:  DECF   6D,F
....................             //Si nos pasamos del principio de la semana, nos vamos al final 
....................             if(weekday == 255) 
170E:  INCFSZ 6D,W
1710:  BRA    1716
....................                weekday = 6; 
1712:  MOVLW  06
1714:  MOVWF  6D
....................             //Esperamos a que el botón se suelte 
....................             while(!menos){}; 
1716:  BTFSC  F82.1
1718:  BRA    171C
171A:  BRA    1716
....................          } 
....................  
....................          //Elegimos el nombre del día de la semana a mostrar según el número 
....................          switch(weekday) 
....................          { 
171C:  MOVF   6D,W
171E:  ADDLW  F9
1720:  BTFSC  FD8.0
1722:  BRA    17EC
1724:  ADDLW  07
1726:  GOTO   1B12
....................             case 0: printf(lcd_putc, "LUN"); 
172A:  CLRF   73
172C:  MOVF   73,W
172E:  CALL   0BB8
1732:  IORLW  00
1734:  BZ    1744
1736:  INCF   73,F
1738:  MOVLB  2
173A:  MOVWF  x80
173C:  MOVLB  0
173E:  CALL   0E7C
1742:  BRA    172C
....................                     break; 
1744:  BRA    17EC
....................             case 1: printf(lcd_putc, "MAR"); 
1746:  CLRF   73
1748:  MOVF   73,W
174A:  CALL   0BD6
174E:  IORLW  00
1750:  BZ    1760
1752:  INCF   73,F
1754:  MOVLB  2
1756:  MOVWF  x80
1758:  MOVLB  0
175A:  CALL   0E7C
175E:  BRA    1748
....................                     break; 
1760:  BRA    17EC
....................             case 2: printf(lcd_putc, "MIE"); 
1762:  CLRF   73
1764:  MOVF   73,W
1766:  CALL   0BF4
176A:  IORLW  00
176C:  BZ    177C
176E:  INCF   73,F
1770:  MOVLB  2
1772:  MOVWF  x80
1774:  MOVLB  0
1776:  CALL   0E7C
177A:  BRA    1764
....................                     break; 
177C:  BRA    17EC
....................             case 3: printf(lcd_putc, "JUE"); 
177E:  CLRF   73
1780:  MOVF   73,W
1782:  CALL   0C12
1786:  IORLW  00
1788:  BZ    1798
178A:  INCF   73,F
178C:  MOVLB  2
178E:  MOVWF  x80
1790:  MOVLB  0
1792:  CALL   0E7C
1796:  BRA    1780
....................                     break; 
1798:  BRA    17EC
....................             case 4: printf(lcd_putc, "VIE"); 
179A:  CLRF   73
179C:  MOVF   73,W
179E:  CALL   0C30
17A2:  IORLW  00
17A4:  BZ    17B4
17A6:  INCF   73,F
17A8:  MOVLB  2
17AA:  MOVWF  x80
17AC:  MOVLB  0
17AE:  CALL   0E7C
17B2:  BRA    179C
....................                     break; 
17B4:  BRA    17EC
....................             case 5: printf(lcd_putc, "SAB"); 
17B6:  CLRF   73
17B8:  MOVF   73,W
17BA:  CALL   0C4E
17BE:  IORLW  00
17C0:  BZ    17D0
17C2:  INCF   73,F
17C4:  MOVLB  2
17C6:  MOVWF  x80
17C8:  MOVLB  0
17CA:  CALL   0E7C
17CE:  BRA    17B8
....................                     break; 
17D0:  BRA    17EC
....................             case 6: printf(lcd_putc, "DOM"); 
17D2:  CLRF   73
17D4:  MOVF   73,W
17D6:  CALL   0C6C
17DA:  IORLW  00
17DC:  BZ    17EC
17DE:  INCF   73,F
17E0:  MOVLB  2
17E2:  MOVWF  x80
17E4:  MOVLB  0
17E6:  CALL   0E7C
17EA:  BRA    17D4
....................          } 
....................  
....................          //Retornamos el cursor a su posición 
....................          lcd_gotoxy(2,2); 
17EC:  MOVLW  02
17EE:  MOVLB  2
17F0:  MOVWF  x81
17F2:  MOVWF  x82
17F4:  MOVLB  0
17F6:  CALL   0E56
....................       } 
....................  
....................       //Si se pulsa SI, confirmamos que ese es el día de la semana que queremos introducir 
....................       if(!si) 
17FA:  BTFSC  F82.2
17FC:  BRA    1804
....................       { 
....................          while(!si); 
17FE:  BTFSS  F82.2
1800:  BRA    17FE
....................          break; 
1802:  BRA    1806
....................       } 
....................    } 
1804:  BRA    16EC
....................  
....................    //Leemos el día del mes 
....................    dia = buscar_numero(6, 1, 31, 1); 
1806:  MOVLW  06
1808:  MOVWF  73
180A:  MOVLW  01
180C:  MOVWF  74
180E:  MOVLW  1F
1810:  MOVWF  75
1812:  MOVLW  01
1814:  MOVWF  76
1816:  CALL   0FD4
181A:  MOVFF  01,6E
....................    if(dia==NOCODE) 
181E:  MOVF   6E,W
1820:  SUBLW  64
1822:  BNZ   1826
....................       //Si pulsamos NO, reseteamos la operación 
....................       goto e1; 
1824:  BRA    16A6
....................    //Leemos el mes 
....................    mes = buscar_numero(9, 1, 12, 1); 
1826:  MOVLW  09
1828:  MOVWF  73
182A:  MOVLW  01
182C:  MOVWF  74
182E:  MOVLW  0C
1830:  MOVWF  75
1832:  MOVLW  01
1834:  MOVWF  76
1836:  CALL   0FD4
183A:  MOVFF  01,6F
....................    if(mes==NOCODE) 
183E:  MOVF   6F,W
1840:  SUBLW  64
1842:  BNZ   1846
....................       goto e1; 
1844:  BRA    16A6
....................  
....................    //Si el día introducido no se encuentra en el mes seleccionado, mostramos un mensaje 
....................    //de error y reseteamos la operación 
....................    if((dia>29 && mes==2)||(dia==31 && (mes==4 || mes==6 || mes==9 || mes==11))) 
1846:  MOVF   6E,W
1848:  SUBLW  1D
184A:  BC    1852
184C:  MOVF   6F,W
184E:  SUBLW  02
1850:  BZ    1870
1852:  MOVF   6E,W
1854:  SUBLW  1F
1856:  BNZ   18BC
1858:  MOVF   6F,W
185A:  SUBLW  04
185C:  BZ    1870
185E:  MOVF   6F,W
1860:  SUBLW  06
1862:  BZ    1870
1864:  MOVF   6F,W
1866:  SUBLW  09
1868:  BZ    1870
186A:  MOVF   6F,W
186C:  SUBLW  0B
186E:  BNZ   18BC
....................    { 
....................       lcd_send_byte(LCD_ORDEN, LCD_CLEAR); 
1870:  MOVLB  2
1872:  CLRF   x85
1874:  MOVLW  01
1876:  MOVWF  x86
1878:  MOVLB  0
187A:  CALL   0DA8
....................       lcd_send_byte(LCD_ORDEN, LCD_NO_CURSOR); 
187E:  MOVLB  2
1880:  CLRF   x85
1882:  MOVLW  0C
1884:  MOVWF  x86
1886:  MOVLB  0
1888:  CALL   0DA8
....................       printf(lcd_putc, " Error en\n la fecha"); 
188C:  CLRF   73
188E:  MOVF   73,W
1890:  CALL   0C8A
1894:  IORLW  00
1896:  BZ    18A6
1898:  INCF   73,F
189A:  MOVLB  2
189C:  MOVWF  x80
189E:  MOVLB  0
18A0:  CALL   0E7C
18A4:  BRA    188E
....................       delay_ms(LCD_T_RETARDO); 
18A6:  MOVLW  02
18A8:  MOVWF  73
18AA:  MOVLW  FA
18AC:  MOVLB  2
18AE:  MOVWF  x87
18B0:  MOVLB  0
18B2:  CALL   0D30
18B6:  DECFSZ 73,F
18B8:  BRA    18AA
....................       goto e1; 
18BA:  BRA    16A6
....................    } 
....................  
....................    //Leemos el año 
....................    anno = buscar_numero(14, 9, 99, 9); 
18BC:  MOVLW  0E
18BE:  MOVWF  73
18C0:  MOVLW  09
18C2:  MOVWF  74
18C4:  MOVLW  63
18C6:  MOVWF  75
18C8:  MOVLW  09
18CA:  MOVWF  76
18CC:  CALL   0FD4
18D0:  MOVFF  01,70
....................    if(anno==NOCODE) 
18D4:  MOVF   70,W
18D6:  SUBLW  64
18D8:  BNZ   18DC
....................       //Si pulsamos NO, reseteamos la operación 
....................       goto e1; 
18DA:  BRA    16A6
....................  
....................    //Si el año no es bisiesto y hemos seleccionado el 29 de febrero, 
....................    //mostramos un mensaje y reseteamos la operación. 
....................    if(anno%4!=0 && mes==2 && dia==29) 
18DC:  MOVF   70,W
18DE:  ANDLW  03
18E0:  BZ    193A
18E2:  MOVF   6F,W
18E4:  SUBLW  02
18E6:  BNZ   193A
18E8:  MOVF   6E,W
18EA:  SUBLW  1D
18EC:  BNZ   193A
....................    { 
....................       lcd_send_byte(LCD_ORDEN, LCD_CLEAR); 
18EE:  MOVLB  2
18F0:  CLRF   x85
18F2:  MOVLW  01
18F4:  MOVWF  x86
18F6:  MOVLB  0
18F8:  CALL   0DA8
....................       lcd_send_byte(LCD_ORDEN, LCD_NO_CURSOR); 
18FC:  MOVLB  2
18FE:  CLRF   x85
1900:  MOVLW  0C
1902:  MOVWF  x86
1904:  MOVLB  0
1906:  CALL   0DA8
....................       printf(lcd_putc, " El anno no\n es bisiesto"); 
190A:  CLRF   73
190C:  MOVF   73,W
190E:  CALL   0CB8
1912:  IORLW  00
1914:  BZ    1924
1916:  INCF   73,F
1918:  MOVLB  2
191A:  MOVWF  x80
191C:  MOVLB  0
191E:  CALL   0E7C
1922:  BRA    190C
....................       delay_ms(LCD_T_RETARDO); 
1924:  MOVLW  02
1926:  MOVWF  73
1928:  MOVLW  FA
192A:  MOVLB  2
192C:  MOVWF  x87
192E:  MOVLB  0
1930:  CALL   0D30
1934:  DECFSZ 73,F
1936:  BRA    1928
....................       goto e1; 
1938:  BRA    16A6
....................    } 
....................  
....................    //Calculamos el año en el intervalo de 0 a 3 según sean bisiesto este año 
....................    //o los anteriores. 
....................    if(anno%4==0) 
193A:  MOVF   70,W
193C:  ANDLW  03
193E:  BNZ   1944
....................       anno_actual_0_to_3 = 0; 
1940:  CLRF   55
....................    else if((anno-1)%4==0) 
1942:  BRA    196C
1944:  MOVLW  01
1946:  SUBWF  70,W
1948:  ANDLW  03
194A:  BNZ   1952
....................       anno_actual_0_to_3 = 1; 
194C:  MOVLW  01
194E:  MOVWF  55
....................    else if((anno-2)%4==0) 
1950:  BRA    196C
1952:  MOVLW  02
1954:  SUBWF  70,W
1956:  ANDLW  03
1958:  BNZ   1960
....................       anno_actual_0_to_3 = 2; 
195A:  MOVLW  02
195C:  MOVWF  55
....................    else if((anno-3)%4==0) 
195E:  BRA    196C
1960:  MOVLW  03
1962:  SUBWF  70,W
1964:  ANDLW  03
1966:  BNZ   196C
....................       anno_actual_0_to_3 = 3; 
1968:  MOVLW  03
196A:  MOVWF  55
....................  
....................    //Se pide la introducción de la hora 
....................    lcd_send_byte(LCD_ORDEN, LCD_CLEAR); 
196C:  MOVLB  2
196E:  CLRF   x85
1970:  MOVLW  01
1972:  MOVWF  x86
1974:  MOVLB  0
1976:  CALL   0DA8
....................    lcd_send_byte(LCD_ORDEN, LCD_CURSOR); 
197A:  MOVLB  2
197C:  CLRF   x85
197E:  MOVLW  0E
1980:  MOVWF  x86
1982:  MOVLB  0
1984:  CALL   0DA8
....................    printf(lcd_putc, "     HORA\n     00:00"); 
1988:  CLRF   73
198A:  MOVF   73,W
198C:  CALL   0CEC
1990:  IORLW  00
1992:  BZ    19A2
1994:  INCF   73,F
1996:  MOVLB  2
1998:  MOVWF  x80
199A:  MOVLB  0
199C:  CALL   0E7C
19A0:  BRA    198A
....................  
....................    //Leemos la hora 
....................    horas = buscar_numero(6, 0, 23, 0); 
19A2:  MOVLW  06
19A4:  MOVWF  73
19A6:  CLRF   74
19A8:  MOVLW  17
19AA:  MOVWF  75
19AC:  CLRF   76
19AE:  CALL   0FD4
19B2:  MOVFF  01,71
....................    if(horas==NOCODE) 
19B6:  MOVF   71,W
19B8:  SUBLW  64
19BA:  BNZ   19BE
....................       //Si se pulsa el botón NO, se resetea todo el proceso 
....................       goto e1; 
19BC:  BRA    16A6
....................    //Leemos los minutos 
....................    minutos = buscar_numero(9, 0, 59, 0); 
19BE:  MOVLW  09
19C0:  MOVWF  73
19C2:  CLRF   74
19C4:  MOVLW  3B
19C6:  MOVWF  75
19C8:  CLRF   76
19CA:  CALL   0FD4
19CE:  MOVFF  01,72
....................    if(minutos==NOCODE) 
19D2:  MOVF   72,W
19D4:  SUBLW  64
19D6:  BNZ   19DA
....................       goto e1; 
19D8:  BRA    16A6
....................  
....................    //Almacenamos todo en la estructura que contiene la información del tiempo 
....................    tiempo.month   = mes; 
19DA:  MOVFF  6F,49
....................    tiempo.day     = dia; 
19DE:  MOVFF  6E,48
....................    tiempo.year    = anno_actual_0_to_3; 
19E2:  MOVFF  55,4A
....................    tiempo.hours   = horas; 
19E6:  MOVFF  71,47
....................    tiempo.minutes = minutos; 
19EA:  MOVFF  72,46
....................    tiempo.seconds = 0x00; 
19EE:  CLRF   45
....................    tiempo.weekday = weekday; 
19F0:  MOVFF  6D,4B
....................  
....................    //Fijamos el reloj a esa fecha y hora 
....................    PCF8583_set_datetime(&tiempo); 
19F4:  CLRF   74
19F6:  MOVLW  45
19F8:  MOVWF  73
19FA:  BRA    12E6
....................  
....................    //Establecemos los parámetros iniciales del sistema para resetear la memoria 
....................    termostato = 20; 
19FC:  CLRF   22
19FE:  CLRF   21
1A00:  MOVLW  20
1A02:  MOVWF  20
1A04:  MOVLW  83
1A06:  MOVWF  1F
....................    num_intervalos = 0; 
1A08:  CLRF   43
....................    num_registros = 0; 
1A0A:  CLRF   53
....................    anno_actual = anno; 
1A0C:  MOVFF  70,54
....................  
....................  
....................    //Escribimos los datos en la EEPROM 
....................    write_eeprom(eeprom_termostato, (int)termostato); 
1A10:  MOVFF  22,86
1A14:  MOVFF  21,85
1A18:  MOVFF  20,84
1A1C:  MOVFF  1F,83
1A20:  RCALL  142C
1A22:  MOVFF  01,73
1A26:  CLRF   FA9
1A28:  MOVFF  01,FA8
1A2C:  BCF    FA6.6
1A2E:  BCF    FA6.7
1A30:  BSF    FA6.2
1A32:  MOVFF  FF2,00
1A36:  BCF    FF2.7
1A38:  MOVLB  F
1A3A:  MOVLW  55
1A3C:  MOVWF  FA7
1A3E:  MOVLW  AA
1A40:  MOVWF  FA7
1A42:  BSF    FA6.1
1A44:  BTFSC  FA6.1
1A46:  BRA    1A44
1A48:  BCF    FA6.2
1A4A:  MOVF   00,W
1A4C:  IORWF  FF2,F
....................    write_eeprom(eeprom_num_intervalos, num_intervalos); 
1A4E:  MOVLW  01
1A50:  MOVWF  FA9
1A52:  MOVFF  43,FA8
1A56:  BCF    FA6.6
1A58:  BCF    FA6.7
1A5A:  BSF    FA6.2
1A5C:  MOVFF  FF2,00
1A60:  BCF    FF2.7
1A62:  MOVLW  55
1A64:  MOVWF  FA7
1A66:  MOVLW  AA
1A68:  MOVWF  FA7
1A6A:  BSF    FA6.1
1A6C:  BTFSC  FA6.1
1A6E:  BRA    1A6C
1A70:  BCF    FA6.2
1A72:  MOVF   00,W
1A74:  IORWF  FF2,F
....................    write_eeprom(eeprom_num_registros, num_registros); 
1A76:  MOVLW  02
1A78:  MOVWF  FA9
1A7A:  MOVFF  53,FA8
1A7E:  BCF    FA6.6
1A80:  BCF    FA6.7
1A82:  BSF    FA6.2
1A84:  MOVFF  FF2,00
1A88:  BCF    FF2.7
1A8A:  MOVLW  55
1A8C:  MOVWF  FA7
1A8E:  MOVLW  AA
1A90:  MOVWF  FA7
1A92:  BSF    FA6.1
1A94:  BTFSC  FA6.1
1A96:  BRA    1A94
1A98:  BCF    FA6.2
1A9A:  MOVF   00,W
1A9C:  IORWF  FF2,F
....................    write_eeprom(eeprom_anno_actual, anno_actual); 
1A9E:  MOVLW  03
1AA0:  MOVWF  FA9
1AA2:  MOVFF  54,FA8
1AA6:  BCF    FA6.6
1AA8:  BCF    FA6.7
1AAA:  BSF    FA6.2
1AAC:  MOVFF  FF2,00
1AB0:  BCF    FF2.7
1AB2:  MOVLW  55
1AB4:  MOVWF  FA7
1AB6:  MOVLW  AA
1AB8:  MOVWF  FA7
1ABA:  BSF    FA6.1
1ABC:  BTFSC  FA6.1
1ABE:  BRA    1ABC
1AC0:  BCF    FA6.2
1AC2:  MOVF   00,W
1AC4:  IORWF  FF2,F
....................    write_eeprom(eeprom_anno_0_to_3, anno_actual_0_to_3); 
1AC6:  MOVLW  04
1AC8:  MOVWF  FA9
1ACA:  MOVFF  55,FA8
1ACE:  BCF    FA6.6
1AD0:  BCF    FA6.7
1AD2:  BSF    FA6.2
1AD4:  MOVFF  FF2,00
1AD8:  BCF    FF2.7
1ADA:  MOVLW  55
1ADC:  MOVWF  FA7
1ADE:  MOVLW  AA
1AE0:  MOVWF  FA7
1AE2:  BSF    FA6.1
1AE4:  BTFSC  FA6.1
1AE6:  BRA    1AE4
1AE8:  BCF    FA6.2
1AEA:  MOVF   00,W
1AEC:  IORWF  FF2,F
....................  
....................    //Escribimos el valor del termostato en el sensor de temperatura. 
....................    //Ponemos como valor alto 127.5 grados, temperatura que no se va a alcanzar. 
....................    ds1820_establecer_TH_TL(127.5, termostato); 
1AEE:  CLRF   76
1AF0:  CLRF   75
1AF2:  MOVLW  7F
1AF4:  MOVWF  74
1AF6:  MOVLW  85
1AF8:  MOVWF  73
1AFA:  MOVFF  22,7A
1AFE:  MOVFF  21,79
1B02:  MOVFF  20,78
1B06:  MOVFF  1F,77
1B0A:  MOVLB  0
1B0C:  RCALL  15CE
.................... } 
1B0E:  GOTO   5586 (RETURN)
....................  

Configuration Fuses:
   Word  1: 0200   HS NOIESO NOFCMEN RESERVED
   Word  2: 181E   BROWNOUT NOWDT BORV25 PUT WDT4096
   Word  3: 8300   PBADEN CCP2C1 NOLPT1OSC MCLR RESERVED
   Word  4: 0081   STVREN NODEBUG NOLVP NOXINST RESERVED
   Word  5: C00F   NOPROTECT NOCPD NOCPB
   Word  6: E00F   NOWRT NOWRTD NOWRTC NOWRTB
   Word  7: 400F   NOEBTR NOEBTRB
