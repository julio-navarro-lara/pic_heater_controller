CCS PCH C Compiler, Version 3.249, 28193               26-feb-10 12:42

               Filename: E:\programming\sed\Proyecto 1\Prototipo 3 (presentación)\proyecto1.lst

               ROM used: 26516 bytes (81%)
                         Largest free fragment is 6248
               RAM used: 94 (6%) at main() level
                         679 (44%) worst case
               Stack:    8 worst case (7 in main + 1 for interrupts)

*
0000:  GOTO   5962
*
0008:  MOVWF  05
000A:  MOVFF  FD8,06
000E:  MOVFF  FE0,07
0012:  MOVLB  0
0014:  MOVFF  FE9,0D
0018:  MOVFF  FEA,08
001C:  MOVFF  FE1,09
0020:  MOVFF  FE2,0A
0024:  MOVFF  FD9,0B
0028:  MOVFF  FDA,0C
002C:  MOVFF  FF3,14
0030:  MOVFF  FF4,15
0034:  MOVFF  FFA,16
0038:  MOVFF  00,0F
003C:  MOVFF  01,10
0040:  MOVFF  02,11
0044:  MOVFF  03,12
0048:  MOVFF  04,13
004C:  BTFSS  FF0.3
004E:  GOTO   0058
0052:  BTFSC  FF0.0
0054:  GOTO   10DC
0058:  MOVFF  0F,00
005C:  MOVFF  10,01
0060:  MOVFF  11,02
0064:  MOVFF  12,03
0068:  MOVFF  13,04
006C:  MOVFF  0D,FE9
0070:  MOVFF  08,FEA
0074:  MOVFF  09,FE1
0078:  MOVFF  0A,FE2
007C:  MOVFF  0B,FD9
0080:  MOVFF  0C,FDA
0084:  MOVFF  14,FF3
0088:  MOVFF  15,FF4
008C:  MOVFF  16,FFA
0090:  MOVF   05,W
0092:  MOVFF  07,FE0
0096:  MOVFF  06,FD8
009A:  RETFIE 0
.................... //***************************************************************** 
.................... //***   PROYECTO 1: Control de un sistema de calefacción de una *** 
.................... //***   vivienda utilizando un microcontrolador PIC18F4520      *** 
.................... //***************************************************************** 
.................... //Author: Julio Navarro Lara        2010 
....................  
.................... //En este caso está preparado para probarse en la placa EasyPic3 
....................  
....................  
....................  
.................... #include "18F4520.H" 
.................... //////// Standard Header file for the PIC18F4520 device //////////////// 
.................... #DEVICE PIC18F4520 //Aunque el convertidor A/D es de 10 bits, con esta directiva 
009C:  MOVFF  FF2,0E
00A0:  BCF    FF2.7
00A2:  CLRF   FF7
00A4:  ADDLW  B6
00A6:  MOVWF  FF6
00A8:  MOVLW  00
00AA:  ADDWFC FF7,F
00AC:  TBLRD*+
00AE:  MOVF   FF5,W
00B0:  BTFSC  0E.7
00B2:  BSF    FF2.7
00B4:  RETURN 0
00B6:  DATA 2C,0F
00B8:  DATA 01,06
00BA:  MOVFF  FF2,0E
00BE:  BCF    FF2.7
00C0:  CLRF   FF7
00C2:  ADDLW  D4
00C4:  MOVWF  FF6
00C6:  MOVLW  00
00C8:  ADDWFC FF7,F
00CA:  TBLRD*+
00CC:  MOVF   FF5,W
00CE:  BTFSC  0E.7
00D0:  BSF    FF2.7
00D2:  RETURN 0
00D4:  DATA 49,6E
00D6:  DATA 69,63
00D8:  DATA 69,61
00DA:  DATA 6C,69
00DC:  DATA 7A,61
00DE:  DATA 6E,64
00E0:  DATA 6F,2E
00E2:  DATA 2E,2E
00E4:  DATA 00,00
00E6:  MOVFF  FF2,0E
00EA:  BCF    FF2.7
00EC:  CLRF   FF7
00EE:  ADDLW  00
00F0:  MOVWF  FF6
00F2:  MOVLW  01
00F4:  ADDWFC FF7,F
00F6:  TBLRD*+
00F8:  MOVF   FF5,W
00FA:  BTFSC  0E.7
00FC:  BSF    FF2.7
00FE:  RETURN 0
0100:  DATA 53,69
0102:  DATA 73,74
0104:  DATA 65,6D
0106:  DATA 61,20
0108:  DATA 69,6E
010A:  DATA 69,63
010C:  DATA 69,61
010E:  DATA 6C,69
0110:  DATA 7A,61
0112:  DATA 64,6F
0114:  DATA 20,63
0116:  DATA 6F,6E
0118:  DATA 20,65
011A:  DATA 78,69
011C:  DATA 74,6F
011E:  DATA 21,0D
0120:  DATA 00,00
0122:  MOVFF  FF2,0E
0126:  BCF    FF2.7
0128:  CLRF   FF7
012A:  ADDLW  3C
012C:  MOVWF  FF6
012E:  MOVLW  01
0130:  ADDWFC FF7,F
0132:  TBLRD*+
0134:  MOVF   FF5,W
0136:  BTFSC  0E.7
0138:  BSF    FF2.7
013A:  RETURN 0
013C:  DATA 20,20
013E:  DATA 45,6E
0140:  DATA 63,65
0142:  DATA 6E,64
0144:  DATA 69,65
0146:  DATA 6E,64
0148:  DATA 6F,0A
014A:  DATA 20,20
014C:  DATA 73,69
014E:  DATA 73,74
0150:  DATA 65,6D
0152:  DATA 61,2E
0154:  DATA 2E,2E
0156:  DATA 00,00
0158:  MOVFF  FF2,0E
015C:  BCF    FF2.7
015E:  CLRF   FF7
0160:  ADDLW  72
0162:  MOVWF  FF6
0164:  MOVLW  01
0166:  ADDWFC FF7,F
0168:  TBLRD*+
016A:  MOVF   FF5,W
016C:  BTFSC  0E.7
016E:  BSF    FF2.7
0170:  RETURN 0
0172:  DATA 20,20
0174:  DATA 41,70
0176:  DATA 61,67
0178:  DATA 61,6E
017A:  DATA 64,6F
017C:  DATA 0A,20
017E:  DATA 20,73
0180:  DATA 69,73
0182:  DATA 74,65
0184:  DATA 6D,61
0186:  DATA 2E,2E
0188:  DATA 2E,00
018A:  MOVFF  FF2,0E
018E:  BCF    FF2.7
0190:  CLRF   FF7
0192:  ADDLW  A4
0194:  MOVWF  FF6
0196:  MOVLW  01
0198:  ADDWFC FF7,F
019A:  TBLRD*+
019C:  MOVF   FF5,W
019E:  BTFSC  0E.7
01A0:  BSF    FF2.7
01A2:  RETURN 0
01A4:  DATA 20,20
01A6:  DATA 49,6E
01A8:  DATA 64,69
01AA:  DATA 71,75
01AC:  DATA 65,20
01AE:  DATA 6C,61
01B0:  DATA 20,0A
01B2:  DATA 20,20
01B4:  DATA 6F,70
01B6:  DATA 65,72
01B8:  DATA 61,63
01BA:  DATA 69,6F
01BC:  DATA 6E,20
01BE:  DATA 20,20
01C0:  DATA 31,00
01C2:  MOVFF  FF2,0E
01C6:  BCF    FF2.7
01C8:  CLRF   FF7
01CA:  ADDLW  DC
01CC:  MOVWF  FF6
01CE:  MOVLW  01
01D0:  ADDWFC FF7,F
01D2:  TBLRD*+
01D4:  MOVF   FF5,W
01D6:  BTFSC  0E.7
01D8:  BSF    FF2.7
01DA:  RETURN 0
01DC:  DATA 20,20
01DE:  DATA 41,6E
01E0:  DATA 75,6C
01E2:  DATA 61,6E
01E4:  DATA 64,6F
01E6:  DATA 0A,20
01E8:  DATA 20,6F
01EA:  DATA 70,65
01EC:  DATA 72,61
01EE:  DATA 63,69
01F0:  DATA 6F,6E
01F2:  DATA 2E,2E
01F4:  DATA 2E,00
01F6:  MOVFF  FF2,0E
01FA:  BCF    FF2.7
01FC:  CLRF   FF7
01FE:  ADDLW  10
0200:  MOVWF  FF6
0202:  MOVLW  02
0204:  ADDWFC FF7,F
0206:  TBLRD*+
0208:  MOVF   FF5,W
020A:  BTFSC  0E.7
020C:  BSF    FF2.7
020E:  RETURN 0
0210:  DATA 4D,6F
0212:  DATA 64,69
0214:  DATA 66,69
0216:  DATA 63,61
0218:  DATA 72,0A
021A:  DATA 74,65
021C:  DATA 72,6D
021E:  DATA 6F,73
0220:  DATA 74,61
0222:  DATA 74,6F
0224:  DATA 20,25
0226:  DATA 2E,30
0228:  DATA 66,25
022A:  DATA 63,43
022C:  DATA 00,00
022E:  MOVFF  FF2,0E
0232:  BCF    FF2.7
0234:  CLRF   FF7
0236:  ADDLW  48
0238:  MOVWF  FF6
023A:  MOVLW  02
023C:  ADDWFC FF7,F
023E:  TBLRD*+
0240:  MOVF   FF5,W
0242:  BTFSC  0E.7
0244:  BSF    FF2.7
0246:  RETURN 0
0248:  DATA 4E,75
024A:  DATA 65,76
024C:  DATA 6F,20
024E:  DATA 76,61
0250:  DATA 6C,6F
0252:  DATA 72,3A
0254:  DATA 0A,25
0256:  DATA 63,43
0258:  DATA 00,00
025A:  MOVFF  FF2,0E
025E:  BCF    FF2.7
0260:  CLRF   FF7
0262:  ADDLW  74
0264:  MOVWF  FF6
0266:  MOVLW  02
0268:  ADDWFC FF7,F
026A:  TBLRD*+
026C:  MOVF   FF5,W
026E:  BTFSC  0E.7
0270:  BSF    FF2.7
0272:  RETURN 0
0274:  DATA 20,20
0276:  DATA 41,70
0278:  DATA 6C,69
027A:  DATA 63,61
027C:  DATA 6E,64
027E:  DATA 6F,0A
0280:  DATA 20,20
0282:  DATA 63,61
0284:  DATA 6D,62
0286:  DATA 69,6F
0288:  DATA 73,2E
028A:  DATA 2E,2E
028C:  DATA 00,00
028E:  MOVFF  FF2,0E
0292:  BCF    FF2.7
0294:  CLRF   FF7
0296:  ADDLW  A8
0298:  MOVWF  FF6
029A:  MOVLW  02
029C:  ADDWFC FF7,F
029E:  TBLRD*+
02A0:  MOVF   FF5,W
02A2:  BTFSC  0E.7
02A4:  BSF    FF2.7
02A6:  RETURN 0
02A8:  DATA 20,50
02AA:  DATA 72,6F
02AC:  DATA 67,72
02AE:  DATA 61,6D
02B0:  DATA 61,72
02B2:  DATA 0A,20
02B4:  DATA 73,69
02B6:  DATA 73,74
02B8:  DATA 65,6D
02BA:  DATA 61,00
02BC:  MOVFF  FF2,0E
02C0:  BCF    FF2.7
02C2:  CLRF   FF7
02C4:  ADDLW  D6
02C6:  MOVWF  FF6
02C8:  MOVLW  02
02CA:  ADDWFC FF7,F
02CC:  TBLRD*+
02CE:  MOVF   FF5,W
02D0:  BTFSC  0E.7
02D2:  BSF    FF2.7
02D4:  RETURN 0
02D6:  DATA 20,49
02D8:  DATA 4E,54
02DA:  DATA 45,52
02DC:  DATA 56,41
02DE:  DATA 4C,4F
02E0:  DATA 20,25
02E2:  DATA 69,0A
02E4:  DATA 3A,3A
02E6:  DATA 00,00
02E8:  MOVFF  FF2,0E
02EC:  BCF    FF2.7
02EE:  CLRF   FF7
02F0:  ADDLW  02
02F2:  MOVWF  FF6
02F4:  MOVLW  03
02F6:  ADDWFC FF7,F
02F8:  TBLRD*+
02FA:  MOVF   FF5,W
02FC:  BTFSC  0E.7
02FE:  BSF    FF2.7
0300:  RETURN 0
0302:  DATA 20,20
0304:  DATA 20,56
0306:  DATA 61,6C
0308:  DATA 6F,72
030A:  DATA 65,73
030C:  DATA 0A,20
030E:  DATA 20,20
0310:  DATA 69,6E
0312:  DATA 63,6F
0314:  DATA 72,72
0316:  DATA 65,63
0318:  DATA 74,6F
031A:  DATA 73,00
031C:  MOVFF  FF2,0E
0320:  BCF    FF2.7
0322:  CLRF   FF7
0324:  ADDLW  36
0326:  MOVWF  FF6
0328:  MOVLW  03
032A:  ADDWFC FF7,F
032C:  TBLRD*+
032E:  MOVF   FF5,W
0330:  BTFSC  0E.7
0332:  BSF    FF2.7
0334:  RETURN 0
0336:  DATA 49,6E
0338:  DATA 74,65
033A:  DATA 72,76
033C:  DATA 61,6C
033E:  DATA 6F,20
0340:  DATA 6C,69
0342:  DATA 6D,69
0344:  DATA 74,65
0346:  DATA 0A,64
0348:  DATA 65,20
034A:  DATA 34,20
034C:  DATA 68,6F
034E:  DATA 72,61
0350:  DATA 73,00
0352:  MOVFF  FF2,0E
0356:  BCF    FF2.7
0358:  CLRF   FF7
035A:  ADDLW  6C
035C:  MOVWF  FF6
035E:  MOVLW  03
0360:  ADDWFC FF7,F
0362:  TBLRD*+
0364:  MOVF   FF5,W
0366:  BTFSC  0E.7
0368:  BSF    FF2.7
036A:  RETURN 0
036C:  DATA 54,65
036E:  DATA 72,6D
0370:  DATA 6F,73
0372:  DATA 74,61
0374:  DATA 74,6F
0376:  DATA 20,25
0378:  DATA 69,0A
037A:  DATA 25,63
037C:  DATA 43,00
037E:  MOVFF  FF2,0E
0382:  BCF    FF2.7
0384:  CLRF   FF7
0386:  ADDLW  98
0388:  MOVWF  FF6
038A:  MOVLW  03
038C:  ADDWFC FF7,F
038E:  TBLRD*+
0390:  MOVF   FF5,W
0392:  BTFSC  0E.7
0394:  BSF    FF2.7
0396:  RETURN 0
0398:  DATA 53,6F
039A:  DATA 6C,61
039C:  DATA 70,61
039E:  DATA 6D,69
03A0:  DATA 65,6E
03A2:  DATA 74,6F
03A4:  DATA 0A,64
03A6:  DATA 65,20
03A8:  DATA 69,6E
03AA:  DATA 74,65
03AC:  DATA 72,76
03AE:  DATA 61,6C
03B0:  DATA 6F,73
03B2:  DATA 21,00
03B4:  MOVFF  FF2,0E
03B8:  BCF    FF2.7
03BA:  CLRF   FF7
03BC:  ADDLW  CE
03BE:  MOVWF  FF6
03C0:  MOVLW  03
03C2:  ADDWFC FF7,F
03C4:  TBLRD*+
03C6:  MOVF   FF5,W
03C8:  BTFSC  0E.7
03CA:  BSF    FF2.7
03CC:  RETURN 0
03CE:  DATA 20,20
03D0:  DATA 49,6E
03D2:  DATA 74,72
03D4:  DATA 6F,64
03D6:  DATA 75,7A
03D8:  DATA 63,61
03DA:  DATA 0A,20
03DC:  DATA 20,63
03DE:  DATA 6C,61
03E0:  DATA 76,65
03E2:  DATA 00,00
03E4:  MOVFF  FF2,0E
03E8:  BCF    FF2.7
03EA:  CLRF   FF7
03EC:  ADDLW  FE
03EE:  MOVWF  FF6
03F0:  MOVLW  03
03F2:  ADDWFC FF7,F
03F4:  TBLRD*+
03F6:  MOVF   FF5,W
03F8:  BTFSC  0E.7
03FA:  BSF    FF2.7
03FC:  RETURN 0
03FE:  DATA 20,20
0400:  DATA 43,6C
0402:  DATA 61,76
0404:  DATA 65,0A
0406:  DATA 20,20
0408:  DATA 69,6E
040A:  DATA 63,6F
040C:  DATA 72,72
040E:  DATA 65,63
0410:  DATA 74,61
0412:  DATA 00,00
0414:  MOVFF  FF2,0E
0418:  BCF    FF2.7
041A:  CLRF   FF7
041C:  ADDLW  2E
041E:  MOVWF  FF6
0420:  MOVLW  04
0422:  ADDWFC FF7,F
0424:  TBLRD*+
0426:  MOVF   FF5,W
0428:  BTFSC  0E.7
042A:  BSF    FF2.7
042C:  RETURN 0
042E:  DATA 20,20
0430:  DATA 4D,6F
0432:  DATA 64,6F
0434:  DATA 0A,20
0436:  DATA 20,72
0438:  DATA 65,76
043A:  DATA 69,73
043C:  DATA 69,6F
043E:  DATA 6E,00
0440:  MOVFF  FF2,0E
0444:  BCF    FF2.7
0446:  CLRF   FF7
0448:  ADDLW  5A
044A:  MOVWF  FF6
044C:  MOVLW  04
044E:  ADDWFC FF7,F
0450:  TBLRD*+
0452:  MOVF   FF5,W
0454:  BTFSC  0E.7
0456:  BSF    FF2.7
0458:  RETURN 0
045A:  DATA 44,65
045C:  DATA 6D,61
045E:  DATA 73,69
0460:  DATA 61,64
0462:  DATA 6F,20
0464:  DATA 74,69
0466:  DATA 65,6D
0468:  DATA 70,6F
046A:  DATA 0A,65
046C:  DATA 6E,63
046E:  DATA 65,6E
0470:  DATA 64,69
0472:  DATA 64,6F
0474:  DATA 21,00
0476:  MOVFF  FF2,0E
047A:  BCF    FF2.7
047C:  CLRF   FF7
047E:  ADDLW  90
0480:  MOVWF  FF6
0482:  MOVLW  04
0484:  ADDWFC FF7,F
0486:  TBLRD*+
0488:  MOVF   FF5,W
048A:  BTFSC  0E.7
048C:  BSF    FF2.7
048E:  RETURN 0
0490:  DATA 30,00
0492:  MOVFF  FF2,0E
0496:  BCF    FF2.7
0498:  CLRF   FF7
049A:  ADDLW  AC
049C:  MOVWF  FF6
049E:  MOVLW  04
04A0:  ADDWFC FF7,F
04A2:  TBLRD*+
04A4:  MOVF   FF5,W
04A6:  BTFSC  0E.7
04A8:  BSF    FF2.7
04AA:  RETURN 0
04AC:  DATA 0D,49
04AE:  DATA 6E,69
04B0:  DATA 63,69
04B2:  DATA 61,6C
04B4:  DATA 69,7A
04B6:  DATA 61,63
04B8:  DATA 69,6F
04BA:  DATA 6E,20
04BC:  DATA 64,65
04BE:  DATA 6C,20
04C0:  DATA 73,69
04C2:  DATA 73,74
04C4:  DATA 65,6D
04C6:  DATA 61,0D
04C8:  DATA 00,00
04CA:  MOVFF  FF2,0E
04CE:  BCF    FF2.7
04D0:  CLRF   FF7
04D2:  ADDLW  E4
04D4:  MOVWF  FF6
04D6:  MOVLW  04
04D8:  ADDWFC FF7,F
04DA:  TBLRD*+
04DC:  MOVF   FF5,W
04DE:  BTFSC  0E.7
04E0:  BSF    FF2.7
04E2:  RETURN 0
04E4:  DATA 2A,2A
04E6:  DATA 2A,2A
04E8:  DATA 2A,2A
04EA:  DATA 2A,2A
04EC:  DATA 2A,2A
04EE:  DATA 2A,2A
04F0:  DATA 2A,2A
04F2:  DATA 2A,2A
04F4:  DATA 2A,2A
04F6:  DATA 2A,2A
04F8:  DATA 2A,2A
04FA:  DATA 2A,2A
04FC:  DATA 2A,2A
04FE:  DATA 0D,00
0500:  MOVFF  FF2,0E
0504:  BCF    FF2.7
0506:  CLRF   FF7
0508:  ADDLW  1A
050A:  MOVWF  FF6
050C:  MOVLW  05
050E:  ADDWFC FF7,F
0510:  TBLRD*+
0512:  MOVF   FF5,W
0514:  BTFSC  0E.7
0516:  BSF    FF2.7
0518:  RETURN 0
051A:  DATA 44,69
051C:  DATA 61,20
051E:  DATA 64,65
0520:  DATA 20,6C
0522:  DATA 61,20
0524:  DATA 73,65
0526:  DATA 6D,61
0528:  DATA 6E,61
052A:  DATA 20,28
052C:  DATA 31,2D
052E:  DATA 3E,4C
0530:  DATA 75,6E
0532:  DATA 65,73
0534:  DATA 2C,20
0536:  DATA 32,2D
0538:  DATA 3E,4D
053A:  DATA 61,72
053C:  DATA 74,65
053E:  DATA 73,2C
0540:  DATA 20,2E
0542:  DATA 2E,2E
0544:  DATA 29,3A
0546:  DATA 20,4C
0548:  DATA 55,4E
054A:  DATA 45,53
054C:  DATA 20,20
054E:  DATA 20,20
0550:  DATA 00,00
0552:  MOVFF  FF2,0E
0556:  BCF    FF2.7
0558:  CLRF   FF7
055A:  ADDLW  6C
055C:  MOVWF  FF6
055E:  MOVLW  05
0560:  ADDWFC FF7,F
0562:  TBLRD*+
0564:  MOVF   FF5,W
0566:  BTFSC  0E.7
0568:  BSF    FF2.7
056A:  RETURN 0
056C:  DATA 08,08
056E:  DATA 08,08
0570:  DATA 08,08
0572:  DATA 08,08
0574:  DATA 08,4C
0576:  DATA 55,4E
0578:  DATA 45,53
057A:  DATA 20,20
057C:  DATA 20,20
057E:  DATA 00,00
0580:  MOVFF  FF2,0E
0584:  BCF    FF2.7
0586:  CLRF   FF7
0588:  ADDLW  9A
058A:  MOVWF  FF6
058C:  MOVLW  05
058E:  ADDWFC FF7,F
0590:  TBLRD*+
0592:  MOVF   FF5,W
0594:  BTFSC  0E.7
0596:  BSF    FF2.7
0598:  RETURN 0
059A:  DATA 08,08
059C:  DATA 08,08
059E:  DATA 08,08
05A0:  DATA 08,08
05A2:  DATA 08,4D
05A4:  DATA 41,52
05A6:  DATA 54,45
05A8:  DATA 53,20
05AA:  DATA 20,20
05AC:  DATA 00,00
05AE:  MOVFF  FF2,0E
05B2:  BCF    FF2.7
05B4:  CLRF   FF7
05B6:  ADDLW  C8
05B8:  MOVWF  FF6
05BA:  MOVLW  05
05BC:  ADDWFC FF7,F
05BE:  TBLRD*+
05C0:  MOVF   FF5,W
05C2:  BTFSC  0E.7
05C4:  BSF    FF2.7
05C6:  RETURN 0
05C8:  DATA 08,08
05CA:  DATA 08,08
05CC:  DATA 08,08
05CE:  DATA 08,08
05D0:  DATA 08,4D
05D2:  DATA 49,45
05D4:  DATA 52,43
05D6:  DATA 4F,4C
05D8:  DATA 45,53
05DA:  DATA 00,00
05DC:  MOVFF  FF2,0E
05E0:  BCF    FF2.7
05E2:  CLRF   FF7
05E4:  ADDLW  F6
05E6:  MOVWF  FF6
05E8:  MOVLW  05
05EA:  ADDWFC FF7,F
05EC:  TBLRD*+
05EE:  MOVF   FF5,W
05F0:  BTFSC  0E.7
05F2:  BSF    FF2.7
05F4:  RETURN 0
05F6:  DATA 08,08
05F8:  DATA 08,08
05FA:  DATA 08,08
05FC:  DATA 08,08
05FE:  DATA 08,4A
0600:  DATA 55,45
0602:  DATA 56,45
0604:  DATA 53,20
0606:  DATA 20,20
0608:  DATA 00,00
060A:  MOVFF  FF2,0E
060E:  BCF    FF2.7
0610:  CLRF   FF7
0612:  ADDLW  24
0614:  MOVWF  FF6
0616:  MOVLW  06
0618:  ADDWFC FF7,F
061A:  TBLRD*+
061C:  MOVF   FF5,W
061E:  BTFSC  0E.7
0620:  BSF    FF2.7
0622:  RETURN 0
0624:  DATA 08,08
0626:  DATA 08,08
0628:  DATA 08,08
062A:  DATA 08,08
062C:  DATA 08,56
062E:  DATA 49,45
0630:  DATA 52,4E
0632:  DATA 45,53
0634:  DATA 20,20
0636:  DATA 00,00
0638:  MOVFF  FF2,0E
063C:  BCF    FF2.7
063E:  CLRF   FF7
0640:  ADDLW  52
0642:  MOVWF  FF6
0644:  MOVLW  06
0646:  ADDWFC FF7,F
0648:  TBLRD*+
064A:  MOVF   FF5,W
064C:  BTFSC  0E.7
064E:  BSF    FF2.7
0650:  RETURN 0
0652:  DATA 08,08
0654:  DATA 08,08
0656:  DATA 08,08
0658:  DATA 08,08
065A:  DATA 08,53
065C:  DATA 41,42
065E:  DATA 41,44
0660:  DATA 4F,20
0662:  DATA 20,20
0664:  DATA 00,00
0666:  MOVFF  FF2,0E
066A:  BCF    FF2.7
066C:  CLRF   FF7
066E:  ADDLW  80
0670:  MOVWF  FF6
0672:  MOVLW  06
0674:  ADDWFC FF7,F
0676:  TBLRD*+
0678:  MOVF   FF5,W
067A:  BTFSC  0E.7
067C:  BSF    FF2.7
067E:  RETURN 0
0680:  DATA 08,08
0682:  DATA 08,08
0684:  DATA 08,08
0686:  DATA 08,08
0688:  DATA 08,44
068A:  DATA 4F,4D
068C:  DATA 49,4E
068E:  DATA 47,4F
0690:  DATA 20,20
0692:  DATA 00,00
0694:  MOVFF  FF2,0E
0698:  BCF    FF2.7
069A:  CLRF   FF7
069C:  ADDLW  AE
069E:  MOVWF  FF6
06A0:  MOVLW  06
06A2:  ADDWFC FF7,F
06A4:  TBLRD*+
06A6:  MOVF   FF5,W
06A8:  BTFSC  0E.7
06AA:  BSF    FF2.7
06AC:  RETURN 0
06AE:  DATA 0D,46
06B0:  DATA 45,43
06B2:  DATA 48,41
06B4:  DATA 3A,20
06B6:  DATA 00,00
06B8:  MOVFF  FF2,0E
06BC:  BCF    FF2.7
06BE:  CLRF   FF7
06C0:  ADDLW  D2
06C2:  MOVWF  FF6
06C4:  MOVLW  06
06C6:  ADDWFC FF7,F
06C8:  TBLRD*+
06CA:  MOVF   FF5,W
06CC:  BTFSC  0E.7
06CE:  BSF    FF2.7
06D0:  RETURN 0
06D2:  DATA 0D,52
06D4:  DATA 65,73
06D6:  DATA 65,74
06D8:  DATA 65,61
06DA:  DATA 6E,64
06DC:  DATA 6F,20
06DE:  DATA 69,6E
06E0:  DATA 69,63
06E2:  DATA 69,61
06E4:  DATA 6C,69
06E6:  DATA 7A,61
06E8:  DATA 63,69
06EA:  DATA 6F,6E
06EC:  DATA 2E,2E
06EE:  DATA 2E,0D
06F0:  DATA 00,00
06F2:  MOVFF  FF2,0E
06F6:  BCF    FF2.7
06F8:  CLRF   FF7
06FA:  ADDLW  0C
06FC:  MOVWF  FF6
06FE:  MOVLW  07
0700:  ADDWFC FF7,F
0702:  TBLRD*+
0704:  MOVF   FF5,W
0706:  BTFSC  0E.7
0708:  BSF    FF2.7
070A:  RETURN 0
070C:  DATA 0D,44
070E:  DATA 69,61
0710:  DATA 20,69
0712:  DATA 6E,63
0714:  DATA 6F,72
0716:  DATA 72,65
0718:  DATA 63,74
071A:  DATA 6F,2E
071C:  DATA 20,52
071E:  DATA 65,73
0720:  DATA 65,74
0722:  DATA 65,61
0724:  DATA 6E,64
0726:  DATA 6F,20
0728:  DATA 69,6E
072A:  DATA 69,63
072C:  DATA 69,61
072E:  DATA 6C,69
0730:  DATA 7A,61
0732:  DATA 63,69
0734:  DATA 6F,6E
0736:  DATA 2E,2E
0738:  DATA 2E,0D
073A:  DATA 00,00
073C:  MOVFF  FF2,0E
0740:  BCF    FF2.7
0742:  CLRF   FF7
0744:  ADDLW  56
0746:  MOVWF  FF6
0748:  MOVLW  07
074A:  ADDWFC FF7,F
074C:  TBLRD*+
074E:  MOVF   FF5,W
0750:  BTFSC  0E.7
0752:  BSF    FF2.7
0754:  RETURN 0
0756:  DATA 2F,00
0758:  MOVFF  FF2,0E
075C:  BCF    FF2.7
075E:  CLRF   FF7
0760:  ADDLW  72
0762:  MOVWF  FF6
0764:  MOVLW  07
0766:  ADDWFC FF7,F
0768:  TBLRD*+
076A:  MOVF   FF5,W
076C:  BTFSC  0E.7
076E:  BSF    FF2.7
0770:  RETURN 0
0772:  DATA 0D,4D
0774:  DATA 65,73
0776:  DATA 20,69
0778:  DATA 6E,63
077A:  DATA 6F,72
077C:  DATA 72,65
077E:  DATA 63,74
0780:  DATA 6F,2E
0782:  DATA 20,52
0784:  DATA 65,73
0786:  DATA 65,74
0788:  DATA 65,61
078A:  DATA 6E,64
078C:  DATA 6F,20
078E:  DATA 69,6E
0790:  DATA 69,63
0792:  DATA 69,61
0794:  DATA 6C,69
0796:  DATA 7A,61
0798:  DATA 63,69
079A:  DATA 6F,6E
079C:  DATA 2E,2E
079E:  DATA 2E,0D
07A0:  DATA 00,00
07A2:  MOVFF  FF2,0E
07A6:  BCF    FF2.7
07A8:  CLRF   FF7
07AA:  ADDLW  BC
07AC:  MOVWF  FF6
07AE:  MOVLW  07
07B0:  ADDWFC FF7,F
07B2:  TBLRD*+
07B4:  MOVF   FF5,W
07B6:  BTFSC  0E.7
07B8:  BSF    FF2.7
07BA:  RETURN 0
07BC:  DATA 0D,45
07BE:  DATA 72,72
07C0:  DATA 6F,72
07C2:  DATA 20,65
07C4:  DATA 6E,20
07C6:  DATA 6C,61
07C8:  DATA 20,66
07CA:  DATA 65,63
07CC:  DATA 68,61
07CE:  DATA 2E,20
07D0:  DATA 52,65
07D2:  DATA 73,65
07D4:  DATA 74,65
07D6:  DATA 61,6E
07D8:  DATA 64,6F
07DA:  DATA 20,69
07DC:  DATA 6E,69
07DE:  DATA 63,69
07E0:  DATA 61,6C
07E2:  DATA 69,7A
07E4:  DATA 61,63
07E6:  DATA 69,6F
07E8:  DATA 6E,2E
07EA:  DATA 2E,2E
07EC:  DATA 0D,00
07EE:  MOVFF  FF2,0E
07F2:  BCF    FF2.7
07F4:  CLRF   FF7
07F6:  ADDLW  08
07F8:  MOVWF  FF6
07FA:  MOVLW  08
07FC:  ADDWFC FF7,F
07FE:  TBLRD*+
0800:  MOVF   FF5,W
0802:  BTFSC  0E.7
0804:  BSF    FF2.7
0806:  RETURN 0
0808:  DATA 0D,41
080A:  DATA 6E,6E
080C:  DATA 6F,20
080E:  DATA 69,6E
0810:  DATA 63,6F
0812:  DATA 72,72
0814:  DATA 65,63
0816:  DATA 74,6F
0818:  DATA 2E,20
081A:  DATA 52,65
081C:  DATA 73,65
081E:  DATA 74,65
0820:  DATA 61,6E
0822:  DATA 64,6F
0824:  DATA 20,69
0826:  DATA 6E,69
0828:  DATA 63,69
082A:  DATA 61,6C
082C:  DATA 69,7A
082E:  DATA 61,63
0830:  DATA 69,6F
0832:  DATA 6E,2E
0834:  DATA 2E,2E
0836:  DATA 0D,00
0838:  MOVFF  FF2,0E
083C:  BCF    FF2.7
083E:  CLRF   FF7
0840:  ADDLW  52
0842:  MOVWF  FF6
0844:  MOVLW  08
0846:  ADDWFC FF7,F
0848:  TBLRD*+
084A:  MOVF   FF5,W
084C:  BTFSC  0E.7
084E:  BSF    FF2.7
0850:  RETURN 0
0852:  DATA 0D,45
0854:  DATA 6C,20
0856:  DATA 61,6E
0858:  DATA 6E,6F
085A:  DATA 20,6E
085C:  DATA 6F,20
085E:  DATA 65,73
0860:  DATA 20,62
0862:  DATA 69,73
0864:  DATA 69,65
0866:  DATA 73,74
0868:  DATA 6F,2E
086A:  DATA 20,52
086C:  DATA 65,73
086E:  DATA 65,74
0870:  DATA 65,61
0872:  DATA 6E,64
0874:  DATA 6F,20
0876:  DATA 69,6E
0878:  DATA 69,63
087A:  DATA 69,61
087C:  DATA 6C,69
087E:  DATA 7A,61
0880:  DATA 63,69
0882:  DATA 6F,6E
0884:  DATA 2E,2E
0886:  DATA 2E,0D
0888:  DATA 00,00
088A:  MOVFF  FF2,0E
088E:  BCF    FF2.7
0890:  CLRF   FF7
0892:  ADDLW  A4
0894:  MOVWF  FF6
0896:  MOVLW  08
0898:  ADDWFC FF7,F
089A:  TBLRD*+
089C:  MOVF   FF5,W
089E:  BTFSC  0E.7
08A0:  BSF    FF2.7
08A2:  RETURN 0
08A4:  DATA 0D,48
08A6:  DATA 4F,52
08A8:  DATA 41,3A
08AA:  DATA 20,00
08AC:  MOVFF  FF2,0E
08B0:  BCF    FF2.7
08B2:  CLRF   FF7
08B4:  ADDLW  C6
08B6:  MOVWF  FF6
08B8:  MOVLW  08
08BA:  ADDWFC FF7,F
08BC:  TBLRD*+
08BE:  MOVF   FF5,W
08C0:  BTFSC  0E.7
08C2:  BSF    FF2.7
08C4:  RETURN 0
08C6:  DATA 0D,52
08C8:  DATA 65,73
08CA:  DATA 65,74
08CC:  DATA 65,61
08CE:  DATA 6E,64
08D0:  DATA 6F,20
08D2:  DATA 6C,61
08D4:  DATA 20,69
08D6:  DATA 6E,69
08D8:  DATA 63,69
08DA:  DATA 61,6C
08DC:  DATA 69,7A
08DE:  DATA 61,63
08E0:  DATA 69,6F
08E2:  DATA 6E,2E
08E4:  DATA 2E,2E
08E6:  DATA 0D,00
08E8:  MOVFF  FF2,0E
08EC:  BCF    FF2.7
08EE:  CLRF   FF7
08F0:  ADDLW  02
08F2:  MOVWF  FF6
08F4:  MOVLW  09
08F6:  ADDWFC FF7,F
08F8:  TBLRD*+
08FA:  MOVF   FF5,W
08FC:  BTFSC  0E.7
08FE:  BSF    FF2.7
0900:  RETURN 0
0902:  DATA 20,20
0904:  DATA 48,6F
0906:  DATA 72,61
0908:  DATA 20,69
090A:  DATA 6E,63
090C:  DATA 6F,72
090E:  DATA 72,65
0910:  DATA 63,74
0912:  DATA 61,21
0914:  DATA 00,00
0916:  MOVFF  FF2,0E
091A:  BCF    FF2.7
091C:  CLRF   FF7
091E:  ADDLW  30
0920:  MOVWF  FF6
0922:  MOVLW  09
0924:  ADDWFC FF7,F
0926:  TBLRD*+
0928:  MOVF   FF5,W
092A:  BTFSC  0E.7
092C:  BSF    FF2.7
092E:  RETURN 0
0930:  DATA 3A,00
0932:  MOVFF  FF2,0E
0936:  BCF    FF2.7
0938:  CLRF   FF7
093A:  ADDLW  4C
093C:  MOVWF  FF6
093E:  MOVLW  09
0940:  ADDWFC FF7,F
0942:  TBLRD*+
0944:  MOVF   FF5,W
0946:  BTFSC  0E.7
0948:  BSF    FF2.7
094A:  RETURN 0
094C:  DATA 20,20
094E:  DATA 4D,69
0950:  DATA 6E,75
0952:  DATA 74,6F
0954:  DATA 73,20
0956:  DATA 69,6E
0958:  DATA 63,6F
095A:  DATA 72,72
095C:  DATA 65,63
095E:  DATA 74,6F
0960:  DATA 73,21
0962:  DATA 00,00
0964:  MOVFF  FF2,0E
0968:  BCF    FF2.7
096A:  CLRF   FF7
096C:  ADDLW  7E
096E:  MOVWF  FF6
0970:  MOVLW  09
0972:  ADDWFC FF7,F
0974:  TBLRD*+
0976:  MOVF   FF5,W
0978:  BTFSC  0E.7
097A:  BSF    FF2.7
097C:  RETURN 0
097E:  DATA 0D,47
0980:  DATA 75,61
0982:  DATA 72,64
0984:  DATA 61,6E
0986:  DATA 64,6F
0988:  DATA 20,63
098A:  DATA 6F,6E
098C:  DATA 66,69
098E:  DATA 67,75
0990:  DATA 72,61
0992:  DATA 63,69
0994:  DATA 6F,6E
0996:  DATA 2E,2E
0998:  DATA 2E,00
099A:  MOVFF  FF2,0E
099E:  BCF    FF2.7
09A0:  CLRF   FF7
09A2:  ADDLW  B4
09A4:  MOVWF  FF6
09A6:  MOVLW  09
09A8:  ADDWFC FF7,F
09AA:  TBLRD*+
09AC:  MOVF   FF5,W
09AE:  BTFSC  0E.7
09B0:  BSF    FF2.7
09B2:  RETURN 0
09B4:  DATA 0D,49
09B6:  DATA 6E,69
09B8:  DATA 63,69
09BA:  DATA 61,6E
09BC:  DATA 64,6F
09BE:  DATA 20,73
09C0:  DATA 69,73
09C2:  DATA 74,65
09C4:  DATA 6D,61
09C6:  DATA 2E,2E
09C8:  DATA 2E,0D
09CA:  DATA 00,00
09CC:  MOVFF  FF2,0E
09D0:  BCF    FF2.7
09D2:  CLRF   FF7
09D4:  ADDLW  E6
09D6:  MOVWF  FF6
09D8:  MOVLW  09
09DA:  ADDWFC FF7,F
09DC:  TBLRD*+
09DE:  MOVF   FF5,W
09E0:  BTFSC  0E.7
09E2:  BSF    FF2.7
09E4:  RETURN 0
09E6:  DATA 54,45
09E8:  DATA 4D,50
09EA:  DATA 20,2D
09EC:  DATA 20,25
09EE:  DATA 33,2E
09F0:  DATA 31,66
09F2:  DATA 20,25
09F4:  DATA 63,43
09F6:  DATA 0A,48
09F8:  DATA 4F,52
09FA:  DATA 41,20
09FC:  DATA 2D,20
09FE:  DATA 00,00
0A00:  MOVFF  FF2,0E
0A04:  BCF    FF2.7
0A06:  CLRF   FF7
0A08:  ADDLW  1A
0A0A:  MOVWF  FF6
0A0C:  MOVLW  0A
0A0E:  ADDWFC FF7,F
0A10:  TBLRD*+
0A12:  MOVF   FF5,W
0A14:  BTFSC  0E.7
0A16:  BSF    FF2.7
0A18:  RETURN 0
0A1A:  DATA 0D,52
0A1C:  DATA 45,47
0A1E:  DATA 49,53
0A20:  DATA 54,52
0A22:  DATA 4F,20
0A24:  DATA 44,45
0A26:  DATA 20,45
0A28:  DATA 56,45
0A2A:  DATA 4E,54
0A2C:  DATA 4F,53
0A2E:  DATA 0D,00
0A30:  MOVFF  FF2,0E
0A34:  BCF    FF2.7
0A36:  CLRF   FF7
0A38:  ADDLW  4A
0A3A:  MOVWF  FF6
0A3C:  MOVLW  0A
0A3E:  ADDWFC FF7,F
0A40:  TBLRD*+
0A42:  MOVF   FF5,W
0A44:  BTFSC  0E.7
0A46:  BSF    FF2.7
0A48:  RETURN 0
0A4A:  DATA 2A,2A
0A4C:  DATA 2A,2A
0A4E:  DATA 2A,2A
0A50:  DATA 2A,2A
0A52:  DATA 2A,2A
0A54:  DATA 2A,2A
0A56:  DATA 2A,2A
0A58:  DATA 2A,2A
0A5A:  DATA 2A,2A
0A5C:  DATA 2A,0D
0A5E:  DATA 00,00
0A60:  MOVFF  FF2,0E
0A64:  BCF    FF2.7
0A66:  CLRF   FF7
0A68:  ADDLW  7A
0A6A:  MOVWF  FF6
0A6C:  MOVLW  0A
0A6E:  ADDWFC FF7,F
0A70:  TBLRD*+
0A72:  MOVF   FF5,W
0A74:  BTFSC  0E.7
0A76:  BSF    FF2.7
0A78:  RETURN 0
0A7A:  DATA 46,65
0A7C:  DATA 63,68
0A7E:  DATA 61,20
0A80:  DATA 20,20
0A82:  DATA 20,20
0A84:  DATA 20,20
0A86:  DATA 20,20
0A88:  DATA 20,20
0A8A:  DATA 54,65
0A8C:  DATA 6D,70
0A8E:  DATA 2E,20
0A90:  DATA 20,20
0A92:  DATA 20,54
0A94:  DATA 65,72
0A96:  DATA 6D,2E
0A98:  DATA 20,20
0A9A:  DATA 4D,69
0A9C:  DATA 6E,2E
0A9E:  DATA 53,2E
0AA0:  DATA 20,20
0AA2:  DATA 4D,69
0AA4:  DATA 6E,2E
0AA6:  DATA 43,2E
0AA8:  DATA 0D,00
0AAA:  MOVFF  FF2,0E
0AAE:  BCF    FF2.7
0AB0:  CLRF   FF7
0AB2:  ADDLW  C4
0AB4:  MOVWF  FF6
0AB6:  MOVLW  0A
0AB8:  ADDWFC FF7,F
0ABA:  TBLRD*+
0ABC:  MOVF   FF5,W
0ABE:  BTFSC  0E.7
0AC0:  BSF    FF2.7
0AC2:  RETURN 0
0AC4:  DATA 3D,3D
0AC6:  DATA 3D,3D
0AC8:  DATA 3D,3D
0ACA:  DATA 3D,3D
0ACC:  DATA 3D,3D
0ACE:  DATA 3D,3D
0AD0:  DATA 3D,3D
0AD2:  DATA 3D,3D
0AD4:  DATA 3D,3D
0AD6:  DATA 3D,3D
0AD8:  DATA 3D,3D
0ADA:  DATA 3D,3D
0ADC:  DATA 3D,3D
0ADE:  DATA 3D,3D
0AE0:  DATA 3D,3D
0AE2:  DATA 3D,3D
0AE4:  DATA 3D,3D
0AE6:  DATA 3D,3D
0AE8:  DATA 3D,3D
0AEA:  DATA 3D,3D
0AEC:  DATA 3D,3D
0AEE:  DATA 3D,3D
0AF0:  DATA 3D,3D
0AF2:  DATA 0D,00
0AF4:  MOVFF  FF2,0E
0AF8:  BCF    FF2.7
0AFA:  CLRF   FF7
0AFC:  ADDLW  0E
0AFE:  MOVWF  FF6
0B00:  MOVLW  0B
0B02:  ADDWFC FF7,F
0B04:  TBLRD*+
0B06:  MOVF   FF5,W
0B08:  BTFSC  0E.7
0B0A:  BSF    FF2.7
0B0C:  RETURN 0
0B0E:  DATA 20,00
0B10:  MOVFF  FF2,0E
0B14:  BCF    FF2.7
0B16:  CLRF   FF7
0B18:  ADDLW  2A
0B1A:  MOVWF  FF6
0B1C:  MOVLW  0B
0B1E:  ADDWFC FF7,F
0B20:  TBLRD*+
0B22:  MOVF   FF5,W
0B24:  BTFSC  0E.7
0B26:  BSF    FF2.7
0B28:  RETURN 0
0B2A:  DATA 0D,3D
0B2C:  DATA 3D,3D
0B2E:  DATA 3D,3D
0B30:  DATA 3D,3D
0B32:  DATA 3D,3D
0B34:  DATA 3D,3D
0B36:  DATA 3D,3D
0B38:  DATA 3D,3D
0B3A:  DATA 3D,3D
0B3C:  DATA 3D,3D
0B3E:  DATA 3D,3D
0B40:  DATA 3D,3D
0B42:  DATA 3D,3D
0B44:  DATA 3D,3D
0B46:  DATA 3D,3D
0B48:  DATA 3D,3D
0B4A:  DATA 3D,3D
0B4C:  DATA 3D,3D
0B4E:  DATA 3D,3D
0B50:  DATA 3D,3D
0B52:  DATA 3D,3D
0B54:  DATA 3D,3D
0B56:  DATA 3D,3D
0B58:  DATA 0D,00
0B5A:  MOVFF  FF2,0E
0B5E:  BCF    FF2.7
0B60:  CLRF   FF7
0B62:  ADDLW  74
0B64:  MOVWF  FF6
0B66:  MOVLW  0B
0B68:  ADDWFC FF7,F
0B6A:  TBLRD*+
0B6C:  MOVF   FF5,W
0B6E:  BTFSC  0E.7
0B70:  BSF    FF2.7
0B72:  RETURN 0
0B74:  DATA BF,51
0B76:  DATA 75,65
0B78:  DATA 20,6F
0B7A:  DATA 70,65
0B7C:  DATA 72,61
0B7E:  DATA 63,69
0B80:  DATA 6F,6E
0B82:  DATA 20,64
0B84:  DATA 65,73
0B86:  DATA 65,61
0B88:  DATA 20,72
0B8A:  DATA 65,61
0B8C:  DATA 6C,69
0B8E:  DATA 7A,61
0B90:  DATA 72,3F
0B92:  DATA 0D,00
0B94:  MOVFF  FF2,0E
0B98:  BCF    FF2.7
0B9A:  CLRF   FF7
0B9C:  ADDLW  AE
0B9E:  MOVWF  FF6
0BA0:  MOVLW  0B
0BA2:  ADDWFC FF7,F
0BA4:  TBLRD*+
0BA6:  MOVF   FF5,W
0BA8:  BTFSC  0E.7
0BAA:  BSF    FF2.7
0BAC:  RETURN 0
0BAE:  DATA 30,2E
0BB0:  DATA 20,53
0BB2:  DATA 61,6C
0BB4:  DATA 69,72
0BB6:  DATA 0D,00
0BB8:  MOVFF  FF2,0E
0BBC:  BCF    FF2.7
0BBE:  CLRF   FF7
0BC0:  ADDLW  D2
0BC2:  MOVWF  FF6
0BC4:  MOVLW  0B
0BC6:  ADDWFC FF7,F
0BC8:  TBLRD*+
0BCA:  MOVF   FF5,W
0BCC:  BTFSC  0E.7
0BCE:  BSF    FF2.7
0BD0:  RETURN 0
0BD2:  DATA 31,2E
0BD4:  DATA 20,45
0BD6:  DATA 78,74
0BD8:  DATA 72,61
0BDA:  DATA 65,72
0BDC:  DATA 20,74
0BDE:  DATA 69,65
0BE0:  DATA 6D,70
0BE2:  DATA 6F,73
0BE4:  DATA 20,6D
0BE6:  DATA 65,64
0BE8:  DATA 69,6F
0BEA:  DATA 73,20
0BEC:  DATA 70,6F
0BEE:  DATA 72,20
0BF0:  DATA 64,69
0BF2:  DATA 61,0D
0BF4:  DATA 00,00
0BF6:  MOVFF  FF2,0E
0BFA:  BCF    FF2.7
0BFC:  CLRF   FF7
0BFE:  ADDLW  10
0C00:  MOVWF  FF6
0C02:  MOVLW  0C
0C04:  ADDWFC FF7,F
0C06:  TBLRD*+
0C08:  MOVF   FF5,W
0C0A:  BTFSC  0E.7
0C0C:  BSF    FF2.7
0C0E:  RETURN 0
0C10:  DATA 32,2E
0C12:  DATA 20,45
0C14:  DATA 78,74
0C16:  DATA 72,61
0C18:  DATA 65,72
0C1A:  DATA 20,74
0C1C:  DATA 69,65
0C1E:  DATA 6D,70
0C20:  DATA 6F,73
0C22:  DATA 20,74
0C24:  DATA 6F,74
0C26:  DATA 61,6C
0C28:  DATA 65,73
0C2A:  DATA 0D,00
0C2C:  MOVFF  FF2,0E
0C30:  BCF    FF2.7
0C32:  CLRF   FF7
0C34:  ADDLW  46
0C36:  MOVWF  FF6
0C38:  MOVLW  0C
0C3A:  ADDWFC FF7,F
0C3C:  TBLRD*+
0C3E:  MOVF   FF5,W
0C40:  BTFSC  0E.7
0C42:  BSF    FF2.7
0C44:  RETURN 0
0C46:  DATA 33,2E
0C48:  DATA 20,45
0C4A:  DATA 78,74
0C4C:  DATA 72,61
0C4E:  DATA 65,72
0C50:  DATA 20,64
0C52:  DATA 61,74
0C54:  DATA 6F,73
0C56:  DATA 20,6D
0C58:  DATA 65,6E
0C5A:  DATA 73,75
0C5C:  DATA 61,6C
0C5E:  DATA 65,73
0C60:  DATA 0D,00
0C62:  MOVFF  FF2,0E
0C66:  BCF    FF2.7
0C68:  CLRF   FF7
0C6A:  ADDLW  7C
0C6C:  MOVWF  FF6
0C6E:  MOVLW  0C
0C70:  ADDWFC FF7,F
0C72:  TBLRD*+
0C74:  MOVF   FF5,W
0C76:  BTFSC  0E.7
0C78:  BSF    FF2.7
0C7A:  RETURN 0
0C7C:  DATA 3D,3D
0C7E:  DATA 3D,3D
0C80:  DATA 3D,3D
0C82:  DATA 3D,3D
0C84:  DATA 3D,3D
0C86:  DATA 3D,3D
0C88:  DATA 3D,3D
0C8A:  DATA 3D,3D
0C8C:  DATA 3D,3D
0C8E:  DATA 3D,3D
0C90:  DATA 3D,3D
0C92:  DATA 3D,3D
0C94:  DATA 3D,3D
0C96:  DATA 3D,3D
0C98:  DATA 3D,3D
0C9A:  DATA 3D,3D
0C9C:  DATA 3D,3D
0C9E:  DATA 3D,3D
0CA0:  DATA 3D,3D
0CA2:  DATA 3D,3D
0CA4:  DATA 3D,3D
0CA6:  DATA 3D,3D
0CA8:  DATA 3D,0D
0CAA:  DATA 00,00
0CAC:  MOVFF  FF2,0E
0CB0:  BCF    FF2.7
0CB2:  CLRF   FF7
0CB4:  ADDLW  C6
0CB6:  MOVWF  FF6
0CB8:  MOVLW  0C
0CBA:  ADDWFC FF7,F
0CBC:  TBLRD*+
0CBE:  MOVF   FF5,W
0CC0:  BTFSC  0E.7
0CC2:  BSF    FF2.7
0CC4:  RETURN 0
0CC6:  DATA 0D,53
0CC8:  DATA 61,6C
0CCA:  DATA 69,65
0CCC:  DATA 6E,64
0CCE:  DATA 6F,2E
0CD0:  DATA 2E,2E
0CD2:  DATA 0D,00
0CD4:  MOVFF  FF2,0E
0CD8:  BCF    FF2.7
0CDA:  CLRF   FF7
0CDC:  ADDLW  EE
0CDE:  MOVWF  FF6
0CE0:  MOVLW  0C
0CE2:  ADDWFC FF7,F
0CE4:  TBLRD*+
0CE6:  MOVF   FF5,W
0CE8:  BTFSC  0E.7
0CEA:  BSF    FF2.7
0CEC:  RETURN 0
0CEE:  DATA 0D,54
0CF0:  DATA 2E,20
0CF2:  DATA 6D,65
0CF4:  DATA 64,69
0CF6:  DATA 6F,20
0CF8:  DATA 65,6E
0CFA:  DATA 63,65
0CFC:  DATA 6E,64
0CFE:  DATA 69,64
0D00:  DATA 6F,20
0D02:  DATA 73,69
0D04:  DATA 73,74
0D06:  DATA 65,6D
0D08:  DATA 61,20
0D0A:  DATA 70,6F
0D0C:  DATA 72,20
0D0E:  DATA 64,69
0D10:  DATA 61,3A
0D12:  DATA 20,25
0D14:  DATA 33,2E
0D16:  DATA 32,66
0D18:  DATA 20,6D
0D1A:  DATA 69,6E
0D1C:  DATA 75,74
0D1E:  DATA 6F,73
0D20:  DATA 0D,0D
0D22:  DATA 00,00
0D24:  MOVFF  FF2,0E
0D28:  BCF    FF2.7
0D2A:  CLRF   FF7
0D2C:  ADDLW  3E
0D2E:  MOVWF  FF6
0D30:  MOVLW  0D
0D32:  ADDWFC FF7,F
0D34:  TBLRD*+
0D36:  MOVF   FF5,W
0D38:  BTFSC  0E.7
0D3A:  BSF    FF2.7
0D3C:  RETURN 0
0D3E:  DATA 54,2E
0D40:  DATA 20,6D
0D42:  DATA 65,64
0D44:  DATA 69,6F
0D46:  DATA 20,65
0D48:  DATA 6E,63
0D4A:  DATA 65,6E
0D4C:  DATA 64,69
0D4E:  DATA 64,6F
0D50:  DATA 20,63
0D52:  DATA 61,6C
0D54:  DATA 64,65
0D56:  DATA 72,61
0D58:  DATA 20,70
0D5A:  DATA 6F,72
0D5C:  DATA 20,64
0D5E:  DATA 69,61
0D60:  DATA 3A,20
0D62:  DATA 25,33
0D64:  DATA 2E,32
0D66:  DATA 66,20
0D68:  DATA 6D,69
0D6A:  DATA 6E,75
0D6C:  DATA 74,6F
0D6E:  DATA 73,0D
0D70:  DATA 0D,00
0D72:  MOVFF  FF2,0E
0D76:  BCF    FF2.7
0D78:  CLRF   FF7
0D7A:  ADDLW  8C
0D7C:  MOVWF  FF6
0D7E:  MOVLW  0D
0D80:  ADDWFC FF7,F
0D82:  TBLRD*+
0D84:  MOVF   FF5,W
0D86:  BTFSC  0E.7
0D88:  BSF    FF2.7
0D8A:  RETURN 0
0D8C:  DATA 0D,54
0D8E:  DATA 2E,20
0D90:  DATA 74,6F
0D92:  DATA 74,61
0D94:  DATA 6C,20
0D96:  DATA 65,6E
0D98:  DATA 63,65
0D9A:  DATA 6E,64
0D9C:  DATA 69,64
0D9E:  DATA 6F,20
0DA0:  DATA 73,69
0DA2:  DATA 73,74
0DA4:  DATA 65,6D
0DA6:  DATA 61,3A
0DA8:  DATA 20,25
0DAA:  DATA 6C,75
0DAC:  DATA 20,6D
0DAE:  DATA 69,6E
0DB0:  DATA 75,74
0DB2:  DATA 6F,73
0DB4:  DATA 0D,0D
0DB6:  DATA 00,00
0DB8:  MOVFF  FF2,0E
0DBC:  BCF    FF2.7
0DBE:  CLRF   FF7
0DC0:  ADDLW  D2
0DC2:  MOVWF  FF6
0DC4:  MOVLW  0D
0DC6:  ADDWFC FF7,F
0DC8:  TBLRD*+
0DCA:  MOVF   FF5,W
0DCC:  BTFSC  0E.7
0DCE:  BSF    FF2.7
0DD0:  RETURN 0
0DD2:  DATA 54,2E
0DD4:  DATA 20,74
0DD6:  DATA 6F,74
0DD8:  DATA 61,6C
0DDA:  DATA 20,65
0DDC:  DATA 6E,63
0DDE:  DATA 65,6E
0DE0:  DATA 64,69
0DE2:  DATA 64,6F
0DE4:  DATA 20,63
0DE6:  DATA 61,6C
0DE8:  DATA 64,65
0DEA:  DATA 72,61
0DEC:  DATA 3A,20
0DEE:  DATA 25,6C
0DF0:  DATA 75,20
0DF2:  DATA 6D,69
0DF4:  DATA 6E,75
0DF6:  DATA 74,6F
0DF8:  DATA 73,0D
0DFA:  DATA 0D,00
0DFC:  MOVFF  FF2,0E
0E00:  BCF    FF2.7
0E02:  CLRF   FF7
0E04:  ADDLW  16
0E06:  MOVWF  FF6
0E08:  MOVLW  0E
0E0A:  ADDWFC FF7,F
0E0C:  TBLRD*+
0E0E:  MOVF   FF5,W
0E10:  BTFSC  0E.7
0E12:  BSF    FF2.7
0E14:  RETURN 0
0E16:  DATA 0D,32
0E18:  DATA 30,00
0E1A:  MOVFF  FF2,0E
0E1E:  BCF    FF2.7
0E20:  CLRF   FF7
0E22:  ADDLW  34
0E24:  MOVWF  FF6
0E26:  MOVLW  0E
0E28:  ADDWFC FF7,F
0E2A:  TBLRD*+
0E2C:  MOVF   FF5,W
0E2E:  BTFSC  0E.7
0E30:  BSF    FF2.7
0E32:  RETURN 0
0E34:  DATA 2D,2D
0E36:  DATA 2D,2D
0E38:  DATA 2D,2D
0E3A:  DATA 2D,2D
0E3C:  DATA 2D,2D
0E3E:  DATA 2D,2D
0E40:  DATA 2D,2D
0E42:  DATA 2D,2D
0E44:  DATA 2D,2D
0E46:  DATA 2D,2D
0E48:  DATA 2D,2D
0E4A:  DATA 2D,2D
0E4C:  DATA 2D,2D
0E4E:  DATA 2D,2D
0E50:  DATA 2D,2D
0E52:  DATA 2D,2D
0E54:  DATA 2D,2D
0E56:  DATA 2D,2D
0E58:  DATA 2D,2D
0E5A:  DATA 2D,2D
0E5C:  DATA 2D,2D
0E5E:  DATA 2D,2D
0E60:  DATA 2D,2D
0E62:  DATA 2D,2D
0E64:  DATA 2D,2D
0E66:  DATA 2D,2D
0E68:  DATA 2D,0D
0E6A:  DATA 00,00
0E6C:  MOVFF  FF2,0E
0E70:  BCF    FF2.7
0E72:  CLRF   FF7
0E74:  ADDLW  86
0E76:  MOVWF  FF6
0E78:  MOVLW  0E
0E7A:  ADDWFC FF7,F
0E7C:  TBLRD*+
0E7E:  MOVF   FF5,W
0E80:  BTFSC  0E.7
0E82:  BSF    FF2.7
0E84:  RETURN 0
0E86:  DATA 20,20
0E88:  DATA 20,20
0E8A:  DATA 20,20
0E8C:  DATA 20,20
0E8E:  DATA 20,20
0E90:  DATA 20,54
0E92:  DATA 2E,20
0E94:  DATA 73,69
0E96:  DATA 73,74
0E98:  DATA 65,6D
0E9A:  DATA 61,20
0E9C:  DATA 28,6D
0E9E:  DATA 69,6E
0EA0:  DATA 2F,64
0EA2:  DATA 69,61
0EA4:  DATA 29,20
0EA6:  DATA 20,54
0EA8:  DATA 2E,20
0EAA:  DATA 63,61
0EAC:  DATA 6C,64
0EAE:  DATA 65,72
0EB0:  DATA 61,20
0EB2:  DATA 28,6D
0EB4:  DATA 69,6E
0EB6:  DATA 2F,64
0EB8:  DATA 69,61
0EBA:  DATA 29,0D
0EBC:  DATA 00,00
0EBE:  MOVFF  FF2,0E
0EC2:  BCF    FF2.7
0EC4:  CLRF   FF7
0EC6:  ADDLW  D8
0EC8:  MOVWF  FF6
0ECA:  MOVLW  0E
0ECC:  ADDWFC FF7,F
0ECE:  TBLRD*+
0ED0:  MOVF   FF5,W
0ED2:  BTFSC  0E.7
0ED4:  BSF    FF2.7
0ED6:  RETURN 0
0ED8:  DATA 45,4E
0EDA:  DATA 45,52
0EDC:  DATA 4F,25
0EDE:  DATA 33,2E
0EE0:  DATA 32,66
0EE2:  DATA 25,33
0EE4:  DATA 2E,32
0EE6:  DATA 66,0D
0EE8:  DATA 00,00
0EEA:  MOVFF  FF2,0E
0EEE:  BCF    FF2.7
0EF0:  CLRF   FF7
0EF2:  ADDLW  04
0EF4:  MOVWF  FF6
0EF6:  MOVLW  0F
0EF8:  ADDWFC FF7,F
0EFA:  TBLRD*+
0EFC:  MOVF   FF5,W
0EFE:  BTFSC  0E.7
0F00:  BSF    FF2.7
0F02:  RETURN 0
0F04:  DATA 46,45
0F06:  DATA 42,52
0F08:  DATA 45,52
0F0A:  DATA 4F,25
0F0C:  DATA 33,2E
0F0E:  DATA 32,66
0F10:  DATA 25,33
0F12:  DATA 2E,32
0F14:  DATA 66,0D
0F16:  DATA 00,00
0F18:  MOVFF  FF2,0E
0F1C:  BCF    FF2.7
0F1E:  CLRF   FF7
0F20:  ADDLW  32
0F22:  MOVWF  FF6
0F24:  MOVLW  0F
0F26:  ADDWFC FF7,F
0F28:  TBLRD*+
0F2A:  MOVF   FF5,W
0F2C:  BTFSC  0E.7
0F2E:  BSF    FF2.7
0F30:  RETURN 0
0F32:  DATA 4D,41
0F34:  DATA 52,5A
0F36:  DATA 4F,25
0F38:  DATA 33,2E
0F3A:  DATA 32,66
0F3C:  DATA 25,33
0F3E:  DATA 2E,32
0F40:  DATA 66,0D
0F42:  DATA 00,00
0F44:  MOVFF  FF2,0E
0F48:  BCF    FF2.7
0F4A:  CLRF   FF7
0F4C:  ADDLW  5E
0F4E:  MOVWF  FF6
0F50:  MOVLW  0F
0F52:  ADDWFC FF7,F
0F54:  TBLRD*+
0F56:  MOVF   FF5,W
0F58:  BTFSC  0E.7
0F5A:  BSF    FF2.7
0F5C:  RETURN 0
0F5E:  DATA 41,42
0F60:  DATA 52,49
0F62:  DATA 4C,25
0F64:  DATA 33,2E
0F66:  DATA 32,66
0F68:  DATA 25,33
0F6A:  DATA 2E,32
0F6C:  DATA 66,0D
0F6E:  DATA 00,00
0F70:  MOVFF  FF2,0E
0F74:  BCF    FF2.7
0F76:  CLRF   FF7
0F78:  ADDLW  8A
0F7A:  MOVWF  FF6
0F7C:  MOVLW  0F
0F7E:  ADDWFC FF7,F
0F80:  TBLRD*+
0F82:  MOVF   FF5,W
0F84:  BTFSC  0E.7
0F86:  BSF    FF2.7
0F88:  RETURN 0
0F8A:  DATA 4D,41
0F8C:  DATA 59,4F
0F8E:  DATA 25,33
0F90:  DATA 2E,32
0F92:  DATA 66,25
0F94:  DATA 33,2E
0F96:  DATA 32,66
0F98:  DATA 0D,00
0F9A:  MOVFF  FF2,0E
0F9E:  BCF    FF2.7
0FA0:  CLRF   FF7
0FA2:  ADDLW  B4
0FA4:  MOVWF  FF6
0FA6:  MOVLW  0F
0FA8:  ADDWFC FF7,F
0FAA:  TBLRD*+
0FAC:  MOVF   FF5,W
0FAE:  BTFSC  0E.7
0FB0:  BSF    FF2.7
0FB2:  RETURN 0
0FB4:  DATA 4A,55
0FB6:  DATA 4E,49
0FB8:  DATA 4F,25
0FBA:  DATA 33,2E
0FBC:  DATA 32,66
0FBE:  DATA 25,33
0FC0:  DATA 2E,32
0FC2:  DATA 66,0D
0FC4:  DATA 00,00
0FC6:  MOVFF  FF2,0E
0FCA:  BCF    FF2.7
0FCC:  CLRF   FF7
0FCE:  ADDLW  E0
0FD0:  MOVWF  FF6
0FD2:  MOVLW  0F
0FD4:  ADDWFC FF7,F
0FD6:  TBLRD*+
0FD8:  MOVF   FF5,W
0FDA:  BTFSC  0E.7
0FDC:  BSF    FF2.7
0FDE:  RETURN 0
0FE0:  DATA 4A,55
0FE2:  DATA 4C,49
0FE4:  DATA 4F,25
0FE6:  DATA 33,2E
0FE8:  DATA 32,66
0FEA:  DATA 25,33
0FEC:  DATA 2E,32
0FEE:  DATA 66,0D
0FF0:  DATA 00,00
0FF2:  MOVFF  FF2,0E
0FF6:  BCF    FF2.7
0FF8:  CLRF   FF7
0FFA:  ADDLW  0C
0FFC:  MOVWF  FF6
0FFE:  MOVLW  10
1000:  ADDWFC FF7,F
1002:  TBLRD*+
1004:  MOVF   FF5,W
1006:  BTFSC  0E.7
1008:  BSF    FF2.7
100A:  RETURN 0
100C:  DATA 41,47
100E:  DATA 4F,53
1010:  DATA 54,4F
1012:  DATA 25,33
1014:  DATA 2E,32
1016:  DATA 66,25
1018:  DATA 33,2E
101A:  DATA 32,66
101C:  DATA 0D,00
101E:  MOVFF  FF2,0E
1022:  BCF    FF2.7
1024:  CLRF   FF7
1026:  ADDLW  38
1028:  MOVWF  FF6
102A:  MOVLW  10
102C:  ADDWFC FF7,F
102E:  TBLRD*+
1030:  MOVF   FF5,W
1032:  BTFSC  0E.7
1034:  BSF    FF2.7
1036:  RETURN 0
1038:  DATA 53,45
103A:  DATA 50,54
103C:  DATA 49,45
103E:  DATA 4D,42
1040:  DATA 52,45
1042:  DATA 25,33
1044:  DATA 2E,32
1046:  DATA 66,25
1048:  DATA 33,2E
104A:  DATA 32,66
104C:  DATA 0D,00
104E:  MOVFF  FF2,0E
1052:  BCF    FF2.7
1054:  CLRF   FF7
1056:  ADDLW  68
1058:  MOVWF  FF6
105A:  MOVLW  10
105C:  ADDWFC FF7,F
105E:  TBLRD*+
1060:  MOVF   FF5,W
1062:  BTFSC  0E.7
1064:  BSF    FF2.7
1066:  RETURN 0
1068:  DATA 4F,43
106A:  DATA 54,55
106C:  DATA 42,52
106E:  DATA 45,25
1070:  DATA 33,2E
1072:  DATA 32,66
1074:  DATA 25,33
1076:  DATA 2E,32
1078:  DATA 66,0D
107A:  DATA 00,00
107C:  MOVFF  FF2,0E
1080:  BCF    FF2.7
1082:  CLRF   FF7
1084:  ADDLW  96
1086:  MOVWF  FF6
1088:  MOVLW  10
108A:  ADDWFC FF7,F
108C:  TBLRD*+
108E:  MOVF   FF5,W
1090:  BTFSC  0E.7
1092:  BSF    FF2.7
1094:  RETURN 0
1096:  DATA 4E,4F
1098:  DATA 56,49
109A:  DATA 45,4D
109C:  DATA 42,52
109E:  DATA 45,25
10A0:  DATA 33,2E
10A2:  DATA 32,66
10A4:  DATA 25,33
10A6:  DATA 2E,32
10A8:  DATA 66,0D
10AA:  DATA 00,00
10AC:  MOVFF  FF2,0E
10B0:  BCF    FF2.7
10B2:  CLRF   FF7
10B4:  ADDLW  C6
10B6:  MOVWF  FF6
10B8:  MOVLW  10
10BA:  ADDWFC FF7,F
10BC:  TBLRD*+
10BE:  MOVF   FF5,W
10C0:  BTFSC  0E.7
10C2:  BSF    FF2.7
10C4:  RETURN 0
10C6:  DATA 44,49
10C8:  DATA 43,49
10CA:  DATA 45,4D
10CC:  DATA 42,52
10CE:  DATA 45,25
10D0:  DATA 33,2E
10D2:  DATA 32,66
10D4:  DATA 25,33
10D6:  DATA 2E,32
10D8:  DATA 66,0D
10DA:  DATA 00,00
*
1242:  CLRF   00
1244:  CLRF   01
1246:  MOVF   7D,W
1248:  BCF    FD8.0
124A:  BTFSC  7E.0
124C:  ADDWF  00,F
124E:  RRCF   00,F
1250:  RRCF   01,F
1252:  BTFSC  7E.1
1254:  ADDWF  00,F
1256:  RRCF   00,F
1258:  RRCF   01,F
125A:  BTFSC  7E.2
125C:  ADDWF  00,F
125E:  RRCF   00,F
1260:  RRCF   01,F
1262:  BTFSC  7E.3
1264:  ADDWF  00,F
1266:  RRCF   00,F
1268:  RRCF   01,F
126A:  BTFSC  7E.4
126C:  ADDWF  00,F
126E:  RRCF   00,F
1270:  RRCF   01,F
1272:  BTFSC  7E.5
1274:  ADDWF  00,F
1276:  RRCF   00,F
1278:  RRCF   01,F
127A:  BTFSC  7E.6
127C:  ADDWF  00,F
127E:  RRCF   00,F
1280:  RRCF   01,F
1282:  BTFSC  7E.7
1284:  ADDWF  00,F
1286:  RRCF   00,F
1288:  RRCF   01,F
128A:  GOTO   1366 (RETURN)
*
1620:  MOVLW  8E
1622:  MOVWF  00
1624:  MOVF   x83,W
1626:  SUBWF  00,F
1628:  MOVFF  84,02
162C:  MOVFF  85,01
1630:  BSF    02.7
1632:  MOVF   00,F
1634:  BZ    1648
1636:  BCF    FD8.0
1638:  MOVF   02,F
163A:  BNZ   1640
163C:  MOVF   01,F
163E:  BZ    1648
1640:  RRCF   02,F
1642:  RRCF   01,F
1644:  DECFSZ 00,F
1646:  BRA    1636
1648:  BTFSS  x84.7
164A:  BRA    1656
164C:  COMF   01,F
164E:  COMF   02,F
1650:  INCF   01,F
1652:  BTFSC  FD8.2
1654:  INCF   02,F
1656:  NOP   
1658:  RETLW  00
*
16C2:  MOVLB  2
16C4:  MOVF   x9A,W
16C6:  BTFSC  FD8.2
16C8:  BRA    17AC
16CA:  MOVWF  00
16CC:  MOVF   x9E,W
16CE:  BTFSC  FD8.2
16D0:  BRA    17AC
16D2:  ADDWF  00,F
16D4:  BNC   16DE
16D6:  MOVLW  81
16D8:  ADDWF  00,F
16DA:  BC    17AC
16DC:  BRA    16E6
16DE:  MOVLW  7F
16E0:  SUBWF  00,F
16E2:  BNC   17AC
16E4:  BZ    17AC
16E6:  MOVFF  29B,2A2
16EA:  MOVF   x9F,W
16EC:  XORWF  xA2,F
16EE:  BSF    x9B.7
16F0:  BSF    x9F.7
16F2:  MOVF   x9D,W
16F4:  MULWF  xA1
16F6:  MOVFF  FF4,2A4
16FA:  MOVF   x9C,W
16FC:  MULWF  xA0
16FE:  MOVFF  FF4,03
1702:  MOVFF  FF3,2A3
1706:  MULWF  xA1
1708:  MOVF   FF3,W
170A:  ADDWF  xA4,F
170C:  MOVF   FF4,W
170E:  ADDWFC xA3,F
1710:  MOVLW  00
1712:  ADDWFC 03,F
1714:  MOVF   x9D,W
1716:  MULWF  xA0
1718:  MOVF   FF3,W
171A:  ADDWF  xA4,F
171C:  MOVF   FF4,W
171E:  ADDWFC xA3,F
1720:  MOVLW  00
1722:  CLRF   02
1724:  ADDWFC 03,F
1726:  ADDWFC 02,F
1728:  MOVF   x9B,W
172A:  MULWF  xA1
172C:  MOVF   FF3,W
172E:  ADDWF  xA3,F
1730:  MOVF   FF4,W
1732:  ADDWFC 03,F
1734:  MOVLW  00
1736:  ADDWFC 02,F
1738:  MOVF   x9B,W
173A:  MULWF  xA0
173C:  MOVF   FF3,W
173E:  ADDWF  03,F
1740:  MOVF   FF4,W
1742:  ADDWFC 02,F
1744:  MOVLW  00
1746:  CLRF   01
1748:  ADDWFC 01,F
174A:  MOVF   x9D,W
174C:  MULWF  x9F
174E:  MOVF   FF3,W
1750:  ADDWF  xA3,F
1752:  MOVF   FF4,W
1754:  ADDWFC 03,F
1756:  MOVLW  00
1758:  ADDWFC 02,F
175A:  ADDWFC 01,F
175C:  MOVF   x9C,W
175E:  MULWF  x9F
1760:  MOVF   FF3,W
1762:  ADDWF  03,F
1764:  MOVF   FF4,W
1766:  ADDWFC 02,F
1768:  MOVLW  00
176A:  ADDWFC 01,F
176C:  MOVF   x9B,W
176E:  MULWF  x9F
1770:  MOVF   FF3,W
1772:  ADDWF  02,F
1774:  MOVF   FF4,W
1776:  ADDWFC 01,F
1778:  INCF   00,F
177A:  BTFSC  01.7
177C:  BRA    1788
177E:  RLCF   xA3,F
1780:  RLCF   03,F
1782:  RLCF   02,F
1784:  RLCF   01,F
1786:  DECF   00,F
1788:  MOVLW  00
178A:  BTFSS  xA3.7
178C:  BRA    17A2
178E:  INCF   03,F
1790:  ADDWFC 02,F
1792:  ADDWFC 01,F
1794:  MOVF   01,W
1796:  BNZ   17A2
1798:  MOVF   02,W
179A:  BNZ   17A2
179C:  MOVF   03,W
179E:  BNZ   17A2
17A0:  INCF   00,F
17A2:  BTFSC  xA2.7
17A4:  BSF    01.7
17A6:  BTFSS  xA2.7
17A8:  BCF    01.7
17AA:  BRA    17B4
17AC:  CLRF   00
17AE:  CLRF   01
17B0:  CLRF   02
17B2:  CLRF   03
17B4:  NOP   
17B6:  MOVLB  0
17B8:  RETLW  00
*
1E2C:  MOVFF  FF2,0E
1E30:  BCF    FF2.7
1E32:  ADDWF  FE8,W
1E34:  ADDLW  51
1E36:  MOVWF  FF6
1E38:  MOVLW  1E
1E3A:  MOVWF  FF7
1E3C:  BTFSC  FD8.0
1E3E:  INCF   FF7,F
1E40:  TBLRD*-
1E42:  MOVF   FF5,W
1E44:  MOVWF  FFA
1E46:  TBLRD*
1E48:  MOVF   FF5,W
1E4A:  BTFSC  0E.7
1E4C:  BSF    FF2.7
1E4E:  MOVWF  FF9
1E50:  DATA FA,18
1E52:  DATA 12,19
1E54:  DATA 2A,19
1E56:  DATA 42,19
1E58:  DATA 5A,19
1E5A:  DATA 72,19
1E5C:  DATA 8A,19
*
1EA6:  MOVLW  8E
1EA8:  MOVWF  00
1EAA:  MOVFF  7D,01
1EAE:  MOVFF  7C,02
1EB2:  CLRF   03
1EB4:  BTFSS  7D.7
1EB6:  BRA    1EC2
1EB8:  COMF   01,F
1EBA:  COMF   02,F
1EBC:  INCF   02,F
1EBE:  BNZ   1EC2
1EC0:  INCF   01,F
1EC2:  MOVF   01,F
1EC4:  BNZ   1ED8
1EC6:  MOVFF  02,01
1ECA:  CLRF   02
1ECC:  MOVLW  08
1ECE:  SUBWF  00,F
1ED0:  MOVF   01,F
1ED2:  BNZ   1ED8
1ED4:  CLRF   00
1ED6:  BRA    1EEC
1ED8:  BCF    FD8.0
1EDA:  BTFSC  01.7
1EDC:  BRA    1EE6
1EDE:  RLCF   02,F
1EE0:  RLCF   01,F
1EE2:  DECF   00,F
1EE4:  BRA    1ED8
1EE6:  BTFSC  7D.7
1EE8:  BRA    1EEC
1EEA:  BCF    01.7
1EEC:  NOP   
1EEE:  GOTO   20A6 (RETURN)
1EF2:  MOVLB  2
1EF4:  MOVF   x84,W
1EF6:  BTFSC  FD8.2
1EF8:  BRA    2044
1EFA:  MOVWF  x90
1EFC:  MOVF   x88,W
1EFE:  BTFSC  FD8.2
1F00:  BRA    2044
1F02:  SUBWF  x90,F
1F04:  BNC   1F10
1F06:  MOVLW  7F
1F08:  ADDWF  x90,F
1F0A:  BTFSC  FD8.0
1F0C:  BRA    2044
1F0E:  BRA    1F1C
1F10:  MOVLW  81
1F12:  SUBWF  x90,F
1F14:  BTFSS  FD8.0
1F16:  BRA    2044
1F18:  BTFSC  FD8.2
1F1A:  BRA    2044
1F1C:  MOVFF  290,00
1F20:  CLRF   01
1F22:  CLRF   02
1F24:  CLRF   03
1F26:  CLRF   x8F
1F28:  MOVFF  285,28E
1F2C:  BSF    x8E.7
1F2E:  MOVFF  286,28D
1F32:  MOVFF  287,28C
1F36:  MOVLW  19
1F38:  MOVWF  x90
1F3A:  MOVF   x8B,W
1F3C:  SUBWF  x8C,F
1F3E:  BC    1F5A
1F40:  MOVLW  01
1F42:  SUBWF  x8D,F
1F44:  BC    1F5A
1F46:  SUBWF  x8E,F
1F48:  BC    1F5A
1F4A:  SUBWF  x8F,F
1F4C:  BC    1F5A
1F4E:  INCF   x8F,F
1F50:  INCF   x8E,F
1F52:  INCF   x8D,F
1F54:  MOVF   x8B,W
1F56:  ADDWF  x8C,F
1F58:  BRA    1FAA
1F5A:  MOVF   x8A,W
1F5C:  SUBWF  x8D,F
1F5E:  BC    1F84
1F60:  MOVLW  01
1F62:  SUBWF  x8E,F
1F64:  BC    1F84
1F66:  SUBWF  x8F,F
1F68:  BC    1F84
1F6A:  INCF   x8F,F
1F6C:  INCF   x8E,F
1F6E:  MOVF   x8A,W
1F70:  ADDWF  x8D,F
1F72:  MOVF   x8B,W
1F74:  ADDWF  x8C,F
1F76:  BNC   1FAA
1F78:  INCF   x8D,F
1F7A:  BNZ   1FAA
1F7C:  INCF   x8E,F
1F7E:  BNZ   1FAA
1F80:  INCF   x8F,F
1F82:  BRA    1FAA
1F84:  MOVF   x89,W
1F86:  IORLW  80
1F88:  SUBWF  x8E,F
1F8A:  BC    1FA8
1F8C:  MOVLW  01
1F8E:  SUBWF  x8F,F
1F90:  BC    1FA8
1F92:  INCF   x8F,F
1F94:  MOVF   x89,W
1F96:  IORLW  80
1F98:  ADDWF  x8E,F
1F9A:  MOVF   x8A,W
1F9C:  ADDWF  x8D,F
1F9E:  BNC   1F72
1FA0:  INCF   x8E,F
1FA2:  BNZ   1F72
1FA4:  INCF   x8F,F
1FA6:  BRA    1F72
1FA8:  BSF    03.0
1FAA:  DECFSZ x90,F
1FAC:  BRA    1FB0
1FAE:  BRA    1FC6
1FB0:  BCF    FD8.0
1FB2:  RLCF   x8C,F
1FB4:  RLCF   x8D,F
1FB6:  RLCF   x8E,F
1FB8:  RLCF   x8F,F
1FBA:  BCF    FD8.0
1FBC:  RLCF   03,F
1FBE:  RLCF   02,F
1FC0:  RLCF   01,F
1FC2:  RLCF   x91,F
1FC4:  BRA    1F3A
1FC6:  BTFSS  x91.0
1FC8:  BRA    1FD6
1FCA:  BCF    FD8.0
1FCC:  RRCF   01,F
1FCE:  RRCF   02,F
1FD0:  RRCF   03,F
1FD2:  RRCF   x91,F
1FD4:  BRA    1FDA
1FD6:  DECF   00,F
1FD8:  BZ    2044
1FDA:  BTFSC  x91.7
1FDC:  BRA    201A
1FDE:  BCF    FD8.0
1FE0:  RLCF   x8C,F
1FE2:  RLCF   x8D,F
1FE4:  RLCF   x8E,F
1FE6:  RLCF   x8F,F
1FE8:  MOVF   x8B,W
1FEA:  SUBWF  x8C,F
1FEC:  BC    1FFC
1FEE:  MOVLW  01
1FF0:  SUBWF  x8D,F
1FF2:  BC    1FFC
1FF4:  SUBWF  x8E,F
1FF6:  BC    1FFC
1FF8:  SUBWF  x8F,F
1FFA:  BNC   2030
1FFC:  MOVF   x8A,W
1FFE:  SUBWF  x8D,F
2000:  BC    200C
2002:  MOVLW  01
2004:  SUBWF  x8E,F
2006:  BC    200C
2008:  SUBWF  x8F,F
200A:  BNC   2030
200C:  MOVF   x89,W
200E:  IORLW  80
2010:  SUBWF  x8E,F
2012:  BC    201A
2014:  MOVLW  01
2016:  SUBWF  x8F,F
2018:  BNC   2030
201A:  INCF   03,F
201C:  BNZ   2030
201E:  INCF   02,F
2020:  BNZ   2030
2022:  INCF   01,F
2024:  BNZ   2030
2026:  INCF   00,F
2028:  BZ    2044
202A:  RRCF   01,F
202C:  RRCF   02,F
202E:  RRCF   03,F
2030:  MOVFF  285,290
2034:  MOVF   x89,W
2036:  XORWF  x90,F
2038:  BTFSS  x90.7
203A:  BRA    2040
203C:  BSF    01.7
203E:  BRA    204C
2040:  BCF    01.7
2042:  BRA    204C
2044:  CLRF   00
2046:  CLRF   01
2048:  CLRF   02
204A:  CLRF   03
204C:  NOP   
204E:  MOVLB  0
2050:  RETLW  00
*
21AC:  MOVLW  80
21AE:  BTFSS  FD8.1
21B0:  BRA    21B6
21B2:  MOVLB  2
21B4:  XORWF  x83,F
21B6:  MOVLB  2
21B8:  CLRF   x88
21BA:  CLRF   x89
21BC:  MOVFF  27F,287
21C0:  MOVF   x83,W
21C2:  XORWF  x87,F
21C4:  MOVF   x7E,W
21C6:  BTFSC  FD8.2
21C8:  BRA    2388
21CA:  MOVWF  x86
21CC:  MOVWF  00
21CE:  MOVF   x82,W
21D0:  BTFSC  FD8.2
21D2:  BRA    239A
21D4:  SUBWF  x86,F
21D6:  BTFSC  FD8.2
21D8:  BRA    22E0
21DA:  BNC   2258
21DC:  MOVFF  283,28C
21E0:  BSF    x8C.7
21E2:  MOVFF  284,28B
21E6:  MOVFF  285,28A
21EA:  CLRF   x89
21EC:  BCF    FD8.0
21EE:  RRCF   x8C,F
21F0:  RRCF   x8B,F
21F2:  RRCF   x8A,F
21F4:  RRCF   x89,F
21F6:  DECFSZ x86,F
21F8:  BRA    21EA
21FA:  BTFSS  x87.7
21FC:  BRA    2204
21FE:  BSF    x88.0
2200:  BRA    23C2
2202:  BCF    x88.0
2204:  BCF    x86.0
2206:  BSF    x88.4
2208:  MOVLW  02
220A:  MOVWF  FEA
220C:  MOVLW  81
220E:  MOVWF  FE9
2210:  BRA    23E8
2212:  BCF    x88.4
2214:  BTFSC  x87.7
2216:  BRA    222C
2218:  BTFSS  x86.0
221A:  BRA    2242
221C:  RRCF   x8C,F
221E:  RRCF   x8B,F
2220:  RRCF   x8A,F
2222:  RRCF   x89,F
2224:  INCF   00,F
2226:  BTFSC  FD8.2
2228:  BRA    23B8
222A:  BRA    2242
222C:  BTFSC  x8C.7
222E:  BRA    2248
2230:  BCF    FD8.0
2232:  RLCF   x89,F
2234:  RLCF   x8A,F
2236:  RLCF   x8B,F
2238:  RLCF   x8C,F
223A:  DECF   00,F
223C:  BTFSC  FD8.2
223E:  BRA    23B8
2240:  BRA    222C
2242:  BSF    x88.6
2244:  BRA    2320
2246:  BCF    x88.6
2248:  MOVFF  27F,287
224C:  BTFSS  x7F.7
224E:  BRA    2254
2250:  BSF    x8C.7
2252:  BRA    23AA
2254:  BCF    x8C.7
2256:  BRA    23AA
2258:  MOVFF  282,286
225C:  MOVFF  282,00
2260:  MOVF   x7E,W
2262:  SUBWF  x86,F
2264:  MOVFF  27F,28C
2268:  BSF    x8C.7
226A:  MOVFF  280,28B
226E:  MOVFF  281,28A
2272:  CLRF   x89
2274:  BCF    FD8.0
2276:  RRCF   x8C,F
2278:  RRCF   x8B,F
227A:  RRCF   x8A,F
227C:  RRCF   x89,F
227E:  DECFSZ x86,F
2280:  BRA    2272
2282:  BTFSS  x87.7
2284:  BRA    228C
2286:  BSF    x88.1
2288:  BRA    23C2
228A:  BCF    x88.1
228C:  BCF    x86.0
228E:  BSF    x88.5
2290:  MOVLW  02
2292:  MOVWF  FEA
2294:  MOVLW  85
2296:  MOVWF  FE9
2298:  BRA    23E8
229A:  BCF    x88.5
229C:  BTFSC  x87.7
229E:  BRA    22B4
22A0:  BTFSS  x86.0
22A2:  BRA    22CA
22A4:  RRCF   x8C,F
22A6:  RRCF   x8B,F
22A8:  RRCF   x8A,F
22AA:  RRCF   x89,F
22AC:  INCF   00,F
22AE:  BTFSC  FD8.2
22B0:  BRA    23B8
22B2:  BRA    22CA
22B4:  BTFSC  x8C.7
22B6:  BRA    22D0
22B8:  BCF    FD8.0
22BA:  RLCF   x89,F
22BC:  RLCF   x8A,F
22BE:  RLCF   x8B,F
22C0:  RLCF   x8C,F
22C2:  DECF   00,F
22C4:  BTFSC  FD8.2
22C6:  BRA    23B8
22C8:  BRA    22B4
22CA:  BSF    x88.7
22CC:  BRA    2320
22CE:  BCF    x88.7
22D0:  MOVFF  283,287
22D4:  BTFSS  x83.7
22D6:  BRA    22DC
22D8:  BSF    x8C.7
22DA:  BRA    23AA
22DC:  BCF    x8C.7
22DE:  BRA    23AA
22E0:  MOVFF  283,28C
22E4:  BSF    x8C.7
22E6:  MOVFF  284,28B
22EA:  MOVFF  285,28A
22EE:  BTFSS  x87.7
22F0:  BRA    22FA
22F2:  BCF    x8C.7
22F4:  BSF    x88.2
22F6:  BRA    23C2
22F8:  BCF    x88.2
22FA:  CLRF   x89
22FC:  BCF    x86.0
22FE:  MOVLW  02
2300:  MOVWF  FEA
2302:  MOVLW  81
2304:  MOVWF  FE9
2306:  BRA    23E8
2308:  BTFSC  x87.7
230A:  BRA    2344
230C:  MOVFF  27F,287
2310:  BTFSS  x86.0
2312:  BRA    2320
2314:  RRCF   x8C,F
2316:  RRCF   x8B,F
2318:  RRCF   x8A,F
231A:  RRCF   x89,F
231C:  INCF   00,F
231E:  BZ    23B8
2320:  BTFSS  x89.7
2322:  BRA    233A
2324:  INCF   x8A,F
2326:  BNZ   233A
2328:  INCF   x8B,F
232A:  BNZ   233A
232C:  INCF   x8C,F
232E:  BNZ   233A
2330:  RRCF   x8C,F
2332:  RRCF   x8B,F
2334:  RRCF   x8A,F
2336:  INCF   00,F
2338:  BZ    23B8
233A:  BTFSC  x88.6
233C:  BRA    2246
233E:  BTFSC  x88.7
2340:  BRA    22CE
2342:  BRA    237C
2344:  MOVLW  80
2346:  XORWF  x8C,F
2348:  BTFSS  x8C.7
234A:  BRA    2354
234C:  BRA    23C2
234E:  MOVFF  283,287
2352:  BRA    2368
2354:  MOVFF  27F,287
2358:  MOVF   x8C,F
235A:  BNZ   2368
235C:  MOVF   x8B,F
235E:  BNZ   2368
2360:  MOVF   x8A,F
2362:  BNZ   2368
2364:  CLRF   00
2366:  BRA    23AA
2368:  BTFSC  x8C.7
236A:  BRA    237C
236C:  BCF    FD8.0
236E:  RLCF   x89,F
2370:  RLCF   x8A,F
2372:  RLCF   x8B,F
2374:  RLCF   x8C,F
2376:  DECFSZ 00,F
2378:  BRA    2368
237A:  BRA    23B8
237C:  BTFSS  x87.7
237E:  BRA    2384
2380:  BSF    x8C.7
2382:  BRA    23AA
2384:  BCF    x8C.7
2386:  BRA    23AA
2388:  MOVFF  282,00
238C:  MOVFF  283,28C
2390:  MOVFF  284,28B
2394:  MOVFF  285,28A
2398:  BRA    23AA
239A:  MOVFF  27E,00
239E:  MOVFF  27F,28C
23A2:  MOVFF  280,28B
23A6:  MOVFF  281,28A
23AA:  MOVFF  28C,01
23AE:  MOVFF  28B,02
23B2:  MOVFF  28A,03
23B6:  BRA    2420
23B8:  CLRF   00
23BA:  CLRF   01
23BC:  CLRF   02
23BE:  CLRF   03
23C0:  BRA    2420
23C2:  CLRF   x89
23C4:  COMF   x8A,F
23C6:  COMF   x8B,F
23C8:  COMF   x8C,F
23CA:  COMF   x89,F
23CC:  INCF   x89,F
23CE:  BNZ   23DA
23D0:  INCF   x8A,F
23D2:  BNZ   23DA
23D4:  INCF   x8B,F
23D6:  BNZ   23DA
23D8:  INCF   x8C,F
23DA:  BTFSC  x88.0
23DC:  BRA    2202
23DE:  BTFSC  x88.1
23E0:  BRA    228A
23E2:  BTFSC  x88.2
23E4:  BRA    22F8
23E6:  BRA    234E
23E8:  MOVF   FEF,W
23EA:  ADDWF  x8A,F
23EC:  BNC   23F8
23EE:  INCF   x8B,F
23F0:  BNZ   23F8
23F2:  INCF   x8C,F
23F4:  BTFSC  FD8.2
23F6:  BSF    x86.0
23F8:  MOVF   FED,F
23FA:  MOVF   FEF,W
23FC:  ADDWF  x8B,F
23FE:  BNC   2406
2400:  INCF   x8C,F
2402:  BTFSC  FD8.2
2404:  BSF    x86.0
2406:  MOVF   FED,F
2408:  MOVF   FEF,W
240A:  BTFSC  FEF.7
240C:  BRA    2410
240E:  XORLW  80
2410:  ADDWF  x8C,F
2412:  BTFSC  FD8.0
2414:  BSF    x86.0
2416:  BTFSC  x88.4
2418:  BRA    2212
241A:  BTFSC  x88.5
241C:  BRA    229A
241E:  BRA    2308
2420:  NOP   
2422:  MOVLB  0
2424:  RETLW  00
2426:  MOVLW  8E
2428:  MOVWF  00
242A:  MOVFF  285,01
242E:  MOVFF  284,02
2432:  CLRF   03
2434:  MOVF   01,F
2436:  BNZ   244A
2438:  MOVFF  02,01
243C:  CLRF   02
243E:  MOVLW  08
2440:  SUBWF  00,F
2442:  MOVF   01,F
2444:  BNZ   244A
2446:  CLRF   00
2448:  BRA    245A
244A:  BCF    FD8.0
244C:  BTFSC  01.7
244E:  BRA    2458
2450:  RLCF   02,F
2452:  RLCF   01,F
2454:  DECF   00,F
2456:  BRA    244A
2458:  BCF    01.7
245A:  NOP   
245C:  RETLW  00
245E:  MOVFF  74,7B
2462:  MOVF   78,W
2464:  XORWF  7B,F
2466:  BTFSS  7B.7
2468:  BRA    2474
246A:  BCF    FD8.2
246C:  BCF    FD8.0
246E:  BTFSC  74.7
2470:  BSF    FD8.0
2472:  BRA    24D2
2474:  MOVFF  74,7B
2478:  MOVFF  77,7C
247C:  MOVF   73,W
247E:  SUBWF  7C,F
2480:  BZ    248E
2482:  BTFSS  7B.7
2484:  BRA    24D2
2486:  MOVF   FD8,W
2488:  XORLW  01
248A:  MOVWF  FD8
248C:  BRA    24D2
248E:  MOVFF  78,7C
2492:  MOVF   74,W
2494:  SUBWF  7C,F
2496:  BZ    24A4
2498:  BTFSS  7B.7
249A:  BRA    24D2
249C:  MOVF   FD8,W
249E:  XORLW  01
24A0:  MOVWF  FD8
24A2:  BRA    24D2
24A4:  MOVFF  79,7C
24A8:  MOVF   75,W
24AA:  SUBWF  7C,F
24AC:  BZ    24BA
24AE:  BTFSS  7B.7
24B0:  BRA    24D2
24B2:  MOVF   FD8,W
24B4:  XORLW  01
24B6:  MOVWF  FD8
24B8:  BRA    24D2
24BA:  MOVFF  7A,7C
24BE:  MOVF   76,W
24C0:  SUBWF  7C,F
24C2:  BZ    24D0
24C4:  BTFSS  7B.7
24C6:  BRA    24D2
24C8:  MOVF   FD8,W
24CA:  XORLW  01
24CC:  MOVWF  FD8
24CE:  BRA    24D2
24D0:  BCF    FD8.0
24D2:  RETLW  00
*
295A:  MOVF   x84,W
295C:  MULWF  x86
295E:  MOVFF  FF3,01
2962:  MOVFF  FF4,00
2966:  MULWF  x87
2968:  MOVF   FF3,W
296A:  ADDWF  00,F
296C:  MOVF   x85,W
296E:  MULWF  x86
2970:  MOVF   FF3,W
2972:  ADDWFC 00,W
2974:  MOVWF  02
2976:  RETLW  00
*
2BB6:  CLRF   01
2BB8:  CLRF   02
2BBA:  CLRF   00
2BBC:  CLRF   03
2BBE:  MOVF   78,W
2BC0:  BNZ   2BC6
2BC2:  MOVF   77,W
2BC4:  BZ    2BF6
2BC6:  MOVLW  10
2BC8:  MOVWF  79
2BCA:  BCF    FD8.0
2BCC:  RLCF   75,F
2BCE:  RLCF   76,F
2BD0:  RLCF   00,F
2BD2:  RLCF   03,F
2BD4:  MOVF   78,W
2BD6:  SUBWF  03,W
2BD8:  BNZ   2BDE
2BDA:  MOVF   77,W
2BDC:  SUBWF  00,W
2BDE:  BNC   2BEE
2BE0:  MOVF   77,W
2BE2:  SUBWF  00,F
2BE4:  BTFSS  FD8.0
2BE6:  DECF   03,F
2BE8:  MOVF   78,W
2BEA:  SUBWF  03,F
2BEC:  BSF    FD8.0
2BEE:  RLCF   01,F
2BF0:  RLCF   02,F
2BF2:  DECFSZ 79,F
2BF4:  BRA    2BCA
2BF6:  NOP   
2BF8:  GOTO   2F04 (RETURN)
*
302E:  MOVLB  2
3030:  MOVF   x82,W
3032:  CLRF   01
3034:  SUBWF  x81,W
3036:  BC    303E
3038:  MOVFF  281,00
303C:  BRA    3056
303E:  CLRF   00
3040:  MOVLW  08
3042:  MOVWF  x83
3044:  RLCF   x81,F
3046:  RLCF   00,F
3048:  MOVF   x82,W
304A:  SUBWF  00,W
304C:  BTFSC  FD8.0
304E:  MOVWF  00
3050:  RLCF   01,F
3052:  DECFSZ x83,F
3054:  BRA    3044
3056:  MOVLB  0
3058:  RETLW  00
305A:  MOVLW  20
305C:  BTFSS  77.4
305E:  MOVLW  30
3060:  MOVWF  78
3062:  MOVFF  76,00
3066:  BTFSS  76.7
3068:  BRA    3078
306A:  COMF   00,F
306C:  INCF   00,F
306E:  MOVFF  00,76
3072:  MOVLW  2D
3074:  MOVWF  78
3076:  BSF    77.7
3078:  MOVF   01,W
307A:  MOVFF  76,281
307E:  MOVLW  64
3080:  MOVLB  2
3082:  MOVWF  x82
3084:  MOVLB  0
3086:  RCALL  302E
3088:  MOVFF  00,76
308C:  MOVLW  30
308E:  ADDWF  01,W
3090:  MOVWF  79
3092:  MOVFF  76,281
3096:  MOVLW  0A
3098:  MOVLB  2
309A:  MOVWF  x82
309C:  MOVLB  0
309E:  RCALL  302E
30A0:  MOVLW  30
30A2:  ADDWF  00,W
30A4:  MOVWF  7B
30A6:  MOVLW  30
30A8:  ADDWF  01,W
30AA:  MOVWF  7A
30AC:  MOVFF  78,00
30B0:  BTFSS  77.3
30B2:  BRA    30B8
30B4:  BTFSS  77.7
30B6:  BCF    77.2
30B8:  BTFSC  77.4
30BA:  BRA    30D2
30BC:  BTFSS  77.7
30BE:  BRA    3104
30C0:  BTFSC  77.2
30C2:  BRA    3104
30C4:  MOVFF  00,79
30C8:  BTFSC  77.1
30CA:  BRA    3104
30CC:  MOVFF  00,7A
30D0:  BRA    3104
30D2:  MOVLW  30
30D4:  SUBWF  79,W
30D6:  BNZ   3104
30D8:  MOVFF  00,79
30DC:  MOVLW  20
30DE:  MOVWF  78
30E0:  BTFSS  77.3
30E2:  BRA    30EC
30E4:  BCF    77.2
30E6:  BSF    77.1
30E8:  BTFSS  77.7
30EA:  BCF    77.1
30EC:  MOVLW  30
30EE:  SUBWF  7A,W
30F0:  BNZ   3104
30F2:  MOVFF  00,7A
30F6:  MOVLW  20
30F8:  MOVWF  79
30FA:  BTFSS  77.3
30FC:  BRA    30EC
30FE:  BCF    77.1
3100:  BTFSS  77.7
3102:  BCF    77.0
3104:  BTFSS  77.2
3106:  BRA    3110
3108:  MOVFF  78,7D
310C:  CALL   11FE
3110:  BTFSS  77.1
3112:  BRA    311C
3114:  MOVFF  79,7D
3118:  CALL   11FE
311C:  BTFSS  77.0
311E:  BRA    3128
3120:  MOVFF  7A,7D
3124:  CALL   11FE
3128:  MOVFF  7B,7D
312C:  CALL   11FE
3130:  RETLW  00
3132:  MOVLB  2
3134:  MOVF   x9A,W
3136:  SUBLW  B6
3138:  MOVWF  x9A
313A:  CLRF   03
313C:  MOVFF  29B,29E
3140:  BSF    x9B.7
3142:  BCF    FD8.0
3144:  RRCF   x9B,F
3146:  RRCF   x9C,F
3148:  RRCF   x9D,F
314A:  RRCF   03,F
314C:  RRCF   02,F
314E:  RRCF   01,F
3150:  RRCF   00,F
3152:  DECFSZ x9A,F
3154:  BRA    3142
3156:  BTFSS  x9E.7
3158:  BRA    3170
315A:  COMF   00,F
315C:  COMF   01,F
315E:  COMF   02,F
3160:  COMF   03,F
3162:  INCF   00,F
3164:  BTFSC  FD8.2
3166:  INCF   01,F
3168:  BTFSC  FD8.2
316A:  INCF   02,F
316C:  BTFSC  FD8.2
316E:  INCF   03,F
3170:  MOVLB  0
3172:  RETLW  00
3174:  CLRF   00
3176:  CLRF   01
3178:  CLRF   02
317A:  CLRF   03
317C:  MOVLB  2
317E:  CLRF   xA2
3180:  CLRF   xA3
3182:  CLRF   xA4
3184:  CLRF   xA5
3186:  MOVF   xA1,W
3188:  IORWF  xA0,W
318A:  IORWF  x9F,W
318C:  IORWF  x9E,W
318E:  BZ    31E8
3190:  MOVLW  20
3192:  MOVWF  xA6
3194:  BCF    FD8.0
3196:  RLCF   x9A,F
3198:  RLCF   x9B,F
319A:  RLCF   x9C,F
319C:  RLCF   x9D,F
319E:  RLCF   xA2,F
31A0:  RLCF   xA3,F
31A2:  RLCF   xA4,F
31A4:  RLCF   xA5,F
31A6:  MOVF   xA1,W
31A8:  SUBWF  xA5,W
31AA:  BNZ   31BC
31AC:  MOVF   xA0,W
31AE:  SUBWF  xA4,W
31B0:  BNZ   31BC
31B2:  MOVF   x9F,W
31B4:  SUBWF  xA3,W
31B6:  BNZ   31BC
31B8:  MOVF   x9E,W
31BA:  SUBWF  xA2,W
31BC:  BNC   31DC
31BE:  MOVF   x9E,W
31C0:  SUBWF  xA2,F
31C2:  MOVF   x9F,W
31C4:  BTFSS  FD8.0
31C6:  INCFSZ x9F,W
31C8:  SUBWF  xA3,F
31CA:  MOVF   xA0,W
31CC:  BTFSS  FD8.0
31CE:  INCFSZ xA0,W
31D0:  SUBWF  xA4,F
31D2:  MOVF   xA1,W
31D4:  BTFSS  FD8.0
31D6:  INCFSZ xA1,W
31D8:  SUBWF  xA5,F
31DA:  BSF    FD8.0
31DC:  RLCF   00,F
31DE:  RLCF   01,F
31E0:  RLCF   02,F
31E2:  RLCF   03,F
31E4:  DECFSZ xA6,F
31E6:  BRA    3194
31E8:  NOP   
31EA:  MOVLW  02
31EC:  MOVWF  FEA
31EE:  MOVLW  A2
31F0:  MOVWF  FE9
31F2:  MOVLB  0
31F4:  RETLW  00
31F6:  MOVF   FE9,W
31F8:  MOVWF  75
31FA:  MOVF   74,W
31FC:  MOVWF  77
31FE:  BZ    3238
3200:  MOVFF  73,29D
3204:  MOVFF  72,29C
3208:  MOVFF  71,29B
320C:  MOVFF  70,29A
3210:  MOVLB  2
3212:  CLRF   xA1
3214:  CLRF   xA0
3216:  MOVLW  20
3218:  MOVWF  x9F
321A:  MOVLW  82
321C:  MOVWF  x9E
321E:  MOVLB  0
3220:  CALL   16C2
3224:  MOVFF  03,73
3228:  MOVFF  02,72
322C:  MOVFF  01,71
3230:  MOVFF  00,70
3234:  DECFSZ 77,F
3236:  BRA    3200
3238:  MOVFF  73,29D
323C:  MOVFF  72,29C
3240:  MOVFF  71,29B
3244:  MOVFF  70,29A
3248:  RCALL  3132
324A:  MOVFF  03,73
324E:  MOVFF  02,72
3252:  MOVFF  01,71
3256:  MOVFF  00,70
325A:  BTFSS  73.7
325C:  BRA    3278
325E:  DECF   75,F
3260:  BSF    75.5
3262:  COMF   70,F
3264:  COMF   71,F
3266:  COMF   72,F
3268:  COMF   73,F
326A:  INCF   70,F
326C:  BTFSC  FD8.2
326E:  INCF   71,F
3270:  BTFSC  FD8.2
3272:  INCF   72,F
3274:  BTFSC  FD8.2
3276:  INCF   73,F
3278:  MOVLW  3B
327A:  MOVWF  7C
327C:  MOVLW  9A
327E:  MOVWF  7B
3280:  MOVLW  CA
3282:  MOVWF  7A
3284:  CLRF   79
3286:  MOVLW  0A
3288:  MOVWF  77
328A:  MOVF   74,W
328C:  BTFSC  FD8.2
328E:  INCF   75,F
3290:  MOVFF  73,29D
3294:  MOVFF  72,29C
3298:  MOVFF  71,29B
329C:  MOVFF  70,29A
32A0:  MOVFF  7C,2A1
32A4:  MOVFF  7B,2A0
32A8:  MOVFF  7A,29F
32AC:  MOVFF  79,29E
32B0:  RCALL  3174
32B2:  MOVF   01,W
32B4:  MOVFF  FEF,70
32B8:  MOVFF  FEC,71
32BC:  MOVFF  FEC,72
32C0:  MOVFF  FEC,73
32C4:  MOVF   00,F
32C6:  BNZ   32E6
32C8:  INCF   74,W
32CA:  SUBWF  77,W
32CC:  BZ    32E6
32CE:  MOVF   75,W
32D0:  BZ    32EA
32D2:  ANDLW  0F
32D4:  SUBWF  77,W
32D6:  BZ    32DA
32D8:  BC    3350
32DA:  BTFSC  75.7
32DC:  BRA    3350
32DE:  BTFSC  75.6
32E0:  BRA    32EA
32E2:  MOVLW  20
32E4:  BRA    3346
32E6:  MOVLW  20
32E8:  ANDWF  75,F
32EA:  BTFSS  75.5
32EC:  BRA    3308
32EE:  BCF    75.5
32F0:  MOVF   74,W
32F2:  BTFSS  FD8.2
32F4:  DECF   75,F
32F6:  MOVF   00,W
32F8:  MOVWF  75
32FA:  MOVLW  2D
32FC:  MOVWF  7D
32FE:  CALL   11FE
3302:  MOVF   75,W
3304:  MOVWF  00
3306:  CLRF   75
3308:  MOVF   74,W
330A:  SUBWF  77,W
330C:  BNZ   3324
330E:  MOVF   00,W
3310:  MOVWF  75
3312:  MOVLW  2E
3314:  MOVWF  7D
3316:  CALL   11FE
331A:  MOVF   75,W
331C:  MOVWF  00
331E:  MOVLW  20
3320:  ANDWF  75,F
3322:  MOVLW  00
3324:  MOVLW  30
3326:  BTFSS  75.5
3328:  BRA    3346
332A:  BCF    75.5
332C:  MOVF   74,W
332E:  BTFSS  FD8.2
3330:  DECF   75,F
3332:  MOVF   00,W
3334:  MOVWF  75
3336:  MOVLW  2D
3338:  MOVWF  7D
333A:  CALL   11FE
333E:  MOVF   75,W
3340:  MOVWF  00
3342:  CLRF   75
3344:  MOVLW  30
3346:  ADDWF  00,F
3348:  MOVFF  00,7D
334C:  CALL   11FE
3350:  MOVFF  7C,29D
3354:  MOVFF  7B,29C
3358:  MOVFF  7A,29B
335C:  MOVFF  79,29A
3360:  MOVLB  2
3362:  CLRF   xA1
3364:  CLRF   xA0
3366:  CLRF   x9F
3368:  MOVLW  0A
336A:  MOVWF  x9E
336C:  MOVLB  0
336E:  RCALL  3174
3370:  MOVFF  03,7C
3374:  MOVFF  02,7B
3378:  MOVFF  01,7A
337C:  MOVFF  00,79
3380:  DECFSZ 77,F
3382:  BRA    3290
3384:  RETLW  00
*
38D2:  MOVF   01,W
38D4:  MOVFF  27F,281
38D8:  MOVLW  64
38DA:  MOVLB  2
38DC:  MOVWF  x82
38DE:  MOVLB  0
38E0:  CALL   302E
38E4:  MOVFF  00,27F
38E8:  MOVF   01,W
38EA:  MOVLW  30
38EC:  BNZ   38FE
38EE:  MOVLB  2
38F0:  BTFSS  x80.1
38F2:  BRA    3910
38F4:  BTFSC  x80.3
38F6:  BRA    3910
38F8:  BTFSC  x80.4
38FA:  MOVLW  20
38FC:  BRA    3906
38FE:  MOVLB  2
3900:  BCF    x80.3
3902:  BCF    x80.4
3904:  BSF    x80.0
3906:  ADDWF  01,F
3908:  MOVF   01,W
390A:  BTFSS  F9E.4
390C:  BRA    390A
390E:  MOVWF  FAD
3910:  MOVFF  27F,281
3914:  MOVLW  0A
3916:  MOVWF  x82
3918:  MOVLB  0
391A:  CALL   302E
391E:  MOVFF  00,27F
3922:  MOVF   01,W
3924:  MOVLW  30
3926:  BNZ   3938
3928:  MOVLB  2
392A:  BTFSC  x80.3
392C:  BRA    3944
392E:  BTFSS  x80.0
3930:  BRA    3944
3932:  BTFSC  x80.4
3934:  MOVLW  20
3936:  MOVLB  0
3938:  ADDWF  01,F
393A:  MOVF   01,W
393C:  BTFSS  F9E.4
393E:  BRA    393C
3940:  MOVWF  FAD
3942:  MOVLB  2
3944:  MOVLW  30
3946:  ADDWF  x7F,F
3948:  MOVF   x7F,W
394A:  BTFSS  F9E.4
394C:  BRA    394A
394E:  MOVWF  FAD
3950:  MOVLB  0
3952:  RETLW  00
3954:  MOVF   FE9,W
3956:  MOVLB  2
3958:  MOVWF  x92
395A:  MOVF   x91,W
395C:  MOVWF  x94
395E:  BZ    3998
3960:  MOVFF  290,29D
3964:  MOVFF  28F,29C
3968:  MOVFF  28E,29B
396C:  MOVFF  28D,29A
3970:  CLRF   xA1
3972:  CLRF   xA0
3974:  MOVLW  20
3976:  MOVWF  x9F
3978:  MOVLW  82
397A:  MOVWF  x9E
397C:  MOVLB  0
397E:  CALL   16C2
3982:  MOVFF  03,290
3986:  MOVFF  02,28F
398A:  MOVFF  01,28E
398E:  MOVFF  00,28D
3992:  MOVLB  2
3994:  DECFSZ x94,F
3996:  BRA    3960
3998:  MOVFF  290,29D
399C:  MOVFF  28F,29C
39A0:  MOVFF  28E,29B
39A4:  MOVFF  28D,29A
39A8:  MOVLB  0
39AA:  CALL   3132
39AE:  MOVFF  03,290
39B2:  MOVFF  02,28F
39B6:  MOVFF  01,28E
39BA:  MOVFF  00,28D
39BE:  MOVLB  2
39C0:  BTFSS  x90.7
39C2:  BRA    39DE
39C4:  DECF   x92,F
39C6:  BSF    x92.5
39C8:  COMF   x8D,F
39CA:  COMF   x8E,F
39CC:  COMF   x8F,F
39CE:  COMF   x90,F
39D0:  INCF   x8D,F
39D2:  BTFSC  FD8.2
39D4:  INCF   x8E,F
39D6:  BTFSC  FD8.2
39D8:  INCF   x8F,F
39DA:  BTFSC  FD8.2
39DC:  INCF   x90,F
39DE:  MOVLW  3B
39E0:  MOVWF  x99
39E2:  MOVLW  9A
39E4:  MOVWF  x98
39E6:  MOVLW  CA
39E8:  MOVWF  x97
39EA:  CLRF   x96
39EC:  MOVLW  0A
39EE:  MOVWF  x94
39F0:  MOVF   x91,W
39F2:  BTFSC  FD8.2
39F4:  INCF   x92,F
39F6:  MOVFF  290,29D
39FA:  MOVFF  28F,29C
39FE:  MOVFF  28E,29B
3A02:  MOVFF  28D,29A
3A06:  MOVFF  299,2A1
3A0A:  MOVFF  298,2A0
3A0E:  MOVFF  297,29F
3A12:  MOVFF  296,29E
3A16:  MOVLB  0
3A18:  CALL   3174
3A1C:  MOVF   01,W
3A1E:  MOVFF  FEF,28D
3A22:  MOVFF  FEC,28E
3A26:  MOVFF  FEC,28F
3A2A:  MOVFF  FEC,290
3A2E:  MOVF   00,F
3A30:  BNZ   3A58
3A32:  MOVLB  2
3A34:  INCF   x91,W
3A36:  SUBWF  x94,W
3A38:  BTFSS  FD8.2
3A3A:  BRA    3A40
3A3C:  MOVLB  0
3A3E:  BRA    3A58
3A40:  MOVF   x92,W
3A42:  BZ    3A5E
3A44:  ANDLW  0F
3A46:  SUBWF  x94,W
3A48:  BZ    3A4C
3A4A:  BC    3AC4
3A4C:  BTFSC  x92.7
3A4E:  BRA    3AC4
3A50:  BTFSC  x92.6
3A52:  BRA    3A5E
3A54:  MOVLW  20
3A56:  BRA    3ABA
3A58:  MOVLW  20
3A5A:  MOVLB  2
3A5C:  ANDWF  x92,F
3A5E:  BTFSS  x92.5
3A60:  BRA    3A7C
3A62:  BCF    x92.5
3A64:  MOVF   x91,W
3A66:  BTFSS  FD8.2
3A68:  DECF   x92,F
3A6A:  MOVF   00,W
3A6C:  MOVWF  x92
3A6E:  MOVLW  2D
3A70:  BTFSS  F9E.4
3A72:  BRA    3A70
3A74:  MOVWF  FAD
3A76:  MOVF   x92,W
3A78:  MOVWF  00
3A7A:  CLRF   x92
3A7C:  MOVF   x91,W
3A7E:  SUBWF  x94,W
3A80:  BNZ   3A98
3A82:  MOVF   00,W
3A84:  MOVWF  x92
3A86:  MOVLW  2E
3A88:  BTFSS  F9E.4
3A8A:  BRA    3A88
3A8C:  MOVWF  FAD
3A8E:  MOVF   x92,W
3A90:  MOVWF  00
3A92:  MOVLW  20
3A94:  ANDWF  x92,F
3A96:  MOVLW  00
3A98:  MOVLW  30
3A9A:  BTFSS  x92.5
3A9C:  BRA    3ABA
3A9E:  BCF    x92.5
3AA0:  MOVF   x91,W
3AA2:  BTFSS  FD8.2
3AA4:  DECF   x92,F
3AA6:  MOVF   00,W
3AA8:  MOVWF  x92
3AAA:  MOVLW  2D
3AAC:  BTFSS  F9E.4
3AAE:  BRA    3AAC
3AB0:  MOVWF  FAD
3AB2:  MOVF   x92,W
3AB4:  MOVWF  00
3AB6:  CLRF   x92
3AB8:  MOVLW  30
3ABA:  ADDWF  00,F
3ABC:  MOVF   00,W
3ABE:  BTFSS  F9E.4
3AC0:  BRA    3ABE
3AC2:  MOVWF  FAD
3AC4:  MOVFF  299,29D
3AC8:  MOVFF  298,29C
3ACC:  MOVFF  297,29B
3AD0:  MOVFF  296,29A
3AD4:  CLRF   xA1
3AD6:  CLRF   xA0
3AD8:  CLRF   x9F
3ADA:  MOVLW  0A
3ADC:  MOVWF  x9E
3ADE:  MOVLB  0
3AE0:  CALL   3174
3AE4:  MOVFF  03,299
3AE8:  MOVFF  02,298
3AEC:  MOVFF  01,297
3AF0:  MOVFF  00,296
3AF4:  MOVLB  2
3AF6:  DECFSZ x94,F
3AF8:  BRA    39F6
3AFA:  MOVLB  0
3AFC:  RETLW  00
3AFE:  MOVFF  FEA,287
3B02:  MOVFF  FE9,286
3B06:  MOVLB  2
3B08:  SWAPF  x80,W
3B0A:  IORLW  F0
3B0C:  MOVWF  x82
3B0E:  ADDWF  x82,F
3B10:  ADDLW  E2
3B12:  MOVWF  x83
3B14:  ADDLW  32
3B16:  MOVWF  x85
3B18:  MOVF   x80,W
3B1A:  ANDLW  0F
3B1C:  ADDWF  x83,F
3B1E:  ADDWF  x83,F
3B20:  ADDWF  x85,F
3B22:  ADDLW  E9
3B24:  MOVWF  x84
3B26:  ADDWF  x84,F
3B28:  ADDWF  x84,F
3B2A:  SWAPF  x7F,W
3B2C:  ANDLW  0F
3B2E:  ADDWF  x84,F
3B30:  ADDWF  x85,F
3B32:  RLCF   x84,F
3B34:  RLCF   x85,F
3B36:  COMF   x85,F
3B38:  RLCF   x85,F
3B3A:  MOVF   x7F,W
3B3C:  ANDLW  0F
3B3E:  ADDWF  x85,F
3B40:  RLCF   x82,F
3B42:  MOVLW  07
3B44:  MOVWF  x81
3B46:  MOVLW  0A
3B48:  DECF   x84,F
3B4A:  ADDWF  x85,F
3B4C:  BNC   3B48
3B4E:  DECF   x83,F
3B50:  ADDWF  x84,F
3B52:  BNC   3B4E
3B54:  DECF   x82,F
3B56:  ADDWF  x83,F
3B58:  BNC   3B54
3B5A:  DECF   x81,F
3B5C:  ADDWF  x82,F
3B5E:  BNC   3B5A
3B60:  MOVLW  02
3B62:  MOVWF  FEA
3B64:  MOVLW  81
3B66:  MOVWF  FE9
3B68:  MOVLW  07
3B6A:  ANDWF  x86,W
3B6C:  BCF    x86.6
3B6E:  ADDWF  FE9,F
3B70:  MOVLW  85
3B72:  SUBWF  FE9,W
3B74:  BTFSC  FD8.2
3B76:  BSF    x86.6
3B78:  MOVF   FEF,W
3B7A:  MOVWF  00
3B7C:  BNZ   3B8E
3B7E:  BTFSC  x86.6
3B80:  BRA    3B8E
3B82:  BTFSC  x86.4
3B84:  BRA    3B9E
3B86:  BTFSC  x86.3
3B88:  BRA    3B8E
3B8A:  MOVLW  20
3B8C:  BRA    3B94
3B8E:  BSF    x86.3
3B90:  BCF    x86.4
3B92:  MOVLW  30
3B94:  ADDWF  00,F
3B96:  MOVF   00,W
3B98:  BTFSS  F9E.4
3B9A:  BRA    3B98
3B9C:  MOVWF  FAD
3B9E:  MOVF   FEE,W
3BA0:  BTFSS  x86.6
3BA2:  BRA    3B70
3BA4:  MOVLB  0
3BA6:  RETLW  00
*
56AC:  MOVFF  FF2,0E
56B0:  BCF    FF2.7
56B2:  ADDWF  FE8,W
56B4:  ADDLW  D1
56B6:  MOVWF  FF6
56B8:  MOVLW  56
56BA:  MOVWF  FF7
56BC:  BTFSC  FD8.0
56BE:  INCF   FF7,F
56C0:  TBLRD*-
56C2:  MOVF   FF5,W
56C4:  MOVWF  FFA
56C6:  TBLRD*
56C8:  MOVF   FF5,W
56CA:  BTFSC  0E.7
56CC:  BSF    FF2.7
56CE:  MOVWF  FF9
56D0:  DATA 78,49
56D2:  DATA 9A,49
56D4:  DATA 5C,4A
56D6:  DATA 0A,4B
*
5734:  MOVF   01,W
5736:  MOVFF  6B,281
573A:  MOVLW  64
573C:  MOVLB  2
573E:  MOVWF  x82
5740:  MOVLB  0
5742:  CALL   302E
5746:  MOVFF  00,6B
574A:  MOVF   01,W
574C:  MOVLW  30
574E:  BNZ   575E
5750:  BTFSS  6C.1
5752:  BRA    576E
5754:  BTFSC  6C.3
5756:  BRA    576E
5758:  BTFSC  6C.4
575A:  MOVLW  20
575C:  BRA    5764
575E:  BCF    6C.3
5760:  BCF    6C.4
5762:  BSF    6C.0
5764:  ADDWF  01,F
5766:  MOVFF  01,7D
576A:  CALL   11FE
576E:  MOVFF  6B,281
5772:  MOVLW  0A
5774:  MOVLB  2
5776:  MOVWF  x82
5778:  MOVLB  0
577A:  CALL   302E
577E:  MOVFF  00,6B
5782:  MOVF   01,W
5784:  MOVLW  30
5786:  BNZ   5794
5788:  BTFSC  6C.3
578A:  BRA    579E
578C:  BTFSS  6C.0
578E:  BRA    579E
5790:  BTFSC  6C.4
5792:  MOVLW  20
5794:  ADDWF  01,F
5796:  MOVFF  01,7D
579A:  CALL   11FE
579E:  MOVLW  30
57A0:  ADDWF  6B,F
57A2:  MOVFF  6B,7D
57A6:  CALL   11FE
57AA:  RETLW  00
....................                   //fijamos que el valor leído esté representado con 8 bits 
....................                   //(es decir de 00 a FF). 
....................                   //Para cambiar el rango de salida usamos: ADC=10 (000 a 3FF) 
....................                   //                                      ó ADC=16 (0000 a FFC0) 
.................... #list 
....................  
.................... #include "proyecto1.h" 
.................... //****************************************** 
.................... //Archivo de cabecera del Proyecto 1 
.................... //****************************************** 
.................... //Author: Julio Navarro Lara         2010 
....................  
.................... //Definimos los puertos del microcontrolador 
.................... #byte port_a = 0xF80 
.................... #byte port_b = 0xF81 
.................... #byte port_c = 0xF82 
.................... #byte port_d = 0xF83 
.................... #byte port_e = 0xF84 
....................  
.................... #bit sistema_encendido = 0xF83.2    //Pin que indica el encendido del sistema con un valor alto 
.................... #bit motor = 0xF83.1                //Pin que indica el encendido del motor de circulación del agua con un valor alto 
.................... #bit caldera_encendida = 0xF83.0    //Pin que indica el encendido de la caldera con un valor alto 
.................... #bit menos =    0xF82.1             //Pines para gestionar la entrada de los pulsadores 
.................... #bit mas   =    0xF82.0             //'' 
.................... #bit si    =    0xF82.2             //'' 
.................... #bit no    =    0xF82.5             //'' 
....................  
.................... //Código para definir el botón NO 
.................... #define NOCODE          100 
....................  
.................... //Parámetros de la pantalla LCD 
.................... #define LCD_ORDEN       0    //Código para enviar un orden 
.................... #define LCD_DATO        1    //Código para enviar un dato 
....................  
.................... #define LCD_CLEAR       0x01  //Orden para borrar la pantalla 
.................... #define LCD_NO_CURSOR   0x0C  //Orden para eliminar el cursor de la pantalla 
.................... #define LCD_CURSOR      0x0E  //Orden para visualizar el cursor en la pantalla 
.................... #define LCD_PARPADEAR   0x0D  //Orden para que parpadee el cursor 
....................  
.................... //Tiempo que se mantienen los mensajes temporales en pantalla (ms) 
.................... //En ocasiones este retardo se introduce simplemente para que el usuario o el técnico visualicen los propios 
.................... //valores que han introducido por pantalla sin ser atosigados por la siguiente operación. 
.................... #define LCD_T_RETARDO   500 
....................  
.................... //Parámetros del conversor AD 
.................... #define termostato_caldera   3   //Entrada AD que se refiere a la temperatura de referencia de la caldera 
.................... #define temperatura_caldera  2   //Entrada AD que se refiere a la temperatura del agua en la caldera 
.................... #define histeresis_caldera   5   //Diferencia de histéresis para el agua de la caldera 
.................... //Para probar en el PROTEUS, poner una histeresis de 10 ºC (los potenciómetros simulados no tienen más sensibilidad) 
.................... #define t_max_caldera        100  //Temperatura máxima a la que puede regularse la caldera 
.................... #define t_min_caldera        0  //Temperatura mínima a la que puede regularse la caldera 
.................... #define AD_num_valores       255 //Número de valores de escala del conversor (sensibilidad de los potenciómetros) 
....................  
.................... //Parámetros de control de temperatura 
.................... //Datos suministrados por el aparato de aire acondicionado (con bomba de calor) de mi casa 
.................... #define temp_max          32  //Temperatura máxima de regulación del termostato 
.................... #define temp_min          16  //Temperatura mínima de regulación del termostato 
....................  
.................... //Direcciones para la EEPROM 
.................... #define eeprom_termostato        0x00  //Valor del termostato 
.................... #define eeprom_num_intervalos    0x01  //Número de intervalos de programación de los que disponemos 
.................... #define eeprom_num_registros     0x02  //Número de registros de desconexión de los que se disponen 
.................... #define eeprom_anno_actual       0x03  //Año en el que nos encontramos 
.................... #define eeprom_anno_0_to_3       0x04  //Año en el que nos encontramos medido de 0 a 3 (llamado 1_to_3 por razones "históricas") 
.................... #define eeprom_programaciones    0x05  //Posición a partir de la cual se almacenan las programaciones de alarmas 
.................... #define eeprom_registros         0x14  //Posición a partir de la cual se almacenan los registros 
....................                                        //En este caso, por usar la memoria interna del microprocesador, caben sólo 26 registros 
....................  
.................... #fuses HS, NOPROTECT, BROWNOUT, PUT, NOLVP, NOXINST, WDT4096, NOWDT 
.................... //El watchdog-timer salta cada 16.384 segundos, aproximadamente 
.................... #use delay(clock=8000000, restart_wdt) 
*
10E6:  CLRF   FEA
10E8:  MOVLW  84
10EA:  MOVWF  FE9
10EC:  MOVF   FEF,W
10EE:  BZ    1114
10F0:  MOVLW  02
10F2:  MOVWF  01
10F4:  MOVLW  BF
10F6:  MOVWF  00
10F8:  CLRWDT
10FA:  DECFSZ 00,F
10FC:  BRA    10F8
10FE:  DECFSZ 01,F
1100:  BRA    10F4
1102:  MOVLW  96
1104:  MOVWF  00
1106:  DECFSZ 00,F
1108:  BRA    1106
110A:  NOP   
110C:  NOP   
110E:  CLRWDT
1110:  DECFSZ FEF,F
1112:  BRA    10F0
1114:  RETLW  00
*
1134:  MOVLW  09
1136:  SUBWF  x85,F
1138:  BNC   1150
113A:  CLRF   FEA
113C:  MOVLW  85
113E:  MOVWF  FE9
1140:  BCF    FD8.0
1142:  RRCF   FEF,F
1144:  MOVF   FEF,W
1146:  BZ    1150
1148:  BRA    114C
114A:  CLRWDT
114C:  DECFSZ FEF,F
114E:  BRA    114A
1150:  RETLW  00
.................... #use rs232(baud=4800, xmit=PIN_C6,rcv=PIN_C7) 
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  (x==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  (x<' ') 
.................... #define isprint(x)  (x>=' ') 
.................... #define isgraph(x)  (x>' ') 
.................... #define ispunct(x)  ((x>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(int *)==1 
.................... #define ptrdiff_t int 
.................... #else 
.................... #define ptrdiff_t long 
.................... #endif 
....................  
.................... #define size_t int 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: float atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... float atof(char * s); 
....................  
.................... /* Standard template: float atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... float atoe(char * s); 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int32 atoi32(char *s); 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, int8 base, char * s); 
....................  
.................... /* Standard template: signed long  atol(char * s) 
....................  * converts the initial portion of the string s to a signed long 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: float strtol(char * s,char *endptr) 
....................  * converts the initial portion of the string s to a float 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... float strtod(char *s,char *endptr); 
....................  
.................... /* Standard template: long strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr,signed int base); 
....................  
.................... /* Standard template: long strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... long strtoul(char *s,char *endptr,signed int base); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... long rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer,signed int denom); 
.................... ldiv_t ldiv(signed long numer,signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(int *)==1 
.................... #define ptrdiff_t int 
.................... #else 
.................... #define ptrdiff_t long 
.................... #endif 
....................  
.................... #define size_t int 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(int *)==1 
.................... #define ptrdiff_t int 
.................... #else 
.................... #define ptrdiff_t long 
.................... #endif 
....................  
.................... #define size_t int 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  (x==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  (x<' ') 
.................... #define isprint(x)  (x>=' ') 
.................... #define isgraph(x)  (x>' ') 
.................... #define ispunct(x)  ((x>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* compiler ignored the name 'strcpy()'; perhaps, it's reserved? 
....................    Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1*/ 
....................  
.................... char *strcopy(char *s1, char *s2) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; *s2 != 0; s++, s2++) { 
.................... 	  *s = *s2; 
....................   } 
....................   *s = *s2; 
....................   return(s1); 
.................... } 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   int n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,int c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, int c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... int *strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, int c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... int *strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
.................... 	 if (*sc2 == '\0') 
.................... 	    return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
.................... 	char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
.................... 	while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && *s == *t; ++s, ++t); 
....................  
.................... 		if (*t == '\0') 
.................... 			return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
.................... 	} 
.................... 	return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(int errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... int *strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer,signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer,signed long denom) 
.................... { 
....................    ldiv_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... float atof(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int sign = 0; 
....................    char c; 
....................    int ptr = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
....................  
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int sign = 0; 
....................    int expsign = 0; 
....................    char c; 
....................    int ptr = 0; 
....................    int i; 
....................    float exp = 1.0; 
....................    int expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
128E:  CLRF   7B
....................    sign = 0; 
1290:  CLRF   79
....................    base = 10; 
1292:  MOVLW  0A
1294:  MOVWF  7A
....................    result = 0; 
1296:  CLRF   78
....................  
....................    if (!s) 
1298:  MOVF   76,W
129A:  IORWF  77,W
129C:  BNZ   12A4
....................       return 0; 
129E:  MOVLW  00
12A0:  MOVWF  01
12A2:  BRA    1426
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
12A4:  MOVF   7B,W
12A6:  INCF   7B,F
12A8:  CLRF   03
12AA:  ADDWF  76,W
12AC:  MOVWF  FE9
12AE:  MOVF   77,W
12B0:  ADDWFC 03,W
12B2:  MOVWF  FEA
12B4:  MOVFF  FEF,7C
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
12B8:  MOVF   7C,W
12BA:  SUBLW  2D
12BC:  BNZ   12D8
....................    { 
....................       sign = 1;         // Set the sign to negative 
12BE:  MOVLW  01
12C0:  MOVWF  79
....................       c = s[index++]; 
12C2:  MOVF   7B,W
12C4:  INCF   7B,F
12C6:  CLRF   03
12C8:  ADDWF  76,W
12CA:  MOVWF  FE9
12CC:  MOVF   77,W
12CE:  ADDWFC 03,W
12D0:  MOVWF  FEA
12D2:  MOVFF  FEF,7C
....................    } 
....................    else if (c == '+') 
12D6:  BRA    12F2
12D8:  MOVF   7C,W
12DA:  SUBLW  2B
12DC:  BNZ   12F2
....................    { 
....................       c = s[index++]; 
12DE:  MOVF   7B,W
12E0:  INCF   7B,F
12E2:  CLRF   03
12E4:  ADDWF  76,W
12E6:  MOVWF  FE9
12E8:  MOVF   77,W
12EA:  ADDWFC 03,W
12EC:  MOVWF  FEA
12EE:  MOVFF  FEF,7C
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
12F2:  MOVF   7C,W
12F4:  SUBLW  2F
12F6:  BTFSC  FD8.0
12F8:  BRA    1416
12FA:  MOVF   7C,W
12FC:  SUBLW  39
12FE:  BTFSS  FD8.0
1300:  BRA    1416
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
1302:  MOVF   7C,W
1304:  SUBLW  30
1306:  BNZ   134A
1308:  CLRF   03
130A:  MOVF   7B,W
130C:  ADDWF  76,W
130E:  MOVWF  FE9
1310:  MOVF   77,W
1312:  ADDWFC 03,W
1314:  MOVWF  FEA
1316:  MOVF   FEF,W
1318:  SUBLW  78
131A:  BZ    1330
131C:  CLRF   03
131E:  MOVF   7B,W
1320:  ADDWF  76,W
1322:  MOVWF  FE9
1324:  MOVF   77,W
1326:  ADDWFC 03,W
1328:  MOVWF  FEA
132A:  MOVF   FEF,W
132C:  SUBLW  58
132E:  BNZ   134A
....................       { 
....................          base = 16; 
1330:  MOVLW  10
1332:  MOVWF  7A
....................          index++; 
1334:  INCF   7B,F
....................          c = s[index++]; 
1336:  MOVF   7B,W
1338:  INCF   7B,F
133A:  CLRF   03
133C:  ADDWF  76,W
133E:  MOVWF  FE9
1340:  MOVF   77,W
1342:  ADDWFC 03,W
1344:  MOVWF  FEA
1346:  MOVFF  FEF,7C
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
134A:  MOVF   7A,W
134C:  SUBLW  0A
134E:  BNZ   1386
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
1350:  MOVF   7C,W
1352:  SUBLW  2F
1354:  BC    1384
1356:  MOVF   7C,W
1358:  SUBLW  39
135A:  BNC   1384
....................             result = 10*result + (c - '0'); 
135C:  MOVLW  0A
135E:  MOVWF  7D
1360:  MOVFF  78,7E
1364:  BRA    1242
1366:  MOVLW  30
1368:  SUBWF  7C,W
136A:  ADDWF  01,W
136C:  MOVWF  78
....................             c = s[index++]; 
136E:  MOVF   7B,W
1370:  INCF   7B,F
1372:  CLRF   03
1374:  ADDWF  76,W
1376:  MOVWF  FE9
1378:  MOVF   77,W
137A:  ADDWFC 03,W
137C:  MOVWF  FEA
137E:  MOVFF  FEF,7C
....................          } 
1382:  BRA    1350
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
1384:  BRA    1416
1386:  MOVF   7A,W
1388:  SUBLW  10
138A:  BNZ   1416
....................       { 
....................          c = toupper(c); 
138C:  MOVF   7C,W
138E:  SUBLW  60
1390:  BC    139E
1392:  MOVF   7C,W
1394:  SUBLW  7A
1396:  BNC   139E
1398:  MOVF   7C,W
139A:  ANDLW  DF
139C:  BRA    13A0
139E:  MOVF   7C,W
13A0:  MOVWF  7C
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
13A2:  MOVF   7C,W
13A4:  SUBLW  2F
13A6:  BC    13AE
13A8:  MOVF   7C,W
13AA:  SUBLW  39
13AC:  BC    13BA
13AE:  MOVF   7C,W
13B0:  SUBLW  40
13B2:  BC    1416
13B4:  MOVF   7C,W
13B6:  SUBLW  46
13B8:  BNC   1416
....................             if (c >= '0' && c <= '9') 
13BA:  MOVF   7C,W
13BC:  SUBLW  2F
13BE:  BC    13D8
13C0:  MOVF   7C,W
13C2:  SUBLW  39
13C4:  BNC   13D8
....................                result = (result << 4) + (c - '0'); 
13C6:  SWAPF  78,W
13C8:  MOVWF  7D
13CA:  MOVLW  F0
13CC:  ANDWF  7D,F
13CE:  MOVLW  30
13D0:  SUBWF  7C,W
13D2:  ADDWF  7D,W
13D4:  MOVWF  78
....................             else 
13D6:  BRA    13EA
....................                result = (result << 4) + (c - 'A' + 10); 
13D8:  SWAPF  78,W
13DA:  MOVWF  7D
13DC:  MOVLW  F0
13DE:  ANDWF  7D,F
13E0:  MOVLW  41
13E2:  SUBWF  7C,W
13E4:  ADDLW  0A
13E6:  ADDWF  7D,W
13E8:  MOVWF  78
....................  
....................             c = s[index++]; 
13EA:  MOVF   7B,W
13EC:  INCF   7B,F
13EE:  CLRF   03
13F0:  ADDWF  76,W
13F2:  MOVWF  FE9
13F4:  MOVF   77,W
13F6:  ADDWFC 03,W
13F8:  MOVWF  FEA
13FA:  MOVFF  FEF,7C
....................             c = toupper(c); 
13FE:  MOVF   7C,W
1400:  SUBLW  60
1402:  BC    1410
1404:  MOVF   7C,W
1406:  SUBLW  7A
1408:  BNC   1410
140A:  MOVF   7C,W
140C:  ANDLW  DF
140E:  BRA    1412
1410:  MOVF   7C,W
1412:  MOVWF  7C
....................          } 
1414:  BRA    13A2
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
1416:  DECFSZ 79,W
1418:  BRA    1422
141A:  MOVF   7A,W
141C:  SUBLW  0A
141E:  BNZ   1422
....................        result = -result; 
1420:  NEGF   78
....................  
....................    return(result); 
1422:  MOVFF  78,01
.................... } 
1426:  RETLW  00
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... char * itoa(signed int32 num, int8 base, char *s) 
.................... { 
....................      int32 temp=1; 
....................      int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... float strtod(char *s,char *endptr) { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int sign = 0, point = 0; 
....................    char c; 
....................    int ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c=s[ptr++]; 
....................  
....................  
....................    while((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 0) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          point = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 1) { 
....................          pow10 = pow10*10; 
....................          result += (c - '0')/pow10; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '+') { 
....................          c = s[ptr++]; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................          *((char *)endptr)=s+ptr; 
....................       } 
....................       else 
....................          *((char *)endptr)=s; 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... long strtoul(char *s,char *endptr,signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-') 
....................    { 
....................       if (endptr) 
....................       { 
....................         *((char *)endptr)=s; 
....................       } 
....................       return 0; 
....................    } 
....................  
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    { 
....................       if (endptr) 
....................       { 
....................         *((char *)endptr)=s; 
....................       } 
....................       return 0; 
....................    } 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................       if (endptr) 
....................       { 
....................         *((char *)endptr)=s; 
....................       } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................         *((char *)endptr)=sc; 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr,signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    { 
....................       if (endptr) 
....................       { 
....................         *((char *)endptr)=s; 
....................       } 
....................       return 0; 
....................    } 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................       if (endptr) 
....................       { 
....................         *((char *)endptr)=s; 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................         *((char *)endptr)=sc; 
....................    return x; 
.................... } 
....................  
.................... signed int system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed = 1; 
....................  
.................... long rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned long)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... typedef signed int (*_Cmpfun)(char * p1,char * p2); 
....................  
.................... void qsort(char * qdata, int qitems, int qsize, _Cmpfun cmp) { 
....................    int m,j,i,l; 
....................    short done; 
....................    BYTE t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=TRUE; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = FALSE; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include "PCF8583.c" 
.................... // Funciones para el RTC I2c: PCF8583 
.................... // Este código no procede de CCS (no está totalmente verificado) 
.................... // Inluye funciones de conversión BCD-Binario 
.................... // y de lectura/escritura a través de I2C. 
....................  
.................... //Vamos a eliminar todos los casos en los que se habiliten las interrupciones globales 
.................... //Estas sentencias nos impedían utilizar estos métodos en las interrupciones 
....................  
.................... #ifndef PCF8583_SDA 
.................... #define PCF8583_SDA  PIN_C4 
.................... #define PCF8583_SCL  PIN_C3 
.................... #endif 
....................  
.................... #use i2c(master, sda=PCF8583_SDA, scl=PCF8583_SCL, NOFORCE_SW) 
*
14BE:  BCF    FC6.7
14C0:  BCF    F9E.3
14C2:  MOVFF  7E,FC9
14C6:  MOVLW  02
14C8:  BTFSC  FC6.7
14CA:  BRA    14D6
14CC:  BTFSS  F9E.3
14CE:  BRA    14CC
14D0:  MOVLW  00
14D2:  BTFSC  FC5.6
14D4:  MOVLW  01
14D6:  MOVWF  01
14D8:  RETLW  00
*
26C4:  BSF    FC5.3
26C6:  BTFSC  FC5.3
26C8:  BRA    26C6
26CA:  BTFSC  00.0
26CC:  BCF    FC5.5
26CE:  BTFSS  00.0
26D0:  BSF    FC5.5
26D2:  BSF    FC5.4
26D4:  BTFSC  FC5.4
26D6:  BRA    26D4
26D8:  MOVFF  FC9,01
26DC:  RETLW  00
....................  
.................... #ifndef PCF8583_WRITE_ADDRESS 
.................... #define PCF8583_WRITE_ADDRESS 0xA0 
.................... #define PCF8583_READ_ADDRESS  0xA1 
.................... #endif 
....................  
.................... // Register addresses 
.................... #define PCF8583_CTRL_STATUS_REG    0x00 
.................... #define PCF8583_100S_REG           0x01 
.................... #define PCF8583_SECONDS_REG        0x02 
.................... #define PCF8583_MINUTES_REG        0x03 
.................... #define PCF8583_HOURS_REG          0x04 
.................... #define PCF8583_DATE_REG           0x05 
.................... #define PCF8583_MONTHS_REG         0x06 
.................... #define PCF8583_TIMER_REG          0x07 
....................  
.................... #define PCF8583_ALARM_CONTROL_REG  0x08 
.................... #define PCF8583_ALARM_100S_REG     0x09 
.................... #define PCF8583_ALARM_SECS_REG     0x0A 
.................... #define PCF8583_ALARM_MINS_REG     0x0B 
.................... #define PCF8583_ALARM_HOURS_REG    0x0C 
.................... #define PCF8583_ALARM_DATE_REG     0x0D 
.................... #define PCF8583_ALARM_MONTHS_REG   0x0E 
.................... #define PCF8583_ALARM_TIMER_REG    0x0F 
....................  
.................... // Use the first NVRAM address for the year byte. 
.................... #define PCF8583_YEAR_REG           0x10 
....................  
....................  
.................... // Commands for the Control/Status register. 
.................... #define PCF8583_START_COUNTING     0x00 
.................... #define PCF8583_STOP_COUNTING      0x80 
.................... #define PCF8583_ACTIVAR_ALARMA     0b00000100  //Palabra de activación de la alarma 
.................... #define PCF8583_DEFINIR_ALARMA     0b10010000  //Palabra para definir el comportamiento 
....................                                                //de la alarma en su registro 
....................  
.................... #define PCF8583_DESACTIVAR_INT     0b00010000 
....................  
....................  
....................  
....................  
.................... char const weekday_names[7][10] = 
.................... { 
.................... {"DOM"}, 
.................... {"LUN"}, 
.................... {"MAR"}, 
.................... {"MIE"}, 
.................... {"JUE"}, 
.................... {"VIE"}, 
.................... {"SAB"} 
.................... }; 
....................  
.................... // This structure defines the user's date and time data. 
.................... // The values are stored as unsigned integers.  The user 
.................... // should declare a structure of this type in the application 
.................... // program. Then the address of the structure should be 
.................... // passed to the PCF8583 read/write functions in this 
.................... // driver, whenever you want to talk to the chip. 
.................... typedef struct 
.................... { 
.................... int8 seconds;    // 0 to 59 
.................... int8 minutes;    // 0 to 59 
.................... int8 hours;      // 0 to 23  (24-hour time) 
.................... int8 day;        // 1 to 31 
.................... int8 month;      // 1 to 12 
.................... int8 year;       // 00 to 99 
.................... int8 weekday;    // 0 = Sunday, 1 = Monday, etc. 
.................... }date_time_t; 
....................  
....................  
.................... //---------------------------------------------- 
.................... void PCF8583_write_byte(int8 address, int8 data) 
.................... { 
.................... disable_interrupts(GLOBAL); 
*
14DA:  BCF    FF2.6
14DC:  BCF    FF2.7
14DE:  BTFSC  FF2.7
14E0:  BRA    14DC
.................... i2c_start(); 
14E2:  BSF    FC5.0
14E4:  BTFSC  FC5.0
14E6:  BRA    14E4
.................... i2c_write(PCF8583_WRITE_ADDRESS); 
14E8:  MOVLW  A0
14EA:  MOVWF  7E
14EC:  RCALL  14BE
.................... i2c_write(address); 
14EE:  MOVFF  7C,7E
14F2:  RCALL  14BE
.................... i2c_write(data); 
14F4:  MOVFF  7D,7E
14F8:  RCALL  14BE
.................... i2c_stop(); 
14FA:  BSF    FC5.2
14FC:  BTFSC  FC5.2
14FE:  BRA    14FC
.................... } 
1500:  RETLW  00
....................  
.................... //---------------------------------------------- 
.................... int8 PCF8583_read_byte(int8 address) 
.................... { 
.................... int8 retval; 
....................  
.................... disable_interrupts(GLOBAL); 
*
2704:  BCF    FF2.6
2706:  BCF    FF2.7
2708:  BTFSC  FF2.7
270A:  BRA    2706
.................... i2c_start(); 
270C:  BSF    FC5.0
270E:  BTFSC  FC5.0
2710:  BRA    270E
.................... i2c_write(PCF8583_WRITE_ADDRESS); 
2712:  MOVLW  A0
2714:  MOVWF  7E
2716:  CALL   14BE
.................... i2c_write(address); 
271A:  MOVFF  7C,7E
271E:  CALL   14BE
.................... i2c_start(); 
2722:  BSF    FC5.1
2724:  BTFSC  FC5.1
2726:  BRA    2724
.................... i2c_write(PCF8583_READ_ADDRESS); 
2728:  MOVLW  A1
272A:  MOVWF  7E
272C:  CALL   14BE
.................... retval = i2c_read(0); 
2730:  CLRF   00
2732:  RCALL  26C4
2734:  MOVFF  01,7D
.................... i2c_stop(); 
2738:  BSF    FC5.2
273A:  BTFSC  FC5.2
273C:  BRA    273A
....................  
.................... return(retval); 
273E:  MOVFF  7D,01
.................... } 
2742:  GOTO   2892 (RETURN)
....................  
....................  
.................... void PCF8583_init(void) 
.................... { 
.................... PCF8583_write_byte(PCF8583_CTRL_STATUS_REG, 
....................                               PCF8583_START_COUNTING); 
.................... } 
....................  
.................... //---------------------------------------------- 
.................... // This function converts an 8 bit binary value 
.................... // to an 8 bit BCD value. 
.................... // The input range must be from 0 to 99. 
....................  
.................... int8 bin2bcd(int8 value) 
.................... { 
.................... char retval; 
....................  
.................... retval = 0; 
*
149E:  CLRF   7C
....................  
.................... while(1) 
....................   { 
....................    // Get the tens digit by doing multiple subtraction 
....................    // of 10 from the binary value. 
....................    if(value >= 10) 
14A0:  MOVF   7B,W
14A2:  SUBLW  09
14A4:  BC    14B0
....................      { 
....................       value -= 10; 
14A6:  MOVLW  0A
14A8:  SUBWF  7B,F
....................       retval += 0x10; 
14AA:  MOVLW  10
14AC:  ADDWF  7C,F
....................      } 
....................    else // Get the ones digit by adding the remainder. 
14AE:  BRA    14B6
....................      { 
....................       retval += value; 
14B0:  MOVF   7B,W
14B2:  ADDWF  7C,F
....................       break; 
14B4:  BRA    14B8
....................      } 
....................    } 
14B6:  BRA    14A0
....................  
.................... return(retval); 
14B8:  MOVFF  7C,01
.................... } 
14BC:  RETLW  00
....................  
.................... //---------------------------------------------- 
.................... // This function converts an 8 bit BCD value to 
.................... // an 8 bit binary value. 
.................... // The input range must be from 00 to 99. 
....................  
.................... char bcd2bin(char bcd_value) 
.................... { 
.................... char temp; 
....................  
.................... temp = bcd_value; 
*
26DE:  MOVFF  7F,80
....................  
.................... // Shifting the upper digit right by 1 is 
.................... // the same as multiplying it by 8. 
.................... temp >>= 1; 
26E2:  BCF    FD8.0
26E4:  RRCF   x80,F
....................  
.................... // Isolate the bits for the upper digit. 
.................... temp &= 0x78; 
26E6:  MOVLW  78
26E8:  ANDWF  x80,F
....................  
.................... // Now return: (Tens * 8) + (Tens * 2) + Ones 
.................... return(temp + (temp >> 2) + (bcd_value & 0x0f)); 
26EA:  RRCF   x80,W
26EC:  MOVWF  00
26EE:  RRCF   00,F
26F0:  MOVLW  3F
26F2:  ANDWF  00,F
26F4:  MOVF   00,W
26F6:  ADDWF  x80,W
26F8:  MOVWF  x81
26FA:  MOVF   7F,W
26FC:  ANDLW  0F
26FE:  ADDWF  x81,W
2700:  MOVWF  01
....................  
.................... } 
2702:  RETLW  00
....................  
.................... //---------------------------------------------- 
.................... void PCF8583_set_datetime(date_time_t *dt) 
.................... { 
.................... int8 bcd_sec; 
.................... int8 bcd_min; 
.................... int8 bcd_hrs; 
.................... int8 bcd_day; 
.................... int8 bcd_mon; 
....................  
.................... // Convert the input date/time into BCD values 
.................... // that are formatted for the PCF8583 registers. 
.................... bcd_sec = bin2bcd(dt->seconds); 
*
1502:  MOVF   73,W
1504:  MOVWF  FE9
1506:  MOVFF  74,FEA
150A:  MOVFF  FEF,7A
150E:  MOVFF  7A,7B
1512:  RCALL  149E
1514:  MOVFF  01,75
.................... bcd_min = bin2bcd(dt->minutes); 
1518:  MOVLW  01
151A:  ADDWF  73,W
151C:  MOVWF  FE9
151E:  MOVLW  00
1520:  ADDWFC 74,W
1522:  MOVWF  FEA
1524:  MOVFF  FEF,7A
1528:  MOVFF  7A,7B
152C:  RCALL  149E
152E:  MOVFF  01,76
.................... bcd_hrs = bin2bcd(dt->hours); 
1532:  MOVLW  02
1534:  ADDWF  73,W
1536:  MOVWF  FE9
1538:  MOVLW  00
153A:  ADDWFC 74,W
153C:  MOVWF  FEA
153E:  MOVFF  FEF,7A
1542:  MOVFF  7A,7B
1546:  RCALL  149E
1548:  MOVFF  01,77
.................... bcd_day = bin2bcd(dt->day) | (dt->year << 6); 
154C:  MOVLW  03
154E:  ADDWF  73,W
1550:  MOVWF  FE9
1552:  MOVLW  00
1554:  ADDWFC 74,W
1556:  MOVWF  FEA
1558:  MOVFF  FEF,7A
155C:  MOVFF  7A,7B
1560:  RCALL  149E
1562:  MOVLW  05
1564:  ADDWF  73,W
1566:  MOVWF  FE9
1568:  MOVLW  00
156A:  ADDWFC 74,W
156C:  MOVWF  FEA
156E:  SWAPF  FEF,W
1570:  MOVWF  00
1572:  RLCF   00,F
1574:  RLCF   00,F
1576:  MOVLW  C0
1578:  ANDWF  00,F
157A:  MOVF   00,W
157C:  IORWF  01,W
157E:  MOVWF  78
.................... bcd_mon = bin2bcd(dt->month) | (dt->weekday << 5); 
1580:  MOVLW  04
1582:  ADDWF  73,W
1584:  MOVWF  FE9
1586:  MOVLW  00
1588:  ADDWFC 74,W
158A:  MOVWF  FEA
158C:  MOVFF  FEF,7A
1590:  MOVFF  7A,7B
1594:  RCALL  149E
1596:  MOVLW  06
1598:  ADDWF  73,W
159A:  MOVWF  FE9
159C:  MOVLW  00
159E:  ADDWFC 74,W
15A0:  MOVWF  FEA
15A2:  SWAPF  FEF,W
15A4:  MOVWF  00
15A6:  RLCF   00,F
15A8:  MOVLW  E0
15AA:  ANDWF  00,F
15AC:  MOVF   00,W
15AE:  IORWF  01,W
15B0:  MOVWF  79
....................  
.................... // Stop the RTC from counting, before we write to 
.................... // the date and time registers. 
.................... PCF8583_write_byte(PCF8583_CTRL_STATUS_REG, 
....................                               PCF8583_STOP_COUNTING); 
15B2:  CLRF   7C
15B4:  MOVLW  80
15B6:  MOVWF  7D
15B8:  RCALL  14DA
....................  
.................... // Write to the date and time registers.  Disable interrupts 
.................... // so they can't disrupt the i2c operations. 
.................... disable_interrupts(GLOBAL); 
15BA:  BCF    FF2.6
15BC:  BCF    FF2.7
15BE:  BTFSC  FF2.7
15C0:  BRA    15BC
.................... i2c_start(); 
15C2:  BSF    FC5.0
15C4:  BTFSC  FC5.0
15C6:  BRA    15C4
.................... i2c_write(PCF8583_WRITE_ADDRESS); 
15C8:  MOVLW  A0
15CA:  MOVWF  7E
15CC:  RCALL  14BE
.................... i2c_write(PCF8583_100S_REG);   // Start at 100's reg. 
15CE:  MOVLW  01
15D0:  MOVWF  7E
15D2:  RCALL  14BE
.................... i2c_write(0x00);               // Set 100's reg = 0 
15D4:  CLRF   7E
15D6:  RCALL  14BE
.................... i2c_write(bcd_sec); 
15D8:  MOVFF  75,7E
15DC:  RCALL  14BE
.................... i2c_write(bcd_min); 
15DE:  MOVFF  76,7E
15E2:  RCALL  14BE
.................... i2c_write(bcd_hrs); 
15E4:  MOVFF  77,7E
15E8:  RCALL  14BE
.................... i2c_write(bcd_day); 
15EA:  MOVFF  78,7E
15EE:  RCALL  14BE
.................... i2c_write(bcd_mon); 
15F0:  MOVFF  79,7E
15F4:  RCALL  14BE
.................... i2c_stop(); 
15F6:  BSF    FC5.2
15F8:  BTFSC  FC5.2
15FA:  BRA    15F8
....................  
.................... // Write the year byte to the first NVRAM location. 
.................... // Leave it in binary format. 
.................... PCF8583_write_byte(PCF8583_YEAR_REG, dt->year); 
15FC:  MOVLW  05
15FE:  ADDWF  73,W
1600:  MOVWF  FE9
1602:  MOVLW  00
1604:  ADDWFC 74,W
1606:  MOVWF  FEA
1608:  MOVFF  FEF,7A
160C:  MOVLW  10
160E:  MOVWF  7C
1610:  MOVFF  7A,7D
1614:  RCALL  14DA
....................  
.................... // Now allow the PCF8583 to start counting again. 
.................... PCF8583_write_byte(PCF8583_CTRL_STATUS_REG, 
....................                               PCF8583_START_COUNTING); 
1616:  CLRF   7C
1618:  CLRF   7D
161A:  RCALL  14DA
.................... } 
161C:  GOTO   1D00 (RETURN)
....................  
.................... //---------------------------------------------- 
.................... // Read the Date and Time from the hardware registers 
.................... // in the PCF8583.   We don't have to disable counting 
.................... // during read operations, because according to the data 
.................... // sheet, if any of the lower registers (1 to 7) is read, 
.................... // all of them are loaded into "capture" registers. 
.................... // All further reading within that cycle is done from 
.................... // those registers. 
....................  
.................... void PCF8583_read_datetime(date_time_t *dt) 
.................... { 
.................... int8 year_bits; 
.................... int8 year; 
....................  
.................... int8 bcd_sec; 
.................... int8 bcd_min; 
.................... int8 bcd_hrs; 
.................... int8 bcd_day; 
.................... int8 bcd_mon; 
....................  
.................... // Disable interrupts so the i2c process is not disrupted. 
.................... disable_interrupts(GLOBAL); 
*
2746:  BCF    FF2.6
2748:  BCF    FF2.7
274A:  BTFSC  FF2.7
274C:  BRA    2748
....................  
.................... // Read the date/time registers inside the PCF8583. 
.................... i2c_start(); 
274E:  BSF    FC5.0
2750:  BTFSC  FC5.0
2752:  BRA    2750
.................... i2c_write(PCF8583_WRITE_ADDRESS); 
2754:  MOVLW  A0
2756:  MOVWF  7E
2758:  CALL   14BE
.................... i2c_write(PCF8583_SECONDS_REG);   // Start at seconds reg. 
275C:  MOVLW  02
275E:  MOVWF  7E
2760:  CALL   14BE
.................... i2c_start(); 
2764:  BSF    FC5.1
2766:  BTFSC  FC5.1
2768:  BRA    2766
.................... i2c_write(PCF8583_READ_ADDRESS); 
276A:  MOVLW  A1
276C:  MOVWF  7E
276E:  CALL   14BE
....................  
.................... bcd_sec = i2c_read(); 
2772:  MOVLW  01
2774:  MOVWF  00
2776:  RCALL  26C4
2778:  MOVFF  01,77
.................... bcd_min = i2c_read(); 
277C:  MOVLW  01
277E:  MOVWF  00
2780:  RCALL  26C4
2782:  MOVFF  01,78
.................... bcd_hrs = i2c_read(); 
2786:  MOVLW  01
2788:  MOVWF  00
278A:  RCALL  26C4
278C:  MOVFF  01,79
.................... bcd_day = i2c_read(); 
2790:  MOVLW  01
2792:  MOVWF  00
2794:  RCALL  26C4
2796:  MOVFF  01,7A
.................... bcd_mon = i2c_read(0); 
279A:  CLRF   00
279C:  RCALL  26C4
279E:  MOVFF  01,7B
.................... i2c_stop(); 
27A2:  BSF    FC5.2
27A4:  BTFSC  FC5.2
27A6:  BRA    27A4
....................  
....................  
.................... // Convert the date/time values from BCD to 
.................... // unsigned 8-bit integers.  Unpack the bits 
.................... // in the PCF8583 registers where required. 
.................... dt->seconds = bcd2bin(bcd_sec); 
27A8:  MOVFF  73,01
27AC:  MOVFF  74,03
27B0:  MOVFF  73,7C
27B4:  MOVFF  74,7D
27B8:  MOVFF  77,7F
27BC:  RCALL  26DE
27BE:  MOVFF  7D,FEA
27C2:  MOVFF  7C,FE9
27C6:  MOVFF  01,FEF
.................... dt->minutes = bcd2bin(bcd_min); 
27CA:  MOVLW  01
27CC:  ADDWF  73,W
27CE:  MOVWF  01
27D0:  MOVLW  00
27D2:  ADDWFC 74,W
27D4:  MOVWF  03
27D6:  MOVFF  01,7C
27DA:  MOVWF  7D
27DC:  MOVFF  78,7F
27E0:  RCALL  26DE
27E2:  MOVFF  7D,FEA
27E6:  MOVFF  7C,FE9
27EA:  MOVFF  01,FEF
.................... dt->hours   = bcd2bin(bcd_hrs & 0x3F); 
27EE:  MOVLW  02
27F0:  ADDWF  73,W
27F2:  MOVWF  01
27F4:  MOVLW  00
27F6:  ADDWFC 74,W
27F8:  MOVWF  03
27FA:  MOVFF  01,7C
27FE:  MOVWF  7D
2800:  MOVF   79,W
2802:  ANDLW  3F
2804:  MOVWF  7E
2806:  MOVWF  7F
2808:  RCALL  26DE
280A:  MOVFF  7D,FEA
280E:  MOVFF  7C,FE9
2812:  MOVFF  01,FEF
.................... dt->day     = bcd2bin(bcd_day & 0x3F); 
2816:  MOVLW  03
2818:  ADDWF  73,W
281A:  MOVWF  01
281C:  MOVLW  00
281E:  ADDWFC 74,W
2820:  MOVWF  03
2822:  MOVFF  01,7C
2826:  MOVWF  7D
2828:  MOVF   7A,W
282A:  ANDLW  3F
282C:  MOVWF  7E
282E:  MOVWF  7F
2830:  RCALL  26DE
2832:  MOVFF  7D,FEA
2836:  MOVFF  7C,FE9
283A:  MOVFF  01,FEF
.................... dt->month   = bcd2bin(bcd_mon & 0x1F); 
283E:  MOVLW  04
2840:  ADDWF  73,W
2842:  MOVWF  01
2844:  MOVLW  00
2846:  ADDWFC 74,W
2848:  MOVWF  03
284A:  MOVFF  01,7C
284E:  MOVWF  7D
2850:  MOVF   7B,W
2852:  ANDLW  1F
2854:  MOVWF  7E
2856:  MOVWF  7F
2858:  RCALL  26DE
285A:  MOVFF  7D,FEA
285E:  MOVFF  7C,FE9
2862:  MOVFF  01,FEF
.................... dt->weekday = bcd_mon >> 5; 
2866:  MOVLW  06
2868:  ADDWF  73,W
286A:  MOVWF  FE9
286C:  MOVLW  00
286E:  ADDWFC 74,W
2870:  MOVWF  FEA
2872:  SWAPF  7B,W
2874:  MOVWF  00
2876:  RRCF   00,F
2878:  MOVLW  07
287A:  ANDWF  00,F
287C:  MOVFF  00,FEF
.................... year_bits   = bcd_day >> 6; 
2880:  SWAPF  7A,W
2882:  MOVWF  75
2884:  RRCF   75,F
2886:  RRCF   75,F
2888:  MOVLW  03
288A:  ANDWF  75,F
....................  
.................... // Read the year byte from NVRAM. 
.................... // This is an added feature of this driver. 
.................... year = PCF8583_read_byte(PCF8583_YEAR_REG); 
288C:  MOVLW  10
288E:  MOVWF  7C
2890:  BRA    2704
2892:  MOVFF  01,76
....................  
.................... // Check if the two "year bits" were incremented by 
.................... // the PCF8583.  If so, increment the 8-bit year 
.................... // byte (read from NVRAM) by the same amount. 
.................... while(year_bits != (year & 3)) 
....................       year++; 
2896:  MOVF   76,W
2898:  ANDLW  03
289A:  SUBWF  75,W
289C:  BZ    28A2
289E:  INCF   76,F
28A0:  BRA    2896
....................  
.................... dt->year = year; 
28A2:  MOVLW  05
28A4:  ADDWF  73,W
28A6:  MOVWF  FE9
28A8:  MOVLW  00
28AA:  ADDWFC 74,W
28AC:  MOVWF  FEA
28AE:  MOVFF  76,FEF
....................  
.................... // Now update the year byte in the NVRAM 
.................... // inside the PCF8583. 
.................... PCF8583_write_byte(PCF8583_YEAR_REG, year); 
28B2:  MOVLW  10
28B4:  MOVWF  7C
28B6:  MOVFF  76,7D
28BA:  CALL   14DA
....................  
.................... } 
28BE:  RETLW  00
....................  
....................  
.................... #include "LCDeasy.c" 
.................... ////----------------------------------------------------------------------------//// 
.................... // 	Funciones para la gestion del display LCD de la EasyPIC3 
.................... //	con el compilador de CCS. 
.................... //	Es una adaptación del archivo LCD.c de CCS para las prácticas de la 
.................... //	asignatura, y por tanto no distribuible a usuarios no autorizados. 
.................... //------------------------------------------------------------------------------//// 
....................  
.................... //  lcd_init()   Inicializa el LCD: debe ser llamada antes que las otras funciones. 
.................... // 
.................... //  lcd_putc(c)  Visualiza c en la siguiente posición del display. 
.................... //               Caracteres especiales de control: 
.................... //                      \f  Borrar display 
.................... //                      \n  Saltar a la segunda linea 
.................... //                      \b  Retroceder una posición. 
.................... // 
.................... //  lcd_gotoxy(x,y) Selecciona la nueva posicion de escritura en el display. 
.................... //                  (la esquina superior izquierda es 1,1) 
.................... // 
.................... //  lcd_getc(x,y)   Devuelve el caracter de la posicion x,y del display. 
.................... //			(esta función no va en la EASYPIC3, pues R/W=0) 
.................... // 
.................... //  lcd_send_byte(rs,byte)	escribe byte en el registro de datos(con rs=1) o de 
.................... //				instrucciones (con rs=0). 
.................... //------------------------------------------------------------------------------// 
.................... // Conexion del LCD con el PIC: 
.................... //     RB0 -- 
.................... //     RB1 -- 
.................... //     RB2  rs 
.................... //     RB3  Enable 
.................... //     RB4  D4 
.................... //     RB5  D5 
.................... //     RB6  D6 
.................... //     RB7  D7 
.................... // 
.................... // Los pines D0-D3 del LCD no se usan 
.................... // El pin RB0 del PIC no se usa 
.................... // El pin RB1 no está conectado en la tarjeta, 
.................... // podría ser para r/w 
....................  
.................... // Un-comment the following define to use port B 
.................... #define use_portb_lcd TRUE 		//LINEA DES-COMENTADA---------------- 
....................  
....................  
.................... struct lcd_pin_map {                 // This structure is overlayed 
....................            int unused : 2 ;	//MODIFICADA PARA EASYPIC-------------------- 
.................... 	   //BOOLEAN rw;		//MODIFICADA PARA EASYPIC-------------------- 
.................... 	   BOOLEAN rs;           // on to an I/O port to gain 
....................            BOOLEAN ENABLE;            // access to the LCD pins. 
....................            		           	// The bits are allocated from 
....................            			          // low order up.  ENABLE will 
....................            int     data : 4;         	// be pin B3------------------------- 
....................         } lcd; 
....................  
....................  
.................... #if defined(__PCH__) 
.................... #if defined use_portb_lcd 
....................    #byte lcd = 0xF81                   // This puts the entire structure 
.................... #else 
....................    #byte lcd = 0xF83                   // This puts the entire structure 
.................... #endif 
.................... #else 
.................... #if defined use_portb_lcd 
....................    #byte lcd = 6                  // on to port B (at address 6) 
.................... #else 
....................    #byte lcd = 8                 // on to port D (at address 8) 
.................... #endif 
.................... #endif 
....................  
.................... #if defined use_portb_lcd 
....................    #define set_tris_lcd(x) set_tris_b(x) 
.................... #else 
....................    #define set_tris_lcd(x) set_tris_d(x) 
.................... #endif 
....................  
....................  
.................... #define lcd_type 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #define lcd_line_two 0x40    // LCD RAM address for the second line 
....................  
....................  
.................... BYTE const LCD_INIT_STRING[4] = {0x24 | (lcd_type << 2), 0xF, 1, 6}; 
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................  
....................  
....................                              // The following are used for setting 
....................                              // the I/O port direction register. 
....................  
.................... struct lcd_pin_map const LCD_WRITE = {3,0,0,0}; // For write mode all pins are out 
.................... struct lcd_pin_map const LCD_READ = {3,0,0,15}; // For read mode data pins are in 
....................  
....................  
....................  
.................... BYTE lcd_read_byte() { 
....................       BYTE low,high; 
....................       set_tris_lcd(LCD_READ); 
....................       //////lcd.rw = 1; 
....................       delay_cycles(1); 
....................       lcd.enable = 1; 
....................       delay_cycles(1); 
....................       high = lcd.data; 
....................       lcd.enable = 0; 
....................       delay_cycles(1); 
....................       lcd.enable = 1; 
....................       delay_us(1); 
....................       low = lcd.data; 
....................       lcd.enable = 0; 
....................       set_tris_lcd(LCD_WRITE); 
....................       return( (high<<4) | low); 
.................... } 
....................  
....................  
.................... void lcd_send_nibble( BYTE n ) { 
....................       lcd.data = n; 
*
1116:  SWAPF  x85,W
1118:  ANDLW  F0
111A:  MOVWF  00
111C:  MOVLW  0F
111E:  ANDWF  F81,W
1120:  IORWF  00,W
1122:  MOVWF  F81
....................       delay_cycles(1); 
1124:  NOP   
....................       lcd.enable = 1; 
1126:  BSF    F81.3
....................       delay_us(2); 
1128:  CLRWDT
112A:  NOP   
112C:  NOP   
112E:  NOP   
....................       lcd.enable = 0; 
1130:  BCF    F81.3
.................... } 
1132:  RETLW  00
....................  
....................  
.................... void lcd_send_byte( BYTE address, BYTE n ) { 
....................  
....................       lcd.rs = 0; 
*
1152:  BCF    F81.2
....................       delay_us(3000); 
1154:  CLRWDT
1156:  MOVLW  02
1158:  MOVWF  x84
115A:  RCALL  10E6
115C:  MOVLW  09
115E:  MOVWF  x84
1160:  MOVLW  6D
1162:  MOVWF  x85
1164:  RCALL  1134
1166:  DECFSZ x84,F
1168:  BRA    1160
.................... //      while ( bit_test(lcd_read_byte(),7) ) ; 
....................       lcd.rs = address; 
116A:  BTFSS  x82.0
116C:  BCF    F81.2
116E:  BTFSC  x82.0
1170:  BSF    F81.2
....................       delay_cycles(1); 
1172:  NOP   
....................       //////////lcd.rw = 0; 
....................       delay_cycles(1); 
1174:  NOP   
....................       lcd.enable = 0; 
1176:  BCF    F81.3
....................       lcd_send_nibble(n >> 4); 
1178:  SWAPF  x83,W
117A:  MOVWF  x84
117C:  MOVLW  0F
117E:  ANDWF  x84,F
1180:  MOVFF  84,85
1184:  RCALL  1116
....................       lcd_send_nibble(n & 0xf); 
1186:  MOVF   x83,W
1188:  ANDLW  0F
118A:  MOVWF  x84
118C:  MOVWF  x85
118E:  RCALL  1116
.................... } 
1190:  RETLW  00
....................  
....................  
.................... void lcd_init() { 
....................     BYTE i; 
....................     set_tris_lcd(LCD_WRITE); 
1192:  MOVLW  03
1194:  MOVWF  F93
....................     lcd.rs = 0; 
1196:  BCF    F81.2
....................     /////lcd.rw = 0; 
....................     lcd.enable = 0; 
1198:  BCF    F81.3
....................     delay_ms(50); 
119A:  MOVLW  32
119C:  MOVWF  x84
119E:  RCALL  10E6
....................     //for(i=1;i<=3;++i) { 
....................     //   lcd_send_nibble(3); 
....................     //  delay_ms(5); 
....................     //} 
....................     lcd_send_nibble(2); 
11A0:  MOVLW  02
11A2:  MOVWF  x85
11A4:  RCALL  1116
....................     delay_ms(5); 
11A6:  MOVLW  05
11A8:  MOVWF  x84
11AA:  RCALL  10E6
....................     for(i=0;i<=3;++i) 
11AC:  CLRF   6B
11AE:  MOVF   6B,W
11B0:  SUBLW  03
11B2:  BNC   11D8
....................        { lcd_send_byte(0,LCD_INIT_STRING[i]); 
11B4:  CLRF   03
11B6:  MOVF   6B,W
11B8:  MOVFF  FF2,6C
11BC:  BCF    FF2.7
11BE:  CALL   009C
11C2:  BTFSC  6C.7
11C4:  BSF    FF2.7
11C6:  MOVWF  6D
11C8:  CLRF   x82
11CA:  MOVWF  x83
11CC:  RCALL  1152
....................         delay_ms(5); } 
11CE:  MOVLW  05
11D0:  MOVWF  x84
11D2:  RCALL  10E6
11D4:  INCF   6B,F
11D6:  BRA    11AE
.................... } 
11D8:  GOTO   59CE (RETURN)
....................  
....................  
.................... void lcd_gotoxy( BYTE x, BYTE y) { 
....................    BYTE address; 
....................  
....................    if(y!=1) 
11DC:  DECFSZ 7F,W
11DE:  BRA    11E2
11E0:  BRA    11E8
....................      address=lcd_line_two; 
11E2:  MOVLW  40
11E4:  MOVWF  x80
....................    else 
11E6:  BRA    11EA
....................      address=0; 
11E8:  CLRF   x80
....................    address+=x-1; 
11EA:  MOVLW  01
11EC:  SUBWF  7E,W
11EE:  ADDWF  x80,F
....................    lcd_send_byte(0,0x80|address); 
11F0:  MOVF   x80,W
11F2:  IORLW  80
11F4:  MOVWF  x81
11F6:  CLRF   x82
11F8:  MOVWF  x83
11FA:  RCALL  1152
.................... } 
11FC:  RETLW  00
....................  
.................... void lcd_putc( char c) { 
....................    switch (c) { 
11FE:  MOVF   7D,W
1200:  XORLW  0C
1202:  BZ    120E
1204:  XORLW  06
1206:  BZ    121E
1208:  XORLW  02
120A:  BZ    122A
120C:  BRA    1234
....................      case '\f'   : lcd_send_byte(0,1); 
120E:  CLRF   x82
1210:  MOVLW  01
1212:  MOVWF  x83
1214:  RCALL  1152
....................                    delay_ms(2); 
1216:  MOVLW  02
1218:  MOVWF  x84
121A:  RCALL  10E6
....................                                            break; 
121C:  BRA    1240
....................      case '\n'   : lcd_gotoxy(1,2);        break; 
121E:  MOVLW  01
1220:  MOVWF  7E
1222:  MOVLW  02
1224:  MOVWF  7F
1226:  RCALL  11DC
1228:  BRA    1240
....................      case '\b'   : lcd_send_byte(0,0x10);  break; 
122A:  CLRF   x82
122C:  MOVLW  10
122E:  MOVWF  x83
1230:  RCALL  1152
1232:  BRA    1240
....................      default     : lcd_send_byte(1,c);     break; 
1234:  MOVLW  01
1236:  MOVWF  x82
1238:  MOVFF  7D,83
123C:  RCALL  1152
123E:  BRA    1240
....................    } 
.................... } 
1240:  RETLW  00
....................  
.................... char lcd_getc( BYTE x, BYTE y) { 
....................    char value; 
....................  
....................     lcd_gotoxy(x,y); 
....................     while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................     lcd.rs=1; 
....................     value = lcd_read_byte(); 
....................     lcd.rs=0; 
....................     return(value); 
.................... } 
....................  
.................... #include "1wire.c" 
.................... /***********************1Wire Class***********************/ 
.................... /*Funciones básicas para comunicación con un solo sensor 1wire */ 
.................... /*********************************************************/ 
.................... /*-------1-wire definitions-------*/ 
....................  
.................... #define ONE_WIRE_PIN PIN_A5 //modificar de acuerdo con la tarjeta 
....................  
....................  
.................... /************onewire_reset*************************************************/ 
.................... void onewire_reset()  // OK if just using a single permanently connected device 
.................... { 
....................  output_low(ONE_WIRE_PIN); 
*
165A:  BCF    F92.5
165C:  BCF    F89.5
....................  delay_us( 500 ); // pull 1-wire low for reset pulse 
165E:  CLRWDT
1660:  MOVLW  02
1662:  MOVWF  x83
1664:  MOVLW  F7
1666:  MOVWF  x85
1668:  RCALL  1134
166A:  DECFSZ x83,F
166C:  BRA    1664
....................  output_float(ONE_WIRE_PIN); // float 1-wire high 
166E:  BSF    F92.5
....................  delay_us( 500 ); // wait-out remaining initialisation window. 
1670:  CLRWDT
1672:  MOVLW  02
1674:  MOVWF  x83
1676:  MOVLW  F7
1678:  MOVWF  x85
167A:  RCALL  1134
167C:  DECFSZ x83,F
167E:  BRA    1676
....................  output_float(ONE_WIRE_PIN); 
1680:  BSF    F92.5
.................... } 
1682:  RETLW  00
....................  
.................... /*********************** onewire_write() ********************************/ 
.................... /*Esta función escribe un byte en el sensor.*/ 
.................... /* */ 
.................... /*Parametros: byte - el byte a escribir en el 1wire */ 
....................  
.................... void onewire_write(int data) 
.................... { 
....................  int count; 
....................  
....................  for (count=0; count<8; ++count) 
1684:  CLRF   x85
1686:  MOVF   x85,W
1688:  SUBLW  07
168A:  BNC   16C0
....................  { 
....................   output_low(ONE_WIRE_PIN); 
168C:  BCF    F92.5
168E:  BCF    F89.5
....................   delay_us( 2 ); // pull 1-wire low to initiate write time-slot. 
1690:  CLRWDT
1692:  NOP   
1694:  NOP   
1696:  NOP   
....................   output_bit(ONE_WIRE_PIN, shift_right(&data,1,0)); // set output bit on 1-wire 
1698:  BCF    FD8.0
169A:  RRCF   x84,F
169C:  BC    16A2
169E:  BCF    F89.5
16A0:  BRA    16A4
16A2:  BSF    F89.5
16A4:  BCF    F92.5
....................   delay_us( 60 ); // wait until end of write slot. 
16A6:  CLRWDT
16A8:  MOVLW  27
16AA:  MOVWF  00
16AC:  DECFSZ 00,F
16AE:  BRA    16AC
16B0:  NOP   
....................   output_float(ONE_WIRE_PIN); // set 1-wire high again, 
16B2:  BSF    F92.5
....................   delay_us( 2 ); // for more than 1us minimum. 
16B4:  CLRWDT
16B6:  NOP   
16B8:  NOP   
16BA:  NOP   
....................  } 
16BC:  INCF   x85,F
16BE:  BRA    1686
.................... } 
16C0:  RETLW  00
....................  
.................... /*********************** read1wire() *********************************/ 
.................... /*Esta función lee un dato de 8 bits del sensor.*/ 
.................... /*Devuelve: dato de 8-bit (1-byte)*/ 
....................  
.................... int onewire_read() 
.................... { 
....................  int count, data; 
....................  
....................  for (count=0; count<8; ++count) 
*
1E5E:  CLRF   7C
1E60:  MOVF   7C,W
1E62:  SUBLW  07
1E64:  BNC   1EA0
....................  { 
....................   output_low(ONE_WIRE_PIN); 
1E66:  BCF    F92.5
1E68:  BCF    F89.5
....................   delay_us( 2 ); // pull 1-wire low to initiate read time-slot. 
1E6A:  CLRWDT
1E6C:  NOP   
1E6E:  NOP   
1E70:  NOP   
....................   output_float(ONE_WIRE_PIN); // now let 1-wire float high, 
1E72:  BSF    F92.5
....................   delay_us( 8 ); // let device state stabilise, 
1E74:  CLRWDT
1E76:  MOVLW  04
1E78:  MOVWF  00
1E7A:  DECFSZ 00,F
1E7C:  BRA    1E7A
1E7E:  NOP   
1E80:  NOP   
....................   shift_right(&data,1,input(ONE_WIRE_PIN)); // and load result. 
1E82:  BSF    F92.5
1E84:  BTFSC  F80.5
1E86:  BRA    1E8C
1E88:  BCF    FD8.0
1E8A:  BRA    1E8E
1E8C:  BSF    FD8.0
1E8E:  RRCF   7D,F
....................   delay_us( 120 ); // wait until end of read slot. 
1E90:  CLRWDT
1E92:  MOVLW  4F
1E94:  MOVWF  00
1E96:  DECFSZ 00,F
1E98:  BRA    1E96
1E9A:  NOP   
....................  } 
1E9C:  INCF   7C,F
1E9E:  BRA    1E60
....................  
....................  return( data ); 
1EA0:  MOVFF  7D,01
.................... } 
1EA4:  RETLW  00
....................  
.................... /////////////////////////////////////////////////////////////////// 
....................  
....................  
....................  
.................... #include "ds1820.c" 
....................  
.................... /***************************************************/ 
.................... /*Driver básico del termómetro/termostato ds1820.c */ 
.................... // 
.................... //Realiza una secuencia completa de incialización, conversión 
.................... //de temperatura, y lectura del (único) sensor de temperatura 
.................... //con alimentación externa (no parásita). 
.................... // 
.................... /***************************************************/ 
....................  
.................... float ds1820_read() 
.................... { 
....................  int8 busy=0, temp1, temp2; 
*
2052:  CLRF   73
....................  signed int16 temp3; 
....................  float result; 
....................  
....................  onewire_reset();     // Cada acceso al sensor debe iniciarse con reset 
2054:  CALL   165A
....................  onewire_write(0xCC); //Instrucción SKIP ROM (selecciona todos los dispositivos del 1wire) 
2058:  MOVLW  CC
205A:  MOVWF  x84
205C:  CALL   1684
....................  onewire_write(0x44); //Orden de inicio de conversión de temperatura 
2060:  MOVLW  44
2062:  MOVWF  x84
2064:  CALL   1684
....................  
....................  while (busy == 0) 	//el sensor mantiene la linea a 0 mientras realiza la conversión 
....................   busy = onewire_read(); //y la deja a 1 al completarla 
2068:  MOVF   73,F
206A:  BNZ   2074
206C:  RCALL  1E5E
206E:  MOVFF  01,73
2072:  BRA    2068
....................  
....................  onewire_reset(); 
2074:  CALL   165A
....................  onewire_write(0xCC); 
2078:  MOVLW  CC
207A:  MOVWF  x84
207C:  CALL   1684
....................  onewire_write(0xBE); //Envío de la orden READ SCRATCHPAD (lectura de la memoria temporal) 
2080:  MOVLW  BE
2082:  MOVWF  x84
2084:  CALL   1684
....................  temp1 = onewire_read(); //lectura del LSB de la temperatura 
2088:  RCALL  1E5E
208A:  MOVFF  01,74
....................  temp2 = onewire_read(); //lectura del MSB de la temperatura 
208E:  RCALL  1E5E
2090:  MOVFF  01,75
....................  
....................  temp3 = make16(temp2, temp1); // 
2094:  MOVFF  75,77
2098:  MOVFF  74,76
....................  result = (float) temp3 / 2.0;   //Calculation for DS18S20 with 0.5 deg C resolution 
209C:  MOVFF  77,7D
20A0:  MOVFF  76,7C
20A4:  BRA    1EA6
20A6:  MOVFF  00,7C
20AA:  MOVFF  01,7D
20AE:  MOVFF  02,7E
20B2:  MOVFF  03,7F
20B6:  MOVFF  03,287
20BA:  MOVFF  02,286
20BE:  MOVFF  01,285
20C2:  MOVFF  00,284
20C6:  MOVLB  2
20C8:  CLRF   x8B
20CA:  CLRF   x8A
20CC:  CLRF   x89
20CE:  MOVLW  80
20D0:  MOVWF  x88
20D2:  MOVLB  0
20D4:  RCALL  1EF2
20D6:  MOVFF  03,7B
20DA:  MOVFF  02,7A
20DE:  MOVFF  01,79
20E2:  MOVFF  00,78
.................... // result = (float) temp3 / 16.0;  //Calculation for DS18B20 with 0.1 deg C resolution 
....................  
....................  delay_ms(200); 
20E6:  MOVLW  C8
20E8:  MOVWF  x84
20EA:  CALL   10E6
....................  return(result); 
20EE:  MOVFF  78,00
20F2:  MOVFF  79,01
20F6:  MOVFF  7A,02
20FA:  MOVFF  7B,03
.................... } 
20FE:  RETLW  00
....................  
.................... //Establece la temperatura máxima y mínima para el termostato 
.................... void ds1820_establecer_TH_TL(float th, float tl){ 
....................    float th2, tl2; 
....................    onewire_reset(); 
*
17BA:  RCALL  165A
....................    onewire_write(0xCC); //Accedemos a todos los dispositivos 
17BC:  MOVLW  CC
17BE:  MOVWF  x84
17C0:  RCALL  1684
....................    onewire_write(0x4E); //Envío de la orden Write Scratchpad (escritura en la memoria principal) 
17C2:  MOVLW  4E
17C4:  MOVWF  x84
17C6:  RCALL  1684
....................    th2=2*th; 
17C8:  MOVLB  2
17CA:  CLRF   x9D
17CC:  CLRF   x9C
17CE:  CLRF   x9B
17D0:  MOVLW  80
17D2:  MOVWF  x9A
17D4:  MOVFF  76,2A1
17D8:  MOVFF  75,2A0
17DC:  MOVFF  74,29F
17E0:  MOVFF  73,29E
17E4:  MOVLB  0
17E6:  RCALL  16C2
17E8:  MOVFF  03,7E
17EC:  MOVFF  02,7D
17F0:  MOVFF  01,7C
17F4:  MOVFF  00,7B
....................    tl2=2*tl; 
17F8:  MOVLB  2
17FA:  CLRF   x9D
17FC:  CLRF   x9C
17FE:  CLRF   x9B
1800:  MOVLW  80
1802:  MOVWF  x9A
1804:  MOVFF  7A,2A1
1808:  MOVFF  79,2A0
180C:  MOVFF  78,29F
1810:  MOVFF  77,29E
1814:  MOVLB  0
1816:  RCALL  16C2
1818:  MOVFF  03,82
181C:  MOVFF  02,81
1820:  MOVFF  01,80
1824:  MOVFF  00,7F
....................    onewire_write((int8)th2); 
1828:  MOVFF  7E,86
182C:  MOVFF  7D,85
1830:  MOVFF  7C,84
1834:  MOVFF  7B,83
1838:  RCALL  1620
183A:  MOVFF  01,83
183E:  MOVFF  01,84
1842:  RCALL  1684
....................    onewire_write((int8)tl2); 
1844:  MOVFF  82,86
1848:  MOVFF  81,85
184C:  MOVFF  80,84
1850:  MOVFF  7F,83
1854:  RCALL  1620
1856:  MOVFF  01,83
185A:  MOVFF  01,84
185E:  RCALL  1684
....................  
....................    //Copiamos los valores en la ROM 
....................    onewire_reset(); 
1860:  RCALL  165A
....................    onewire_write(0xCC); 
1862:  MOVLW  CC
1864:  MOVWF  x84
1866:  RCALL  1684
....................    onewire_write(0x48); 
1868:  MOVLW  48
186A:  MOVWF  x84
186C:  RCALL  1684
....................  
....................    //Dejamos un poco de tiempo para que se escriba en la EEPROM 
....................    //El tiempo ha sido calculado a partir de la simulación en Proteus 
....................    delay_us(10600); 
186E:  CLRWDT
1870:  MOVLW  0A
1872:  MOVWF  x84
1874:  RCALL  10E6
1876:  MOVLW  0D
1878:  MOVWF  x83
187A:  MOVLW  2C
187C:  MOVWF  x85
187E:  RCALL  1134
1880:  DECFSZ x83,F
1882:  BRA    187A
....................  
.................... } 
1884:  RETLW  00
....................  
.................... //Intenta buscar la alarma del único sensor conectado por si ha saltado 
.................... //el termostato. Si lo ha hecho, devuelve TRUE, y en caso contrario, FALSE. 
.................... int1 ds1820_termostato(){ 
....................    int busy=0; 
*
2100:  CLRF   6B
....................    int1 bit1, bit2; 
....................  
....................    //Primero forzamos la conversión de la temperatura 
....................    onewire_reset(); 
2102:  CALL   165A
....................    onewire_write(0xCC); 
2106:  MOVLW  CC
2108:  MOVWF  x84
210A:  CALL   1684
....................    onewire_write(0x44); 
210E:  MOVLW  44
2110:  MOVWF  x84
2112:  CALL   1684
....................  
....................    while(busy == 0) 
....................       busy = onewire_read(); 
2116:  MOVF   6B,F
2118:  BNZ   2122
211A:  RCALL  1E5E
211C:  MOVFF  01,6B
2120:  BRA    2116
....................  
....................    onewire_reset(); 
2122:  CALL   165A
....................    onewire_write(0xEC); //Buscamos la alarma de algún dispositivo (función ALARM SEARCH) 
2126:  MOVLW  EC
2128:  MOVWF  x84
212A:  CALL   1684
....................  
....................    //Leemos dos bits consecutivos. Si el dispositivo tiene el flag de alarma activado, escribirá 
....................    //en la línea el bit más bajo de su dirección ROM y, después, su complemento. Si no, no hará 
....................    //nada. Por eso, si ambos bits leídos son diferentes, la alarma estará activada, mientras que 
....................    //si son iguales, no lo estarán. No es necesario continuar leyendo toda la dirección del dispositivo. 
....................    output_low(ONE_WIRE_PIN); 
212E:  BCF    F92.5
2130:  BCF    F89.5
....................    delay_us( 2 ); 
2132:  CLRWDT
2134:  NOP   
2136:  NOP   
2138:  NOP   
....................    output_float(ONE_WIRE_PIN); 
213A:  BSF    F92.5
....................    delay_us( 8 ); 
213C:  CLRWDT
213E:  MOVLW  04
2140:  MOVWF  00
2142:  DECFSZ 00,F
2144:  BRA    2142
2146:  NOP   
2148:  NOP   
....................    bit1 = input(ONE_WIRE_PIN); //Leemos el bit menos significativo de la dirección ROM 
214A:  BSF    F92.5
214C:  BCF    6C.0
214E:  BTFSC  F80.5
2150:  BSF    6C.0
....................    delay_us( 120 ); 
2152:  CLRWDT
2154:  MOVLW  4F
2156:  MOVWF  00
2158:  DECFSZ 00,F
215A:  BRA    2158
215C:  NOP   
....................  
....................    output_low(ONE_WIRE_PIN); 
215E:  BCF    F92.5
2160:  BCF    F89.5
....................    delay_us( 2 ); 
2162:  CLRWDT
2164:  NOP   
2166:  NOP   
2168:  NOP   
....................    output_float(ONE_WIRE_PIN); 
216A:  BSF    F92.5
....................    delay_us( 8 ); 
216C:  CLRWDT
216E:  MOVLW  04
2170:  MOVWF  00
2172:  DECFSZ 00,F
2174:  BRA    2172
2176:  NOP   
2178:  NOP   
....................    bit2 = input(ONE_WIRE_PIN); //Leemos su complemento (si la alarma está activada) 
217A:  BSF    F92.5
217C:  BCF    6C.1
217E:  BTFSC  F80.5
2180:  BSF    6C.1
....................    delay_us( 120 ); 
2182:  CLRWDT
2184:  MOVLW  4F
2186:  MOVWF  00
2188:  DECFSZ 00,F
218A:  BRA    2188
218C:  NOP   
....................  
....................    if(bit1 != bit2) 
218E:  CLRF   00
2190:  BTFSC  6C.1
2192:  BSF    00.0
2194:  MOVF   6C,W
2196:  XORWF  00,W
2198:  ANDLW  01
219A:  BZ    21A4
....................       return TRUE; 
219C:  MOVLW  01
219E:  MOVWF  01
21A0:  BRA    21AA
....................    else 
21A2:  BRA    21AA
....................       return FALSE; 
21A4:  MOVLW  00
21A6:  MOVWF  01
21A8:  BRA    21AA
....................  
....................  
.................... } 
21AA:  RETLW  00
....................  
.................... ////////////////////////////////////////////////////////////////////////////////////// 
....................  
....................  
....................  
....................  
.................... #use fast_io(A) 
.................... #use fast_io(B) 
.................... #use fast_io(C) 
.................... #use fast_io(D) 
....................  
.................... int1 temperatura_caldera_superada; //Control de la histéresis en la caldera 
.................... int1 temp_habitacion_superada;  //Control de la histéresis del ambiente 
.................... int1 encendido_por_alarma; //Indica si la última vez que se encendió fue en respuesta o no a una alarma 
.................... int1 toca_encender; //Indica si la próxima alarma es de encendido o de apagado 
.................... float termostato; //Temperatura límite de la vivienda 
.................... float termostato_provisional; //Valor de termostato provisional para cuando saltan las alarmas 
.................... float temperatura; //Temperatura de la vivienda 
.................... float histeresis_vivienda = 0.5; //Intervalo de histéresis de la vivienda 
....................  
.................... //Estructura de un intervalo de programación 
.................... typedef struct 
.................... { 
....................    unsigned int horas_inicio;    //Hora a la que se inicia el encendido 
....................    unsigned int minutos_inicio;  // 
....................    unsigned int horas_fin;       //Hora a la que se apaga el sistema 
....................    unsigned int minutos_fin;     // 
....................    unsigned int termostato;      //Termostato vigente en ese intervalo 
.................... }programacion; 
....................  
.................... //Vector que incluye todas las programaciones horarias 
.................... //La información se distribuye en grupos de 5: hora_inicio, minutos_inicio, 
.................... //hora_fin, minutos_fin y termostato. 
.................... programacion programaciones[3]; 
....................  
.................... //Programación en curso en este momento 
.................... programacion prg; 
.................... int num_intervalos; //Número de intervalos de programación con los que contamos 
.................... int posicion_alarmas; //Variable que apunta a la posición de la próxima alarma 
....................  
.................... //Estructura para leer el tiempo del reloj 
.................... date_time_t tiempo; 
....................  
.................... //Registro de la hora en la que se enciende el sistema 
.................... int hora_encendido; 
.................... int minutos_encendido; 
....................  
.................... //Registro de la hora en la que se enciende la caldera 
.................... //Se supone que el encendido de la caldera se realiza en intervalos cortos, 
.................... //que se alcanza la temperatura deseada relativamente rápido. 
.................... int hora_caldera; 
.................... int minutos_caldera; 
.................... int segundos_caldera; 
.................... //Tiempo total de encendido de la caldera en cada intervalo de encendido del sistema 
.................... long t_total_caldera; 
....................  
.................... //Variables para el registro en memoria 
.................... unsigned int num_registros;  //Número de registros de fechas almacenados 
.................... int anno_actual;             //Año en el que estamos (de 0 a 99) 
.................... int anno_actual_0_to_3;      //Año en el que estamos (de 0 a 3, a pesar de 
....................                               //que la variable se llame 1_to_3 por razones "históricas") 
....................  
.................... //Flag para activar las interrupciones de interfaz con el teclado y alarma 
.................... int1 lcd_int; 
.................... int1 alarma_int; 
....................  
.................... //Variables para gestionar las alarmas por software 
.................... int hora_alarma; 
.................... int minutos_alarma; 
.................... int1 alarma; 
....................  
....................  
.................... //Listado de métodos utilizados ordenados por orden alfabético 
.................... //************************************************************ 
.................... //Mostramos aquí una breve explicación de cada uno. El interior de los métodos está 
.................... //descrito después del método main. 
....................  
.................... //apagar_caldera() -> Apaga la caldera, almacenando el tiempo que ha estado encendida. 
.................... void apagar_caldera(); 
.................... //apagar_sistema() -> Realiza todas las operaciones necesarias para el apagado 
.................... //del sistema, como el almacenamiento de los datos necesarios en memoria. 
.................... void apagar_sistema(); 
.................... //buscar_numero(int led_unidades, int min, int max, int valor_inicial) -> Busca un número introducido con los 
.................... //botones + y - y se va mostrando el valor en la posición led_unidades del display (siempre en la fila 2). El 
.................... //rango de variación del valor está limitado por el intervalo [min,max]. Valor_inicial es el valor con el que 
.................... //se muestra la variable al principio. Si se pulsa SI, se aprueba el valor que aparece, y si aparece NO, se 
.................... //devuelve el código correspondiente. 
.................... int buscar_numero(int led_unidades, int min, int max, int valor_inicial); 
.................... //buscar_numero_rs232() -> Registra la introducción de un número de dos cifras mediante la interfaz RS232 y 
.................... //lo devuelve. Además, si se pulsa el "backspace" durante el proceso, devuelve el código correspondiente a NO 
.................... int buscar_numero_rs232(); 
.................... //comp_caldera() -> Devuelve TRUE si debemos apagar la caldera. Esta función tiene en cuenta 
.................... //cierta histéresis para evitar ciclos continuos de apagado-encendido. 
.................... int comp_caldera(); 
.................... //comprobar_hora(int hora1, int min1, int hora2, int min2) -> Devuelve TRUE 
.................... //si hora1:min1 corresponde a un tiempo menor o igual que hora2:min2. 
.................... int comprobar_hora(int hora1,int min1, int hora2, int min2); 
.................... //comprobar_temperatura() -> Devuelve TRUE si la temperatura de la habitación es menor 
.................... //que la indicada en el termostato, y FALSE en caso contrario. 
.................... int comprobar_temperatura(); 
.................... //diferencia_tiempo(int hora1, int min1, int hora2, int min2) -> Calcula la 
.................... //diferencia de tiempo en minutos entre hora1:min1 y hora2:min2. 
.................... //Si hora1:min1 es mayor que hora2:min2, los considera en días consecutivos. 
.................... long diferencia_tiempo(int hora1,int min1, int hora2, int min2); 
.................... //diferencia_tiempo_sec(int hora1, int min1, int sec1, int hora2, int min2, int sec2) -> 
.................... //Calcula la diferencia de tiempo en segundos entre hora1:min1:sec1 y hora2:min2:sec2 
.................... //Si hora1:min1:sec1 es mayor que hora2:min2:sec2, los considera en días consecutivos 
.................... long diferencia_tiempo_sec(int hora1,int min1, int sec1, int hora2, int min2, int sec2); 
.................... //encender_caldera() -> Enciende la caldera, almacenando el tiempo de encendido en 
.................... //las variables correspondientes. 
.................... void encender_caldera(); 
.................... //encender_sistema() -> Realiza todas las operaciones necesarias para el encendido 
.................... //del sistema, como registro del tiempo de inicio. 
.................... void encender_sistema(); 
.................... //grabar_programaciones() -> Graba los datos de las programaciones en la memoria EEPROM. 
.................... void grabar_programaciones(); 
.................... //inicializacion() -> Gestiona la inicialización del sistema por parte del técnico. 
.................... void inicializacion(); 
.................... //leer_programaciones() -> Recupera de la memoria los datos de las programaciones. 
.................... void leer_programaciones(); 
.................... //mostrar_temperatura() -> Muestra en la pantalla LCD la temperatura actual y la hora. 
.................... void mostrar_temperatura(); 
.................... //ordenar_programaciones -> Ordena las programaciones por orden creciente de hora. 
.................... void ordenar_programaciones(); 
.................... //programar_proxima_alarma() -> Programa la próxima alarma que tendrá lugar. 
.................... //Siempre se tratará de una alarma para el encendido. 
.................... void programar_proxima_alarma(); 
.................... //representar_registros() -> Representa la información de los registros en el puerto RS232 
.................... //Nunca guardamos la información de los registros para no saturar la memoria y 
.................... //aprovechamos la representación de los datos para calcular medias y demás y así 
.................... //no tener que realizar un segundo barrido de lectura en memoria. 
.................... void representar_registros(); 
.................... //seleccionar_alarma() -> Selecciona la alarma más cercana a la hora en la que nos encontramos, 
.................... //en el caso de que las hubiese. 
.................... void seleccionar_alarma(); 
....................  
.................... //-------------------------------------------------------------------------------- 
....................  
.................... //Gestión de interrupciones de activación de la interfaz de usuario 
.................... #INT_EXT1 
.................... void activacion_led(){ 
....................    clear_interrupt(INT_EXT1); 
*
10DC:  BCF    FF0.0
....................    //Se activa el flag correspondiente 
....................    lcd_int = TRUE; 
10DE:  BSF    1E.4
.................... } 
....................  
.................... //*********************************************************** 
.................... //Método main 
.................... //*********************************************************** 
10E0:  BCF    FF0.0
10E2:  GOTO   0058
.................... void main() 
.................... { 
*
5962:  CLRF   FF8
5964:  BCF    FD0.7
5966:  BSF    0D.7
5968:  CLRF   FEA
596A:  CLRF   FE9
596C:  BCF    FB8.3
596E:  MOVLW  19
5970:  MOVWF  FAF
5972:  MOVLW  22
5974:  MOVWF  FAC
5976:  MOVLW  90
5978:  MOVWF  FAB
597A:  BSF    F94.3
597C:  BSF    F94.4
597E:  MOVLW  13
5980:  MOVWF  FC8
5982:  MOVLW  28
5984:  MOVWF  FC6
5986:  BSF    FC7.7
5988:  BCF    FC7.6
598A:  MOVF   FC1,W
598C:  ANDLW  C0
598E:  IORLW  0F
5990:  MOVWF  FC1
5992:  MOVLW  07
5994:  MOVWF  FB4
5996:  CLRF   18
5998:  CLRF   19
599A:  MOVLW  01
599C:  MOVWF  1A
599E:  CLRF   1B
59A0:  CLRF   1C
59A2:  CLRF   1D
59A4:  MOVLW  7E
59A6:  MOVWF  2B
59A8:  CLRF   2C
59AA:  CLRF   2D
59AC:  CLRF   2E
....................    //Variable auxiliar 
....................    int aux; 
....................  
....................    //Determinamos que las patilla de interrupción se activen al pasar de alta a baja 
....................    ext_int_edge(1, H_TO_L); 
59AE:  BCF    FF1.5
....................  
....................    clear_interrupt(INT_EXT1); 
59B0:  BCF    FF0.0
....................  
....................    //Inicializamos salidas 
....................    //Comenzamos con todo apagado (sistema, motor y caldera) 
....................    sistema_encendido = FALSE; 
59B2:  BCF    F83.2
....................    motor = FALSE; 
59B4:  BCF    F83.1
....................    caldera_encendida = FALSE; 
59B6:  BCF    F83.0
....................    encendido_por_alarma = FALSE; 
59B8:  BCF    1E.2
....................    t_total_caldera = 0; //El tiempo total de encendido de la caldera también lo ponemos a 0 
59BA:  CLRF   52
59BC:  CLRF   51
....................  
....................    //Establecemos el estado de los puertos como entradas o salidas 
....................    set_tris_b(0x03); 
59BE:  MOVLW  03
59C0:  MOVWF  F93
....................    set_tris_d(0x00); 
59C2:  MOVLW  00
59C4:  MOVWF  F95
....................    set_tris_c(0xE7); 
59C6:  MOVLW  E7
59C8:  MOVWF  F94
....................  
....................    //Inicializamos la pantalla lcd 
....................    lcd_init(); 
59CA:  GOTO   1192
....................  
....................    //Mostramos un mensaje de inicio 
....................    lcd_send_byte(LCD_ORDEN, LCD_CLEAR); 
59CE:  CLRF   x82
59D0:  MOVLW  01
59D2:  MOVWF  x83
59D4:  CALL   1152
....................    lcd_send_byte(LCD_ORDEN, LCD_NO_CURSOR); 
59D8:  CLRF   x82
59DA:  MOVLW  0C
59DC:  MOVWF  x83
59DE:  CALL   1152
....................    printf(lcd_putc, "Inicializando..."); 
59E2:  CLRF   6B
59E4:  MOVF   6B,W
59E6:  CALL   00BA
59EA:  IORLW  00
59EC:  BZ    59F8
59EE:  INCF   6B,F
59F0:  MOVWF  7D
59F2:  CALL   11FE
59F6:  BRA    59E4
....................  
....................    //----------------------------------------------------------- 
....................    //Rutina de inicialización del sistema por parte del técnico 
....................    //----------------------------------------------------------- 
....................    inicializacion(); 
59F8:  GOTO   1886
....................  
....................    //Propiedades de conversión analógico digital 
....................    //Caracterizamos los puertos A0 a A3 como entradas analógicas 
....................    setup_adc_ports(AN0_TO_AN3); 
59FC:  MOVF   FC1,W
59FE:  ANDLW  C0
5A00:  IORLW  0B
5A02:  MOVWF  FC1
....................    //Definimos el reloj de conversión 
....................    setup_adc(adc_clock_div_32); 
5A04:  MOVF   FC0,W
5A06:  ANDLW  C0
5A08:  IORLW  02
5A0A:  MOVWF  FC0
5A0C:  BCF    FC0.7
5A0E:  BSF    FC2.0
....................  
....................    /* 
....................    //El siguiente fragmento de código se descomentaría en el caso de que quiera obviarse la fase 
....................    //de inicialización del sistema y quieran leerse datos conservados en memoria, si, por ejemplo, 
....................    //ya tenemos el reloj configurado. En ese caso, debemos borrar la sentencia de "inicializacion" de arriba. 
....................    //******************************************************************************** 
....................  
....................    //Recuperación de datos de la memoria 
....................    //Recuperamos a partir de la dirección eeprom_termostato los datos en 
....................    //el siguiente orden: termostato, número de intervalos de alarma, número de registros 
....................    //de encendido de la caldera, año actual en valores de 0 a 99 y año actual en valores de 0 a 3. 
....................    termostato = read_eeprom(eeprom_termostato); 
....................    num_intervalos = read_eeprom(eeprom_num_intervalos); 
....................    num_registros = read_eeprom(eeprom_num_registros); 
....................    anno_actual = read_eeprom(eeprom_anno_actual); 
....................    anno_actual_0_to_3 = read_eeprom(eeprom_anno_0_to_3); 
....................  
....................  
....................    //Lee las programaciones de alarmas guardadas en memoria 
....................    leer_programaciones(); 
....................  
....................  
....................    //Comprobamos si hay alarmas programadas en memoria 
....................    if(num_intervalos!=0) 
....................    { 
....................       //Si las hay, seleccionamos la siguiente y programamos su activación 
....................       seleccionar_alarma(); 
....................       programar_proxima_alarma(); 
....................       toca_encender = TRUE; 
....................    } 
....................  
....................    //Iniciamos la cuenta del reloj 
....................    PCF8583_write_byte(PCF8583_CTRL_STATUS_REG, 
....................                            PCF8583_START_COUNTING); 
....................  
....................    */ 
....................  
....................  
....................    //Leemos la temperatura 
....................    temperatura = ds1820_read(); 
5A10:  CALL   2052
5A14:  MOVFF  03,2A
5A18:  MOVFF  02,29
5A1C:  MOVFF  01,28
5A20:  MOVFF  00,27
....................    if(!ds1820_termostato()) 
5A24:  CALL   2100
5A28:  MOVF   01,F
5A2A:  BNZ   5A86
....................    { 
....................       //Si supera el valor del termostato, lo indicamos con el flag 
....................       temp_habitacion_superada = TRUE; 
5A2C:  BSF    1E.1
....................       //Tendremos que establecer un nuevo termostato teniendo en cuenta la histéresis de la temperatura 
....................       termostato = termostato - histeresis_vivienda; 
5A2E:  BSF    FD8.1
5A30:  MOVFF  22,281
5A34:  MOVFF  21,280
5A38:  MOVFF  20,27F
5A3C:  MOVFF  1F,27E
5A40:  MOVFF  2E,285
5A44:  MOVFF  2D,284
5A48:  MOVFF  2C,283
5A4C:  MOVFF  2B,282
5A50:  CALL   21AC
5A54:  MOVFF  03,22
5A58:  MOVFF  02,21
5A5C:  MOVFF  01,20
5A60:  MOVFF  00,1F
....................       //Guardamos el dato en el sensor 
....................       //La TH la configuramos con un valor muy alto (127.5ºC) 
....................       ds1820_establecer_TH_TL(127.5, termostato); 
5A64:  CLRF   76
5A66:  CLRF   75
5A68:  MOVLW  7F
5A6A:  MOVWF  74
5A6C:  MOVLW  85
5A6E:  MOVWF  73
5A70:  MOVFF  22,7A
5A74:  MOVFF  21,79
5A78:  MOVFF  20,78
5A7C:  MOVFF  1F,77
5A80:  CALL   17BA
....................    }else 
5A84:  BRA    5A88
....................       //Si no se supera, se indica también 
....................       temp_habitacion_superada = FALSE; 
5A86:  BCF    1E.1
....................  
....................  
....................    //Asumimos que en principio la temperatura de la caldera no ha sido superada 
....................    temperatura_caldera_superada = FALSE; 
5A88:  BCF    1E.0
....................    if(comp_caldera()) 
5A8A:  CALL   24D4
5A8E:  MOVF   01,F
5A90:  BZ    5A94
....................       //Si la temperatura del agua en la caldera supera el termostato, activamos el flag 
....................       temperatura_caldera_superada = TRUE; 
5A92:  BSF    1E.0
....................  
....................    //Desactivamos los flag de las interrupciones 
....................    alarma_int = lcd_int = FALSE; 
5A94:  BCF    1E.4
5A96:  BCF    1E.5
....................  
....................  
....................  
....................    //Activamos las interrupciones del puerto B1 
....................    enable_interrupts(INT_EXT1); 
5A98:  BSF    FF0.3
....................    enable_interrupts(GLOBAL); 
5A9A:  MOVLW  C0
5A9C:  IORWF  FF2,F
....................  
....................    //Mostramos un mensaje que indica al técnico el éxito en la inicialización 
....................    printf("Sistema inicializado con exito!\r"); 
5A9E:  CLRF   6B
5AA0:  MOVF   6B,W
5AA2:  CALL   00E6
5AA6:  IORLW  00
5AA8:  BZ    5AB4
5AAA:  INCF   6B,F
5AAC:  BTFSS  F9E.4
5AAE:  BRA    5AAC
5AB0:  MOVWF  FAD
5AB2:  BRA    5AA0
....................  
....................    //Repetimos la siguiente rutina hasta que se desconecte el micro 
....................    while(1){ 
....................       inicio: 
....................       //Inhabilitamos el perro guardián para que no interfiera con las gestión de interrupciones y 
....................       //con la medida de la temperatura 
....................       setup_wdt(WDT_OFF); 
5AB4:  BCF    FD1.0
....................  
....................       //Borramos los flags de interrupción que pudiesen estar activos 
....................       clear_interrupt(INT_EXT1); 
5AB6:  BCF    FF0.0
....................  
....................       //Si la interrupción de alarma se activa, gestionamos el proceso. En realidad no se trata de una 
....................       //interrupción propiamente dicha, pues se activa por software según lo que apunto en el comentario 
....................       //correspondiente a la activación (al final del main). 
....................       if(alarma_int) 
5AB8:  BTFSS  1E.5
5ABA:  BRA    5C2A
....................       { 
....................  
....................          //Desactivamos interrupciones 
....................          disable_interrupts(GLOBAL); 
5ABC:  BCF    FF2.6
5ABE:  BCF    FF2.7
5AC0:  BTFSC  FF2.7
5AC2:  BRA    5ABE
....................  
....................          if(toca_encender) 
5AC4:  BTFSS  1E.3
5AC6:  BRA    5BAC
....................          { 
....................             if(!sistema_encendido) 
5AC8:  BTFSC  F83.2
5ACA:  BRA    5B92
....................             { 
....................                //Ejecutamos esto si se trata de una alarma de encendido y el sistema 
....................                //está apagado. 
....................                //Actualizamos el termostato, guardando el valor que había ya (teniendo 
....................                //en cuenta la histéresis) 
....................                if(temp_habitacion_superada) 
5ACC:  BTFSS  1E.1
5ACE:  BRA    5B08
....................                   termostato_provisional = termostato + histeresis_vivienda; 
5AD0:  BCF    FD8.1
5AD2:  MOVFF  22,281
5AD6:  MOVFF  21,280
5ADA:  MOVFF  20,27F
5ADE:  MOVFF  1F,27E
5AE2:  MOVFF  2E,285
5AE6:  MOVFF  2D,284
5AEA:  MOVFF  2C,283
5AEE:  MOVFF  2B,282
5AF2:  CALL   21AC
5AF6:  MOVFF  03,26
5AFA:  MOVFF  02,25
5AFE:  MOVFF  01,24
5B02:  MOVFF  00,23
....................                else 
5B06:  BRA    5B18
....................                   termostato_provisional = termostato; 
5B08:  MOVFF  22,26
5B0C:  MOVFF  21,25
5B10:  MOVFF  20,24
5B14:  MOVFF  1F,23
....................                termostato = prg.termostato; 
5B18:  MOVLB  2
5B1A:  CLRF   x85
5B1C:  MOVFF  42,284
5B20:  MOVLB  0
5B22:  CALL   2426
5B26:  MOVFF  03,22
5B2A:  MOVFF  02,21
5B2E:  MOVFF  01,20
5B32:  MOVFF  00,1F
....................                //Grabamos el termostato en el sensor como valor TL 
....................                ds1820_establecer_TH_TL(127.5, termostato); 
5B36:  CLRF   76
5B38:  CLRF   75
5B3A:  MOVLW  7F
5B3C:  MOVWF  74
5B3E:  MOVLW  85
5B40:  MOVWF  73
5B42:  MOVFF  22,7A
5B46:  MOVFF  21,79
5B4A:  MOVFF  20,78
5B4E:  MOVFF  1F,77
5B52:  CALL   17BA
....................  
....................                //Si la temperatura no está superada, desactivamos el flag por si acaso 
....................                //lo estaba con el otro valor de termostato. 
....................                if(ds1820_termostato()) 
5B56:  CALL   2100
5B5A:  MOVF   01,F
5B5C:  BZ    5B60
....................                   temp_habitacion_superada = FALSE; 
5B5E:  BCF    1E.1
....................  
....................                //Determinamos la próxima alarma como de apagado 
....................                toca_encender = FALSE; 
5B60:  BCF    1E.3
....................  
....................                //Activamos el flag de sistema encendido por alarma 
....................                encendido_por_alarma = TRUE; 
5B62:  BSF    1E.2
....................                //Mostramos un mensaje 
....................                lcd_send_byte(LCD_ORDEN,LCD_CLEAR); 
5B64:  CLRF   x82
5B66:  MOVLW  01
5B68:  MOVWF  x83
5B6A:  CALL   1152
....................                printf(lcd_putc, "  Encendiendo\n  sistema..."); 
5B6E:  CLRF   6B
5B70:  MOVF   6B,W
5B72:  CALL   0122
5B76:  IORLW  00
5B78:  BZ    5B84
5B7A:  INCF   6B,F
5B7C:  MOVWF  7D
5B7E:  CALL   11FE
5B82:  BRA    5B70
....................                //Encendemos el sistema 
....................                encender_sistema(); 
5B84:  CALL   28C0
....................  
....................                //Recogemos el tiempo en el que debe de saltar la alarma de apagado. 
....................                 
....................                hora_alarma = prg.horas_fin; 
5B88:  MOVFF  40,56
....................                minutos_alarma = prg.minutos_fin; 
5B8C:  MOVFF  41,57
....................  
....................  
....................             }else 
5B90:  BRA    5BAA
....................             { 
....................                //Si se trata de una alarma de encendido y el sistema está encendido 
....................                delay_ms(250); //Retraso para evitar solapamiento de alarmas 
5B92:  MOVLW  FA
5B94:  MOVWF  x84
5B96:  CALL   10E6
....................  
....................                //Nos vamos a la siguiente alarma 
....................                posicion_alarmas++; 
5B9A:  INCF   44,F
....................                //Si hemos llegado al final de la lista, volvemos al principio 
....................                if(posicion_alarmas==num_intervalos) 
5B9C:  MOVF   43,W
5B9E:  SUBWF  44,W
5BA0:  BNZ   5BA4
....................                   posicion_alarmas = 0; 
5BA2:  CLRF   44
....................  
....................                //Programamos la próxima alarma de encendido 
....................                programar_proxima_alarma(); 
5BA4:  CALL   28E8
....................  
....................                //Determinamos que la siguiente es de encendido 
....................                toca_encender = TRUE; 
5BA8:  BSF    1E.3
....................             } 
....................          }else 
5BAA:  BRA    5C22
....................          { 
....................             //Si se trata de una alarma de apagado 
....................  
....................             delay_ms(250); //Retraso para evitar el solapamiento de alarmas 
5BAC:  MOVLW  FA
5BAE:  MOVWF  x84
5BB0:  CALL   10E6
....................  
....................             if(sistema_encendido && encendido_por_alarma) 
5BB4:  BTFSS  F83.2
5BB6:  BRA    5C12
5BB8:  BTFSS  1E.2
5BBA:  BRA    5C12
....................             { 
....................                //Si el sistema está encendido y se trata de un encendido por alarma: 
....................                //Restauramos el valor del termostato que había antes de la alarma 
....................                termostato=termostato_provisional; 
5BBC:  MOVFF  26,22
5BC0:  MOVFF  25,21
5BC4:  MOVFF  24,20
5BC8:  MOVFF  23,1F
....................                //Grabamos la información en el sensor 
....................                ds1820_establecer_TH_TL(127.5, termostato); 
5BCC:  CLRF   76
5BCE:  CLRF   75
5BD0:  MOVLW  7F
5BD2:  MOVWF  74
5BD4:  MOVLW  85
5BD6:  MOVWF  73
5BD8:  MOVFF  22,7A
5BDC:  MOVFF  21,79
5BE0:  MOVFF  20,78
5BE4:  MOVFF  1F,77
5BE8:  CALL   17BA
....................                //Determinamos que la próxima vez que se encienda no sea por alarma 
....................                encendido_por_alarma = FALSE; 
5BEC:  BCF    1E.2
....................                //Mostramos un mensaje 
....................                lcd_send_byte(LCD_ORDEN,LCD_CLEAR); 
5BEE:  CLRF   x82
5BF0:  MOVLW  01
5BF2:  MOVWF  x83
5BF4:  CALL   1152
....................                printf(lcd_putc, "  Apagando\n  sistema..."); 
5BF8:  CLRF   6B
5BFA:  MOVF   6B,W
5BFC:  CALL   0158
5C00:  IORLW  00
5C02:  BZ    5C0E
5C04:  INCF   6B,F
5C06:  MOVWF  7D
5C08:  CALL   11FE
5C0C:  BRA    5BFA
....................                //Apagamos el sistema 
....................                apagar_sistema(); 
5C0E:  CALL   2BFC
....................             } 
....................  
....................             //Nos vamos a la siguiente alarma 
....................             posicion_alarmas++; 
5C12:  INCF   44,F
....................             //Si llegamos al final de la lista, volvemos al principio 
....................             if(posicion_alarmas==num_intervalos) 
5C14:  MOVF   43,W
5C16:  SUBWF  44,W
5C18:  BNZ   5C1C
....................                posicion_alarmas = 0; 
5C1A:  CLRF   44
....................  
....................             //Programamos la próxima alarma de encendido 
....................             programar_proxima_alarma(); 
5C1C:  CALL   28E8
....................  
....................             //Y activamos que, efectivamente, se trata de una alarma de encendido 
....................             toca_encender = TRUE; 
5C20:  BSF    1E.3
....................          } 
....................  
....................          //Activamos de nuevo la alarma 
....................          alarma = TRUE; 
5C22:  BSF    1E.6
....................  
....................          //Desactivamos el flag de interrupción 
....................          alarma_int = FALSE; 
5C24:  BCF    1E.5
....................  
....................          //Activamos de nuevo las interrupciones 
....................          enable_interrupts(GLOBAL); 
5C26:  MOVLW  C0
5C28:  IORWF  FF2,F
....................       } 
....................  
....................  
....................       //Si se activa la interrupción de interfaz con el usuario, se gestiona el proceso 
....................       if(lcd_int) 
5C2A:  BTFSS  1E.4
5C2C:  GOTO   6656
....................       { 
....................          //Contadores y valores auxiliares 
....................          int contador, contador2, valor, input; 
....................          //Variable para almacenar el nuevo valor del termostato 
....................          float term; 
....................          //Variables provisionales para buscar en la lista de programaciones 
....................          programacion pr, pr2; 
....................  
....................          //Desactivamos interrupciones 
....................          disable_interrupts(GLOBAL); 
5C30:  BCF    FF2.6
5C32:  BCF    FF2.7
5C34:  BTFSC  FF2.7
5C36:  BRA    5C32
....................  
....................          //Mostramos un mensaje al usuario para que elija su opción 
....................          lcd_send_byte(LCD_ORDEN,LCD_CLEAR); 
5C38:  CLRF   x82
5C3A:  MOVLW  01
5C3C:  MOVWF  x83
5C3E:  CALL   1152
....................          printf(lcd_putc, "  Indique la \n  operacion   1"); 
5C42:  CLRF   6B
5C44:  MOVF   6B,W
5C46:  CALL   018A
5C4A:  IORLW  00
5C4C:  BZ    5C58
5C4E:  INCF   6B,F
5C50:  MOVWF  7D
5C52:  CALL   11FE
5C56:  BRA    5C44
....................          lcd_gotoxy(15,2); 
5C58:  MOVLW  0F
5C5A:  MOVWF  7E
5C5C:  MOVLW  02
5C5E:  MOVWF  7F
5C60:  CALL   11DC
....................          lcd_send_byte(LCD_ORDEN,LCD_CURSOR); //Activamos el parpadeo del cursor 
5C64:  CLRF   x82
5C66:  MOVLW  0E
5C68:  MOVWF  x83
5C6A:  CALL   1152
....................  
....................          input = 1; 
5C6E:  MOVLW  01
5C70:  MOVWF  5C
....................          //Mientras que no se pulse SI o NO, esperamos a que el usuario introduzca un número con los cursores 
....................          while(1) 
....................          { 
....................             if(!mas) 
5C72:  BTFSC  F82.0
5C74:  BRA    5CA2
....................             { 
....................                //Si se pulsa el botón de +, se aumenta el valor de input 
....................                input++; 
5C76:  INCF   5C,F
....................                //Si llegamos al límite de las opciones, reseteamos 
....................                if(input>4) 
5C78:  MOVF   5C,W
5C7A:  SUBLW  04
5C7C:  BC    5C82
....................                   input = 1; 
5C7E:  MOVLW  01
5C80:  MOVWF  5C
....................                //Se muestra por pantalla 
....................                printf(lcd_putc,"%i",input); 
5C82:  MOVFF  5C,76
5C86:  MOVLW  1F
5C88:  MOVWF  77
5C8A:  CALL   305A
....................                //Regresamos el cursor a su posición 
....................                lcd_gotoxy(15,2); 
5C8E:  MOVLW  0F
5C90:  MOVWF  7E
5C92:  MOVLW  02
5C94:  MOVWF  7F
5C96:  CALL   11DC
....................                //Esperamos a que se levante la tecla 
....................                while(!mas){} 
5C9A:  BTFSC  F82.0
5C9C:  BRA    5CA0
5C9E:  BRA    5C9A
....................                continue; 
5CA0:  BRA    5C72
....................             } 
....................             if(!menos) 
5CA2:  BTFSC  F82.1
5CA4:  BRA    5CD0
....................             { 
....................                //Si se pulsa el botón de -, se decrementa el valor de input 
....................                input--; 
5CA6:  DECF   5C,F
....................                //Si llegamos al límite de las opciones, reseteamos 
....................                if(input<1) 
5CA8:  MOVF   5C,F
5CAA:  BNZ   5CB0
....................                   input = 4; 
5CAC:  MOVLW  04
5CAE:  MOVWF  5C
....................                //Se muestra por pantalla 
....................                printf(lcd_putc,"%i",input); 
5CB0:  MOVFF  5C,76
5CB4:  MOVLW  1F
5CB6:  MOVWF  77
5CB8:  CALL   305A
....................                //Regresamos el cursor a su posición 
....................                lcd_gotoxy(15,2); 
5CBC:  MOVLW  0F
5CBE:  MOVWF  7E
5CC0:  MOVLW  02
5CC2:  MOVWF  7F
5CC4:  CALL   11DC
....................                //Esperamos a que se levante la tecla 
....................                while(!menos){} 
5CC8:  BTFSC  F82.1
5CCA:  BRA    5CCE
5CCC:  BRA    5CC8
....................                continue; 
5CCE:  BRA    5C72
....................             } 
....................             if(!si) 
5CD0:  BTFSC  F82.2
5CD2:  BRA    5CDC
....................             { 
....................                //Si se pulsa Si, nos quedamos con el valor seleccionado 
....................                //Esperamos a que se suelte la tecla 
....................                while(!si){} 
5CD4:  BTFSC  F82.2
5CD6:  BRA    5CDA
5CD8:  BRA    5CD4
....................                break; 
5CDA:  BRA    5D26
....................             } 
....................             if(!no) 
5CDC:  BTFSC  F82.5
5CDE:  BRA    5D24
....................             { 
....................                //Si se pulsa No, salimos 
....................                //Esperamos... 
....................                while(!no){} 
5CE0:  BTFSC  F82.5
5CE2:  BRA    5CE6
5CE4:  BRA    5CE0
....................                //Se muestra un mensaje de finalización 
....................                lcd_send_byte(LCD_ORDEN,LCD_CLEAR); 
5CE6:  CLRF   x82
5CE8:  MOVLW  01
5CEA:  MOVWF  x83
5CEC:  CALL   1152
....................                lcd_send_byte(LCD_ORDEN,LCD_NO_CURSOR); 
5CF0:  CLRF   x82
5CF2:  MOVLW  0C
5CF4:  MOVWF  x83
5CF6:  CALL   1152
....................                printf(lcd_putc, "  Anulando\n  operacion..."); 
5CFA:  CLRF   6B
5CFC:  MOVF   6B,W
5CFE:  CALL   01C2
5D02:  IORLW  00
5D04:  BZ    5D10
5D06:  INCF   6B,F
5D08:  MOVWF  7D
5D0A:  CALL   11FE
5D0E:  BRA    5CFC
....................                delay_ms(LCD_T_RETARDO); 
5D10:  MOVLW  02
5D12:  MOVWF  6B
5D14:  MOVLW  FA
5D16:  MOVWF  x84
5D18:  CALL   10E6
5D1C:  DECFSZ 6B,F
5D1E:  BRA    5D14
....................                lcd_int = FALSE; //Desactivamos el flag de interrupción 
5D20:  BCF    1E.4
....................                goto inicio; 
5D22:  BRA    5AB4
....................             } 
....................          } 
5D24:  BRA    5C72
....................  
....................          lcd_send_byte(LCD_ORDEN, LCD_NO_CURSOR); 
5D26:  CLRF   x82
5D28:  MOVLW  0C
5D2A:  MOVWF  x83
5D2C:  CALL   1152
....................  
....................          //Se elige la opción pertinente 
....................          switch(input) 
....................          { 
5D30:  MOVF   5C,W
5D32:  XORLW  01
5D34:  BZ    5D4C
5D36:  XORLW  03
5D38:  BZ    5DDA
5D3A:  XORLW  01
5D3C:  BTFSC  FD8.2
5D3E:  BRA    60C0
5D40:  XORLW  07
5D42:  BTFSC  FD8.2
5D44:  GOTO   64FA
5D48:  GOTO   6616
....................             //Si es 1, entramos en la opción de apagado y encendido manual del sistema 
....................             case 1: 
....................                      //Si el sistema está apagado, lo encendemos 
....................                      if(!sistema_encendido) 
5D4C:  BTFSC  F83.2
5D4E:  BRA    5D76
....................                      { 
....................                         lcd_send_byte(LCD_ORDEN,LCD_CLEAR); 
5D50:  CLRF   x82
5D52:  MOVLW  01
5D54:  MOVWF  x83
5D56:  CALL   1152
....................                         printf(lcd_putc, "  Encendiendo\n  sistema..."); 
5D5A:  CLRF   6B
5D5C:  MOVF   6B,W
5D5E:  CALL   0122
5D62:  IORLW  00
5D64:  BZ    5D70
5D66:  INCF   6B,F
5D68:  MOVWF  7D
5D6A:  CALL   11FE
5D6E:  BRA    5D5C
....................                         encender_sistema(); 
5D70:  CALL   28C0
....................                      }else 
5D74:  BRA    5DD6
....................                      //Si está encendido, lo apagamos 
....................                      { 
....................                         lcd_send_byte(LCD_ORDEN,LCD_CLEAR); 
5D76:  CLRF   x82
5D78:  MOVLW  01
5D7A:  MOVWF  x83
5D7C:  CALL   1152
....................                         printf(lcd_putc, "  Apagando\n  sistema..."); 
5D80:  CLRF   6B
5D82:  MOVF   6B,W
5D84:  CALL   0158
5D88:  IORLW  00
5D8A:  BZ    5D96
5D8C:  INCF   6B,F
5D8E:  MOVWF  7D
5D90:  CALL   11FE
5D94:  BRA    5D82
....................                         apagar_sistema(); 
5D96:  CALL   2BFC
....................                         //Si el motor estaba en marcha, debemos apagarlo 
....................                         if(motor) 
5D9A:  BTFSS  F83.1
5D9C:  BRA    5DA0
....................                            motor = FALSE; 
5D9E:  BCF    F83.1
....................  
....................                         //Si estaba encendido por alguna alarma debemos indicarlo 
....................                         if(encendido_por_alarma) 
5DA0:  BTFSS  1E.2
5DA2:  BRA    5DD6
....................                         { 
....................                            //Recuperamos el valor del termostato 
....................                            termostato=termostato_provisional; 
5DA4:  MOVFF  26,22
5DA8:  MOVFF  25,21
5DAC:  MOVFF  24,20
5DB0:  MOVFF  23,1F
....................                            //Almacenamos el valor en el sensor 
....................                            ds1820_establecer_TH_TL(127.5, termostato); 
5DB4:  CLRF   76
5DB6:  CLRF   75
5DB8:  MOVLW  7F
5DBA:  MOVWF  74
5DBC:  MOVLW  85
5DBE:  MOVWF  73
5DC0:  MOVFF  22,7A
5DC4:  MOVFF  21,79
5DC8:  MOVFF  20,78
5DCC:  MOVFF  1F,77
5DD0:  CALL   17BA
....................  
....................                            encendido_por_alarma = FALSE; 
5DD4:  BCF    1E.2
....................                         } 
....................                      } 
....................                      break; 
5DD6:  GOTO   6650
....................  
....................  
....................             //Si es 2, entramos en la opción de configuración del termostato 
....................             case 2: 
....................  
....................                      //Mostramos el valor del termostato actual 
....................                      lcd_send_byte(LCD_ORDEN, LCD_CLEAR); 
5DDA:  CLRF   x82
5DDC:  MOVLW  01
5DDE:  MOVWF  x83
5DE0:  CALL   1152
....................                      //Para considerar el valor del termostato hay que tener en cuenta el valor de la histéresis. 
....................                      //Extraemos la parte entera del termostato para así poder trabajar con la función buscar_numero(). 
....................                      //Tampoco es una limitación trabajar con valores enteros del termostato, pues nuestro cuerpo no notará 
....................                      //demasiado la diferencia. 
....................                      if(temp_habitacion_superada) 
5DE4:  BTFSS  1E.1
5DE6:  BRA    5EA0
....................                      { 
....................                         valor = (int)(termostato+histeresis_vivienda); 
5DE8:  BCF    FD8.1
5DEA:  MOVFF  22,281
5DEE:  MOVFF  21,280
5DF2:  MOVFF  20,27F
5DF6:  MOVFF  1F,27E
5DFA:  MOVFF  2E,285
5DFE:  MOVFF  2D,284
5E02:  MOVFF  2C,283
5E06:  MOVFF  2B,282
5E0A:  CALL   21AC
5E0E:  MOVFF  03,86
5E12:  MOVFF  02,85
5E16:  MOVFF  01,84
5E1A:  MOVFF  00,83
5E1E:  CALL   1620
5E22:  MOVFF  01,5B
....................                         printf(lcd_putc, "Modificar\ntermostato %.0f%cC",termostato+histeresis_vivienda,223); 
5E26:  BCF    FD8.1
5E28:  MOVFF  22,281
5E2C:  MOVFF  21,280
5E30:  MOVFF  20,27F
5E34:  MOVFF  1F,27E
5E38:  MOVFF  2E,285
5E3C:  MOVFF  2D,284
5E40:  MOVFF  2C,283
5E44:  MOVFF  2B,282
5E48:  CALL   21AC
5E4C:  MOVFF  00,6B
5E50:  MOVFF  01,6C
5E54:  MOVFF  02,6D
5E58:  MOVFF  03,6E
5E5C:  CLRF   6F
5E5E:  MOVF   6F,W
5E60:  CALL   01F6
5E64:  INCF   6F,F
5E66:  MOVWF  00
5E68:  MOVWF  7D
5E6A:  CALL   11FE
5E6E:  MOVLW  15
5E70:  SUBWF  6F,W
5E72:  BNZ   5E5E
5E74:  MOVLW  89
5E76:  MOVWF  FE9
5E78:  MOVFF  6E,73
5E7C:  MOVFF  6D,72
5E80:  MOVFF  6C,71
5E84:  MOVFF  6B,70
5E88:  CLRF   74
5E8A:  CALL   31F6
5E8E:  MOVLW  DF
5E90:  MOVWF  7D
5E92:  CALL   11FE
5E96:  MOVLW  43
5E98:  MOVWF  7D
5E9A:  CALL   11FE
....................                      } 
....................                      else 
5E9E:  BRA    5EFA
....................                      { 
....................                         valor = (int)termostato; 
5EA0:  MOVFF  22,86
5EA4:  MOVFF  21,85
5EA8:  MOVFF  20,84
5EAC:  MOVFF  1F,83
5EB0:  CALL   1620
5EB4:  MOVFF  01,5B
....................                         printf(lcd_putc, "Modificar\ntermostato %.0f%cC",termostato,223); 
5EB8:  CLRF   6B
5EBA:  MOVF   6B,W
5EBC:  CALL   01F6
5EC0:  INCF   6B,F
5EC2:  MOVWF  00
5EC4:  MOVWF  7D
5EC6:  CALL   11FE
5ECA:  MOVLW  15
5ECC:  SUBWF  6B,W
5ECE:  BNZ   5EBA
5ED0:  MOVLW  89
5ED2:  MOVWF  FE9
5ED4:  MOVFF  22,73
5ED8:  MOVFF  21,72
5EDC:  MOVFF  20,71
5EE0:  MOVFF  1F,70
5EE4:  CLRF   74
5EE6:  CALL   31F6
5EEA:  MOVLW  DF
5EEC:  MOVWF  7D
5EEE:  CALL   11FE
5EF2:  MOVLW  43
5EF4:  MOVWF  7D
5EF6:  CALL   11FE
....................                      } 
....................  
....................                      //Retardamos cierto tiempo para que el usuario vea correctamente los datos de la pantalla 
....................                      delay_ms(LCD_T_RETARDO*2); 
5EFA:  MOVLW  04
5EFC:  MOVWF  6B
5EFE:  MOVLW  FA
5F00:  MOVWF  x84
5F02:  CALL   10E6
5F06:  DECFSZ 6B,F
5F08:  BRA    5EFE
....................  
....................                      //Pedimos la introducción de nuevo valor 
....................                      lcd_send_byte(LCD_ORDEN, LCD_CLEAR); 
5F0A:  CLRF   x82
5F0C:  MOVLW  01
5F0E:  MOVWF  x83
5F10:  CALL   1152
....................                      printf(lcd_putc, "Nuevo valor:\n       %cC",223); 
5F14:  CLRF   6B
5F16:  MOVF   6B,W
5F18:  CALL   022E
5F1C:  INCF   6B,F
5F1E:  MOVWF  00
5F20:  MOVWF  7D
5F22:  CALL   11FE
5F26:  MOVLW  0D
5F28:  SUBWF  6B,W
5F2A:  BNZ   5F16
5F2C:  MOVLW  07
5F2E:  MOVWF  6C
5F30:  MOVLW  20
5F32:  MOVWF  7D
5F34:  CALL   11FE
5F38:  DECFSZ 6C,F
5F3A:  BRA    5F30
5F3C:  MOVLW  DF
5F3E:  MOVWF  7D
5F40:  CALL   11FE
5F44:  MOVLW  43
5F46:  MOVWF  7D
5F48:  CALL   11FE
....................  
....................                      //Recogemos el número de dos cifras introducido por el teclado 
....................                      term=(float)buscar_numero(6, temp_min, temp_max, valor); 
5F4C:  MOVLW  06
5F4E:  MOVWF  6D
5F50:  MOVLW  10
5F52:  MOVWF  6E
5F54:  MOVLW  20
5F56:  MOVWF  6F
5F58:  MOVFF  5B,70
5F5C:  CALL   3386
5F60:  MOVLB  2
5F62:  CLRF   x85
5F64:  MOVFF  01,284
5F68:  MOVLB  0
5F6A:  CALL   2426
5F6E:  MOVFF  03,60
5F72:  MOVFF  02,5F
5F76:  MOVFF  01,5E
5F7A:  MOVFF  00,5D
....................  
....................                      //Si se pulsa la tecla SI o NO, salimos 
....................                      if(term==NOCODE) 
5F7E:  MOVFF  60,76
5F82:  MOVFF  5F,75
5F86:  MOVFF  5E,74
5F8A:  MOVFF  5D,73
5F8E:  CLRF   7A
5F90:  CLRF   79
5F92:  MOVLW  48
5F94:  MOVWF  78
5F96:  MOVLW  85
5F98:  MOVWF  77
5F9A:  CALL   245E
5F9E:  BNZ   5FA4
....................                         goto salir; 
5FA0:  BRA    6616
....................                      else 
5FA2:  BRA    60BE
....................                      { 
....................                         //Retardamos cierto tiempo para permitir al usuario visualizar el valor que ha introducido 
....................                         delay_ms(LCD_T_RETARDO); 
5FA4:  MOVLW  02
5FA6:  MOVWF  6B
5FA8:  MOVLW  FA
5FAA:  MOVWF  x84
5FAC:  CALL   10E6
5FB0:  DECFSZ 6B,F
5FB2:  BRA    5FA8
....................  
....................                         //Mostramos un mensaje de aplicación de cambios 
....................                         lcd_send_byte(LCD_ORDEN, LCD_CLEAR); 
5FB4:  CLRF   x82
5FB6:  MOVLW  01
5FB8:  MOVWF  x83
5FBA:  CALL   1152
....................                         printf(lcd_putc, "  Aplicando\n  cambios..."); 
5FBE:  CLRF   6B
5FC0:  MOVF   6B,W
5FC2:  CALL   025A
5FC6:  IORLW  00
5FC8:  BZ    5FD4
5FCA:  INCF   6B,F
5FCC:  MOVWF  7D
5FCE:  CALL   11FE
5FD2:  BRA    5FC0
....................  
....................                         //Aquí, a diferencia que con el teclado matricial, no es necesario comprobar los límites de temperatura después 
....................  
....................                         //Leemos la temperatura 
....................                         temperatura = ds1820_read(); 
5FD4:  CALL   2052
5FD8:  MOVFF  03,2A
5FDC:  MOVFF  02,29
5FE0:  MOVFF  01,28
5FE4:  MOVFF  00,27
....................                         if(temperatura >= term) 
5FE8:  MOVFF  60,76
5FEC:  MOVFF  5F,75
5FF0:  MOVFF  5E,74
5FF4:  MOVFF  5D,73
5FF8:  MOVFF  2A,7A
5FFC:  MOVFF  29,79
6000:  MOVFF  28,78
6004:  MOVFF  27,77
6008:  CALL   245E
600C:  BC    6010
600E:  BNZ   604A
....................                         { 
....................                            //Si supera el valor del termostato, lo indicamos con el flag 
....................                            temp_habitacion_superada = TRUE; 
6010:  BSF    1E.1
....................                            //Guardamos el termostato nuevo teniendo en cuenta la histeresis de la vivienda 
....................                            termostato = term - histeresis_vivienda; 
6012:  BSF    FD8.1
6014:  MOVFF  60,281
6018:  MOVFF  5F,280
601C:  MOVFF  5E,27F
6020:  MOVFF  5D,27E
6024:  MOVFF  2E,285
6028:  MOVFF  2D,284
602C:  MOVFF  2C,283
6030:  MOVFF  2B,282
6034:  CALL   21AC
6038:  MOVFF  03,22
603C:  MOVFF  02,21
6040:  MOVFF  01,20
6044:  MOVFF  00,1F
....................                         }else 
6048:  BRA    605C
....................                         { 
....................                            //Si no se supera, se indica también 
....................                            temp_habitacion_superada = FALSE; 
604A:  BCF    1E.1
....................                            //Se guarda el valor tal cual 
....................                            termostato = term; 
604C:  MOVFF  60,22
6050:  MOVFF  5F,21
6054:  MOVFF  5E,20
6058:  MOVFF  5D,1F
....................                         } 
....................  
....................                         //Escribimos en el sensor el nuevo valor del termostato 
....................                         ds1820_establecer_TH_TL(127.5, termostato); 
605C:  CLRF   76
605E:  CLRF   75
6060:  MOVLW  7F
6062:  MOVWF  74
6064:  MOVLW  85
6066:  MOVWF  73
6068:  MOVFF  22,7A
606C:  MOVFF  21,79
6070:  MOVFF  20,78
6074:  MOVFF  1F,77
6078:  CALL   17BA
....................  
....................                         //Guardamos el nuevo valor del termostato en memoria 
....................                         write_eeprom(eeprom_termostato, (int)term); 
607C:  MOVFF  60,86
6080:  MOVFF  5F,85
6084:  MOVFF  5E,84
6088:  MOVFF  5D,83
608C:  CALL   1620
6090:  MOVFF  01,6B
6094:  CLRF   FA9
6096:  MOVFF  01,FA8
609A:  BCF    FA6.6
609C:  BCF    FA6.7
609E:  BSF    FA6.2
60A0:  MOVFF  FF2,00
60A4:  BCF    FF2.7
60A6:  MOVLB  F
60A8:  MOVLW  55
60AA:  MOVWF  FA7
60AC:  MOVLW  AA
60AE:  MOVWF  FA7
60B0:  BSF    FA6.1
60B2:  BTFSC  FA6.1
60B4:  BRA    60B2
60B6:  BCF    FA6.2
60B8:  MOVF   00,W
60BA:  IORWF  FF2,F
60BC:  MOVLB  0
....................  
....................  
....................                      } 
....................  
....................                      break; 
60BE:  BRA    6650
....................  
....................  
....................             //Si es 3, entramos en la opción de configuración de las alarmas 
....................             case 3: 
....................  
....................                      //Mostramos el encabezamiento de la operación 
....................                      lcd_send_byte(LCD_ORDEN, LCD_CLEAR); 
60C0:  CLRF   x82
60C2:  MOVLW  01
60C4:  MOVWF  x83
60C6:  CALL   1152
....................                      printf(lcd_putc," Programar\n sistema"); 
60CA:  CLRF   6B
60CC:  MOVF   6B,W
60CE:  CALL   028E
60D2:  IORLW  00
60D4:  BZ    60E0
60D6:  INCF   6B,F
60D8:  MOVWF  7D
60DA:  CALL   11FE
60DE:  BRA    60CC
....................                      delay_ms(LCD_T_RETARDO); 
60E0:  MOVLW  02
60E2:  MOVWF  6B
60E4:  MOVLW  FA
60E6:  MOVWF  x84
60E8:  CALL   10E6
60EC:  DECFSZ 6B,F
60EE:  BRA    60E4
....................  
....................                      //Tenemos la posibilidad de introducir 3 intervalos de alarma. 
....................                      //Se va guiando al usuario por la configuración de cada intervalo mediante el siguiente bucle 
....................                      for(contador=0; contador<3; contador++) 
60F0:  CLRF   59
60F2:  MOVF   59,W
60F4:  SUBLW  02
60F6:  BTFSS  FD8.0
60F8:  BRA    64E2
....................                      { 
....................                         //Se muestra el intervalo a configurar 
....................                         lcd_send_byte(LCD_ORDEN, LCD_CLEAR); 
60FA:  CLRF   x82
60FC:  MOVLW  01
60FE:  MOVWF  x83
6100:  CALL   1152
....................                         printf(lcd_putc, " INTERVALO %i\n   :      :",contador+1); 
6104:  MOVLW  01
6106:  ADDWF  59,W
6108:  MOVWF  6B
610A:  CLRF   6C
610C:  MOVF   6C,W
610E:  CALL   02BC
6112:  INCF   6C,F
6114:  MOVWF  00
6116:  MOVWF  7D
6118:  CALL   11FE
611C:  MOVLW  0B
611E:  SUBWF  6C,W
6120:  BNZ   610C
6122:  MOVFF  6B,76
6126:  MOVLW  1F
6128:  MOVWF  77
612A:  CALL   305A
612E:  MOVLW  0A
6130:  MOVWF  7D
6132:  CALL   11FE
6136:  MOVLW  03
6138:  MOVWF  6D
613A:  MOVLW  20
613C:  MOVWF  7D
613E:  CALL   11FE
6142:  DECFSZ 6D,F
6144:  BRA    613A
6146:  MOVLW  3A
6148:  MOVWF  7D
614A:  CALL   11FE
614E:  MOVLW  06
6150:  MOVWF  6E
6152:  MOVLW  20
6154:  MOVWF  7D
6156:  CALL   11FE
615A:  DECFSZ 6E,F
615C:  BRA    6152
615E:  MOVLW  3A
6160:  MOVWF  7D
6162:  CALL   11FE
....................  
....................                         //Se pide al usuario el valor de hora de inicio de la alarma 
....................                         pr.horas_inicio = buscar_numero(2, 0, 23, 0); 
6166:  MOVLW  02
6168:  MOVWF  6D
616A:  CLRF   6E
616C:  MOVLW  17
616E:  MOVWF  6F
6170:  CLRF   70
6172:  CALL   3386
6176:  MOVFF  01,61
....................  
....................                         //Si se pulsa No, se indica que no quieren introducirse más alarmas. 
....................                         //En el otro código esto se gestionaba pulsando sí y con no simplemente se salía, 
....................                         //pero aquí debemos hacerlo así por falta de botones... 
....................                         if(pr.horas_inicio==NOCODE) 
617A:  MOVF   61,W
617C:  SUBLW  64
617E:  BNZ   618C
....................                         { 
....................                            //Si era la primera alarma que se gestionaba, se interpreta como que 
....................                            //no se quiere activar ninguna alarma 
....................                            if(contador==0) 
6180:  MOVF   59,F
6182:  BNZ   618A
....................                            { 
....................                               //Desactivamos las alarmas 
....................                               alarma = FALSE; 
6184:  BCF    1E.6
....................                               //Salimos 
....................                               goto salir; 
6186:  BRA    6616
....................                            } 
....................                            else 
6188:  BRA    618C
....................                               //Salimos simplemente del bucle 
....................                               break; 
618A:  BRA    64E2
....................                         } 
....................  
....................                         //Se pide al usuario el valor de los minutos de inicio 
....................                         pr.minutos_inicio = buscar_numero(5, 0, 59, 0); 
618C:  MOVLW  05
618E:  MOVWF  6D
6190:  CLRF   6E
6192:  MOVLW  3B
6194:  MOVWF  6F
6196:  CLRF   70
6198:  CALL   3386
619C:  MOVFF  01,62
....................  
....................                         //Si se pulsa NO, interrumpimos la introducción de alarmas 
....................                         if(pr.minutos_inicio==NOCODE) 
61A0:  MOVF   62,W
61A2:  SUBLW  64
61A4:  BNZ   61B2
....................                         { 
....................                            //Si es el primer intervalo, interpretamos como que el usuario 
....................                            //no quiere programar alarmas 
....................                            if(contador==0) 
61A6:  MOVF   59,F
61A8:  BNZ   61B0
....................                            { 
....................                               //Desactivamos las alarmas 
....................                               alarma = FALSE; 
61AA:  BCF    1E.6
....................                               goto salir; 
61AC:  BRA    6616
....................                            } 
....................                            else 
61AE:  BRA    61B2
....................                               //Salimos del bucle 
....................                               break; 
61B0:  BRA    64E2
....................                         } 
....................  
....................                         //Al contrario que ocurría en el Proyecto 1 que contaba con teclado matricial, 
....................                         //en este caso comprobamos que la hora final sea posterior a la inicial en el momento. 
....................                         //Para ello debemos establecer el límite inferior de la hora de fin correctamente. 
....................  
....................                         //Si la hora de inicio corresponde a la última hora del día, no podrá programarse nada 
....................                         if(pr.horas_inicio==23 && pr.minutos_inicio==59) 
61B2:  MOVF   61,W
61B4:  SUBLW  17
61B6:  BNZ   61F2
61B8:  MOVF   62,W
61BA:  SUBLW  3B
61BC:  BNZ   61F2
....................                         { 
....................                            //Si se produce un error de este tipo, se indica 
....................                            lcd_send_byte(LCD_ORDEN, LCD_CLEAR); 
61BE:  CLRF   x82
61C0:  MOVLW  01
61C2:  MOVWF  x83
61C4:  CALL   1152
....................                            printf(lcd_putc, "   Valores\n   incorrectos"); 
61C8:  CLRF   6B
61CA:  MOVF   6B,W
61CC:  CALL   02E8
61D0:  IORLW  00
61D2:  BZ    61DE
61D4:  INCF   6B,F
61D6:  MOVWF  7D
61D8:  CALL   11FE
61DC:  BRA    61CA
....................                            delay_ms(LCD_T_RETARDO); 
61DE:  MOVLW  02
61E0:  MOVWF  6B
61E2:  MOVLW  FA
61E4:  MOVWF  x84
61E6:  CALL   10E6
61EA:  DECFSZ 6B,F
61EC:  BRA    61E2
....................                            //Se repite la última iteración del bloque 
....................                            contador--; 
61EE:  DECF   59,F
....................                            continue; 
61F0:  BRA    64DE
....................                         } 
....................  
....................                         //Si los minutos son 59, tendremos que irnos a la siguiente hora 
....................                         if(pr.minutos_inicio==59) 
61F2:  MOVF   62,W
61F4:  SUBLW  3B
61F6:  BNZ   621E
....................                         { 
....................                            pr.horas_fin = buscar_numero(9, pr.horas_inicio+1, 23, pr.horas_inicio+1); 
61F8:  MOVLW  01
61FA:  ADDWF  61,W
61FC:  MOVWF  6B
61FE:  MOVLW  01
6200:  ADDWF  61,W
6202:  MOVWF  6C
6204:  MOVLW  09
6206:  MOVWF  6D
6208:  MOVFF  6B,6E
620C:  MOVLW  17
620E:  MOVWF  6F
6210:  MOVFF  6C,70
6214:  CALL   3386
6218:  MOVFF  01,63
....................                         }else 
621C:  BRA    6236
....................                         { 
....................                            pr.horas_fin = buscar_numero(9, pr.horas_inicio, 23, pr.horas_inicio); 
621E:  MOVLW  09
6220:  MOVWF  6D
6222:  MOVFF  61,6E
6226:  MOVLW  17
6228:  MOVWF  6F
622A:  MOVFF  61,70
622E:  CALL   3386
6232:  MOVFF  01,63
....................                         } 
....................  
....................                         if(pr.horas_fin==NOCODE) 
6236:  MOVF   63,W
6238:  SUBLW  64
623A:  BNZ   6248
....................                         { 
....................                            if(contador==0) 
623C:  MOVF   59,F
623E:  BNZ   6246
....................                            { 
....................                               alarma = FALSE; 
6240:  BCF    1E.6
....................                               goto salir; 
6242:  BRA    6616
....................                            } 
....................                            else 
6244:  BRA    6248
....................                               break; 
6246:  BRA    64E2
....................                         } 
....................  
....................                         //Si las horas de inicio y fin son las mismas, habrá que limitar que los minutos de finalización 
....................                         //tengan un valor mayor 
....................                         if(pr.horas_inicio == pr.horas_fin) 
6248:  MOVF   63,W
624A:  SUBWF  61,W
624C:  BNZ   6274
....................                            pr.minutos_fin = buscar_numero(12, pr.minutos_inicio+1, 59, pr.minutos_inicio+1); 
624E:  MOVLW  01
6250:  ADDWF  62,W
6252:  MOVWF  6B
6254:  MOVLW  01
6256:  ADDWF  62,W
6258:  MOVWF  6C
625A:  MOVLW  0C
625C:  MOVWF  6D
625E:  MOVFF  6B,6E
6262:  MOVLW  3B
6264:  MOVWF  6F
6266:  MOVFF  6C,70
626A:  CALL   3386
626E:  MOVFF  01,64
....................                         else 
6272:  BRA    6288
....................                            pr.minutos_fin = buscar_numero(12, 0, 59, 0); 
6274:  MOVLW  0C
6276:  MOVWF  6D
6278:  CLRF   6E
627A:  MOVLW  3B
627C:  MOVWF  6F
627E:  CLRF   70
6280:  CALL   3386
6284:  MOVFF  01,64
....................  
....................                         if(pr.minutos_fin==NOCODE) 
6288:  MOVF   64,W
628A:  SUBLW  64
628C:  BNZ   629A
....................                         { 
....................                            if(contador==0) 
628E:  MOVF   59,F
6290:  BNZ   6298
....................                            { 
....................                               alarma = FALSE; 
6292:  BCF    1E.6
....................                               goto salir; 
6294:  BRA    6616
....................                            } 
....................                            else 
6296:  BRA    629A
....................                               break; 
6298:  BRA    64E2
....................                         } 
....................  
....................                         //Introducimos cierto retardo para que el usuario pueda visualizar los valores introducidos en la pantalla 
....................                         delay_ms(LCD_T_RETARDO); 
629A:  MOVLW  02
629C:  MOVWF  6B
629E:  MOVLW  FA
62A0:  MOVWF  x84
62A2:  CALL   10E6
62A6:  DECFSZ 6B,F
62A8:  BRA    629E
....................  
....................                         //No puede haber un intervalo de encendido de más de 4 horas. 
....................                         //Esto deriva de un problema propio de almacenamiento de números enteros, pero es perfectamente lógico 
....................                         //que un sistema de calefacción tenga un tiempo máximo de encendido para regular el uso abusivo del sistema 
....................                         //y evitar averías por un funcionamiento muy prolongado. 
....................                         if(diferencia_tiempo(pr.horas_inicio, pr.minutos_inicio, pr.horas_fin, pr.minutos_fin)>240) 
62AA:  MOVFF  61,73
62AE:  MOVFF  62,74
62B2:  MOVFF  63,75
62B6:  MOVFF  64,76
62BA:  CALL   2978
62BE:  MOVFF  02,6C
62C2:  MOVFF  01,6B
62C6:  MOVF   6C,F
62C8:  BNZ   62D0
62CA:  MOVF   6B,W
62CC:  SUBLW  F0
62CE:  BC    6304
....................                         { 
....................                            //Mostramos un aviso 
....................                            lcd_send_byte(LCD_ORDEN, LCD_CLEAR); 
62D0:  CLRF   x82
62D2:  MOVLW  01
62D4:  MOVWF  x83
62D6:  CALL   1152
....................                            printf(lcd_putc, "Intervalo limite\nde 4 horas"); 
62DA:  CLRF   6B
62DC:  MOVF   6B,W
62DE:  CALL   031C
62E2:  IORLW  00
62E4:  BZ    62F0
62E6:  INCF   6B,F
62E8:  MOVWF  7D
62EA:  CALL   11FE
62EE:  BRA    62DC
....................                            delay_ms(LCD_T_RETARDO); 
62F0:  MOVLW  02
62F2:  MOVWF  6B
62F4:  MOVLW  FA
62F6:  MOVWF  x84
62F8:  CALL   10E6
62FC:  DECFSZ 6B,F
62FE:  BRA    62F4
....................                            //Se repite la última iteración del bloque 
....................                            contador--; 
6300:  DECF   59,F
....................                            continue; 
6302:  BRA    64DE
....................  
....................                         } 
....................  
....................                         //El usuario debe ahora introducir el valor del temostato para ese periodo de encendido 
....................                         lcd_send_byte(LCD_ORDEN, LCD_CLEAR); 
6304:  CLRF   x82
6306:  MOVLW  01
6308:  MOVWF  x83
630A:  CALL   1152
....................                         printf(lcd_putc, "Termostato %i\n      %cC", contador+1, 223); 
630E:  MOVLW  01
6310:  ADDWF  59,W
6312:  MOVWF  6B
6314:  CLRF   6C
6316:  MOVF   6C,W
6318:  CALL   0352
631C:  INCF   6C,F
631E:  MOVWF  00
6320:  MOVWF  7D
6322:  CALL   11FE
6326:  MOVLW  0B
6328:  SUBWF  6C,W
632A:  BNZ   6316
632C:  MOVFF  6B,76
6330:  MOVLW  1F
6332:  MOVWF  77
6334:  CALL   305A
6338:  MOVLW  0A
633A:  MOVWF  7D
633C:  CALL   11FE
6340:  MOVLW  06
6342:  MOVWF  6D
6344:  MOVLW  20
6346:  MOVWF  7D
6348:  CALL   11FE
634C:  DECFSZ 6D,F
634E:  BRA    6344
6350:  MOVLW  DF
6352:  MOVWF  7D
6354:  CALL   11FE
6358:  MOVLW  43
635A:  MOVWF  7D
635C:  CALL   11FE
....................  
....................                         //Recogemos el número introducido por el usuario 
....................                         pr.termostato = buscar_numero(4, temp_min, temp_max, 20); 
6360:  MOVLW  04
6362:  MOVWF  6D
6364:  MOVLW  10
6366:  MOVWF  6E
6368:  MOVLW  20
636A:  MOVWF  6F
636C:  MOVLW  14
636E:  MOVWF  70
6370:  CALL   3386
6374:  MOVFF  01,65
....................  
....................                         //Retardamos para que el usuario pueda ver el valor que ha introducido 
....................                         delay_ms(LCD_T_RETARDO); 
6378:  MOVLW  02
637A:  MOVWF  6B
637C:  MOVLW  FA
637E:  MOVWF  x84
6380:  CALL   10E6
6384:  DECFSZ 6B,F
6386:  BRA    637C
....................  
....................                         //Comprobamos que los intervalos sean correctos respecto a los otros, es decir, 
....................                         //que no haya solapamiento entre los distintos intervalos programados. 
....................                         for(contador2=0; contador2<contador; contador2++) 
6388:  CLRF   5A
638A:  MOVF   59,W
638C:  SUBWF  5A,W
638E:  BTFSC  FD8.0
6390:  BRA    64BA
....................                         { 
....................                            //Tomamos las programaciones almacenadas anteriormente 
....................                            pr2 = programaciones[contador2]; 
6392:  MOVF   5A,W
6394:  MULLW  05
6396:  MOVF   FF3,W
6398:  CLRF   03
639A:  ADDLW  2F
639C:  MOVWF  01
639E:  MOVLW  00
63A0:  ADDWFC 03,F
63A2:  MOVFF  01,6B
63A6:  MOVFF  03,6C
63AA:  CLRF   FEA
63AC:  MOVLW  66
63AE:  MOVWF  FE9
63B0:  MOVFF  03,FE2
63B4:  MOVFF  01,FE1
63B8:  MOVLW  05
63BA:  MOVWF  01
63BC:  MOVFF  FE6,FEE
63C0:  DECFSZ 01,F
63C2:  BRA    63BC
....................  
....................                            //Controlamos todas las posibilidades de solapamiento 
....................                            if( 
....................                               (comprobar_hora(pr2.horas_inicio, pr2.minutos_inicio, pr.horas_fin, pr.minutos_fin) && 
....................                               !comprobar_hora(pr2.horas_inicio, pr2.minutos_inicio, pr.horas_inicio, pr.minutos_inicio)) 
....................  
....................                               ||(comprobar_hora(pr2.horas_fin, pr2.minutos_fin, pr.horas_fin, pr.minutos_fin) && 
....................                                 !comprobar_hora(pr2.horas_fin, pr2.minutos_fin, pr.horas_inicio, pr.minutos_inicio)) 
....................  
....................                               ||(comprobar_hora(pr.horas_inicio, pr.minutos_inicio, pr2.horas_fin, pr2.minutos_fin) && 
....................                                 !comprobar_hora(pr.horas_inicio, pr.minutos_inicio, pr2.horas_inicio, pr2.minutos_inicio)) 
....................  
....................                               ||(comprobar_hora(pr.horas_fin, pr.minutos_fin, pr2.horas_fin, pr2.minutos_fin) && 
....................                                 !comprobar_hora(pr.horas_fin, pr.minutos_fin, pr2.horas_inicio, pr2.minutos_inicio)) 
....................                            ) 
63C4:  MOVFF  66,7D
63C8:  MOVFF  67,7E
63CC:  MOVFF  63,7F
63D0:  MOVFF  64,80
63D4:  CALL   2926
63D8:  MOVF   01,F
63DA:  BZ    63F4
63DC:  MOVFF  66,7D
63E0:  MOVFF  67,7E
63E4:  MOVFF  61,7F
63E8:  MOVFF  62,80
63EC:  CALL   2926
63F0:  MOVF   01,F
63F2:  BZ    6484
63F4:  MOVFF  68,7D
63F8:  MOVFF  69,7E
63FC:  MOVFF  63,7F
6400:  MOVFF  64,80
6404:  CALL   2926
6408:  MOVF   01,F
640A:  BZ    6424
640C:  MOVFF  68,7D
6410:  MOVFF  69,7E
6414:  MOVFF  61,7F
6418:  MOVFF  62,80
641C:  CALL   2926
6420:  MOVF   01,F
6422:  BZ    6484
6424:  MOVFF  61,7D
6428:  MOVFF  62,7E
642C:  MOVFF  68,7F
6430:  MOVFF  69,80
6434:  CALL   2926
6438:  MOVF   01,F
643A:  BZ    6454
643C:  MOVFF  61,7D
6440:  MOVFF  62,7E
6444:  MOVFF  66,7F
6448:  MOVFF  67,80
644C:  CALL   2926
6450:  MOVF   01,F
6452:  BZ    6484
6454:  MOVFF  63,7D
6458:  MOVFF  64,7E
645C:  MOVFF  68,7F
6460:  MOVFF  69,80
6464:  CALL   2926
6468:  MOVF   01,F
646A:  BZ    64B6
646C:  MOVFF  63,7D
6470:  MOVFF  64,7E
6474:  MOVFF  66,7F
6478:  MOVFF  67,80
647C:  CALL   2926
6480:  MOVF   01,F
6482:  BNZ   64B6
....................                            { 
....................                               //Si hay solapamiento, mostramos un mensaje de error y salimos 
....................                               lcd_send_byte(LCD_ORDEN, LCD_CLEAR); 
6484:  CLRF   x82
6486:  MOVLW  01
6488:  MOVWF  x83
648A:  CALL   1152
....................                               printf(lcd_putc, "Solapamiento\nde intervalos!"); 
648E:  CLRF   6B
6490:  MOVF   6B,W
6492:  CALL   037E
6496:  IORLW  00
6498:  BZ    64A4
649A:  INCF   6B,F
649C:  MOVWF  7D
649E:  CALL   11FE
64A2:  BRA    6490
....................                               delay_ms(LCD_T_RETARDO*2); 
64A4:  MOVLW  04
64A6:  MOVWF  6B
64A8:  MOVLW  FA
64AA:  MOVWF  x84
64AC:  CALL   10E6
64B0:  DECFSZ 6B,F
64B2:  BRA    64A8
....................                               goto salir; 
64B4:  BRA    6616
....................                            } 
....................                         } 
64B6:  INCF   5A,F
64B8:  BRA    638A
....................  
....................                         //Añadimos esta programación a la lista de programaciones 
....................                         programaciones[contador]=pr; 
64BA:  MOVF   59,W
64BC:  MULLW  05
64BE:  MOVF   FF3,W
64C0:  CLRF   03
64C2:  ADDLW  2F
64C4:  MOVWF  FE9
64C6:  MOVLW  00
64C8:  ADDWFC 03,W
64CA:  MOVWF  FEA
64CC:  CLRF   FE2
64CE:  MOVLW  61
64D0:  MOVWF  FE1
64D2:  MOVLW  05
64D4:  MOVWF  01
64D6:  MOVFF  FE6,FEE
64DA:  DECFSZ 01,F
64DC:  BRA    64D6
....................                      } 
64DE:  INCF   59,F
64E0:  BRA    60F2
....................  
....................                      //Habilitamos la alarma 
....................                      alarma=TRUE; 
64E2:  BSF    1E.6
....................  
....................                      //Guardamos el número de intervalos configurados 
....................                      num_intervalos = contador; 
64E4:  MOVFF  59,43
....................  
....................                      //Ordenamos las programaciones por orden de hora de inicio 
....................                      ordenar_programaciones(); 
64E8:  GOTO   35AC
....................  
....................                      //Seleccionamos la próxima alarma a ejecutar 
....................                      seleccionar_alarma(); 
64EC:  GOTO   36E4
....................  
....................                      //Programamos la próxima alarma para que salte el reloj en el momento indicado 
....................                      programar_proxima_alarma(); 
64F0:  CALL   28E8
....................  
....................                      //Indicamos que se trata de una alarma de encendido 
....................                      toca_encender = TRUE; 
64F4:  BSF    1E.3
....................  
....................                      //Guardamos las programaciones introducidas 
....................                      grabar_programaciones(); 
64F6:  GOTO   3766
....................  
....................                      break; 
....................  
....................  
....................             //Si es 4, entramos en el modo de revisión y obtención de datos históricos 
....................             case 4: 
....................  
....................                      //Solicitamos la introducción de una clave. 
....................                      //Al contrario de lo que ocurría cuando disponíamos de teclado matricial, 
....................                      //en este caso la clave es una combinación de botones: {+,-,-,SI} 
....................                      lcd_send_byte(LCD_ORDEN, LCD_CLEAR); 
64FA:  CLRF   x82
64FC:  MOVLW  01
64FE:  MOVWF  x83
6500:  CALL   1152
....................                      printf(lcd_putc, "  Introduzca\n  clave"); 
6504:  CLRF   6B
6506:  MOVF   6B,W
6508:  CALL   03B4
650C:  IORLW  00
650E:  BZ    651A
6510:  INCF   6B,F
6512:  MOVWF  7D
6514:  CALL   11FE
6518:  BRA    6506
....................  
....................                      //Realizamos todo el proceso de comprobación de clave correcta según los botones pulsados 
....................                      while(1) 
....................                      { 
....................                         if(!mas) 
651A:  BTFSC  F82.0
651C:  BRA    659E
....................                         { 
....................                            while(!mas){} 
651E:  BTFSC  F82.0
6520:  BRA    6524
6522:  BRA    651E
....................                            while(1) 
....................                            { 
....................                               if(!menos) 
6524:  BTFSC  F82.1
6526:  BRA    6580
....................                               { 
....................                                  while(!menos){} 
6528:  BTFSC  F82.1
652A:  BRA    652E
652C:  BRA    6528
....................                                  while(1) 
....................                                  { 
....................                                     if(!menos) 
652E:  BTFSC  F82.1
6530:  BRA    6562
....................                                     { 
....................                                        while(!menos){} 
6532:  BTFSC  F82.1
6534:  BRA    6538
6536:  BRA    6532
....................                                        while(1) 
....................                                        { 
....................                                           if(!si) 
6538:  BTFSC  F82.2
653A:  BRA    6544
....................                                           { 
....................                                              while(!si){} 
653C:  BTFSC  F82.2
653E:  BRA    6542
6540:  BRA    653C
....................                                              goto clave_correcta; 
6542:  BRA    65EE
....................                                           } 
....................                                           if(!mas || !menos || !no) 
6544:  BTFSS  F82.0
6546:  BRA    6550
6548:  BTFSS  F82.1
654A:  BRA    6550
654C:  BTFSC  F82.5
654E:  BRA    6560
....................                                           { 
....................                                              while(!mas || !menos || !no){} 
6550:  BTFSS  F82.0
6552:  BRA    655C
6554:  BTFSS  F82.1
6556:  BRA    655C
6558:  BTFSC  F82.5
655A:  BRA    655E
655C:  BRA    6550
....................                                              goto clave_incorrecta; 
655E:  BRA    65BC
....................                                           } 
....................                                        } 
6560:  BRA    6538
....................                                     } 
....................                                     if(!mas || !si || !no) 
6562:  BTFSS  F82.0
6564:  BRA    656E
6566:  BTFSS  F82.2
6568:  BRA    656E
656A:  BTFSC  F82.5
656C:  BRA    657E
....................                                     { 
....................                                        while(!mas || !si || !no){} 
656E:  BTFSS  F82.0
6570:  BRA    657A
6572:  BTFSS  F82.2
6574:  BRA    657A
6576:  BTFSC  F82.5
6578:  BRA    657C
657A:  BRA    656E
....................                                        goto clave_incorrecta; 
657C:  BRA    65BC
....................                                     } 
....................                                  } 
657E:  BRA    652E
....................                               } 
....................                               if(!mas || !si || !no) 
6580:  BTFSS  F82.0
6582:  BRA    658C
6584:  BTFSS  F82.2
6586:  BRA    658C
6588:  BTFSC  F82.5
658A:  BRA    659C
....................                               { 
....................                                  while(!mas || !si || !no){} 
658C:  BTFSS  F82.0
658E:  BRA    6598
6590:  BTFSS  F82.2
6592:  BRA    6598
6594:  BTFSC  F82.5
6596:  BRA    659A
6598:  BRA    658C
....................                                  goto clave_incorrecta; 
659A:  BRA    65BC
....................                               } 
....................                            } 
659C:  BRA    6524
....................                         } 
....................                         if(!menos || !si || !no) 
659E:  BTFSS  F82.1
65A0:  BRA    65AA
65A2:  BTFSS  F82.2
65A4:  BRA    65AA
65A6:  BTFSC  F82.5
65A8:  BRA    65BA
....................                         { 
....................                            while(!menos || !si || !no){} 
65AA:  BTFSS  F82.1
65AC:  BRA    65B6
65AE:  BTFSS  F82.2
65B0:  BRA    65B6
65B2:  BTFSC  F82.5
65B4:  BRA    65B8
65B6:  BRA    65AA
....................                            goto clave_incorrecta; 
65B8:  BRA    65BC
....................                         } 
....................                      } 
65BA:  BRA    651A
....................  
....................                      clave_incorrecta: 
....................  
....................                      //Si la clave es incorrecta, lo indicamos y salimos 
....................                      lcd_send_byte(LCD_ORDEN, LCD_CLEAR); 
65BC:  CLRF   x82
65BE:  MOVLW  01
65C0:  MOVWF  x83
65C2:  CALL   1152
....................                      printf(lcd_putc, "  Clave\n  incorrecta"); 
65C6:  CLRF   6B
65C8:  MOVF   6B,W
65CA:  CALL   03E4
65CE:  IORLW  00
65D0:  BZ    65DC
65D2:  INCF   6B,F
65D4:  MOVWF  7D
65D6:  CALL   11FE
65DA:  BRA    65C8
....................                      delay_ms(LCD_T_RETARDO); 
65DC:  MOVLW  02
65DE:  MOVWF  6B
65E0:  MOVLW  FA
65E2:  MOVWF  x84
65E4:  CALL   10E6
65E8:  DECFSZ 6B,F
65EA:  BRA    65E0
....................                      goto salir; 
65EC:  BRA    6616
....................  
....................                      clave_correcta: 
....................  
....................                      //Si la clave es correcta, entramos en el modo revisión 
....................                      lcd_send_byte(LCD_ORDEN, LCD_CLEAR); 
65EE:  CLRF   x82
65F0:  MOVLW  01
65F2:  MOVWF  x83
65F4:  CALL   1152
....................                      printf(lcd_putc, "  Modo\n  revision"); 
65F8:  CLRF   6B
65FA:  MOVF   6B,W
65FC:  CALL   0414
6600:  IORLW  00
6602:  BZ    660E
6604:  INCF   6B,F
6606:  MOVWF  7D
6608:  CALL   11FE
660C:  BRA    65FA
....................  
....................                      //Dejamos la pantalla lcd fija 
....................                      set_tris_d(0xFF); 
660E:  MOVLW  FF
6610:  MOVWF  F95
....................  
....................                      //Representamos el contenido de los registros y activamos la interfaz RS-232 
....................                      representar_registros(); 
6612:  GOTO   3BA8
....................  
....................  
....................                      break; 
....................  
....................               default: 
....................  
....................                         //Aquí confluyen todas las salidas de la rutina de interfaz con el usuario 
....................                         salir: 
....................                         //Se muestra un mensaje de finalización 
....................                         lcd_send_byte(LCD_ORDEN,LCD_CLEAR); 
6616:  CLRF   x82
6618:  MOVLW  01
661A:  MOVWF  x83
661C:  CALL   1152
....................                         lcd_send_byte(LCD_ORDEN,LCD_NO_CURSOR); 
6620:  CLRF   x82
6622:  MOVLW  0C
6624:  MOVWF  x83
6626:  CALL   1152
....................                         printf(lcd_putc, "  Anulando\n  operacion..."); 
662A:  CLRF   6B
662C:  MOVF   6B,W
662E:  CALL   01C2
6632:  IORLW  00
6634:  BZ    6640
6636:  INCF   6B,F
6638:  MOVWF  7D
663A:  CALL   11FE
663E:  BRA    662C
....................                         delay_ms(LCD_T_RETARDO); 
6640:  MOVLW  02
6642:  MOVWF  6B
6644:  MOVLW  FA
6646:  MOVWF  x84
6648:  CALL   10E6
664C:  DECFSZ 6B,F
664E:  BRA    6644
....................  
....................          } 
....................  
....................          //Se desactiva el flag de indicación de la interrupción 
....................          lcd_int = FALSE; 
6650:  BCF    1E.4
....................  
....................          //Volvemos a activar las interrupciones 
....................          enable_interrupts(GLOBAL); 
6652:  MOVLW  C0
6654:  IORWF  FF2,F
....................       } 
....................  
....................       //Comenzamos el bloque de comprobación de parámetros y activación de los procesos necesarios. 
....................  
....................       //Comparamos primero la temperatura del agua en la caldera. Esta comprobación se 
....................       //realiza siempre, independientemente de que el sistema esté o no encendido. 
....................       if(!comp_caldera()) 
6656:  CALL   24D4
665A:  MOVF   01,F
665C:  BNZ   666E
....................       { 
....................          //Entramos aquí si la temperatura de la caldera es menor que la necesaria 
....................          if(temperatura_caldera_superada) 
665E:  BTFSS  1E.0
6660:  BRA    6664
....................            //Si el flag estaba activado, lo desactivamos 
....................            temperatura_caldera_superada = FALSE; 
6662:  BCF    1E.0
....................          if(!caldera_encendida) 
6664:  BTFSC  F83.0
6666:  BRA    666C
....................             //Si no estaba encendida, la encendemos 
....................             encender_caldera(); 
6668:  GOTO   56D8
....................       } 
....................       else 
666C:  BRA    667C
....................       { 
....................          //Si la temperatura de la caldera es mayor que la necesaria, apagamos la caldera si está encendida 
....................          //y activamos el flag correspondiente 
....................          if(!temperatura_caldera_superada) 
666E:  BTFSC  1E.0
6670:  BRA    6674
....................             temperatura_caldera_superada = TRUE; 
6672:  BSF    1E.0
....................          if(caldera_encendida) 
6674:  BTFSS  F83.0
6676:  BRA    667C
....................             apagar_caldera(); 
6678:  GOTO   56F4
....................       } 
....................  
....................       //Comprobamos la temperatura y almacenamos el resultado en una variable 
....................       aux = comprobar_temperatura(); 
667C:  GOTO   587A
6680:  MOVFF  01,58
....................  
....................       //Comprobamos que el sistema no lleve encendido más de 4 horas, ya que en ese caso hay riesgo de avería 
....................       //(en realidad esta limitación deriva de un problema propio de representación en memoria). 
....................       //Ya leimos el tiempo en comprobar_temperatura(), así que no necesitamos leerlo de nuevo. 
....................       if(sistema_encendido && diferencia_tiempo(hora_encendido, minutos_encendido, tiempo.hours, tiempo.minutes)>240) 
6684:  BTFSS  F83.2
6686:  BRA    6742
6688:  MOVFF  4C,73
668C:  MOVFF  4D,74
6690:  MOVFF  47,75
6694:  MOVFF  46,76
6698:  CALL   2978
669C:  MOVFF  02,6C
66A0:  MOVFF  01,6B
66A4:  MOVF   6C,F
66A6:  BNZ   66AE
66A8:  MOVF   6B,W
66AA:  SUBLW  F0
66AC:  BC    6742
....................       { 
....................          //Si la diferencia de tiempo es mayor que 4 horas, lo indicamos y apagamos el motor y el sistema 
....................          lcd_send_byte(LCD_ORDEN,LCD_CLEAR); 
66AE:  CLRF   x82
66B0:  MOVLW  01
66B2:  MOVWF  x83
66B4:  CALL   1152
....................          printf(lcd_putc, "Demasiado tiempo\nencendido!"); 
66B8:  CLRF   6B
66BA:  MOVF   6B,W
66BC:  CALL   0440
66C0:  IORLW  00
66C2:  BZ    66CE
66C4:  INCF   6B,F
66C6:  MOVWF  7D
66C8:  CALL   11FE
66CC:  BRA    66BA
....................          delay_ms(2*LCD_T_RETARDO); 
66CE:  MOVLW  04
66D0:  MOVWF  6B
66D2:  MOVLW  FA
66D4:  MOVWF  x84
66D6:  CALL   10E6
66DA:  DECFSZ 6B,F
66DC:  BRA    66D2
....................          lcd_send_byte(LCD_ORDEN,LCD_CLEAR); 
66DE:  CLRF   x82
66E0:  MOVLW  01
66E2:  MOVWF  x83
66E4:  CALL   1152
....................          printf(lcd_putc, "  Apagando\n  sistema..."); 
66E8:  CLRF   6B
66EA:  MOVF   6B,W
66EC:  CALL   0158
66F0:  IORLW  00
66F2:  BZ    66FE
66F4:  INCF   6B,F
66F6:  MOVWF  7D
66F8:  CALL   11FE
66FC:  BRA    66EA
....................          apagar_sistema(); 
66FE:  CALL   2BFC
....................  
....................          if(motor) 
6702:  BTFSS  F83.1
6704:  BRA    6708
....................            motor = FALSE; 
6706:  BCF    F83.1
....................  
....................          //Si estaba encendido por alguna alarma, recuperamos el termostato anterior. 
....................          if(encendido_por_alarma) 
6708:  BTFSS  1E.2
670A:  BRA    673E
....................          { 
....................             termostato = termostato_provisional; 
670C:  MOVFF  26,22
6710:  MOVFF  25,21
6714:  MOVFF  24,20
6718:  MOVFF  23,1F
....................             //Almacenamos el valor en el sensor 
....................             ds1820_establecer_TH_TL(127.5, termostato); 
671C:  CLRF   76
671E:  CLRF   75
6720:  MOVLW  7F
6722:  MOVWF  74
6724:  MOVLW  85
6726:  MOVWF  73
6728:  MOVFF  22,7A
672C:  MOVFF  21,79
6730:  MOVFF  20,78
6734:  MOVFF  1F,77
6738:  CALL   17BA
....................             encendido_por_alarma = FALSE; 
673C:  BCF    1E.2
....................          } 
....................  
....................          goto inicio; 
673E:  GOTO   5AB4
....................  
....................       } 
....................  
....................       //Comprobamos ahora la temperatura de la vivienda. Esto se realiza sólo si el sistema está encendido 
....................       if(aux && sistema_encendido && temperatura_caldera_superada) 
6742:  MOVF   58,F
6744:  BZ    6756
6746:  BTFSS  F83.2
6748:  BRA    6756
674A:  BTFSS  1E.0
674C:  BRA    6756
....................       { 
....................          //Si la temperatura es menor que la necesaria, el sistema está encendido y la temperatura del 
....................          //agua en la caldera es la adecuada, encendemos el motor de circulación del agua 
....................          if(!motor) 
674E:  BTFSC  F83.1
6750:  BRA    6754
....................             motor = TRUE; 
6752:  BSF    F83.1
....................  
....................       } 
....................       else if(motor) 
6754:  BRA    675C
6756:  BTFSS  F83.1
6758:  BRA    675C
....................          //Si no se cumplen las condiciones, apagamos el motor si está encendido 
....................          motor = FALSE; 
675A:  BCF    F83.1
....................  
....................       //Comprobamos si ha saltado la alarma. Esta comprobación la hacemos por software en lugar de por 
....................       //interrupciones porque he tenido muchos problemas con las interrupciones de reloj en la placa 
....................       //que cogí el día de las pruebas, problemas relacionados con el borrado del flag de alarma del 
....................       //reloj. Ante esto, por tanto, aplico la solución gordiana de hacerlo por software para asegurar 
....................       //que funcione en la defensa. Puede verse un ejemplo de aplicación de las interrupciones de reloj 
....................       //en el modelo de PROTEUS del proyecto final. 
....................       //Para detectar si la alarma ha saltado vemos si la diferencia de tiempo entre ambas horas es igual. 
....................       //Esto no nos dará ningún problema en el tiempo de respuesta de la alarma (que se pase al minuto siguiente) 
....................       //ya que el WDT despierta al PIC varias veces por minuto. 
....................       if(alarma && (diferencia_tiempo(hora_alarma, minutos_alarma, tiempo.hours, tiempo.minutes)==0)) 
675C:  BTFSS  1E.6
675E:  BRA    6786
6760:  MOVFF  56,73
6764:  MOVFF  57,74
6768:  MOVFF  47,75
676C:  MOVFF  46,76
6770:  CALL   2978
6774:  MOVFF  02,6C
6778:  MOVFF  01,6B
677C:  MOVF   6B,F
677E:  BNZ   6786
6780:  MOVF   6C,F
6782:  BNZ   6786
....................       { 
....................          alarma_int=TRUE; 
6784:  BSF    1E.5
....................       } 
....................  
....................       //Activamos el perro guardián 
....................       setup_wdt(WDT_ON); 
6786:  BSF    FD1.0
....................  
....................       //Ponemos a "dormir" al microcontrolador para que el gasto de energía sea menor 
....................       //Esto lo hacemos sólo si no se han levantado los flags de interrupción en estos segundos, 
....................       //ya que esto provocaría que se aplazase la gestión de la interrupción hasta que saltase el 
....................       //perro guardián. 
....................       if(!alarma_int && !lcd_int) 
6788:  BTFSC  1E.5
678A:  BRA    6792
678C:  BTFSC  1E.4
678E:  BRA    6792
....................          sleep(); 
6790:  SLEEP 
....................  
....................    } 
6792:  GOTO   5AB4
....................  
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 
.................... //*************************************************************************** 
.................... //    Descripción de los métodos utilizados ordenados en orden alfabético 
.................... //*************************************************************************** 
.................... //Puede verse una explicación general de la función de cada método al principio del programa 
....................  
.................... void apagar_caldera() 
.................... { 
6796:  SLEEP 
....................    int hora, minutos, segundos; //Variables para el tiempo 
....................  
....................    //Leemos el tiempo 
....................    PCF8583_read_datetime(&tiempo); 
*
56F4:  CLRF   74
56F6:  MOVLW  45
56F8:  MOVWF  73
56FA:  CALL   2746
....................  
....................    //Copiamos en las variables 
....................    hora = tiempo.hours; 
56FE:  MOVFF  47,6B
....................    minutos = tiempo.minutes; 
5702:  MOVFF  46,6C
....................    segundos = tiempo.seconds; 
5706:  MOVFF  45,6D
....................  
....................    //Sumamos al tiempo total de encendido de la caldera el tiempo que ha estado encendida esta vez 
....................    t_total_caldera = t_total_caldera + diferencia_tiempo_sec(hora_caldera, minutos_caldera, segundos_caldera, hora, minutos, segundos); 
570A:  MOVFF  4E,73
570E:  MOVFF  4F,74
5712:  MOVFF  50,75
5716:  MOVFF  6B,76
571A:  MOVFF  6C,77
571E:  MOVFF  6D,78
5722:  CALL   2A64
5726:  MOVF   01,W
5728:  ADDWF  51,F
572A:  MOVF   02,W
572C:  ADDWFC 52,F
....................  
....................    //Apagamos la caldera 
....................    caldera_encendida = FALSE; 
572E:  BCF    F83.0
.................... } 
5730:  GOTO   667C (RETURN)
....................  
.................... //------------------------------------------------------------------------------------------------------------------------------------ 
....................  
.................... void apagar_sistema() 
.................... { 
....................    long minutos_trans;  //Minutos transcurridos desde el encendido del sistema 
....................    int t_entera, t_decimal; //Temperatura del hogar en ese momento (parte entera y decimal) 
....................    float temperatura;  //Temperatura leída 
....................  
....................  
....................    //Si llegamos al límite de la memoria, se resetea el indicador 
....................    //Por utilizar la memoria del PIC sólo contamos con 26 registros de fecha 
....................    if(num_registros > 26) 
*
2BFC:  MOVF   53,W
2BFE:  SUBLW  1A
2C00:  BC    2C04
....................       num_registros = 0; 
2C02:  CLRF   53
....................  
....................    //Leemos el tiempo actual 
....................    PCF8583_read_datetime(&tiempo); 
2C04:  CLRF   74
2C06:  MOVLW  45
2C08:  MOVWF  73
2C0A:  RCALL  2746
....................  
....................    //Calculamos los minutos transcurridos desde el encendido como una diferencia de tiempos 
....................    minutos_trans = diferencia_tiempo(hora_encendido, minutos_encendido, tiempo.hours, tiempo.minutes); 
2C0C:  MOVFF  4C,73
2C10:  MOVFF  4D,74
2C14:  MOVFF  47,75
2C18:  MOVFF  46,76
2C1C:  RCALL  2978
2C1E:  MOVFF  02,6C
2C22:  MOVFF  01,6B
....................  
....................    //Leemos la temperatura en ese momento 
....................    temperatura = ds1820_read(); 
2C26:  CALL   2052
2C2A:  MOVFF  03,72
2C2E:  MOVFF  02,71
2C32:  MOVFF  01,70
2C36:  MOVFF  00,6F
....................  
....................    //Descomponemos la temperatura en su parte entera y parte decimal para almacenarla 
....................    t_entera = (int)temperatura; 
2C3A:  MOVFF  72,86
2C3E:  MOVFF  71,85
2C42:  MOVFF  70,84
2C46:  MOVFF  6F,83
2C4A:  CALL   1620
2C4E:  MOVFF  01,6D
....................    t_decimal = (int)((temperatura-t_entera)*100); 
2C52:  MOVLB  2
2C54:  CLRF   x85
2C56:  MOVFF  6D,284
2C5A:  MOVLB  0
2C5C:  CALL   2426
2C60:  BSF    FD8.1
2C62:  MOVFF  72,281
2C66:  MOVFF  71,280
2C6A:  MOVFF  70,27F
2C6E:  MOVFF  6F,27E
2C72:  MOVFF  03,285
2C76:  MOVFF  02,284
2C7A:  MOVFF  01,283
2C7E:  MOVFF  00,282
2C82:  CALL   21AC
2C86:  MOVFF  00,73
2C8A:  MOVFF  01,74
2C8E:  MOVFF  02,75
2C92:  MOVFF  03,76
2C96:  MOVFF  03,29D
2C9A:  MOVFF  02,29C
2C9E:  MOVFF  01,29B
2CA2:  MOVFF  00,29A
2CA6:  MOVLB  2
2CA8:  CLRF   xA1
2CAA:  CLRF   xA0
2CAC:  MOVLW  48
2CAE:  MOVWF  x9F
2CB0:  MOVLW  85
2CB2:  MOVWF  x9E
2CB4:  MOVLB  0
2CB6:  CALL   16C2
2CBA:  MOVFF  03,86
2CBE:  MOVFF  02,85
2CC2:  MOVFF  01,84
2CC6:  MOVFF  00,83
2CCA:  CALL   1620
2CCE:  MOVFF  01,6E
....................  
....................    //Si la caldera estaba encendida, sumamos el último intervalo de encendido al tiempo total 
....................    if(caldera_encendida) 
2CD2:  BTFSS  F83.0
2CD4:  BRA    2CF8
....................       t_total_caldera = t_total_caldera + diferencia_tiempo_sec(hora_caldera, minutos_caldera, segundos_caldera, tiempo.hours, tiempo.minutes, tiempo.seconds); 
2CD6:  MOVFF  4E,73
2CDA:  MOVFF  4F,74
2CDE:  MOVFF  50,75
2CE2:  MOVFF  47,76
2CE6:  MOVFF  46,77
2CEA:  MOVFF  45,78
2CEE:  RCALL  2A64
2CF0:  MOVF   01,W
2CF2:  ADDWF  51,F
2CF4:  MOVF   02,W
2CF6:  ADDWFC 52,F
....................  
....................    //Calculamos el año en el que nos encontramos 
....................    if(anno_actual_0_to_3 != tiempo.year) 
2CF8:  MOVF   4A,W
2CFA:  SUBWF  55,W
2CFC:  BZ    2D56
....................    { 
....................       //Si el año que teníamos almacenado no es igual que el que marca el reloj, 
....................       //debemos de actualizar las variables correspondientes. 
....................       //Suponemos que al menos se conecta el sistema una vez al año 
....................       anno_actual++; 
2CFE:  INCF   54,F
....................       anno_actual_0_to_3++; 
2D00:  INCF   55,F
....................  
....................       //Guardamos los valores en memoria 
....................       write_eeprom(eeprom_anno_actual, anno_actual); 
2D02:  MOVLW  03
2D04:  MOVWF  FA9
2D06:  MOVFF  54,FA8
2D0A:  BCF    FA6.6
2D0C:  BCF    FA6.7
2D0E:  BSF    FA6.2
2D10:  MOVFF  FF2,00
2D14:  BCF    FF2.7
2D16:  MOVLB  F
2D18:  MOVLW  55
2D1A:  MOVWF  FA7
2D1C:  MOVLW  AA
2D1E:  MOVWF  FA7
2D20:  BSF    FA6.1
2D22:  BTFSC  FA6.1
2D24:  BRA    2D22
2D26:  BCF    FA6.2
2D28:  MOVF   00,W
2D2A:  IORWF  FF2,F
....................       write_eeprom(eeprom_anno_0_to_3, anno_actual_0_to_3); 
2D2C:  MOVLW  04
2D2E:  MOVWF  FA9
2D30:  MOVFF  55,FA8
2D34:  BCF    FA6.6
2D36:  BCF    FA6.7
2D38:  BSF    FA6.2
2D3A:  MOVFF  FF2,00
2D3E:  BCF    FF2.7
2D40:  MOVLW  55
2D42:  MOVWF  FA7
2D44:  MOVLW  AA
2D46:  MOVWF  FA7
2D48:  BSF    FA6.1
2D4A:  BTFSC  FA6.1
2D4C:  BRA    2D4A
2D4E:  BCF    FA6.2
2D50:  MOVF   00,W
2D52:  IORWF  FF2,F
2D54:  MOVLB  0
....................    } 
....................  
....................  
....................    //Almacenamos todos los datos requeridos 
....................    write_eeprom(eeprom_registros + (num_registros)*10    , tiempo.day);                  //Día de desconexión 
2D56:  MOVF   53,W
2D58:  MULLW  0A
2D5A:  MOVF   FF3,W
2D5C:  ADDLW  14
2D5E:  MOVWF  73
2D60:  MOVWF  FA9
2D62:  MOVFF  48,FA8
2D66:  BCF    FA6.6
2D68:  BCF    FA6.7
2D6A:  BSF    FA6.2
2D6C:  MOVFF  FF2,00
2D70:  BCF    FF2.7
2D72:  MOVLB  F
2D74:  MOVLW  55
2D76:  MOVWF  FA7
2D78:  MOVLW  AA
2D7A:  MOVWF  FA7
2D7C:  BSF    FA6.1
2D7E:  BTFSC  FA6.1
2D80:  BRA    2D7E
2D82:  BCF    FA6.2
2D84:  MOVF   00,W
2D86:  IORWF  FF2,F
....................    write_eeprom(eeprom_registros + (num_registros)*10 + 1, tiempo.month);                //Mes de desconexión 
2D88:  MOVF   53,W
2D8A:  MULLW  0A
2D8C:  MOVF   FF3,W
2D8E:  ADDLW  14
2D90:  ADDLW  01
2D92:  MOVWF  74
2D94:  MOVWF  FA9
2D96:  MOVFF  49,FA8
2D9A:  BCF    FA6.6
2D9C:  BCF    FA6.7
2D9E:  BSF    FA6.2
2DA0:  MOVFF  FF2,00
2DA4:  BCF    FF2.7
2DA6:  MOVLW  55
2DA8:  MOVWF  FA7
2DAA:  MOVLW  AA
2DAC:  MOVWF  FA7
2DAE:  BSF    FA6.1
2DB0:  BTFSC  FA6.1
2DB2:  BRA    2DB0
2DB4:  BCF    FA6.2
2DB6:  MOVF   00,W
2DB8:  IORWF  FF2,F
....................    write_eeprom(eeprom_registros + (num_registros)*10 + 2, anno_actual);                 //Año de desconexión 
2DBA:  MOVF   53,W
2DBC:  MULLW  0A
2DBE:  MOVF   FF3,W
2DC0:  ADDLW  14
2DC2:  ADDLW  02
2DC4:  MOVWF  74
2DC6:  MOVWF  FA9
2DC8:  MOVFF  54,FA8
2DCC:  BCF    FA6.6
2DCE:  BCF    FA6.7
2DD0:  BSF    FA6.2
2DD2:  MOVFF  FF2,00
2DD6:  BCF    FF2.7
2DD8:  MOVLW  55
2DDA:  MOVWF  FA7
2DDC:  MOVLW  AA
2DDE:  MOVWF  FA7
2DE0:  BSF    FA6.1
2DE2:  BTFSC  FA6.1
2DE4:  BRA    2DE2
2DE6:  BCF    FA6.2
2DE8:  MOVF   00,W
2DEA:  IORWF  FF2,F
....................    write_eeprom(eeprom_registros + (num_registros)*10 + 3, tiempo.hours);                //Hora de desconexión 
2DEC:  MOVF   53,W
2DEE:  MULLW  0A
2DF0:  MOVF   FF3,W
2DF2:  ADDLW  14
2DF4:  ADDLW  03
2DF6:  MOVWF  74
2DF8:  MOVWF  FA9
2DFA:  MOVFF  47,FA8
2DFE:  BCF    FA6.6
2E00:  BCF    FA6.7
2E02:  BSF    FA6.2
2E04:  MOVFF  FF2,00
2E08:  BCF    FF2.7
2E0A:  MOVLW  55
2E0C:  MOVWF  FA7
2E0E:  MOVLW  AA
2E10:  MOVWF  FA7
2E12:  BSF    FA6.1
2E14:  BTFSC  FA6.1
2E16:  BRA    2E14
2E18:  BCF    FA6.2
2E1A:  MOVF   00,W
2E1C:  IORWF  FF2,F
....................    write_eeprom(eeprom_registros + (num_registros)*10 + 4, tiempo.minutes);              //Minutos de desconexión 
2E1E:  MOVF   53,W
2E20:  MULLW  0A
2E22:  MOVF   FF3,W
2E24:  ADDLW  14
2E26:  ADDLW  04
2E28:  MOVWF  74
2E2A:  MOVWF  FA9
2E2C:  MOVFF  46,FA8
2E30:  BCF    FA6.6
2E32:  BCF    FA6.7
2E34:  BSF    FA6.2
2E36:  MOVFF  FF2,00
2E3A:  BCF    FF2.7
2E3C:  MOVLW  55
2E3E:  MOVWF  FA7
2E40:  MOVLW  AA
2E42:  MOVWF  FA7
2E44:  BSF    FA6.1
2E46:  BTFSC  FA6.1
2E48:  BRA    2E46
2E4A:  BCF    FA6.2
2E4C:  MOVF   00,W
2E4E:  IORWF  FF2,F
....................    write_eeprom(eeprom_registros + (num_registros)*10 + 5, t_entera);                    //Valor entero de última temperatura medida 
2E50:  MOVF   53,W
2E52:  MULLW  0A
2E54:  MOVF   FF3,W
2E56:  ADDLW  14
2E58:  ADDLW  05
2E5A:  MOVWF  74
2E5C:  MOVWF  FA9
2E5E:  MOVFF  6D,FA8
2E62:  BCF    FA6.6
2E64:  BCF    FA6.7
2E66:  BSF    FA6.2
2E68:  MOVFF  FF2,00
2E6C:  BCF    FF2.7
2E6E:  MOVLW  55
2E70:  MOVWF  FA7
2E72:  MOVLW  AA
2E74:  MOVWF  FA7
2E76:  BSF    FA6.1
2E78:  BTFSC  FA6.1
2E7A:  BRA    2E78
2E7C:  BCF    FA6.2
2E7E:  MOVF   00,W
2E80:  IORWF  FF2,F
....................    write_eeprom(eeprom_registros + (num_registros)*10 + 6, t_decimal);                   //Valor decimal de última temperatura medida 
2E82:  MOVF   53,W
2E84:  MULLW  0A
2E86:  MOVF   FF3,W
2E88:  ADDLW  14
2E8A:  ADDLW  06
2E8C:  MOVWF  74
2E8E:  MOVWF  FA9
2E90:  MOVFF  6E,FA8
2E94:  BCF    FA6.6
2E96:  BCF    FA6.7
2E98:  BSF    FA6.2
2E9A:  MOVFF  FF2,00
2E9E:  BCF    FF2.7
2EA0:  MOVLW  55
2EA2:  MOVWF  FA7
2EA4:  MOVLW  AA
2EA6:  MOVWF  FA7
2EA8:  BSF    FA6.1
2EAA:  BTFSC  FA6.1
2EAC:  BRA    2EAA
2EAE:  BCF    FA6.2
2EB0:  MOVF   00,W
2EB2:  IORWF  FF2,F
....................    write_eeprom(eeprom_registros + (num_registros)*10 + 7, (unsigned int)minutos_trans);          //Minutos transcurridos desde el encendido 
2EB4:  MOVF   53,W
2EB6:  MULLW  0A
2EB8:  MOVF   FF3,W
2EBA:  ADDLW  14
2EBC:  ADDLW  07
2EBE:  MOVWF  74
2EC0:  MOVWF  FA9
2EC2:  MOVFF  6B,FA8
2EC6:  BCF    FA6.6
2EC8:  BCF    FA6.7
2ECA:  BSF    FA6.2
2ECC:  MOVFF  FF2,00
2ED0:  BCF    FF2.7
2ED2:  MOVLW  55
2ED4:  MOVWF  FA7
2ED6:  MOVLW  AA
2ED8:  MOVWF  FA7
2EDA:  BSF    FA6.1
2EDC:  BTFSC  FA6.1
2EDE:  BRA    2EDC
2EE0:  BCF    FA6.2
2EE2:  MOVF   00,W
2EE4:  IORWF  FF2,F
....................    write_eeprom(eeprom_registros + (num_registros)*10 + 8, (unsigned int)(t_total_caldera/60));   //Tiempo total que ha estado encendida la caldera 
2EE6:  MOVF   53,W
2EE8:  MULLW  0A
2EEA:  MOVF   FF3,W
2EEC:  ADDLW  14
2EEE:  ADDLW  08
2EF0:  MOVWF  74
2EF2:  MOVFF  52,76
2EF6:  MOVFF  51,75
2EFA:  CLRF   78
2EFC:  MOVLW  3C
2EFE:  MOVWF  77
2F00:  MOVLB  0
2F02:  BRA    2BB6
2F04:  MOVFF  01,75
2F08:  MOVFF  74,FA9
2F0C:  MOVFF  01,FA8
2F10:  BCF    FA6.6
2F12:  BCF    FA6.7
2F14:  BSF    FA6.2
2F16:  MOVFF  FF2,00
2F1A:  BCF    FF2.7
2F1C:  MOVLB  F
2F1E:  MOVLW  55
2F20:  MOVWF  FA7
2F22:  MOVLW  AA
2F24:  MOVWF  FA7
2F26:  BSF    FA6.1
2F28:  BTFSC  FA6.1
2F2A:  BRA    2F28
2F2C:  BCF    FA6.2
2F2E:  MOVF   00,W
2F30:  IORWF  FF2,F
....................                                                                                                  //en este intervalo (en minutos) 
....................  
....................    //Guardamos también el último valor del termostato, teniendo en cuenta la histéresis del sistema 
....................    if(temp_habitacion_superada) 
2F32:  BTFSS  1E.1
2F34:  BRA    2FAE
....................       write_eeprom(eeprom_registros + (num_registros)*10 + 9, (unsigned int)(termostato+histeresis_vivienda)); 
2F36:  MOVF   53,W
2F38:  MULLW  0A
2F3A:  MOVF   FF3,W
2F3C:  ADDLW  14
2F3E:  ADDLW  09
2F40:  MOVWF  74
2F42:  BCF    FD8.1
2F44:  MOVFF  22,281
2F48:  MOVFF  21,280
2F4C:  MOVFF  20,27F
2F50:  MOVFF  1F,27E
2F54:  MOVFF  2E,285
2F58:  MOVFF  2D,284
2F5C:  MOVFF  2C,283
2F60:  MOVFF  2B,282
2F64:  MOVLB  0
2F66:  CALL   21AC
2F6A:  MOVFF  03,86
2F6E:  MOVFF  02,85
2F72:  MOVFF  01,84
2F76:  MOVFF  00,83
2F7A:  CALL   1620
2F7E:  MOVFF  01,75
2F82:  MOVFF  74,FA9
2F86:  MOVFF  01,FA8
2F8A:  BCF    FA6.6
2F8C:  BCF    FA6.7
2F8E:  BSF    FA6.2
2F90:  MOVFF  FF2,00
2F94:  BCF    FF2.7
2F96:  MOVLB  F
2F98:  MOVLW  55
2F9A:  MOVWF  FA7
2F9C:  MOVLW  AA
2F9E:  MOVWF  FA7
2FA0:  BSF    FA6.1
2FA2:  BTFSC  FA6.1
2FA4:  BRA    2FA2
2FA6:  BCF    FA6.2
2FA8:  MOVF   00,W
2FAA:  IORWF  FF2,F
....................    else 
2FAC:  BRA    2FFE
....................       write_eeprom(eeprom_registros + (num_registros)*10 + 9, (unsigned int)termostato); 
2FAE:  MOVF   53,W
2FB0:  MULLW  0A
2FB2:  MOVF   FF3,W
2FB4:  ADDLW  14
2FB6:  ADDLW  09
2FB8:  MOVWF  74
2FBA:  MOVFF  22,86
2FBE:  MOVFF  21,85
2FC2:  MOVFF  20,84
2FC6:  MOVFF  1F,83
2FCA:  MOVLB  0
2FCC:  CALL   1620
2FD0:  MOVFF  01,75
2FD4:  MOVFF  74,FA9
2FD8:  MOVFF  01,FA8
2FDC:  BCF    FA6.6
2FDE:  BCF    FA6.7
2FE0:  BSF    FA6.2
2FE2:  MOVFF  FF2,00
2FE6:  BCF    FF2.7
2FE8:  MOVLB  F
2FEA:  MOVLW  55
2FEC:  MOVWF  FA7
2FEE:  MOVLW  AA
2FF0:  MOVWF  FA7
2FF2:  BSF    FA6.1
2FF4:  BTFSC  FA6.1
2FF6:  BRA    2FF4
2FF8:  BCF    FA6.2
2FFA:  MOVF   00,W
2FFC:  IORWF  FF2,F
....................  
....................    //Aumentamos en uno el número de registros 
....................    num_registros++; 
2FFE:  INCF   53,F
....................  
....................    //Guardamos el número de registros en memoria 
....................    write_eeprom(eeprom_num_registros, num_registros); 
3000:  MOVLW  02
3002:  MOVWF  FA9
3004:  MOVFF  53,FA8
3008:  BCF    FA6.6
300A:  BCF    FA6.7
300C:  BSF    FA6.2
300E:  MOVFF  FF2,00
3012:  BCF    FF2.7
3014:  MOVLW  55
3016:  MOVWF  FA7
3018:  MOVLW  AA
301A:  MOVWF  FA7
301C:  BSF    FA6.1
301E:  BTFSC  FA6.1
3020:  BRA    301E
3022:  BCF    FA6.2
3024:  MOVF   00,W
3026:  IORWF  FF2,F
....................  
....................    //Finalmente, apagamos el sistema 
....................    sistema_encendido = FALSE; 
3028:  BCF    F83.2
.................... } 
302A:  MOVLB  0
302C:  RETLW  00
....................  
.................... //------------------------------------------------------------------------------------------------------------------------------------ 
....................  
.................... int buscar_numero(int led_unidades, int min, int max, int valor_inicial){ 
....................    signed int input; 
....................    unsigned int32 contador; 
....................  
....................    //Iniciamos al valor indicado 
....................    input = valor_inicial; 
*
3386:  MOVFF  70,71
....................  
....................    //Activamos el cursor de la pantalla 
....................    lcd_send_byte(LCD_ORDEN, LCD_CURSOR); 
338A:  CLRF   x82
338C:  MOVLW  0E
338E:  MOVWF  x83
3390:  CALL   1152
....................  
....................    //Se muestra por pantalla 
....................    lcd_gotoxy(led_unidades,2); 
3394:  MOVFF  6D,7E
3398:  MOVLW  02
339A:  MOVWF  7F
339C:  CALL   11DC
....................    //Si el número es menor que 10, le añadimos antes un 0 
....................    if(input<10) 
33A0:  BTFSC  71.7
33A2:  BRA    33AA
33A4:  MOVF   71,W
33A6:  SUBLW  09
33A8:  BNC   33C0
....................       printf(lcd_putc, "0"); 
33AA:  CLRF   76
33AC:  MOVF   76,W
33AE:  CALL   0476
33B2:  IORLW  00
33B4:  BZ    33C0
33B6:  INCF   76,F
33B8:  MOVWF  7D
33BA:  CALL   11FE
33BE:  BRA    33AC
....................    printf(lcd_putc,"%i",input); 
33C0:  MOVFF  71,76
33C4:  MOVLW  1F
33C6:  MOVWF  77
33C8:  RCALL  305A
....................    //Regresamos el cursor a su posición 
....................    lcd_gotoxy(led_unidades,2); 
33CA:  MOVFF  6D,7E
33CE:  MOVLW  02
33D0:  MOVWF  7F
33D2:  CALL   11DC
....................  
....................    while(1) 
....................    { 
....................       if(!mas) 
33D6:  BTFSC  F82.0
33D8:  BRA    34AA
....................       { 
....................          //Si se pulsa el botón de +, se aumenta el valor de input 
....................          input++; 
33DA:  INCF   71,F
....................          //Si llegamos al límite de los valores, reseteamos 
....................          if(input>max) 
33DC:  BTFSC  71.7
33DE:  BRA    33EA
33E0:  MOVF   71,W
33E2:  SUBWF  6F,W
33E4:  BC    33EA
....................             input = min; 
33E6:  MOVFF  6E,71
....................          //Si es un número menor que 10, añadimos un 0 antes 
....................          if(input<10) 
33EA:  BTFSC  71.7
33EC:  BRA    33F4
33EE:  MOVF   71,W
33F0:  SUBLW  09
33F2:  BNC   340A
....................             printf(lcd_putc,"0"); 
33F4:  CLRF   76
33F6:  MOVF   76,W
33F8:  CALL   0476
33FC:  IORLW  00
33FE:  BZ    340A
3400:  INCF   76,F
3402:  MOVWF  7D
3404:  CALL   11FE
3408:  BRA    33F6
....................          //Se muestra por pantalla 
....................          printf(lcd_putc,"%i",input); 
340A:  MOVFF  71,76
340E:  MOVLW  1F
3410:  MOVWF  77
3412:  RCALL  305A
....................          //Regresamos el cursor a su posición 
....................          lcd_gotoxy(led_unidades,2); 
3414:  MOVFF  6D,7E
3418:  MOVLW  02
341A:  MOVWF  7F
341C:  CALL   11DC
....................          //Esperamos a que se levante la tecla 
....................          //Además introducimos un mecanismo de avance rápido que permite pasar de un 
....................          //valor a otro rápidamente sin más que mantener pulsada la tecla 
....................          contador = 1; 
3420:  CLRF   75
3422:  CLRF   74
3424:  CLRF   73
3426:  MOVLW  01
3428:  MOVWF  72
....................          while(!mas) 
....................          { 
342A:  BTFSC  F82.0
342C:  BRA    34A8
....................           if(contador>40000) 
342E:  MOVF   75,F
3430:  BNZ   3446
3432:  MOVF   74,F
3434:  BNZ   3446
3436:  MOVF   73,W
3438:  SUBLW  9B
343A:  BC    3496
343C:  XORLW  FF
343E:  BNZ   3446
3440:  MOVF   72,W
3442:  SUBLW  40
3444:  BC    3496
....................           { 
....................             input++; 
3446:  INCF   71,F
....................             //Si llegamos al límite de los valores, reseteamos 
....................             if(input>max) 
3448:  BTFSC  71.7
344A:  BRA    3456
344C:  MOVF   71,W
344E:  SUBWF  6F,W
3450:  BC    3456
....................                input = min; 
3452:  MOVFF  6E,71
....................             //Si es un número menor que 10, añadimos un 0 antes 
....................             if(input<10) 
3456:  BTFSC  71.7
3458:  BRA    3460
345A:  MOVF   71,W
345C:  SUBLW  09
345E:  BNC   3476
....................                printf(lcd_putc,"0"); 
3460:  CLRF   76
3462:  MOVF   76,W
3464:  CALL   0476
3468:  IORLW  00
346A:  BZ    3476
346C:  INCF   76,F
346E:  MOVWF  7D
3470:  CALL   11FE
3474:  BRA    3462
....................             //Se muestra por pantalla 
....................             printf(lcd_putc,"%i",input); 
3476:  MOVFF  71,76
347A:  MOVLW  1F
347C:  MOVWF  77
347E:  RCALL  305A
....................             //Regresamos el cursor a su posición 
....................             lcd_gotoxy(led_unidades,2); 
3480:  MOVFF  6D,7E
3484:  MOVLW  02
3486:  MOVWF  7F
3488:  CALL   11DC
....................             //Introducimos un poco de retraso 
....................             delay_ms(200); 
348C:  MOVLW  C8
348E:  MOVWF  x84
3490:  CALL   10E6
....................           }else 
3494:  BRA    34A6
....................             contador++; 
3496:  MOVLW  01
3498:  ADDWF  72,F
349A:  BTFSC  FD8.0
349C:  INCF   73,F
349E:  BTFSC  FD8.2
34A0:  INCF   74,F
34A2:  BTFSC  FD8.2
34A4:  INCF   75,F
....................          } 
34A6:  BRA    342A
....................          continue; 
34A8:  BRA    33D6
....................       } 
....................       if(!menos) 
34AA:  BTFSC  F82.1
34AC:  BRA    357E
....................       { 
....................          //Si se pulsa el botón de -, se decrementa el valor de input 
....................          input--; 
34AE:  DECF   71,F
....................          //Si llegamos al límite de las opciones, reseteamos 
....................          if(input<min) 
34B0:  BTFSC  71.7
34B2:  BRA    34BA
34B4:  MOVF   6E,W
34B6:  SUBWF  71,W
34B8:  BC    34BE
....................             input = max; 
34BA:  MOVFF  6F,71
....................          //Si es un número menor que 10, añadimos un 0 antes 
....................          if(input<10) 
34BE:  BTFSC  71.7
34C0:  BRA    34C8
34C2:  MOVF   71,W
34C4:  SUBLW  09
34C6:  BNC   34DE
....................             printf(lcd_putc,"0"); 
34C8:  CLRF   76
34CA:  MOVF   76,W
34CC:  CALL   0476
34D0:  IORLW  00
34D2:  BZ    34DE
34D4:  INCF   76,F
34D6:  MOVWF  7D
34D8:  CALL   11FE
34DC:  BRA    34CA
....................          //Se muestra por pantalla 
....................          printf(lcd_putc,"%i",input); 
34DE:  MOVFF  71,76
34E2:  MOVLW  1F
34E4:  MOVWF  77
34E6:  RCALL  305A
....................          //Regresamos el cursor a su posición 
....................          lcd_gotoxy(led_unidades,2); 
34E8:  MOVFF  6D,7E
34EC:  MOVLW  02
34EE:  MOVWF  7F
34F0:  CALL   11DC
....................          //Esperamos a que se levante la tecla 
....................          //Además introducimos un mecanismo de avance rápido que permite pasar de un 
....................          //valor a otro rápidamente sin más que mantener pulsada la tecla 
....................          contador = 1; 
34F4:  CLRF   75
34F6:  CLRF   74
34F8:  CLRF   73
34FA:  MOVLW  01
34FC:  MOVWF  72
....................          while(!menos){ 
34FE:  BTFSC  F82.1
3500:  BRA    357C
....................           if(contador>40000) 
3502:  MOVF   75,F
3504:  BNZ   351A
3506:  MOVF   74,F
3508:  BNZ   351A
350A:  MOVF   73,W
350C:  SUBLW  9B
350E:  BC    356A
3510:  XORLW  FF
3512:  BNZ   351A
3514:  MOVF   72,W
3516:  SUBLW  40
3518:  BC    356A
....................           { 
....................             input--; 
351A:  DECF   71,F
....................             //Si llegamos al límite de las opciones, reseteamos 
....................             if(input<min) 
351C:  BTFSC  71.7
351E:  BRA    3526
3520:  MOVF   6E,W
3522:  SUBWF  71,W
3524:  BC    352A
....................                input = max; 
3526:  MOVFF  6F,71
....................             //Si es un número menor que 10, añadimos un 0 antes 
....................             if(input<10) 
352A:  BTFSC  71.7
352C:  BRA    3534
352E:  MOVF   71,W
3530:  SUBLW  09
3532:  BNC   354A
....................                printf(lcd_putc,"0"); 
3534:  CLRF   76
3536:  MOVF   76,W
3538:  CALL   0476
353C:  IORLW  00
353E:  BZ    354A
3540:  INCF   76,F
3542:  MOVWF  7D
3544:  CALL   11FE
3548:  BRA    3536
....................             //Se muestra por pantalla 
....................             printf(lcd_putc,"%i",input); 
354A:  MOVFF  71,76
354E:  MOVLW  1F
3550:  MOVWF  77
3552:  RCALL  305A
....................             //Regresamos el cursor a su posición 
....................             lcd_gotoxy(led_unidades,2); 
3554:  MOVFF  6D,7E
3558:  MOVLW  02
355A:  MOVWF  7F
355C:  CALL   11DC
....................             //Introducimos un poco de retraso 
....................             delay_ms(200); 
3560:  MOVLW  C8
3562:  MOVWF  x84
3564:  CALL   10E6
....................           }else 
3568:  BRA    357A
....................             contador++; 
356A:  MOVLW  01
356C:  ADDWF  72,F
356E:  BTFSC  FD8.0
3570:  INCF   73,F
3572:  BTFSC  FD8.2
3574:  INCF   74,F
3576:  BTFSC  FD8.2
3578:  INCF   75,F
....................          } 
357A:  BRA    34FE
....................          continue; 
357C:  BRA    33D6
....................       } 
....................       if(!si) 
357E:  BTFSC  F82.2
3580:  BRA    358A
....................       { 
....................          //Esperamos a que se suelte la tecla 
....................          while(!si){} 
3582:  BTFSC  F82.2
3584:  BRA    3588
3586:  BRA    3582
....................          break; 
3588:  BRA    359C
....................       } 
....................       if(!no) 
358A:  BTFSC  F82.5
358C:  BRA    359A
....................       { 
....................          //Si se pulsa No, devolvemos el valor correspondiente 
....................          input = NOCODE; 
358E:  MOVLW  64
3590:  MOVWF  71
....................          //Esperamos... 
....................          while(!no){} 
3592:  BTFSC  F82.5
3594:  BRA    3598
3596:  BRA    3592
....................          break; 
3598:  BRA    359C
....................       } 
....................  
....................    } 
359A:  BRA    33D6
....................  
....................    //Inhabilitamos el cursor de nuevo 
....................    lcd_send_byte(LCD_ORDEN, LCD_NO_CURSOR); 
359C:  CLRF   x82
359E:  MOVLW  0C
35A0:  MOVWF  x83
35A2:  CALL   1152
....................  
....................    //Devolvemos el valor correspondiente 
....................    return input; 
35A6:  MOVFF  71,01
.................... } 
35AA:  RETLW  00
....................  
.................... //------------------------------------------------------------------------------------------------------------------------------------ 
....................  
.................... int buscar_numero_rs232(){ 
....................    char c[3]; //Cadena que contendrá los números en caracteres 
....................  
....................    //Iniciamos los caracteres a valores nulos que no se correspondan con números 
....................    //Además, esto nos servirá para que c[2] marque el fin de la cadena a la hora de aplicar 
....................    //el método atoi(). 
....................    c[0]=c[1]=c[2]='\0'; 
*
1428:  CLRF   75
142A:  MOVFF  75,74
142E:  MOVFF  74,73
....................  
....................    //Leemos la primera cifra del número 
....................    while(!isdigit(c[0]) && c[0]!='\b') 
....................       c[0]=getch(); 
1432:  MOVF   73,W
1434:  SUBLW  2F
1436:  BC    143E
1438:  MOVF   73,W
143A:  SUBLW  39
143C:  BC    144E
143E:  MOVF   73,W
1440:  SUBLW  08
1442:  BZ    144E
1444:  BTFSS  F9E.5
1446:  BRA    1444
1448:  MOVFF  FAE,73
144C:  BRA    1432
....................    //Si se trata de un "backspace", devolvemos un mensaje de anulación de operación 
....................    if(c[0]=='\b') 
144E:  MOVF   73,W
1450:  SUBLW  08
1452:  BNZ   145A
....................       return NOCODE; 
1454:  MOVLW  64
1456:  MOVWF  01
1458:  BRA    149C
....................    //Imprimimos la primera cifra 
....................    printf("%c", c[0]); 
145A:  MOVF   73,W
145C:  BTFSS  F9E.4
145E:  BRA    145C
1460:  MOVWF  FAD
....................  
....................    //Leemos la segunda cifra del número, procediendo de la misma manera 
....................    while(!isdigit(c[1]) && c[1]!='\b') 
....................       c[1]=getch(); 
1462:  MOVF   74,W
1464:  SUBLW  2F
1466:  BC    146E
1468:  MOVF   74,W
146A:  SUBLW  39
146C:  BC    147E
146E:  MOVF   74,W
1470:  SUBLW  08
1472:  BZ    147E
1474:  BTFSS  F9E.5
1476:  BRA    1474
1478:  MOVFF  FAE,74
147C:  BRA    1462
....................    if(c[1]=='\b') 
147E:  MOVF   74,W
1480:  SUBLW  08
1482:  BNZ   148A
....................       return NOCODE; 
1484:  MOVLW  64
1486:  MOVWF  01
1488:  BRA    149C
....................    printf("%c", c[1]); 
148A:  MOVF   74,W
148C:  BTFSS  F9E.4
148E:  BRA    148C
1490:  MOVWF  FAD
....................  
....................    //Transformamos a entero la cadena y la devolvemos 
....................    return atoi(c); 
1492:  CLRF   77
1494:  MOVLW  73
1496:  MOVWF  76
1498:  RCALL  128E
149A:  MOVF   01,W
....................  
.................... } 
149C:  RETLW  00
....................  
.................... //------------------------------------------------------------------------------------------------------------------------------------ 
....................  
.................... int comp_caldera() 
.................... { 
....................    //Suponemos una variación de la temperatura del agua en la caldera de t_max_calderaºC 
....................    //a t_min_calderaºC, con una precisión que depende del potenciómetro. 
....................  
....................    //Variables para registrar el termostato y la temperatura de la caldera 
....................    float termo, temp; 
....................  
....................    //Establecemos como entrada analógica a analizar la del termostato 
....................    set_adc_channel(termostato_caldera); 
*
24D4:  MOVLW  0C
24D6:  MOVWF  01
24D8:  MOVF   FC2,W
24DA:  ANDLW  C3
24DC:  IORWF  01,W
24DE:  MOVWF  FC2
....................    delay_us(10);  //Retraso para posibilitar la lectura 
24E0:  CLRWDT
24E2:  MOVLW  06
24E4:  MOVWF  00
24E6:  DECFSZ 00,F
24E8:  BRA    24E6
....................    //Transformamos el valor analógico leído en la escala utilizada por el termostato 
....................    termo = t_min_caldera + ((t_max_caldera-t_min_caldera)*(float)read_adc())/AD_num_valores; 
24EA:  BSF    FC2.1
24EC:  BTFSC  FC2.1
24EE:  BRA    24EC
24F0:  MOVF   FC4,W
24F2:  MOVLB  2
24F4:  CLRF   x85
24F6:  MOVWF  x84
24F8:  MOVLB  0
24FA:  RCALL  2426
24FC:  MOVLB  2
24FE:  CLRF   x9D
2500:  CLRF   x9C
2502:  MOVLW  48
2504:  MOVWF  x9B
2506:  MOVLW  85
2508:  MOVWF  x9A
250A:  MOVFF  03,2A1
250E:  MOVFF  02,2A0
2512:  MOVFF  01,29F
2516:  MOVFF  00,29E
251A:  MOVLB  0
251C:  CALL   16C2
2520:  MOVFF  00,73
2524:  MOVFF  01,74
2528:  MOVFF  02,75
252C:  MOVFF  03,76
2530:  MOVFF  03,287
2534:  MOVFF  02,286
2538:  MOVFF  01,285
253C:  MOVFF  00,284
2540:  MOVLB  2
2542:  CLRF   x8B
2544:  CLRF   x8A
2546:  MOVLW  7F
2548:  MOVWF  x89
254A:  MOVLW  86
254C:  MOVWF  x88
254E:  MOVLB  0
2550:  RCALL  1EF2
2552:  BCF    FD8.1
2554:  MOVLB  2
2556:  CLRF   x81
2558:  CLRF   x80
255A:  CLRF   x7F
255C:  CLRF   x7E
255E:  MOVFF  03,285
2562:  MOVFF  02,284
2566:  MOVFF  01,283
256A:  MOVFF  00,282
256E:  MOVLB  0
2570:  RCALL  21AC
2572:  MOVFF  03,6E
2576:  MOVFF  02,6D
257A:  MOVFF  01,6C
257E:  MOVFF  00,6B
....................  
....................    //Establecemos como entrada analógica a analizar la de la temperatura del agua 
....................    set_adc_channel(temperatura_caldera); 
2582:  MOVLW  08
2584:  MOVWF  01
2586:  MOVF   FC2,W
2588:  ANDLW  C3
258A:  IORWF  01,W
258C:  MOVWF  FC2
....................    delay_us(10); //Retraso para posibilitar la lectura 
258E:  CLRWDT
2590:  MOVLW  06
2592:  MOVWF  00
2594:  DECFSZ 00,F
2596:  BRA    2594
....................    //Transformamos el valor analógico leído a la escala utlizada en la temperatura 
....................    temp = t_min_caldera + ((t_max_caldera-t_min_caldera)*(float)read_adc())/AD_num_valores; 
2598:  BSF    FC2.1
259A:  BTFSC  FC2.1
259C:  BRA    259A
259E:  MOVF   FC4,W
25A0:  MOVLB  2
25A2:  CLRF   x85
25A4:  MOVWF  x84
25A6:  MOVLB  0
25A8:  RCALL  2426
25AA:  MOVLB  2
25AC:  CLRF   x9D
25AE:  CLRF   x9C
25B0:  MOVLW  48
25B2:  MOVWF  x9B
25B4:  MOVLW  85
25B6:  MOVWF  x9A
25B8:  MOVFF  03,2A1
25BC:  MOVFF  02,2A0
25C0:  MOVFF  01,29F
25C4:  MOVFF  00,29E
25C8:  MOVLB  0
25CA:  CALL   16C2
25CE:  MOVFF  00,73
25D2:  MOVFF  01,74
25D6:  MOVFF  02,75
25DA:  MOVFF  03,76
25DE:  MOVFF  03,287
25E2:  MOVFF  02,286
25E6:  MOVFF  01,285
25EA:  MOVFF  00,284
25EE:  MOVLB  2
25F0:  CLRF   x8B
25F2:  CLRF   x8A
25F4:  MOVLW  7F
25F6:  MOVWF  x89
25F8:  MOVLW  86
25FA:  MOVWF  x88
25FC:  MOVLB  0
25FE:  RCALL  1EF2
2600:  BCF    FD8.1
2602:  MOVLB  2
2604:  CLRF   x81
2606:  CLRF   x80
2608:  CLRF   x7F
260A:  CLRF   x7E
260C:  MOVFF  03,285
2610:  MOVFF  02,284
2614:  MOVFF  01,283
2618:  MOVFF  00,282
261C:  MOVLB  0
261E:  RCALL  21AC
2620:  MOVFF  03,72
2624:  MOVFF  02,71
2628:  MOVFF  01,70
262C:  MOVFF  00,6F
....................  
....................    //Comparamos ambas temperaturas teniendo en cuenta la histéresis de la caldera 
....................    if(temperatura_caldera_superada) 
2630:  BTFSS  1E.0
2632:  BRA    268E
....................    { 
....................       if(temp >= termo-histeresis_caldera) 
2634:  BSF    FD8.1
2636:  MOVFF  6E,281
263A:  MOVFF  6D,280
263E:  MOVFF  6C,27F
2642:  MOVFF  6B,27E
2646:  MOVLB  2
2648:  CLRF   x85
264A:  CLRF   x84
264C:  MOVLW  20
264E:  MOVWF  x83
2650:  MOVLW  81
2652:  MOVWF  x82
2654:  MOVLB  0
2656:  RCALL  21AC
2658:  MOVFF  03,76
265C:  MOVFF  02,75
2660:  MOVFF  01,74
2664:  MOVFF  00,73
2668:  MOVFF  72,7A
266C:  MOVFF  71,79
2670:  MOVFF  70,78
2674:  MOVFF  6F,77
2678:  RCALL  245E
267A:  BC    267E
267C:  BNZ   2686
....................          return TRUE; 
267E:  MOVLW  01
2680:  MOVWF  01
2682:  BRA    26C2
....................       else 
2684:  BRA    268C
....................          return FALSE; 
2686:  MOVLW  00
2688:  MOVWF  01
268A:  BRA    26C2
....................    }else 
268C:  BRA    26C2
....................    { 
....................       if(temp >= termo) 
268E:  MOVFF  6E,76
2692:  MOVFF  6D,75
2696:  MOVFF  6C,74
269A:  MOVFF  6B,73
269E:  MOVFF  72,7A
26A2:  MOVFF  71,79
26A6:  MOVFF  70,78
26AA:  MOVFF  6F,77
26AE:  RCALL  245E
26B0:  BC    26B4
26B2:  BNZ   26BC
....................          return TRUE; 
26B4:  MOVLW  01
26B6:  MOVWF  01
26B8:  BRA    26C2
....................       else 
26BA:  BRA    26C2
....................          return FALSE; 
26BC:  MOVLW  00
26BE:  MOVWF  01
26C0:  BRA    26C2
....................    } 
.................... } 
26C2:  RETLW  00
....................  
.................... //------------------------------------------------------------------------------------------------------------------------------------ 
....................  
.................... int comprobar_hora(int hora1, int min1, int hora2, int min2) 
.................... { 
....................    //Si hora1 es menor, devolvemos TRUE 
....................    if(hora1 < hora2) 
*
2926:  MOVF   7F,W
2928:  SUBWF  7D,W
292A:  BC    2932
....................       return TRUE; 
292C:  MOVLW  01
292E:  MOVWF  01
2930:  BRA    2958
....................    //Si hora1 es mayor, devolvemos FALSE 
....................    if(hora1 > hora2) 
2932:  MOVF   7D,W
2934:  SUBWF  7F,W
2936:  BC    293E
....................       return FALSE; 
2938:  MOVLW  00
293A:  MOVWF  01
293C:  BRA    2958
....................    //Si las horas coinciden habrá que comparar los minutos 
....................    if(hora1==hora2) 
293E:  MOVF   7F,W
2940:  SUBWF  7D,W
2942:  BNZ   2958
....................    { 
....................       //Se sigue el mismo criterio de antes con la comparación 
....................       //de los minutos. 
....................       if(min1 <= min2) 
2944:  MOVF   7E,W
2946:  SUBWF  x80,W
2948:  BNC   2952
....................          return TRUE; 
294A:  MOVLW  01
294C:  MOVWF  01
294E:  BRA    2958
....................       else 
2950:  BRA    2958
....................          return FALSE; 
2952:  MOVLW  00
2954:  MOVWF  01
2956:  BRA    2958
....................    } 
.................... } 
2958:  RETLW  00
....................  
.................... //------------------------------------------------------------------------------------------------------------------------------------ 
....................  
.................... int1 comprobar_temperatura() 
.................... { 
....................    //Leemos la temperatura 
....................    temperatura = ds1820_read(); 
*
587A:  CALL   2052
587E:  MOVFF  03,2A
5882:  MOVFF  02,29
5886:  MOVFF  01,28
588A:  MOVFF  00,27
....................  
....................    //Mostramos la información en la pantalla lcd 
....................    mostrar_temperatura(); 
588E:  BRA    57AC
....................  
....................    if(ds1820_termostato()) 
5890:  CALL   2100
5894:  MOVF   01,F
5896:  BZ    58FC
....................    { 
....................       //Si la temperatura es menor que la del termostato, devolvemos TRUE 
....................       if(temp_habitacion_superada) 
5898:  BTFSS  1E.1
589A:  BRA    58F4
....................       { 
....................          //Si la temperatura antes era mayor, indicamos el cambio en el flag 
....................          temp_habitacion_superada = FALSE; 
589C:  BCF    1E.1
....................          //Tenemos en cuenta la histéresis para el nuevo valor del termostato 
....................          termostato = termostato + histeresis_vivienda; 
589E:  BCF    FD8.1
58A0:  MOVFF  22,281
58A4:  MOVFF  21,280
58A8:  MOVFF  20,27F
58AC:  MOVFF  1F,27E
58B0:  MOVFF  2E,285
58B4:  MOVFF  2D,284
58B8:  MOVFF  2C,283
58BC:  MOVFF  2B,282
58C0:  CALL   21AC
58C4:  MOVFF  03,22
58C8:  MOVFF  02,21
58CC:  MOVFF  01,20
58D0:  MOVFF  00,1F
....................          //Guardamos la información también en el sensor de temperatura 
....................          //Ponemos como TH una temperatura muy grande (127.5ºC) 
....................          ds1820_establecer_TH_TL(127.5, termostato); 
58D4:  CLRF   76
58D6:  CLRF   75
58D8:  MOVLW  7F
58DA:  MOVWF  74
58DC:  MOVLW  85
58DE:  MOVWF  73
58E0:  MOVFF  22,7A
58E4:  MOVFF  21,79
58E8:  MOVFF  20,78
58EC:  MOVFF  1F,77
58F0:  CALL   17BA
....................       } 
....................       return TRUE; 
58F4:  MOVLW  01
58F6:  MOVWF  01
58F8:  BRA    595E
....................    } 
....................    else 
58FA:  BRA    595E
....................    { 
....................       //Si la temperatura es mayor que la del termostato, devolvemos FALSE 
....................       if(!temp_habitacion_superada) 
58FC:  BTFSC  1E.1
58FE:  BRA    5958
....................       { 
....................          //Si antes era menor, cambiamos el flag 
....................          temp_habitacion_superada = TRUE; 
5900:  BSF    1E.1
....................          //Guardamos el nuevo valor del termostato teniendo en cuenta la histéresis 
....................          termostato = termostato - histeresis_vivienda; 
5902:  BSF    FD8.1
5904:  MOVFF  22,281
5908:  MOVFF  21,280
590C:  MOVFF  20,27F
5910:  MOVFF  1F,27E
5914:  MOVFF  2E,285
5918:  MOVFF  2D,284
591C:  MOVFF  2C,283
5920:  MOVFF  2B,282
5924:  CALL   21AC
5928:  MOVFF  03,22
592C:  MOVFF  02,21
5930:  MOVFF  01,20
5934:  MOVFF  00,1F
....................          //Guardamos la información también en el sensor de temperatura 
....................          //Ponemos como TH una temperatura muy grande (127.5ºC) 
....................          ds1820_establecer_TH_TL(127.5, termostato); 
5938:  CLRF   76
593A:  CLRF   75
593C:  MOVLW  7F
593E:  MOVWF  74
5940:  MOVLW  85
5942:  MOVWF  73
5944:  MOVFF  22,7A
5948:  MOVFF  21,79
594C:  MOVFF  20,78
5950:  MOVFF  1F,77
5954:  CALL   17BA
....................       } 
....................       return FALSE; 
5958:  MOVLW  00
595A:  MOVWF  01
595C:  BRA    595E
....................    } 
.................... } 
595E:  GOTO   6680 (RETURN)
....................  
.................... //------------------------------------------------------------------------------------------------------------------------------------ 
....................  
.................... long diferencia_tiempo(int hora1, int min1, int hora2, int min2) 
.................... { 
....................    long dif; 
....................  
....................    //Si hora1:min1 es menor que hora2:min2, devolvemos simplemente la diferencia en minutos 
....................    if(comprobar_hora(hora1,min1,hora2,min2)) 
*
2978:  MOVFF  73,7D
297C:  MOVFF  74,7E
2980:  MOVFF  75,7F
2984:  MOVFF  76,80
2988:  RCALL  2926
298A:  MOVF   01,F
298C:  BZ    29EE
....................       dif = ((long)hora2*60 + (long)min2) - ((long)hora1*60 + (long)min1); 
298E:  CLRF   7A
2990:  MOVFF  75,79
2994:  MOVFF  7A,85
2998:  MOVFF  75,84
299C:  CLRF   x87
299E:  MOVLW  3C
29A0:  MOVWF  x86
29A2:  RCALL  295A
29A4:  MOVFF  02,7B
29A8:  MOVFF  01,7A
29AC:  CLRF   03
29AE:  MOVF   76,W
29B0:  ADDWF  01,W
29B2:  MOVWF  7C
29B4:  MOVF   03,W
29B6:  ADDWFC 02,W
29B8:  MOVWF  7D
29BA:  CLRF   7F
29BC:  MOVFF  73,7E
29C0:  MOVFF  7F,85
29C4:  MOVFF  73,84
29C8:  CLRF   x87
29CA:  MOVLW  3C
29CC:  MOVWF  x86
29CE:  RCALL  295A
29D0:  MOVFF  01,7F
29D4:  CLRF   03
29D6:  MOVF   74,W
29D8:  ADDWF  01,W
29DA:  MOVWF  01
29DC:  MOVF   02,W
29DE:  ADDWFC 03,F
29E0:  MOVF   01,W
29E2:  SUBWF  7C,W
29E4:  MOVWF  77
29E6:  MOVF   03,W
29E8:  SUBWFB 7D,W
29EA:  MOVWF  78
....................    //Si no es así, habrá que tener en cuenta que hora1:min1 se encuentra en el día anterior 
....................    //al de hora2:min2 
....................    else 
29EC:  BRA    2A5A
....................       dif = (24*60-((long)hora1*60 + (long)min1)) + (long)hora2*60 + (long)min2; 
29EE:  CLRF   7A
29F0:  MOVFF  73,79
29F4:  MOVFF  7A,85
29F8:  MOVFF  73,84
29FC:  CLRF   x87
29FE:  MOVLW  3C
2A00:  MOVWF  x86
2A02:  RCALL  295A
2A04:  MOVFF  02,7B
2A08:  MOVFF  01,7A
2A0C:  CLRF   03
2A0E:  MOVF   74,W
2A10:  ADDWF  01,W
2A12:  MOVWF  01
2A14:  MOVF   02,W
2A16:  ADDWFC 03,F
2A18:  MOVF   01,W
2A1A:  XORLW  FF
2A1C:  ADDLW  A1
2A1E:  MOVWF  7C
2A20:  MOVLW  05
2A22:  SUBFWB 03,W
2A24:  MOVWF  7D
2A26:  CLRF   7F
2A28:  MOVFF  75,7E
2A2C:  MOVFF  7F,85
2A30:  MOVFF  75,84
2A34:  CLRF   x87
2A36:  MOVLW  3C
2A38:  MOVWF  x86
2A3A:  RCALL  295A
2A3C:  MOVFF  02,03
2A40:  MOVF   01,W
2A42:  ADDWF  7C,W
2A44:  MOVWF  7F
2A46:  MOVF   02,W
2A48:  ADDWFC 7D,W
2A4A:  MOVWF  x80
2A4C:  CLRF   03
2A4E:  MOVF   76,W
2A50:  ADDWF  7F,W
2A52:  MOVWF  77
2A54:  MOVF   03,W
2A56:  ADDWFC x80,W
2A58:  MOVWF  78
....................  
....................    //Devolvemos el resultado 
....................    return dif; 
2A5A:  MOVFF  77,01
2A5E:  MOVFF  78,02
.................... } 
2A62:  RETLW  00
....................  
.................... //------------------------------------------------------------------------------------------------------------------------------------ 
....................  
.................... long diferencia_tiempo_sec(int hora1, int min1, int sec1, int hora2, int min2, int sec2) 
.................... { 
....................    unsigned long dif; 
....................    unsigned long dif2; 
....................  
....................    //Si hora1:min1 es menor que hora2:min2, ambas horas están en el mismo día 
....................    if(comprobar_hora(hora1,min1,hora2,min2)) 
2A64:  MOVFF  73,7D
2A68:  MOVFF  74,7E
2A6C:  MOVFF  76,7F
2A70:  MOVFF  77,80
2A74:  RCALL  2926
2A76:  MOVF   01,F
2A78:  BZ    2B18
....................    { 
....................       //Si la hora y los minutos son iguales, devolvemos simplemente la diferencia en segundos 
....................       if(hora1==hora2 && min1==min2) 
2A7A:  MOVF   76,W
2A7C:  SUBWF  73,W
2A7E:  BNZ   2A90
2A80:  MOVF   77,W
2A82:  SUBWF  74,W
2A84:  BNZ   2A90
....................          dif = abs(sec2-sec1); 
2A86:  MOVF   75,W
2A88:  SUBWF  78,W
2A8A:  CLRF   7A
2A8C:  MOVWF  79
....................       else 
2A8E:  BRA    2B16
....................       { 
....................          //Si no habrá que tener en cuenta también la diferencia entre horas y minutos 
....................          dif2 = ((long)hora2*60 + (long)min2) - ((long)hora1*60 + (long)min1); 
2A90:  CLRF   7E
2A92:  MOVFF  76,7D
2A96:  MOVFF  7E,85
2A9A:  MOVFF  76,84
2A9E:  CLRF   x87
2AA0:  MOVLW  3C
2AA2:  MOVWF  x86
2AA4:  RCALL  295A
2AA6:  MOVFF  02,7F
2AAA:  MOVFF  01,7E
2AAE:  CLRF   03
2AB0:  MOVF   77,W
2AB2:  ADDWF  01,W
2AB4:  MOVWF  x80
2AB6:  MOVF   03,W
2AB8:  ADDWFC 02,W
2ABA:  MOVWF  x81
2ABC:  CLRF   x83
2ABE:  MOVFF  73,82
2AC2:  MOVFF  83,85
2AC6:  MOVFF  73,84
2ACA:  CLRF   x87
2ACC:  MOVLW  3C
2ACE:  MOVWF  x86
2AD0:  RCALL  295A
2AD2:  MOVFF  01,83
2AD6:  CLRF   03
2AD8:  MOVF   74,W
2ADA:  ADDWF  01,W
2ADC:  MOVWF  01
2ADE:  MOVF   02,W
2AE0:  ADDWFC 03,F
2AE2:  MOVF   01,W
2AE4:  SUBWF  x80,W
2AE6:  MOVWF  7B
2AE8:  MOVF   03,W
2AEA:  SUBWFB x81,W
2AEC:  MOVWF  7C
....................          //No hacemos la diferencia en segundos directamente porque el long no da de sí 
....................          dif = dif2*60 + sec2 - sec1; 
2AEE:  MOVFF  7C,85
2AF2:  MOVFF  7B,84
2AF6:  CLRF   x87
2AF8:  MOVLW  3C
2AFA:  MOVWF  x86
2AFC:  RCALL  295A
2AFE:  MOVF   78,W
2B00:  ADDWF  01,W
2B02:  MOVWF  7F
2B04:  MOVLW  00
2B06:  ADDWFC 02,W
2B08:  MOVWF  x80
2B0A:  MOVF   75,W
2B0C:  SUBWF  7F,W
2B0E:  MOVWF  79
2B10:  MOVLW  00
2B12:  SUBWFB x80,W
2B14:  MOVWF  7A
....................       } 
....................    } 
....................    else{ 
2B16:  BRA    2BAC
....................       //Si no, simplemente tenemos en cuenta que están en días diferentes y luego le añadimos la 
....................       //diferencia en segundos 
....................       dif2 = (24*60-((long)hora1*60 + (long)min1)) + (long)hora2*60 + (long)min2; 
2B18:  CLRF   7E
2B1A:  MOVFF  73,7D
2B1E:  MOVFF  7E,85
2B22:  MOVFF  73,84
2B26:  CLRF   x87
2B28:  MOVLW  3C
2B2A:  MOVWF  x86
2B2C:  RCALL  295A
2B2E:  MOVFF  02,7F
2B32:  MOVFF  01,7E
2B36:  CLRF   03
2B38:  MOVF   74,W
2B3A:  ADDWF  01,W
2B3C:  MOVWF  01
2B3E:  MOVF   02,W
2B40:  ADDWFC 03,F
2B42:  MOVF   01,W
2B44:  XORLW  FF
2B46:  ADDLW  A1
2B48:  MOVWF  x80
2B4A:  MOVLW  05
2B4C:  SUBFWB 03,W
2B4E:  MOVWF  x81
2B50:  CLRF   x83
2B52:  MOVFF  76,82
2B56:  MOVFF  83,85
2B5A:  MOVFF  76,84
2B5E:  CLRF   x87
2B60:  MOVLW  3C
2B62:  MOVWF  x86
2B64:  RCALL  295A
2B66:  MOVFF  02,03
2B6A:  MOVF   01,W
2B6C:  ADDWF  x80,W
2B6E:  MOVWF  x83
2B70:  MOVF   02,W
2B72:  ADDWFC x81,W
2B74:  MOVWF  x84
2B76:  CLRF   03
2B78:  MOVF   77,W
2B7A:  ADDWF  x83,W
2B7C:  MOVWF  7B
2B7E:  MOVF   03,W
2B80:  ADDWFC x84,W
2B82:  MOVWF  7C
....................       dif = dif2*60 + sec2 - sec1; 
2B84:  MOVFF  7C,85
2B88:  MOVFF  7B,84
2B8C:  CLRF   x87
2B8E:  MOVLW  3C
2B90:  MOVWF  x86
2B92:  RCALL  295A
2B94:  MOVF   78,W
2B96:  ADDWF  01,W
2B98:  MOVWF  7F
2B9A:  MOVLW  00
2B9C:  ADDWFC 02,W
2B9E:  MOVWF  x80
2BA0:  MOVF   75,W
2BA2:  SUBWF  7F,W
2BA4:  MOVWF  79
2BA6:  MOVLW  00
2BA8:  SUBWFB x80,W
2BAA:  MOVWF  7A
....................    } 
....................  
....................    //Devolvemos el resultado 
....................    return dif; 
2BAC:  MOVFF  79,01
2BB0:  MOVFF  7A,02
.................... } 
2BB4:  RETLW  00
....................  
.................... //------------------------------------------------------------------------------------------------------------------------------------ 
....................  
.................... void encender_caldera() 
.................... { 
....................    //Leemos el tiempo actual 
....................    PCF8583_read_datetime(&tiempo); 
*
56D8:  CLRF   74
56DA:  MOVLW  45
56DC:  MOVWF  73
56DE:  CALL   2746
....................  
....................    //Guardamos los datos en las variables correspondientes 
....................    hora_caldera = tiempo.hours; 
56E2:  MOVFF  47,4E
....................    minutos_caldera = tiempo.minutes; 
56E6:  MOVFF  46,4F
....................    segundos_caldera = tiempo.seconds; 
56EA:  MOVFF  45,50
....................  
....................    //Encendemos la caldera 
....................    caldera_encendida = TRUE; 
56EE:  BSF    F83.0
.................... } 
56F0:  GOTO   666C (RETURN)
....................  
.................... //------------------------------------------------------------------------------------------------------------------------------------ 
....................  
.................... void encender_sistema() 
.................... { 
....................    //Leemos el tiempo actual 
....................    PCF8583_read_datetime(&tiempo); 
*
28C0:  CLRF   74
28C2:  MOVLW  45
28C4:  MOVWF  73
28C6:  RCALL  2746
....................  
....................    //Registramos la hora y minutos en los que se enciende el sistema 
....................    hora_encendido    = tiempo.hours; 
28C8:  MOVFF  47,4C
....................    minutos_encendido = tiempo.minutes; 
28CC:  MOVFF  46,4D
....................  
....................    //Inicializamos a 0 el tiempo total que está encendida la caldera 
....................    t_total_caldera = 0; 
28D0:  CLRF   52
28D2:  CLRF   51
....................  
....................    //Si la caldera está encendida, inicializamos el instante de encendido a 
....................    //éste. 
....................    if(caldera_encendida) 
28D4:  BTFSS  F83.0
28D6:  BRA    28E4
....................    { 
....................       hora_caldera = tiempo.hours; 
28D8:  MOVFF  47,4E
....................       minutos_caldera = tiempo.minutes; 
28DC:  MOVFF  46,4F
....................       segundos_caldera = tiempo.seconds; 
28E0:  MOVFF  45,50
....................    } 
....................  
....................    //Encendemos el sistema 
....................    sistema_encendido = TRUE; 
28E4:  BSF    F83.2
.................... } 
28E6:  RETLW  00
....................  
.................... //------------------------------------------------------------------------------------------------------------------------------------ 
....................  
.................... void grabar_programaciones() 
.................... { 
....................    programacion pr; //Variable temporal de programacion 
....................    int contador;   //Contador para el bucle 
....................  
....................    //Recorremos todo el vector de programaciones (hasta el número de programaciones que tengamos) 
....................    for(contador=0; contador<num_intervalos; contador++) 
*
3766:  CLRF   70
3768:  MOVF   43,W
376A:  SUBWF  70,W
376C:  BTFSC  FD8.0
376E:  BRA    38A2
....................    { 
....................       //Seleccionamos la programación 
....................       pr = programaciones[contador]; 
3770:  MOVF   70,W
3772:  MULLW  05
3774:  MOVF   FF3,W
3776:  CLRF   03
3778:  ADDLW  2F
377A:  MOVWF  01
377C:  MOVLW  00
377E:  ADDWFC 03,F
3780:  MOVFF  01,71
3784:  MOVFF  03,72
3788:  CLRF   FEA
378A:  MOVLW  6B
378C:  MOVWF  FE9
378E:  MOVFF  03,FE2
3792:  MOVFF  01,FE1
3796:  MOVLW  05
3798:  MOVWF  01
379A:  MOVFF  FE6,FEE
379E:  DECFSZ 01,F
37A0:  BRA    379A
....................  
....................       //Guardamos en la memoria EEPROM dato a dato 
....................       write_eeprom(eeprom_programaciones + (contador)*5    , pr.horas_inicio); 
37A2:  MOVF   70,W
37A4:  MULLW  05
37A6:  MOVF   FF3,W
37A8:  ADDLW  05
37AA:  MOVWF  71
37AC:  MOVWF  FA9
37AE:  MOVFF  6B,FA8
37B2:  BCF    FA6.6
37B4:  BCF    FA6.7
37B6:  BSF    FA6.2
37B8:  MOVFF  FF2,00
37BC:  BCF    FF2.7
37BE:  MOVLB  F
37C0:  MOVLW  55
37C2:  MOVWF  FA7
37C4:  MOVLW  AA
37C6:  MOVWF  FA7
37C8:  BSF    FA6.1
37CA:  BTFSC  FA6.1
37CC:  BRA    37CA
37CE:  BCF    FA6.2
37D0:  MOVF   00,W
37D2:  IORWF  FF2,F
....................       write_eeprom(eeprom_programaciones + (contador)*5 + 1, pr.minutos_inicio); 
37D4:  MOVF   70,W
37D6:  MULLW  05
37D8:  MOVF   FF3,W
37DA:  ADDLW  05
37DC:  ADDLW  01
37DE:  MOVWF  72
37E0:  MOVWF  FA9
37E2:  MOVFF  6C,FA8
37E6:  BCF    FA6.6
37E8:  BCF    FA6.7
37EA:  BSF    FA6.2
37EC:  MOVFF  FF2,00
37F0:  BCF    FF2.7
37F2:  MOVLW  55
37F4:  MOVWF  FA7
37F6:  MOVLW  AA
37F8:  MOVWF  FA7
37FA:  BSF    FA6.1
37FC:  BTFSC  FA6.1
37FE:  BRA    37FC
3800:  BCF    FA6.2
3802:  MOVF   00,W
3804:  IORWF  FF2,F
....................       write_eeprom(eeprom_programaciones + (contador)*5 + 2, pr.horas_fin); 
3806:  MOVF   70,W
3808:  MULLW  05
380A:  MOVF   FF3,W
380C:  ADDLW  05
380E:  ADDLW  02
3810:  MOVWF  72
3812:  MOVWF  FA9
3814:  MOVFF  6D,FA8
3818:  BCF    FA6.6
381A:  BCF    FA6.7
381C:  BSF    FA6.2
381E:  MOVFF  FF2,00
3822:  BCF    FF2.7
3824:  MOVLW  55
3826:  MOVWF  FA7
3828:  MOVLW  AA
382A:  MOVWF  FA7
382C:  BSF    FA6.1
382E:  BTFSC  FA6.1
3830:  BRA    382E
3832:  BCF    FA6.2
3834:  MOVF   00,W
3836:  IORWF  FF2,F
....................       write_eeprom(eeprom_programaciones + (contador)*5 + 3, pr.minutos_fin); 
3838:  MOVF   70,W
383A:  MULLW  05
383C:  MOVF   FF3,W
383E:  ADDLW  05
3840:  ADDLW  03
3842:  MOVWF  72
3844:  MOVWF  FA9
3846:  MOVFF  6E,FA8
384A:  BCF    FA6.6
384C:  BCF    FA6.7
384E:  BSF    FA6.2
3850:  MOVFF  FF2,00
3854:  BCF    FF2.7
3856:  MOVLW  55
3858:  MOVWF  FA7
385A:  MOVLW  AA
385C:  MOVWF  FA7
385E:  BSF    FA6.1
3860:  BTFSC  FA6.1
3862:  BRA    3860
3864:  BCF    FA6.2
3866:  MOVF   00,W
3868:  IORWF  FF2,F
....................       write_eeprom(eeprom_programaciones + (contador)*5 + 4, pr.termostato); 
386A:  MOVF   70,W
386C:  MULLW  05
386E:  MOVF   FF3,W
3870:  ADDLW  05
3872:  ADDLW  04
3874:  MOVWF  72
3876:  MOVWF  FA9
3878:  MOVFF  6F,FA8
387C:  BCF    FA6.6
387E:  BCF    FA6.7
3880:  BSF    FA6.2
3882:  MOVFF  FF2,00
3886:  BCF    FF2.7
3888:  MOVLW  55
388A:  MOVWF  FA7
388C:  MOVLW  AA
388E:  MOVWF  FA7
3890:  BSF    FA6.1
3892:  BTFSC  FA6.1
3894:  BRA    3892
3896:  BCF    FA6.2
3898:  MOVF   00,W
389A:  IORWF  FF2,F
....................    } 
389C:  INCF   70,F
389E:  MOVLB  0
38A0:  BRA    3768
....................  
....................    //Guardamos en la EEPROM en el número de intervalos 
....................    write_eeprom(eeprom_num_intervalos, num_intervalos); 
38A2:  MOVLW  01
38A4:  MOVWF  FA9
38A6:  MOVFF  43,FA8
38AA:  BCF    FA6.6
38AC:  BCF    FA6.7
38AE:  BSF    FA6.2
38B0:  MOVFF  FF2,00
38B4:  BCF    FF2.7
38B6:  MOVLB  F
38B8:  MOVLW  55
38BA:  MOVWF  FA7
38BC:  MOVLW  AA
38BE:  MOVWF  FA7
38C0:  BSF    FA6.1
38C2:  BTFSC  FA6.1
38C4:  BRA    38C2
38C6:  BCF    FA6.2
38C8:  MOVF   00,W
38CA:  IORWF  FF2,F
.................... } 
38CC:  MOVLB  0
38CE:  GOTO   6650 (RETURN)
....................  
.................... //------------------------------------------------------------------------------------------------------------------------------------ 
....................  
.................... void inicializacion() 
.................... { 
....................    //NOTA: todos los pequeños retardos introducidos en esta rutina sirven para que el técnico 
....................    //no se sienta atosigado por los continuos mensajes que le aparecen solicitándole información. 
....................  
....................  
....................    //Variables para introducir los datos de fecha y hora 
....................    int weekday, dia, mes, anno, horas, minutos; 
....................  
....................    char c[2]; //Cadena para la conversión a int 
....................  
....................    //Comenzamos pidiendo la introducción de la fecha 
....................    //Es una lástima que en RS232 no se vean bien las tildes 
....................    e1: 
....................    printf("\rInicializacion del sistema\r"); 
*
1886:  CLRF   73
1888:  MOVF   73,W
188A:  CALL   0492
188E:  IORLW  00
1890:  BZ    189C
1892:  INCF   73,F
1894:  BTFSS  F9E.4
1896:  BRA    1894
1898:  MOVWF  FAD
189A:  BRA    1888
....................    printf("**************************\r"); 
189C:  CLRF   73
189E:  MOVF   73,W
18A0:  CALL   04CA
18A4:  IORLW  00
18A6:  BZ    18B2
18A8:  INCF   73,F
18AA:  BTFSS  F9E.4
18AC:  BRA    18AA
18AE:  MOVWF  FAD
18B0:  BRA    189E
....................    //Primero solicitamos el día de la semana 
....................    printf("Dia de la semana (1->Lunes, 2->Martes, ...): LUNES    "); 
18B2:  CLRF   73
18B4:  MOVF   73,W
18B6:  CALL   0500
18BA:  IORLW  00
18BC:  BZ    18C8
18BE:  INCF   73,F
18C0:  BTFSS  F9E.4
18C2:  BRA    18C0
18C4:  MOVWF  FAD
18C6:  BRA    18B4
....................  
....................    //En principio se indica que es lunes 
....................    weekday = 0; 
18C8:  CLRF   6B
....................  
....................    //Inicializamos el vector de caracteres a \0 por dos motivos según la posición: 
....................    //c[0] para que no se elija un día indeseado sin intervención del técnico y c[1], 
....................    //para marcar el fin de la cadena. 
....................    c[0]=c[1]='\0'; 
18CA:  CLRF   72
18CC:  MOVFF  72,71
....................  
....................  
....................    //Iteramos en el bucle hasta que no se pulse ENTER 
....................    while(c[0]!=13){ 
18D0:  MOVF   71,W
18D2:  SUBLW  0D
18D4:  BTFSC  FD8.2
18D6:  BRA    19A2
....................       //Guardamos el caracter leído 
....................       c[0]=getch(); 
18D8:  BTFSS  F9E.5
18DA:  BRA    18D8
18DC:  MOVFF  FAE,71
....................  
....................       //Además se asigna un valor numérico a la variable weekday para almacenarla en el reloj. 
....................       weekday=atoi(c)-1; 
18E0:  CLRF   77
18E2:  MOVLW  71
18E4:  MOVWF  76
18E6:  RCALL  128E
18E8:  MOVLW  01
18EA:  SUBWF  01,W
18EC:  MOVWF  6B
....................  
....................       //Según el día introducido, imprimimos un resultado u otro por pantalla, borrando el 
....................       //anterior. Para ello, todos los días ocupan el tamaño del mayor (miércoles) gracias a espacios. 
....................       switch(weekday) 
....................       { 
18EE:  MOVF   6B,W
18F0:  ADDLW  F9
18F2:  BC    19A0
18F4:  ADDLW  07
18F6:  GOTO   1E2C
....................          case 0: printf("\b\b\b\b\b\b\b\b\bLUNES    "); 
18FA:  CLRF   73
18FC:  MOVF   73,W
18FE:  CALL   0552
1902:  IORLW  00
1904:  BZ    1910
1906:  INCF   73,F
1908:  BTFSS  F9E.4
190A:  BRA    1908
190C:  MOVWF  FAD
190E:  BRA    18FC
....................                  break; 
1910:  BRA    19A0
....................          case 1: printf("\b\b\b\b\b\b\b\b\bMARTES   "); 
1912:  CLRF   73
1914:  MOVF   73,W
1916:  CALL   0580
191A:  IORLW  00
191C:  BZ    1928
191E:  INCF   73,F
1920:  BTFSS  F9E.4
1922:  BRA    1920
1924:  MOVWF  FAD
1926:  BRA    1914
....................                  break; 
1928:  BRA    19A0
....................          case 2: printf("\b\b\b\b\b\b\b\b\bMIERCOLES"); 
192A:  CLRF   73
192C:  MOVF   73,W
192E:  CALL   05AE
1932:  IORLW  00
1934:  BZ    1940
1936:  INCF   73,F
1938:  BTFSS  F9E.4
193A:  BRA    1938
193C:  MOVWF  FAD
193E:  BRA    192C
....................                  break; 
1940:  BRA    19A0
....................          case 3: printf("\b\b\b\b\b\b\b\b\bJUEVES   "); 
1942:  CLRF   73
1944:  MOVF   73,W
1946:  CALL   05DC
194A:  IORLW  00
194C:  BZ    1958
194E:  INCF   73,F
1950:  BTFSS  F9E.4
1952:  BRA    1950
1954:  MOVWF  FAD
1956:  BRA    1944
....................                  break; 
1958:  BRA    19A0
....................          case 4: printf("\b\b\b\b\b\b\b\b\bVIERNES  "); 
195A:  CLRF   73
195C:  MOVF   73,W
195E:  CALL   060A
1962:  IORLW  00
1964:  BZ    1970
1966:  INCF   73,F
1968:  BTFSS  F9E.4
196A:  BRA    1968
196C:  MOVWF  FAD
196E:  BRA    195C
....................                  break; 
1970:  BRA    19A0
....................          case 5: printf("\b\b\b\b\b\b\b\b\bSABADO   "); 
1972:  CLRF   73
1974:  MOVF   73,W
1976:  CALL   0638
197A:  IORLW  00
197C:  BZ    1988
197E:  INCF   73,F
1980:  BTFSS  F9E.4
1982:  BRA    1980
1984:  MOVWF  FAD
1986:  BRA    1974
....................                  break; 
1988:  BRA    19A0
....................          case 6: printf("\b\b\b\b\b\b\b\b\bDOMINGO  "); 
198A:  CLRF   73
198C:  MOVF   73,W
198E:  CALL   0666
1992:  IORLW  00
1994:  BZ    19A0
1996:  INCF   73,F
1998:  BTFSS  F9E.4
199A:  BRA    1998
199C:  MOVWF  FAD
199E:  BRA    198C
....................       } 
....................    } 
19A0:  BRA    18D0
....................  
....................    //Pedimos la introducción de la fecha 
....................    printf("\rFECHA: "); 
19A2:  CLRF   73
19A4:  MOVF   73,W
19A6:  CALL   0694
19AA:  IORLW  00
19AC:  BZ    19B8
19AE:  INCF   73,F
19B0:  BTFSS  F9E.4
19B2:  BRA    19B0
19B4:  MOVWF  FAD
19B6:  BRA    19A4
....................  
....................    //Leemos el día del mes 
....................    dia = buscar_numero_rs232(); 
19B8:  RCALL  1428
19BA:  MOVFF  01,6C
....................    //Si pulsamos "backspace", se resetea la inicialización 
....................    if(dia==NOCODE) 
19BE:  MOVF   6C,W
19C0:  SUBLW  64
19C2:  BNZ   19DC
....................    { 
....................       printf("\rReseteando inicializacion...\r"); 
19C4:  CLRF   73
19C6:  MOVF   73,W
19C8:  CALL   06B8
19CC:  IORLW  00
19CE:  BZ    19DA
19D0:  INCF   73,F
19D2:  BTFSS  F9E.4
19D4:  BRA    19D2
19D6:  MOVWF  FAD
19D8:  BRA    19C6
....................       goto e1; 
19DA:  BRA    1886
....................    } 
....................    //Si el día introducido no es válido, también reseteamos la inicialización 
....................    if(dia>31 || dia==0) 
19DC:  MOVF   6C,W
19DE:  SUBLW  1F
19E0:  BNC   19E6
19E2:  MOVF   6C,F
19E4:  BNZ   1A0E
....................    { 
....................       printf("\rDia incorrecto. Reseteando inicializacion...\r"); 
19E6:  CLRF   73
19E8:  MOVF   73,W
19EA:  CALL   06F2
19EE:  IORLW  00
19F0:  BZ    19FC
19F2:  INCF   73,F
19F4:  BTFSS  F9E.4
19F6:  BRA    19F4
19F8:  MOVWF  FAD
19FA:  BRA    19E8
....................       delay_ms(LCD_T_RETARDO); 
19FC:  MOVLW  02
19FE:  MOVWF  73
1A00:  MOVLW  FA
1A02:  MOVWF  x84
1A04:  CALL   10E6
1A08:  DECFSZ 73,F
1A0A:  BRA    1A00
....................       goto e1; 
1A0C:  BRA    1886
....................    } 
....................  
....................    //Leemos el mes 
....................    printf("/"); 
1A0E:  CLRF   73
1A10:  MOVF   73,W
1A12:  CALL   073C
1A16:  IORLW  00
1A18:  BZ    1A24
1A1A:  INCF   73,F
1A1C:  BTFSS  F9E.4
1A1E:  BRA    1A1C
1A20:  MOVWF  FAD
1A22:  BRA    1A10
....................    mes = buscar_numero_rs232(); 
1A24:  RCALL  1428
1A26:  MOVFF  01,6D
....................    //Si pulsamos "backspace", se resetea la inicialización 
....................    if(mes==NOCODE) 
1A2A:  MOVF   6D,W
1A2C:  SUBLW  64
1A2E:  BNZ   1A48
....................    { 
....................       printf("\rReseteando inicializacion...\r"); 
1A30:  CLRF   73
1A32:  MOVF   73,W
1A34:  CALL   06B8
1A38:  IORLW  00
1A3A:  BZ    1A46
1A3C:  INCF   73,F
1A3E:  BTFSS  F9E.4
1A40:  BRA    1A3E
1A42:  MOVWF  FAD
1A44:  BRA    1A32
....................       goto e1; 
1A46:  BRA    1886
....................    } 
....................    //Si el mes introducido no es válido, reseteamos la inicialización de igual modo 
....................    if(mes>12 || mes==0) 
1A48:  MOVF   6D,W
1A4A:  SUBLW  0C
1A4C:  BNC   1A52
1A4E:  MOVF   6D,F
1A50:  BNZ   1A7A
....................    { 
....................       printf("\rMes incorrecto. Reseteando inicializacion...\r"); 
1A52:  CLRF   73
1A54:  MOVF   73,W
1A56:  CALL   0758
1A5A:  IORLW  00
1A5C:  BZ    1A68
1A5E:  INCF   73,F
1A60:  BTFSS  F9E.4
1A62:  BRA    1A60
1A64:  MOVWF  FAD
1A66:  BRA    1A54
....................       delay_ms(LCD_T_RETARDO); 
1A68:  MOVLW  02
1A6A:  MOVWF  73
1A6C:  MOVLW  FA
1A6E:  MOVWF  x84
1A70:  CALL   10E6
1A74:  DECFSZ 73,F
1A76:  BRA    1A6C
....................       goto e1; 
1A78:  BRA    1886
....................    } 
....................  
....................    //Si el día introducido no se encuentra en el mes seleccionado, mostramos un mensaje 
....................    //de error y reseteamos la operación 
....................    if((dia>29 && mes==2)||(dia==31 && (mes==4 || mes==6 || mes==9 || mes==11))) 
1A7A:  MOVF   6C,W
1A7C:  SUBLW  1D
1A7E:  BC    1A86
1A80:  MOVF   6D,W
1A82:  SUBLW  02
1A84:  BZ    1AA4
1A86:  MOVF   6C,W
1A88:  SUBLW  1F
1A8A:  BNZ   1ACC
1A8C:  MOVF   6D,W
1A8E:  SUBLW  04
1A90:  BZ    1AA4
1A92:  MOVF   6D,W
1A94:  SUBLW  06
1A96:  BZ    1AA4
1A98:  MOVF   6D,W
1A9A:  SUBLW  09
1A9C:  BZ    1AA4
1A9E:  MOVF   6D,W
1AA0:  SUBLW  0B
1AA2:  BNZ   1ACC
....................    { 
....................       printf("\rError en la fecha. Reseteando inicializacion...\r"); 
1AA4:  CLRF   73
1AA6:  MOVF   73,W
1AA8:  CALL   07A2
1AAC:  IORLW  00
1AAE:  BZ    1ABA
1AB0:  INCF   73,F
1AB2:  BTFSS  F9E.4
1AB4:  BRA    1AB2
1AB6:  MOVWF  FAD
1AB8:  BRA    1AA6
....................       delay_ms(LCD_T_RETARDO); 
1ABA:  MOVLW  02
1ABC:  MOVWF  73
1ABE:  MOVLW  FA
1AC0:  MOVWF  x84
1AC2:  CALL   10E6
1AC6:  DECFSZ 73,F
1AC8:  BRA    1ABE
....................       goto e1; 
1ACA:  BRA    1886
....................    } 
....................  
....................    //Leemos el año 
....................    printf("/"); 
1ACC:  CLRF   73
1ACE:  MOVF   73,W
1AD0:  CALL   073C
1AD4:  IORLW  00
1AD6:  BZ    1AE2
1AD8:  INCF   73,F
1ADA:  BTFSS  F9E.4
1ADC:  BRA    1ADA
1ADE:  MOVWF  FAD
1AE0:  BRA    1ACE
....................    anno = buscar_numero_rs232(); 
1AE2:  RCALL  1428
1AE4:  MOVFF  01,6E
....................    //Si pulsamos "backspace", se resetea la inicialización 
....................    if(anno==NOCODE) 
1AE8:  MOVF   6E,W
1AEA:  SUBLW  64
1AEC:  BNZ   1B16
....................    { 
....................       printf("\rReseteando inicializacion...\r"); 
1AEE:  CLRF   73
1AF0:  MOVF   73,W
1AF2:  CALL   06B8
1AF6:  IORLW  00
1AF8:  BZ    1B04
1AFA:  INCF   73,F
1AFC:  BTFSS  F9E.4
1AFE:  BRA    1AFC
1B00:  MOVWF  FAD
1B02:  BRA    1AF0
....................       delay_ms(LCD_T_RETARDO); 
1B04:  MOVLW  02
1B06:  MOVWF  73
1B08:  MOVLW  FA
1B0A:  MOVWF  x84
1B0C:  CALL   10E6
1B10:  DECFSZ 73,F
1B12:  BRA    1B08
....................       goto e1; 
1B14:  BRA    1886
....................    } 
....................    //Si el valor del año es incorrecto, reseteamos también la inicialización. 
....................    //Tampoco se permite un año menor que 2009 (año de fabricación del sistema de control) 
....................    if(anno>99 || anno<9) 
1B16:  MOVF   6E,W
1B18:  SUBLW  63
1B1A:  BNC   1B22
1B1C:  MOVF   6E,W
1B1E:  SUBLW  08
1B20:  BNC   1B4A
....................    { 
....................       printf("\rAnno incorrecto. Reseteando inicializacion...\r"); 
1B22:  CLRF   73
1B24:  MOVF   73,W
1B26:  CALL   07EE
1B2A:  IORLW  00
1B2C:  BZ    1B38
1B2E:  INCF   73,F
1B30:  BTFSS  F9E.4
1B32:  BRA    1B30
1B34:  MOVWF  FAD
1B36:  BRA    1B24
....................       delay_ms(LCD_T_RETARDO); 
1B38:  MOVLW  02
1B3A:  MOVWF  73
1B3C:  MOVLW  FA
1B3E:  MOVWF  x84
1B40:  CALL   10E6
1B44:  DECFSZ 73,F
1B46:  BRA    1B3C
....................       goto e1; 
1B48:  BRA    1886
....................    } 
....................  
....................  
....................    //Si el año no es bisiesto y hemos seleccionado el 29 de febrero, 
....................    //mostramos un mensaje y reseteamos la operación. 
....................    if(anno%4!=0 && mes==2 && dia==29) 
1B4A:  MOVF   6E,W
1B4C:  ANDLW  03
1B4E:  BZ    1B84
1B50:  MOVF   6D,W
1B52:  SUBLW  02
1B54:  BNZ   1B84
1B56:  MOVF   6C,W
1B58:  SUBLW  1D
1B5A:  BNZ   1B84
....................    { 
....................       printf("\rEl anno no es bisiesto. Reseteando inicializacion...\r"); 
1B5C:  CLRF   73
1B5E:  MOVF   73,W
1B60:  CALL   0838
1B64:  IORLW  00
1B66:  BZ    1B72
1B68:  INCF   73,F
1B6A:  BTFSS  F9E.4
1B6C:  BRA    1B6A
1B6E:  MOVWF  FAD
1B70:  BRA    1B5E
....................       delay_ms(LCD_T_RETARDO); 
1B72:  MOVLW  02
1B74:  MOVWF  73
1B76:  MOVLW  FA
1B78:  MOVWF  x84
1B7A:  CALL   10E6
1B7E:  DECFSZ 73,F
1B80:  BRA    1B76
....................       goto e1; 
1B82:  BRA    1886
....................    } 
....................  
....................    //Introducimos un pequeño retardo para que el técnico vea los valores introducidos 
....................    delay_ms(LCD_T_RETARDO); 
1B84:  MOVLW  02
1B86:  MOVWF  73
1B88:  MOVLW  FA
1B8A:  MOVWF  x84
1B8C:  CALL   10E6
1B90:  DECFSZ 73,F
1B92:  BRA    1B88
....................  
....................    //Calculamos el año en el intervalo de 0 a 3 según sean bisiesto este año 
....................    //o los anteriores. 
....................    if(anno%4==0) 
1B94:  MOVF   6E,W
1B96:  ANDLW  03
1B98:  BNZ   1B9E
....................       anno_actual_0_to_3 = 0; 
1B9A:  CLRF   55
....................    else if((anno-1)%4==0) 
1B9C:  BRA    1BC6
1B9E:  MOVLW  01
1BA0:  SUBWF  6E,W
1BA2:  ANDLW  03
1BA4:  BNZ   1BAC
....................       anno_actual_0_to_3 = 1; 
1BA6:  MOVLW  01
1BA8:  MOVWF  55
....................    else if((anno-2)%4==0) 
1BAA:  BRA    1BC6
1BAC:  MOVLW  02
1BAE:  SUBWF  6E,W
1BB0:  ANDLW  03
1BB2:  BNZ   1BBA
....................       anno_actual_0_to_3 = 2; 
1BB4:  MOVLW  02
1BB6:  MOVWF  55
....................    else if((anno-3)%4==0) 
1BB8:  BRA    1BC6
1BBA:  MOVLW  03
1BBC:  SUBWF  6E,W
1BBE:  ANDLW  03
1BC0:  BNZ   1BC6
....................       anno_actual_0_to_3 = 3; 
1BC2:  MOVLW  03
1BC4:  MOVWF  55
....................  
....................    e2: 
....................    //Se pide la introducción de la hora 
....................    printf("\rHORA: "); 
1BC6:  CLRF   73
1BC8:  MOVF   73,W
1BCA:  CALL   088A
1BCE:  IORLW  00
1BD0:  BZ    1BDC
1BD2:  INCF   73,F
1BD4:  BTFSS  F9E.4
1BD6:  BRA    1BD4
1BD8:  MOVWF  FAD
1BDA:  BRA    1BC8
....................  
....................    //Leemos la hora 
....................    horas = buscar_numero_rs232(); 
1BDC:  RCALL  1428
1BDE:  MOVFF  01,6F
....................    //Si se pulsa "backspace", se resetea todo el proceso 
....................    if(horas==NOCODE) 
1BE2:  MOVF   6F,W
1BE4:  SUBLW  64
1BE6:  BNZ   1C10
....................    { 
....................       printf("\rReseteando la inicializacion...\r"); 
1BE8:  CLRF   73
1BEA:  MOVF   73,W
1BEC:  CALL   08AC
1BF0:  IORLW  00
1BF2:  BZ    1BFE
1BF4:  INCF   73,F
1BF6:  BTFSS  F9E.4
1BF8:  BRA    1BF6
1BFA:  MOVWF  FAD
1BFC:  BRA    1BEA
....................       delay_ms(LCD_T_RETARDO); 
1BFE:  MOVLW  02
1C00:  MOVWF  73
1C02:  MOVLW  FA
1C04:  MOVWF  x84
1C06:  CALL   10E6
1C0A:  DECFSZ 73,F
1C0C:  BRA    1C02
....................       goto e1; 
1C0E:  BRA    1886
....................    } 
....................    //Si las horas son incorrectas, mostramos un mensaje de error por pantalla y 
....................    //reseteamos la introducción de la misma. 
....................    if(horas>23) 
1C10:  MOVF   6F,W
1C12:  SUBLW  17
1C14:  BC    1C3E
....................    { 
....................       printf("  Hora incorrecta!"); 
1C16:  CLRF   73
1C18:  MOVF   73,W
1C1A:  CALL   08E8
1C1E:  IORLW  00
1C20:  BZ    1C2C
1C22:  INCF   73,F
1C24:  BTFSS  F9E.4
1C26:  BRA    1C24
1C28:  MOVWF  FAD
1C2A:  BRA    1C18
....................       delay_ms(LCD_T_RETARDO); 
1C2C:  MOVLW  02
1C2E:  MOVWF  73
1C30:  MOVLW  FA
1C32:  MOVWF  x84
1C34:  CALL   10E6
1C38:  DECFSZ 73,F
1C3A:  BRA    1C30
....................       goto e2; 
1C3C:  BRA    1BC6
....................    } 
....................  
....................  
....................    //Leemos los minutos 
....................    printf(":"); 
1C3E:  CLRF   73
1C40:  MOVF   73,W
1C42:  CALL   0916
1C46:  IORLW  00
1C48:  BZ    1C54
1C4A:  INCF   73,F
1C4C:  BTFSS  F9E.4
1C4E:  BRA    1C4C
1C50:  MOVWF  FAD
1C52:  BRA    1C40
....................    minutos = buscar_numero_rs232(); 
1C54:  CALL   1428
1C58:  MOVFF  01,70
....................  
....................    //Si se pulsa "backspace", reseteamos la inicialización completa 
....................    if(minutos==NOCODE) 
1C5C:  MOVF   70,W
1C5E:  SUBLW  64
1C60:  BNZ   1C8A
....................    { 
....................       printf("\rReseteando la inicializacion...\r"); 
1C62:  CLRF   73
1C64:  MOVF   73,W
1C66:  CALL   08AC
1C6A:  IORLW  00
1C6C:  BZ    1C78
1C6E:  INCF   73,F
1C70:  BTFSS  F9E.4
1C72:  BRA    1C70
1C74:  MOVWF  FAD
1C76:  BRA    1C64
....................       delay_ms(LCD_T_RETARDO); 
1C78:  MOVLW  02
1C7A:  MOVWF  73
1C7C:  MOVLW  FA
1C7E:  MOVWF  x84
1C80:  CALL   10E6
1C84:  DECFSZ 73,F
1C86:  BRA    1C7C
....................       goto e1; 
1C88:  BRA    1886
....................    } 
....................    //Si los minutos no son correctos, mostramos un mensaje de error por pantalla y 
....................    //reseteamos la introducción de los minutos 
....................    if(minutos>59) 
1C8A:  MOVF   70,W
1C8C:  SUBLW  3B
1C8E:  BC    1CB8
....................    { 
....................       printf("  Minutos incorrectos!"); 
1C90:  CLRF   73
1C92:  MOVF   73,W
1C94:  CALL   0932
1C98:  IORLW  00
1C9A:  BZ    1CA6
1C9C:  INCF   73,F
1C9E:  BTFSS  F9E.4
1CA0:  BRA    1C9E
1CA2:  MOVWF  FAD
1CA4:  BRA    1C92
....................       delay_ms(LCD_T_RETARDO); 
1CA6:  MOVLW  02
1CA8:  MOVWF  73
1CAA:  MOVLW  FA
1CAC:  MOVWF  x84
1CAE:  CALL   10E6
1CB2:  DECFSZ 73,F
1CB4:  BRA    1CAA
....................       goto e2; 
1CB6:  BRA    1BC6
....................    } 
....................  
....................    //Introducimos un pequeño retardo para que el técnico pueda ver la hora introducida 
....................    delay_ms(LCD_T_RETARDO); 
1CB8:  MOVLW  02
1CBA:  MOVWF  73
1CBC:  MOVLW  FA
1CBE:  MOVWF  x84
1CC0:  CALL   10E6
1CC4:  DECFSZ 73,F
1CC6:  BRA    1CBC
....................  
....................    //Mostramos un mensaje de guardado de configuración 
....................    printf("\rGuardando configuracion..."); 
1CC8:  CLRF   73
1CCA:  MOVF   73,W
1CCC:  CALL   0964
1CD0:  IORLW  00
1CD2:  BZ    1CDE
1CD4:  INCF   73,F
1CD6:  BTFSS  F9E.4
1CD8:  BRA    1CD6
1CDA:  MOVWF  FAD
1CDC:  BRA    1CCA
....................  
....................    //Almacenamos todo en la estructura que contiene la información del tiempo 
....................    tiempo.month   = mes; 
1CDE:  MOVFF  6D,49
....................    tiempo.day     = dia; 
1CE2:  MOVFF  6C,48
....................    tiempo.year    = anno_actual_0_to_3; 
1CE6:  MOVFF  55,4A
....................    tiempo.hours   = horas; 
1CEA:  MOVFF  6F,47
....................    tiempo.minutes = minutos; 
1CEE:  MOVFF  70,46
....................    tiempo.seconds = 0x00; 
1CF2:  CLRF   45
....................    tiempo.weekday = weekday; 
1CF4:  MOVFF  6B,4B
....................  
....................    //Fijamos el reloj a esa fecha y hora 
....................    PCF8583_set_datetime(&tiempo); 
1CF8:  CLRF   74
1CFA:  MOVLW  45
1CFC:  MOVWF  73
1CFE:  BRA    1502
....................  
....................    //Establecemos los parámetros iniciales del sistema para resetear la memoria 
....................    termostato = (float)20; 
1D00:  CLRF   22
1D02:  CLRF   21
1D04:  MOVLW  20
1D06:  MOVWF  20
1D08:  MOVLW  83
1D0A:  MOVWF  1F
....................    num_intervalos = 0; 
1D0C:  CLRF   43
....................    num_registros = 0; 
1D0E:  CLRF   53
....................    anno_actual = anno; 
1D10:  MOVFF  6E,54
....................  
....................    //Escribimos los datos en la EEPROM 
....................    write_eeprom(eeprom_termostato, (int)termostato); 
1D14:  MOVFF  22,86
1D18:  MOVFF  21,85
1D1C:  MOVFF  20,84
1D20:  MOVFF  1F,83
1D24:  RCALL  1620
1D26:  MOVFF  01,73
1D2A:  CLRF   FA9
1D2C:  MOVFF  01,FA8
1D30:  BCF    FA6.6
1D32:  BCF    FA6.7
1D34:  BSF    FA6.2
1D36:  MOVFF  FF2,00
1D3A:  BCF    FF2.7
1D3C:  MOVLB  F
1D3E:  MOVLW  55
1D40:  MOVWF  FA7
1D42:  MOVLW  AA
1D44:  MOVWF  FA7
1D46:  BSF    FA6.1
1D48:  BTFSC  FA6.1
1D4A:  BRA    1D48
1D4C:  BCF    FA6.2
1D4E:  MOVF   00,W
1D50:  IORWF  FF2,F
....................    write_eeprom(eeprom_num_intervalos, num_intervalos); 
1D52:  MOVLW  01
1D54:  MOVWF  FA9
1D56:  MOVFF  43,FA8
1D5A:  BCF    FA6.6
1D5C:  BCF    FA6.7
1D5E:  BSF    FA6.2
1D60:  MOVFF  FF2,00
1D64:  BCF    FF2.7
1D66:  MOVLW  55
1D68:  MOVWF  FA7
1D6A:  MOVLW  AA
1D6C:  MOVWF  FA7
1D6E:  BSF    FA6.1
1D70:  BTFSC  FA6.1
1D72:  BRA    1D70
1D74:  BCF    FA6.2
1D76:  MOVF   00,W
1D78:  IORWF  FF2,F
....................    write_eeprom(eeprom_num_registros, num_registros); 
1D7A:  MOVLW  02
1D7C:  MOVWF  FA9
1D7E:  MOVFF  53,FA8
1D82:  BCF    FA6.6
1D84:  BCF    FA6.7
1D86:  BSF    FA6.2
1D88:  MOVFF  FF2,00
1D8C:  BCF    FF2.7
1D8E:  MOVLW  55
1D90:  MOVWF  FA7
1D92:  MOVLW  AA
1D94:  MOVWF  FA7
1D96:  BSF    FA6.1
1D98:  BTFSC  FA6.1
1D9A:  BRA    1D98
1D9C:  BCF    FA6.2
1D9E:  MOVF   00,W
1DA0:  IORWF  FF2,F
....................    write_eeprom(eeprom_anno_actual, anno_actual); 
1DA2:  MOVLW  03
1DA4:  MOVWF  FA9
1DA6:  MOVFF  54,FA8
1DAA:  BCF    FA6.6
1DAC:  BCF    FA6.7
1DAE:  BSF    FA6.2
1DB0:  MOVFF  FF2,00
1DB4:  BCF    FF2.7
1DB6:  MOVLW  55
1DB8:  MOVWF  FA7
1DBA:  MOVLW  AA
1DBC:  MOVWF  FA7
1DBE:  BSF    FA6.1
1DC0:  BTFSC  FA6.1
1DC2:  BRA    1DC0
1DC4:  BCF    FA6.2
1DC6:  MOVF   00,W
1DC8:  IORWF  FF2,F
....................    write_eeprom(eeprom_anno_0_to_3, anno_actual_0_to_3); 
1DCA:  MOVLW  04
1DCC:  MOVWF  FA9
1DCE:  MOVFF  55,FA8
1DD2:  BCF    FA6.6
1DD4:  BCF    FA6.7
1DD6:  BSF    FA6.2
1DD8:  MOVFF  FF2,00
1DDC:  BCF    FF2.7
1DDE:  MOVLW  55
1DE0:  MOVWF  FA7
1DE2:  MOVLW  AA
1DE4:  MOVWF  FA7
1DE6:  BSF    FA6.1
1DE8:  BTFSC  FA6.1
1DEA:  BRA    1DE8
1DEC:  BCF    FA6.2
1DEE:  MOVF   00,W
1DF0:  IORWF  FF2,F
....................  
....................    //Escribimos el valor del termostato en el sensor de temperatura. 
....................    //Ponemos como valor alto 127.5 grados, temperatura que no se va a alcanzar. 
....................    ds1820_establecer_TH_TL(127.5, termostato); 
1DF2:  CLRF   76
1DF4:  CLRF   75
1DF6:  MOVLW  7F
1DF8:  MOVWF  74
1DFA:  MOVLW  85
1DFC:  MOVWF  73
1DFE:  MOVFF  22,7A
1E02:  MOVFF  21,79
1E06:  MOVFF  20,78
1E0A:  MOVFF  1F,77
1E0E:  MOVLB  0
1E10:  RCALL  17BA
....................  
....................    //Mostramos un mensaje de inicio del sistema 
....................    printf("\rIniciando sistema...\r"); 
1E12:  CLRF   73
1E14:  MOVF   73,W
1E16:  CALL   099A
1E1A:  IORLW  00
1E1C:  BZ    1E28
1E1E:  INCF   73,F
1E20:  BTFSS  F9E.4
1E22:  BRA    1E20
1E24:  MOVWF  FAD
1E26:  BRA    1E14
.................... } 
1E28:  GOTO   59FC (RETURN)
....................  
.................... //------------------------------------------------------------------------------------------------------------------------------------ 
....................  
.................... void leer_programaciones(){ 
....................    programacion pr;  //Variable temporal para guardar la programación 
....................    int contador;    //Contador del bucle 
....................  
....................    //Se supone que antes ha sido recuperado el número de intervalos 
....................    //Recorremos todas las programaciones guardadas 
....................    for(contador=0; contador<num_intervalos; contador++) 
....................    { 
....................       //Leemos de memoria y vamos guardando los datos correspondientes 
....................       pr.horas_inicio   = read_eeprom(eeprom_programaciones + (contador)*5); 
....................       pr.minutos_inicio = read_eeprom(eeprom_programaciones + (contador)*5 + 1); 
....................       pr.horas_fin      = read_eeprom(eeprom_programaciones + (contador)*5 + 2); 
....................       pr.minutos_fin    = read_eeprom(eeprom_programaciones + (contador)*5 + 3); 
....................       pr.termostato     = read_eeprom(eeprom_programaciones + (contador)*5 + 4); 
....................  
....................       //Guardamos la programación en el vector correspondiente 
....................       programaciones[contador] = pr; 
....................  
....................    } 
.................... } 
....................  
.................... //------------------------------------------------------------------------------------------------------------------------------------ 
....................  
.................... void mostrar_temperatura() 
.................... { 
....................    //Leemos el tiempo y lo guardamos en la variable tiempo 
....................    PCF8583_read_datetime(&tiempo); 
*
57AC:  CLRF   74
57AE:  MOVLW  45
57B0:  MOVWF  73
57B2:  CALL   2746
....................    //Activamos las interrupciones, que se desactivan dentro del método 
....................    enable_interrupts(GLOBAL); 
57B6:  MOVLW  C0
57B8:  IORWF  FF2,F
....................  
....................    //Mostramos la temperatura registrada 
....................    lcd_send_byte(LCD_ORDEN, LCD_CLEAR); 
57BA:  CLRF   x82
57BC:  MOVLW  01
57BE:  MOVWF  x83
57C0:  CALL   1152
....................    printf(lcd_putc, "TEMP - %3.1f %cC\nHORA - ", temperatura, 223); 
57C4:  CLRF   6B
57C6:  MOVF   6B,W
57C8:  CALL   09CC
57CC:  INCF   6B,F
57CE:  MOVWF  00
57D0:  MOVWF  7D
57D2:  CALL   11FE
57D6:  MOVLW  07
57D8:  SUBWF  6B,W
57DA:  BNZ   57C6
57DC:  MOVLW  02
57DE:  MOVWF  FE9
57E0:  MOVFF  2A,73
57E4:  MOVFF  29,72
57E8:  MOVFF  28,71
57EC:  MOVFF  27,70
57F0:  MOVLW  01
57F2:  MOVWF  74
57F4:  CALL   31F6
57F8:  MOVLW  20
57FA:  MOVWF  7D
57FC:  CALL   11FE
5800:  MOVLW  DF
5802:  MOVWF  7D
5804:  CALL   11FE
5808:  MOVLW  0F
580A:  MOVWF  6C
580C:  MOVF   6C,W
580E:  CALL   09CC
5812:  INCF   6C,F
5814:  MOVWF  00
5816:  MOVWF  7D
5818:  CALL   11FE
581C:  MOVLW  18
581E:  SUBWF  6C,W
5820:  BNZ   580C
....................  
....................    //Mostramos la hora 
....................    //Comprobamos si los valores son menores que 10 para añadir un cero 
....................    //delante y que queden los valores alineados 
....................    if(tiempo.hours < 10) 
5822:  MOVF   47,W
5824:  SUBLW  09
5826:  BNC   583E
....................       printf(lcd_putc, "0"); 
5828:  CLRF   6B
582A:  MOVF   6B,W
582C:  CALL   0476
5830:  IORLW  00
5832:  BZ    583E
5834:  INCF   6B,F
5836:  MOVWF  7D
5838:  CALL   11FE
583C:  BRA    582A
....................    printf(lcd_putc, "%u:", tiempo.hours); 
583E:  MOVFF  47,6B
5842:  MOVLW  1B
5844:  MOVWF  6C
5846:  RCALL  5734
5848:  MOVLW  3A
584A:  MOVWF  7D
584C:  CALL   11FE
....................    if(tiempo.minutes < 10) 
5850:  MOVF   46,W
5852:  SUBLW  09
5854:  BNC   586C
....................       printf(lcd_putc, "0"); 
5856:  CLRF   6B
5858:  MOVF   6B,W
585A:  CALL   0476
585E:  IORLW  00
5860:  BZ    586C
5862:  INCF   6B,F
5864:  MOVWF  7D
5866:  CALL   11FE
586A:  BRA    5858
....................    printf(lcd_putc, "%u", tiempo.minutes); 
586C:  MOVFF  46,6B
5870:  MOVLW  1B
5872:  MOVWF  6C
5874:  RCALL  5734
.................... } 
5876:  GOTO   5890 (RETURN)
....................  
.................... //------------------------------------------------------------------------------------------------------------------------------------ 
....................  
.................... void ordenar_programaciones() 
.................... { 
....................    //Variables temporales y contadores auxiliares 
....................    programacion *pr1; 
....................    programacion *pr2; 
....................    int contador1, contador2; 
....................    int h_inicio_1, min_inicio_1, h_inicio_2, min_inicio_2; 
....................  
....................    //Ambos punteros comienzan apuntando al principio de programaciones 
....................    pr1 = programaciones; 
*
35AC:  CLRF   6C
35AE:  MOVLW  2F
35B0:  MOVWF  6B
....................    pr2 = programaciones; 
35B2:  CLRF   6E
35B4:  MOVWF  6D
....................  
....................  
....................    //Algoritmo de la burbuja 
....................    for(contador1=0; contador1 < num_intervalos; contador1++) 
35B6:  CLRF   6F
35B8:  MOVF   43,W
35BA:  SUBWF  6F,W
35BC:  BTFSC  FD8.0
35BE:  BRA    36E0
....................    { 
....................       //Apuntamos a las dos últimas posiciones del vector 
....................       pr1 = programaciones+num_intervalos-2; 
35C0:  MOVF   43,W
35C2:  MULLW  05
35C4:  MOVF   FF3,W
35C6:  ADDLW  2F
35C8:  MOVWF  7A
35CA:  CLRF   7B
35CC:  BTFSC  FD8.0
35CE:  INCF   7B,F
35D0:  MOVLW  0A
35D2:  SUBWF  7A,W
35D4:  MOVWF  6B
35D6:  MOVLW  00
35D8:  SUBWFB 7B,W
35DA:  MOVWF  6C
....................       pr2 = programaciones+num_intervalos-1; 
35DC:  MOVF   43,W
35DE:  MULLW  05
35E0:  MOVF   FF3,W
35E2:  ADDLW  2F
35E4:  MOVWF  7A
35E6:  CLRF   7B
35E8:  BTFSC  FD8.0
35EA:  INCF   7B,F
35EC:  MOVLW  05
35EE:  SUBWF  7A,W
35F0:  MOVWF  6D
35F2:  MOVLW  00
35F4:  SUBWFB 7B,W
35F6:  MOVWF  6E
....................  
....................       //Iteramos hasta llegar a la zona ordenada del vector 
....................       for(contador2=0; contador2 < num_intervalos-contador1-1; contador2++) 
35F8:  CLRF   70
35FA:  MOVF   6F,W
35FC:  SUBWF  43,W
35FE:  ADDLW  FF
3600:  SUBWF  70,W
3602:  BC    36DC
....................       { 
....................          //Tomamos para la comparación los instantes de inicio 
....................          h_inicio_1   = (*pr1).horas_inicio; 
3604:  MOVFF  6B,FE9
3608:  MOVFF  6C,FEA
360C:  MOVFF  FEF,71
....................          min_inicio_1 = (*pr1).minutos_inicio; 
3610:  MOVLW  01
3612:  ADDWF  6B,W
3614:  MOVWF  FE9
3616:  MOVLW  00
3618:  ADDWFC 6C,W
361A:  MOVWF  FEA
361C:  MOVFF  FEF,72
....................          h_inicio_2   = (*pr2).horas_inicio; 
3620:  MOVFF  6D,FE9
3624:  MOVFF  6E,FEA
3628:  MOVFF  FEF,73
....................          min_inicio_2 = (*pr2).minutos_inicio; 
362C:  MOVLW  01
362E:  ADDWF  6D,W
3630:  MOVWF  FE9
3632:  MOVLW  00
3634:  ADDWFC 6E,W
3636:  MOVWF  FEA
3638:  MOVFF  FEF,74
....................  
....................          //Si la hora de pr2 es menor que la de pr1, habrá que intercambiar los 
....................          //valores para mover la menor a una posición más baja 
....................          if(comprobar_hora(h_inicio_2, min_inicio_2, h_inicio_1, min_inicio_1)) 
363C:  MOVFF  73,7D
3640:  MOVFF  74,7E
3644:  MOVFF  71,7F
3648:  MOVFF  72,80
364C:  CALL   2926
3650:  MOVF   01,F
3652:  BZ    36C8
....................          { 
....................             programacion temporal; 
....................             temporal = *pr1; 
3654:  MOVFF  6C,03
3658:  MOVFF  6B,7A
365C:  MOVFF  6C,7B
3660:  CLRF   FEA
3662:  MOVLW  75
3664:  MOVWF  FE9
3666:  MOVFF  6C,FE2
366A:  MOVFF  6B,FE1
366E:  MOVLW  05
3670:  MOVWF  01
3672:  MOVFF  FE6,FEE
3676:  DECFSZ 01,F
3678:  BRA    3672
....................             *pr1 = *pr2; 
367A:  MOVFF  6B,7C
367E:  MOVFF  6C,7D
3682:  MOVFF  6E,03
3686:  MOVFF  6D,7E
368A:  MOVFF  6E,7F
368E:  MOVFF  6C,FEA
3692:  MOVFF  6B,FE9
3696:  MOVFF  6E,FE2
369A:  MOVFF  6D,FE1
369E:  MOVLW  05
36A0:  MOVWF  01
36A2:  MOVFF  FE6,FEE
36A6:  DECFSZ 01,F
36A8:  BRA    36A2
....................             *pr2 = temporal; 
36AA:  MOVFF  6E,03
36AE:  MOVFF  6D,FE9
36B2:  MOVFF  03,FEA
36B6:  CLRF   FE2
36B8:  MOVLW  75
36BA:  MOVWF  FE1
36BC:  MOVLW  05
36BE:  MOVWF  01
36C0:  MOVFF  FE6,FEE
36C4:  DECFSZ 01,F
36C6:  BRA    36C0
....................          } 
....................  
....................          //Pasamos a la siguiente posición y repetimos el proceso 
....................          pr1--; 
36C8:  MOVLW  FB
36CA:  ADDWF  6B,F
36CC:  BTFSS  FD8.0
36CE:  DECF   6C,F
....................          pr2--; 
36D0:  MOVLW  FB
36D2:  ADDWF  6D,F
36D4:  BTFSS  FD8.0
36D6:  DECF   6E,F
....................       } 
36D8:  INCF   70,F
36DA:  BRA    35FA
....................  
....................    } 
36DC:  INCF   6F,F
36DE:  BRA    35B8
....................  
.................... } 
36E0:  GOTO   64EC (RETURN)
....................  
.................... //------------------------------------------------------------------------------------------------------------------------------------ 
....................  
.................... void programar_proxima_alarma() 
.................... { 
....................    //Recuperamos los datos de inicio de la alarma actual 
....................    prg=programaciones[posicion_alarmas]; 
*
28E8:  MOVF   44,W
28EA:  MULLW  05
28EC:  MOVF   FF3,W
28EE:  CLRF   03
28F0:  ADDLW  2F
28F2:  MOVWF  01
28F4:  MOVLW  00
28F6:  ADDWFC 03,F
28F8:  MOVFF  01,6B
28FC:  MOVFF  03,6C
2900:  CLRF   FEA
2902:  MOVLW  3E
2904:  MOVWF  FE9
2906:  MOVFF  03,FE2
290A:  MOVFF  01,FE1
290E:  MOVLW  05
2910:  MOVWF  01
2912:  MOVFF  FE6,FEE
2916:  DECFSZ 01,F
2918:  BRA    2912
....................  
....................    //Establecemos la alarma a ese tiempo 
....................    hora_alarma = prg.horas_inicio; 
291A:  MOVFF  3E,56
....................    minutos_alarma = prg.minutos_inicio; 
291E:  MOVFF  3F,57
....................    alarma = TRUE; 
2922:  BSF    1E.6
.................... } 
2924:  RETLW  00
....................  
.................... //------------------------------------------------------------------------------------------------------------------------------------ 
....................  
.................... void representar_registros() 
.................... { 
....................    //Contadores para los bucles 
....................    unsigned int contador, contador2; 
....................    //Caracter para la introducción de las opciones 
....................    char caracter; 
....................    //Lista de variables recuperadas 
....................    unsigned int dia, mes, anno, horas, minutos, temp_int, temp_dec, t_sistema, t_caldera, term; 
....................  
....................    float media_dia_mes[12];         //Tiempos medios en minutos que se enciende el sistema en cada mes 
....................    int dias_meses[12];              //Número de dias que tiene cada mes 
....................    float media_dia_caldera;         //Tiempo medio que se enciende la caldera cada día 
....................    float valor;                     //Tiempo medio en minutos que se enciende el sistema por día 
....................    float media_dia_mes_caldera[12]; //Tiempo medio que se enciende la caldera en cada mes 
....................  
....................    unsigned long valor_total;  //Tiempo total de encendido de la caldera 
....................    unsigned long valor_total_caldera; //Tiempo total de encendido del sistema 
....................  
....................    //Capacidad para 4 años de datos 
....................    //Vectores de almacenamiento de los datos anuales 
....................    float media_annos[4][12]; 
....................    float media_annos_caldera[4][12]; 
....................    //Número de años de los que se tienen datos 
....................    int num_annos; 
....................    //Años correspondientes 
....................    int annos[4]; 
....................  
....................    //Variables para almacenar valores provisionales 
....................    long tiempo_x_dia;         //Tiempo que se enciende cada día el sistema (minutos) 
....................    long tiempo_x_dia_caldera; //Tiempo que se enciende cada día la caldera (minutos) 
....................    int fecha[3];             //Día con el que estamos trabajando (día/mes/año) 
....................    long num_dias;             //Número de días que llevamos analizados 
....................  
....................    //dias_meses = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}; 
....................    dias_meses[0] = dias_meses[2] = dias_meses[4] = dias_meses[6] = dias_meses[7] = dias_meses[9] = dias_meses[11] = 31; 
*
3BA8:  MOVLW  1F
3BAA:  MOVWF  xB3
3BAC:  MOVFF  B3,B1
3BB0:  MOVFF  B1,AF
3BB4:  MOVFF  AF,AE
3BB8:  MOVFF  AE,AC
3BBC:  MOVFF  AC,AA
3BC0:  MOVFF  AA,A8
....................    dias_meses[1] = 28; 
3BC4:  MOVLW  1C
3BC6:  MOVWF  xA9
....................    dias_meses[3] = dias_meses[5] = dias_meses[8] = dias_meses[10] = 30; 
3BC8:  MOVLW  1E
3BCA:  MOVWF  xB2
3BCC:  MOVFF  B2,B0
3BD0:  MOVFF  B0,AD
3BD4:  MOVFF  AD,AB
....................  
....................    //Inicializamos los vectores a 0 
....................    for(contador=0; contador<12;contador++) 
3BD8:  CLRF   6B
3BDA:  MOVF   6B,W
3BDC:  SUBLW  0B
3BDE:  BNC   3BFE
....................    { 
....................       media_dia_mes[contador]=0; 
3BE0:  MOVF   6B,W
3BE2:  MULLW  04
3BE4:  MOVF   FF3,W
3BE6:  CLRF   03
3BE8:  ADDLW  78
3BEA:  MOVWF  FE9
3BEC:  MOVLW  00
3BEE:  ADDWFC 03,W
3BF0:  MOVWF  FEA
3BF2:  CLRF   FEF
3BF4:  CLRF   FEC
3BF6:  CLRF   FEC
3BF8:  CLRF   FEC
....................    } 
3BFA:  INCF   6B,F
3BFC:  BRA    3BDA
....................  
....................    for(contador=0; contador<12;contador++) 
3BFE:  CLRF   6B
3C00:  MOVF   6B,W
3C02:  SUBLW  0B
3C04:  BNC   3C24
....................    { 
....................       media_dia_mes_caldera[contador]=0; 
3C06:  MOVF   6B,W
3C08:  MULLW  04
3C0A:  MOVF   FF3,W
3C0C:  CLRF   03
3C0E:  ADDLW  BC
3C10:  MOVWF  FE9
3C12:  MOVLW  00
3C14:  ADDWFC 03,W
3C16:  MOVWF  FEA
3C18:  CLRF   FEF
3C1A:  CLRF   FEC
3C1C:  CLRF   FEC
3C1E:  CLRF   FEC
....................    } 
3C20:  INCF   6B,F
3C22:  BRA    3C00
....................  
....................    for(contador=0; contador<4 ;contador++) 
3C24:  CLRF   6B
3C26:  MOVF   6B,W
3C28:  SUBLW  03
3C2A:  BNC   3C6E
....................    { 
....................       for(contador2=0; contador2<12 ;contador2++) 
3C2C:  CLRF   6C
3C2E:  MOVF   6C,W
3C30:  SUBLW  0B
3C32:  BNC   3C6A
....................       { 
....................          media_annos[contador][contador2]=0; 
3C34:  MOVF   6B,W
3C36:  MULLW  30
3C38:  MOVF   FF3,W
3C3A:  MOVLB  2
3C3C:  CLRF   x7F
3C3E:  MOVWF  x7E
3C40:  MOVF   6C,W
3C42:  MULLW  04
3C44:  MOVF   FF3,W
3C46:  CLRF   03
3C48:  ADDWF  x7E,W
3C4A:  MOVWF  01
3C4C:  MOVF   x7F,W
3C4E:  ADDWFC 03,F
3C50:  MOVF   01,W
3C52:  ADDLW  F0
3C54:  MOVWF  FE9
3C56:  MOVLW  00
3C58:  ADDWFC 03,W
3C5A:  MOVWF  FEA
3C5C:  CLRF   FEF
3C5E:  CLRF   FEC
3C60:  CLRF   FEC
3C62:  CLRF   FEC
....................       } 
3C64:  INCF   6C,F
3C66:  MOVLB  0
3C68:  BRA    3C2E
....................    } 
3C6A:  INCF   6B,F
3C6C:  BRA    3C26
....................  
....................    for(contador=0; contador<4 ;contador++) 
3C6E:  CLRF   6B
3C70:  MOVF   6B,W
3C72:  SUBLW  03
3C74:  BNC   3CB8
....................    { 
....................       for(contador2=0; contador2<12 ;contador2++) 
3C76:  CLRF   6C
3C78:  MOVF   6C,W
3C7A:  SUBLW  0B
3C7C:  BNC   3CB4
....................       { 
....................          media_annos_caldera[contador][contador2]=0; 
3C7E:  MOVF   6B,W
3C80:  MULLW  30
3C82:  MOVF   FF3,W
3C84:  MOVLB  2
3C86:  CLRF   x7F
3C88:  MOVWF  x7E
3C8A:  MOVF   6C,W
3C8C:  MULLW  04
3C8E:  MOVF   FF3,W
3C90:  CLRF   03
3C92:  ADDWF  x7E,W
3C94:  MOVWF  01
3C96:  MOVF   x7F,W
3C98:  ADDWFC 03,F
3C9A:  MOVF   01,W
3C9C:  ADDLW  B0
3C9E:  MOVWF  FE9
3CA0:  MOVLW  01
3CA2:  ADDWFC 03,W
3CA4:  MOVWF  FEA
3CA6:  CLRF   FEF
3CA8:  CLRF   FEC
3CAA:  CLRF   FEC
3CAC:  CLRF   FEC
....................       } 
3CAE:  INCF   6C,F
3CB0:  MOVLB  0
3CB2:  BRA    3C78
....................    } 
3CB4:  INCF   6B,F
3CB6:  BRA    3C70
....................  
....................    //Iniciamos a cero las otras variables 
....................    fecha[0] = fecha[1] = fecha[2] = 0; 
3CB8:  MOVLB  2
3CBA:  CLRF   x7B
3CBC:  MOVFF  27B,27A
3CC0:  MOVFF  27A,279
....................    num_dias = 0; 
3CC4:  CLRF   x7D
3CC6:  CLRF   x7C
....................    num_annos = 0; 
3CC8:  CLRF   x70
....................  
....................    media_dia_caldera = 0; 
3CCA:  MOVLB  0
3CCC:  CLRF   xB7
3CCE:  CLRF   xB6
3CD0:  CLRF   xB5
3CD2:  CLRF   xB4
....................    valor = 0; 
3CD4:  CLRF   xBB
3CD6:  CLRF   xBA
3CD8:  CLRF   xB9
3CDA:  CLRF   xB8
....................    valor_total = 0; 
3CDC:  CLRF   xED
3CDE:  CLRF   xEC
....................    valor_total_caldera = 0; 
3CE0:  CLRF   xEF
3CE2:  CLRF   xEE
....................  
....................    //Imprimimos el encabezamiento 
....................    printf("\rREGISTRO DE EVENTOS\r"); 
3CE4:  MOVLB  2
3CE6:  CLRF   x7E
3CE8:  MOVF   x7E,W
3CEA:  MOVLB  0
3CEC:  CALL   0A00
3CF0:  IORLW  00
3CF2:  BZ    3D02
3CF4:  MOVLB  2
3CF6:  INCF   x7E,F
3CF8:  BTFSS  F9E.4
3CFA:  BRA    3CF8
3CFC:  MOVWF  FAD
3CFE:  BRA    3CE8
3D00:  MOVLB  0
....................    printf("*******************\r"); 
3D02:  MOVLB  2
3D04:  CLRF   x7E
3D06:  MOVF   x7E,W
3D08:  MOVLB  0
3D0A:  CALL   0A30
3D0E:  IORLW  00
3D10:  BZ    3D20
3D12:  MOVLB  2
3D14:  INCF   x7E,F
3D16:  BTFSS  F9E.4
3D18:  BRA    3D16
3D1A:  MOVWF  FAD
3D1C:  BRA    3D06
3D1E:  MOVLB  0
....................    printf("Fecha           Temp.    Term.  Min.S.  Min.C.\r"); 
3D20:  MOVLB  2
3D22:  CLRF   x7E
3D24:  MOVF   x7E,W
3D26:  MOVLB  0
3D28:  CALL   0A60
3D2C:  IORLW  00
3D2E:  BZ    3D3E
3D30:  MOVLB  2
3D32:  INCF   x7E,F
3D34:  BTFSS  F9E.4
3D36:  BRA    3D34
3D38:  MOVWF  FAD
3D3A:  BRA    3D24
3D3C:  MOVLB  0
....................    printf("==============================================\r"); 
3D3E:  MOVLB  2
3D40:  CLRF   x7E
3D42:  MOVF   x7E,W
3D44:  MOVLB  0
3D46:  CALL   0AAA
3D4A:  IORLW  00
3D4C:  BZ    3D5C
3D4E:  MOVLB  2
3D50:  INCF   x7E,F
3D52:  BTFSS  F9E.4
3D54:  BRA    3D52
3D56:  MOVWF  FAD
3D58:  BRA    3D42
3D5A:  MOVLB  0
....................  
....................    //Recorremos todos los registros almacenados 
....................    for(contador=0; contador<num_registros; contador++) 
3D5C:  CLRF   6B
3D5E:  MOVF   53,W
3D60:  SUBWF  6B,W
3D62:  BTFSC  FD8.0
3D64:  GOTO   44FA
....................    { 
....................       //Comenzamos leyendo los datos de memoria 
....................       dia         =  read_eeprom(eeprom_registros + contador*10); 
3D68:  MOVF   6B,W
3D6A:  MULLW  0A
3D6C:  MOVF   FF3,W
3D6E:  ADDLW  14
3D70:  MOVLB  2
3D72:  MOVFF  FF2,27F
3D76:  BCF    FF2.7
3D78:  MOVWF  FA9
3D7A:  BCF    FA6.6
3D7C:  BCF    FA6.7
3D7E:  BSF    FA6.0
3D80:  MOVF   FA8,W
3D82:  BTFSC  x7F.7
3D84:  BSF    FF2.7
3D86:  MOVWF  6E
....................       mes         =  read_eeprom(eeprom_registros + contador*10 + 1); 
3D88:  MOVF   6B,W
3D8A:  MULLW  0A
3D8C:  MOVF   FF3,W
3D8E:  ADDLW  14
3D90:  ADDLW  01
3D92:  MOVFF  FF2,280
3D96:  BCF    FF2.7
3D98:  MOVWF  FA9
3D9A:  BCF    FA6.6
3D9C:  BCF    FA6.7
3D9E:  BSF    FA6.0
3DA0:  MOVF   FA8,W
3DA2:  BTFSC  x80.7
3DA4:  BSF    FF2.7
3DA6:  MOVWF  6F
....................       anno        =  read_eeprom(eeprom_registros + contador*10 + 2); 
3DA8:  MOVF   6B,W
3DAA:  MULLW  0A
3DAC:  MOVF   FF3,W
3DAE:  ADDLW  14
3DB0:  ADDLW  02
3DB2:  MOVFF  FF2,280
3DB6:  BCF    FF2.7
3DB8:  MOVWF  FA9
3DBA:  BCF    FA6.6
3DBC:  BCF    FA6.7
3DBE:  BSF    FA6.0
3DC0:  MOVF   FA8,W
3DC2:  BTFSC  x80.7
3DC4:  BSF    FF2.7
3DC6:  MOVWF  70
....................       horas       =  read_eeprom(eeprom_registros + contador*10 + 3); 
3DC8:  MOVF   6B,W
3DCA:  MULLW  0A
3DCC:  MOVF   FF3,W
3DCE:  ADDLW  14
3DD0:  ADDLW  03
3DD2:  MOVFF  FF2,280
3DD6:  BCF    FF2.7
3DD8:  MOVWF  FA9
3DDA:  BCF    FA6.6
3DDC:  BCF    FA6.7
3DDE:  BSF    FA6.0
3DE0:  MOVF   FA8,W
3DE2:  BTFSC  x80.7
3DE4:  BSF    FF2.7
3DE6:  MOVWF  71
....................       minutos     =  read_eeprom(eeprom_registros + contador*10 + 4); 
3DE8:  MOVF   6B,W
3DEA:  MULLW  0A
3DEC:  MOVF   FF3,W
3DEE:  ADDLW  14
3DF0:  ADDLW  04
3DF2:  MOVFF  FF2,280
3DF6:  BCF    FF2.7
3DF8:  MOVWF  FA9
3DFA:  BCF    FA6.6
3DFC:  BCF    FA6.7
3DFE:  BSF    FA6.0
3E00:  MOVF   FA8,W
3E02:  BTFSC  x80.7
3E04:  BSF    FF2.7
3E06:  MOVWF  72
....................       temp_int    =  read_eeprom(eeprom_registros + contador*10 + 5); 
3E08:  MOVF   6B,W
3E0A:  MULLW  0A
3E0C:  MOVF   FF3,W
3E0E:  ADDLW  14
3E10:  ADDLW  05
3E12:  MOVFF  FF2,280
3E16:  BCF    FF2.7
3E18:  MOVWF  FA9
3E1A:  BCF    FA6.6
3E1C:  BCF    FA6.7
3E1E:  BSF    FA6.0
3E20:  MOVF   FA8,W
3E22:  BTFSC  x80.7
3E24:  BSF    FF2.7
3E26:  MOVWF  73
....................       temp_dec    =  read_eeprom(eeprom_registros + contador*10 + 6); 
3E28:  MOVF   6B,W
3E2A:  MULLW  0A
3E2C:  MOVF   FF3,W
3E2E:  ADDLW  14
3E30:  ADDLW  06
3E32:  MOVFF  FF2,280
3E36:  BCF    FF2.7
3E38:  MOVWF  FA9
3E3A:  BCF    FA6.6
3E3C:  BCF    FA6.7
3E3E:  BSF    FA6.0
3E40:  MOVF   FA8,W
3E42:  BTFSC  x80.7
3E44:  BSF    FF2.7
3E46:  MOVWF  74
....................       t_sistema   =  read_eeprom(eeprom_registros + contador*10 + 7); 
3E48:  MOVF   6B,W
3E4A:  MULLW  0A
3E4C:  MOVF   FF3,W
3E4E:  ADDLW  14
3E50:  ADDLW  07
3E52:  MOVFF  FF2,280
3E56:  BCF    FF2.7
3E58:  MOVWF  FA9
3E5A:  BCF    FA6.6
3E5C:  BCF    FA6.7
3E5E:  BSF    FA6.0
3E60:  MOVF   FA8,W
3E62:  BTFSC  x80.7
3E64:  BSF    FF2.7
3E66:  MOVWF  75
....................       t_caldera   =  read_eeprom(eeprom_registros + contador*10 + 8); 
3E68:  MOVF   6B,W
3E6A:  MULLW  0A
3E6C:  MOVF   FF3,W
3E6E:  ADDLW  14
3E70:  ADDLW  08
3E72:  MOVFF  FF2,280
3E76:  BCF    FF2.7
3E78:  MOVWF  FA9
3E7A:  BCF    FA6.6
3E7C:  BCF    FA6.7
3E7E:  BSF    FA6.0
3E80:  MOVF   FA8,W
3E82:  BTFSC  x80.7
3E84:  BSF    FF2.7
3E86:  MOVWF  76
....................       term        =  read_eeprom(eeprom_registros + contador*10 + 9); 
3E88:  MOVF   6B,W
3E8A:  MULLW  0A
3E8C:  MOVF   FF3,W
3E8E:  ADDLW  14
3E90:  ADDLW  09
3E92:  MOVFF  FF2,280
3E96:  BCF    FF2.7
3E98:  MOVWF  FA9
3E9A:  BCF    FA6.6
3E9C:  BCF    FA6.7
3E9E:  BSF    FA6.0
3EA0:  MOVF   FA8,W
3EA2:  BTFSC  x80.7
3EA4:  BSF    FF2.7
3EA6:  MOVWF  77
....................  
....................       //Si cambiamos de día debemos gestionar los datos del nuevo día y almacenar los del anterior 
....................       if(fecha[0]!=dia || fecha[1]!=mes || fecha[2]!=anno) 
3EA8:  MOVF   6E,W
3EAA:  SUBWF  x79,W
3EAC:  BNZ   3EBC
3EAE:  MOVF   6F,W
3EB0:  SUBWF  x7A,W
3EB2:  BNZ   3EBC
3EB4:  MOVF   70,W
3EB6:  SUBWF  x7B,W
3EB8:  BTFSC  FD8.2
3EBA:  BRA    4218
....................       { 
....................          //Lógicamente, no tenemos en cuenta para la media los días en los que no se enciende: 
....................          //días de verano, calurosos, etc. Esta información puede visualizarse en la media 
....................          //por meses. 
....................          //Guardamos los datos del día anterior si el día no es el primero 
....................          if(fecha[0]!=0) 
3EBC:  MOVF   x79,F
3EBE:  BZ    3F94
....................          { 
....................             //En la media de tiempo por día, acumulamos el tiempo que ha estado encendido el último día 
....................             valor = valor + (float)tiempo_x_dia; 
3EC0:  MOVFF  276,285
3EC4:  MOVFF  275,284
3EC8:  MOVLB  0
3ECA:  CALL   2426
3ECE:  BCF    FD8.1
3ED0:  MOVFF  BB,281
3ED4:  MOVFF  BA,280
3ED8:  MOVFF  B9,27F
3EDC:  MOVFF  B8,27E
3EE0:  MOVFF  03,285
3EE4:  MOVFF  02,284
3EE8:  MOVFF  01,283
3EEC:  MOVFF  00,282
3EF0:  CALL   21AC
3EF4:  MOVFF  03,BB
3EF8:  MOVFF  02,BA
3EFC:  MOVFF  01,B9
3F00:  MOVFF  00,B8
....................             //Guardamos también este valor en el registro del año 
....................             media_dia_mes[fecha[1]-1] = valor; 
3F04:  MOVLW  01
3F06:  MOVLB  2
3F08:  SUBWF  x7A,W
3F0A:  MULLW  04
3F0C:  MOVF   FF3,W
3F0E:  CLRF   03
3F10:  ADDLW  78
3F12:  MOVWF  FE9
3F14:  MOVLW  00
3F16:  ADDWFC 03,W
3F18:  MOVWF  FEA
3F1A:  MOVFF  B8,FEF
3F1E:  MOVFF  B9,FEC
3F22:  MOVFF  BA,FEC
3F26:  MOVFF  BB,FEC
....................             //Realizamos la misma operación con la media de encendido de la caldera 
....................             media_dia_caldera = media_dia_caldera + (float)tiempo_x_dia_caldera; 
3F2A:  MOVFF  278,285
3F2E:  MOVFF  277,284
3F32:  MOVLB  0
3F34:  CALL   2426
3F38:  BCF    FD8.1
3F3A:  MOVFF  B7,281
3F3E:  MOVFF  B6,280
3F42:  MOVFF  B5,27F
3F46:  MOVFF  B4,27E
3F4A:  MOVFF  03,285
3F4E:  MOVFF  02,284
3F52:  MOVFF  01,283
3F56:  MOVFF  00,282
3F5A:  CALL   21AC
3F5E:  MOVFF  03,B7
3F62:  MOVFF  02,B6
3F66:  MOVFF  01,B5
3F6A:  MOVFF  00,B4
....................             media_dia_mes_caldera[fecha[1]-1] = media_dia_caldera; 
3F6E:  MOVLW  01
3F70:  MOVLB  2
3F72:  SUBWF  x7A,W
3F74:  MULLW  04
3F76:  MOVF   FF3,W
3F78:  CLRF   03
3F7A:  ADDLW  BC
3F7C:  MOVWF  FE9
3F7E:  MOVLW  00
3F80:  ADDWFC 03,W
3F82:  MOVWF  FEA
3F84:  MOVFF  B4,FEF
3F88:  MOVFF  B5,FEC
3F8C:  MOVFF  B6,FEC
3F90:  MOVFF  B7,FEC
....................          } 
....................          //La sumatoria podría alcanzar un valor muy alto. El sistema no está preparado para estas eventualidades 
....................          //y debería ser reseteado cada cierto tiempo. Si el sistema va a utilizarse mucho (zonas muy frías o mal 
....................          //aisladas), el usuario debería informar al fabricante para aumentar la memoria de almacenamiento y el 
....................          //tamaño de las variables 
....................  
....................          //Si cambiamos de año, habrá que guardar los datos anuales 
....................          if(fecha[2]!=anno) 
3F94:  MOVF   70,W
3F96:  SUBWF  x7B,W
3F98:  BTFSC  FD8.2
3F9A:  BRA    41FE
....................          { 
....................             //Comprobamos que no nos encontrabamos en el año introducido por defecto 
....................             if(fecha[2]!=0) 
3F9C:  MOVF   x7B,F
3F9E:  BTFSC  FD8.2
3FA0:  BRA    41E8
....................             { 
....................                //En ese caso, guardamos los datos de todo el año 
....................                for(contador2=0; contador2<12; contador2++) 
3FA2:  CLRF   6C
3FA4:  MOVF   6C,W
3FA6:  SUBLW  0B
3FA8:  BTFSS  FD8.0
3FAA:  BRA    41D4
....................                { 
....................                   media_dia_mes[contador2] = media_dia_mes[contador2]/(float)dias_meses[contador2]; 
3FAC:  MOVF   6C,W
3FAE:  MULLW  04
3FB0:  MOVF   FF3,W
3FB2:  CLRF   03
3FB4:  ADDLW  78
3FB6:  MOVWF  01
3FB8:  MOVLW  00
3FBA:  ADDWFC 03,F
3FBC:  MOVFF  01,27E
3FC0:  MOVFF  03,27F
3FC4:  MOVF   6C,W
3FC6:  MULLW  04
3FC8:  MOVF   FF3,W
3FCA:  CLRF   03
3FCC:  ADDLW  78
3FCE:  MOVWF  FE9
3FD0:  MOVLW  00
3FD2:  ADDWFC 03,W
3FD4:  MOVWF  FEA
3FD6:  MOVFF  FEF,280
3FDA:  MOVFF  FEC,281
3FDE:  MOVFF  FEC,282
3FE2:  MOVFF  FEC,283
3FE6:  CLRF   03
3FE8:  MOVF   6C,W
3FEA:  ADDLW  A8
3FEC:  MOVWF  FE9
3FEE:  MOVLW  00
3FF0:  ADDWFC 03,W
3FF2:  MOVWF  FEA
3FF4:  MOVF   FEF,W
3FF6:  CLRF   x85
3FF8:  MOVWF  x84
3FFA:  MOVLB  0
3FFC:  CALL   2426
4000:  MOVFF  283,287
4004:  MOVFF  282,286
4008:  MOVFF  281,285
400C:  MOVFF  280,284
4010:  MOVFF  03,28B
4014:  MOVFF  02,28A
4018:  MOVFF  01,289
401C:  MOVFF  00,288
4020:  CALL   1EF2
4024:  MOVFF  27F,FEA
4028:  MOVFF  27E,FE9
402C:  MOVFF  00,FEF
4030:  MOVFF  01,FEC
4034:  MOVFF  02,FEC
4038:  MOVFF  03,FEC
....................                   media_dia_mes_caldera[contador2] = media_dia_mes_caldera[contador2]/(float)dias_meses[contador2]; 
403C:  MOVF   6C,W
403E:  MULLW  04
4040:  MOVF   FF3,W
4042:  CLRF   03
4044:  ADDLW  BC
4046:  MOVWF  01
4048:  MOVLW  00
404A:  ADDWFC 03,F
404C:  MOVFF  01,27E
4050:  MOVLB  2
4052:  MOVFF  03,27F
4056:  MOVF   6C,W
4058:  MULLW  04
405A:  MOVF   FF3,W
405C:  CLRF   03
405E:  ADDLW  BC
4060:  MOVWF  FE9
4062:  MOVLW  00
4064:  ADDWFC 03,W
4066:  MOVWF  FEA
4068:  MOVFF  FEF,280
406C:  MOVFF  FEC,281
4070:  MOVFF  FEC,282
4074:  MOVFF  FEC,283
4078:  CLRF   03
407A:  MOVF   6C,W
407C:  ADDLW  A8
407E:  MOVWF  FE9
4080:  MOVLW  00
4082:  ADDWFC 03,W
4084:  MOVWF  FEA
4086:  MOVF   FEF,W
4088:  CLRF   x85
408A:  MOVWF  x84
408C:  MOVLB  0
408E:  CALL   2426
4092:  MOVFF  283,287
4096:  MOVFF  282,286
409A:  MOVFF  281,285
409E:  MOVFF  280,284
40A2:  MOVFF  03,28B
40A6:  MOVFF  02,28A
40AA:  MOVFF  01,289
40AE:  MOVFF  00,288
40B2:  CALL   1EF2
40B6:  MOVFF  27F,FEA
40BA:  MOVFF  27E,FE9
40BE:  MOVFF  00,FEF
40C2:  MOVFF  01,FEC
40C6:  MOVFF  02,FEC
40CA:  MOVFF  03,FEC
....................                   media_annos[num_annos][contador2] = media_dia_mes[contador2]; 
40CE:  MOVLB  2
40D0:  MOVF   x70,W
40D2:  MULLW  30
40D4:  MOVF   FF3,W
40D6:  CLRF   x7F
40D8:  MOVWF  x7E
40DA:  MOVF   6C,W
40DC:  MULLW  04
40DE:  MOVF   FF3,W
40E0:  CLRF   03
40E2:  ADDWF  x7E,W
40E4:  MOVWF  01
40E6:  MOVF   x7F,W
40E8:  ADDWFC 03,F
40EA:  MOVF   01,W
40EC:  ADDLW  F0
40EE:  MOVWF  01
40F0:  MOVLW  00
40F2:  ADDWFC 03,F
40F4:  MOVFF  01,280
40F8:  MOVFF  03,281
40FC:  MOVF   6C,W
40FE:  MULLW  04
4100:  MOVF   FF3,W
4102:  CLRF   03
4104:  ADDLW  78
4106:  MOVWF  FE9
4108:  MOVLW  00
410A:  ADDWFC 03,W
410C:  MOVWF  FEA
410E:  MOVFF  FEF,00
4112:  MOVFF  FEC,01
4116:  MOVFF  FEC,02
411A:  MOVFF  FEC,03
411E:  MOVFF  281,FEA
4122:  MOVFF  280,FE9
4126:  MOVFF  00,FEF
412A:  MOVFF  01,FEC
412E:  MOVFF  02,FEC
4132:  MOVFF  03,FEC
....................                   media_annos_caldera[num_annos][contador2] = media_dia_mes_caldera[contador2]; 
4136:  MOVF   x70,W
4138:  MULLW  30
413A:  MOVF   FF3,W
413C:  CLRF   x7F
413E:  MOVWF  x7E
4140:  MOVF   6C,W
4142:  MULLW  04
4144:  MOVF   FF3,W
4146:  CLRF   03
4148:  ADDWF  x7E,W
414A:  MOVWF  01
414C:  MOVF   x7F,W
414E:  ADDWFC 03,F
4150:  MOVF   01,W
4152:  ADDLW  B0
4154:  MOVWF  01
4156:  MOVLW  01
4158:  ADDWFC 03,F
415A:  MOVFF  01,280
415E:  MOVFF  03,281
4162:  MOVF   6C,W
4164:  MULLW  04
4166:  MOVF   FF3,W
4168:  CLRF   03
416A:  ADDLW  BC
416C:  MOVWF  FE9
416E:  MOVLW  00
4170:  ADDWFC 03,W
4172:  MOVWF  FEA
4174:  MOVFF  FEF,00
4178:  MOVFF  FEC,01
417C:  MOVFF  FEC,02
4180:  MOVFF  FEC,03
4184:  MOVFF  281,FEA
4188:  MOVFF  280,FE9
418C:  MOVFF  00,FEF
4190:  MOVFF  01,FEC
4194:  MOVFF  02,FEC
4198:  MOVFF  03,FEC
....................                   //Inicializamos de nuevo los vectores que almacenan los datos del año actual 
....................                   media_dia_mes[contador2]=0; 
419C:  MOVF   6C,W
419E:  MULLW  04
41A0:  MOVF   FF3,W
41A2:  CLRF   03
41A4:  ADDLW  78
41A6:  MOVWF  FE9
41A8:  MOVLW  00
41AA:  ADDWFC 03,W
41AC:  MOVWF  FEA
41AE:  CLRF   FEF
41B0:  CLRF   FEC
41B2:  CLRF   FEC
41B4:  CLRF   FEC
....................                   media_dia_mes_caldera[contador2]=0; 
41B6:  MOVF   6C,W
41B8:  MULLW  04
41BA:  MOVF   FF3,W
41BC:  CLRF   03
41BE:  ADDLW  BC
41C0:  MOVWF  FE9
41C2:  MOVLW  00
41C4:  ADDWFC 03,W
41C6:  MOVWF  FEA
41C8:  CLRF   FEF
41CA:  CLRF   FEC
41CC:  CLRF   FEC
41CE:  CLRF   FEC
....................                } 
41D0:  INCF   6C,F
41D2:  BRA    3FA4
....................  
....................                //Guardamos el año del que se trata 
....................                annos[num_annos]=fecha[2]; 
41D4:  CLRF   03
41D6:  MOVF   x70,W
41D8:  ADDLW  71
41DA:  MOVWF  FE9
41DC:  MOVLW  02
41DE:  ADDWFC 03,W
41E0:  MOVWF  FEA
41E2:  MOVFF  27B,FEF
....................  
....................                //Aumentamos en 1 el número de años 
....................                num_annos++; 
41E6:  INCF   x70,F
....................             } 
....................  
....................             //COMPROBAR BISIESTO 
....................             //En realidad, un año será bisiesto si es divisible por 4 y no lo es por 100, 
....................             //excepto si este último lo es por 400. Sin embargo, dado que trabajamos con las 
....................             //dos últimas cifras y que el próximo año divisible por 4 que no lo es por 100 
....................             //es el 2100, mejor nos limitaremos a la divisibilidad por 4. 
....................             //Dependiendo si el año es bisiesto o no, le damos a febrero 29 o 28 días. 
....................             if(anno%4 == 0) 
41E8:  MOVF   70,W
41EA:  ANDLW  03
41EC:  BNZ   41F6
....................                dias_meses[1] = 29; 
41EE:  MOVLW  1D
41F0:  MOVLB  0
41F2:  MOVWF  xA9
....................             else 
41F4:  BRA    41FC
....................                dias_meses[1] = 28; 
41F6:  MOVLW  1C
41F8:  MOVLB  0
41FA:  MOVWF  xA9
41FC:  MOVLB  2
....................          } 
....................  
....................          //Modificamos la información del día 
....................          fecha[0] = dia; 
41FE:  MOVFF  6E,279
....................          fecha[1] = mes; 
4202:  MOVFF  6F,27A
....................          fecha[2] = anno; 
4206:  MOVFF  70,27B
....................  
....................          //Aumentamos en 1 el número de días 
....................          num_dias++; 
420A:  INCF   x7C,F
420C:  BTFSC  FD8.2
420E:  INCF   x7D,F
....................  
....................          //Reseteamos las variables acumulativas de tiempo por día 
....................          tiempo_x_dia = 0; 
4210:  CLRF   x76
4212:  CLRF   x75
....................          tiempo_x_dia_caldera = 0; 
4214:  CLRF   x78
4216:  CLRF   x77
....................       } 
....................  
....................       //Le sumamos al tiempo de encendido de sistema y caldera el correspondiente de este registro 
....................       tiempo_x_dia = tiempo_x_dia + t_sistema; 
4218:  MOVF   75,W
421A:  ADDWF  x75,F
421C:  MOVLW  00
421E:  ADDWFC x76,F
....................       tiempo_x_dia_caldera = tiempo_x_dia_caldera + t_caldera; 
4220:  MOVF   76,W
4222:  ADDWF  x77,F
4224:  MOVLW  00
4226:  ADDWFC x78,F
....................       //También incrementamos los tiempos totales 
....................       valor_total = valor_total + t_sistema; 
4228:  MOVF   75,W
422A:  MOVLB  0
422C:  ADDWF  xEC,F
422E:  MOVLW  00
4230:  ADDWFC xED,F
....................       valor_total_caldera = valor_total_caldera + t_caldera; 
4232:  MOVF   76,W
4234:  ADDWF  xEE,F
4236:  MOVLW  00
4238:  ADDWFC xEF,F
....................  
....................       //Representamos todos los datos, teniendo en cuenta algunos requisitos representativos 
....................       //para que los datos queden alineados (número menores que 10, que 100, etc). 
....................       if(dia<10) 
423A:  MOVF   6E,W
423C:  SUBLW  09
423E:  BNC   425E
....................          printf(" "); 
4240:  MOVLB  2
4242:  CLRF   x7E
4244:  MOVF   x7E,W
4246:  MOVLB  0
4248:  CALL   0AF4
424C:  IORLW  00
424E:  BZ    425E
4250:  MOVLB  2
4252:  INCF   x7E,F
4254:  BTFSS  F9E.4
4256:  BRA    4254
4258:  MOVWF  FAD
425A:  BRA    4244
425C:  MOVLB  0
....................  
....................       printf("%u/", dia); 
425E:  MOVFF  6E,27F
4262:  MOVLW  1B
4264:  MOVLB  2
4266:  MOVWF  x80
4268:  MOVLB  0
426A:  CALL   38D2
426E:  MOVLW  2F
4270:  BTFSS  F9E.4
4272:  BRA    4270
4274:  MOVWF  FAD
....................  
....................       if(mes<10) 
4276:  MOVF   6F,W
4278:  SUBLW  09
427A:  BNC   429A
....................          printf("0"); 
427C:  MOVLB  2
427E:  CLRF   x7E
4280:  MOVF   x7E,W
4282:  MOVLB  0
4284:  CALL   0476
4288:  IORLW  00
428A:  BZ    429A
428C:  MOVLB  2
428E:  INCF   x7E,F
4290:  BTFSS  F9E.4
4292:  BRA    4290
4294:  MOVWF  FAD
4296:  BRA    4280
4298:  MOVLB  0
....................  
....................       printf("%u/", mes); 
429A:  MOVFF  6F,27F
429E:  MOVLW  1B
42A0:  MOVLB  2
42A2:  MOVWF  x80
42A4:  MOVLB  0
42A6:  CALL   38D2
42AA:  MOVLW  2F
42AC:  BTFSS  F9E.4
42AE:  BRA    42AC
42B0:  MOVWF  FAD
....................  
....................       if(anno<10) 
42B2:  MOVF   70,W
42B4:  SUBLW  09
42B6:  BNC   42D6
....................          printf("0"); 
42B8:  MOVLB  2
42BA:  CLRF   x7E
42BC:  MOVF   x7E,W
42BE:  MOVLB  0
42C0:  CALL   0476
42C4:  IORLW  00
42C6:  BZ    42D6
42C8:  MOVLB  2
42CA:  INCF   x7E,F
42CC:  BTFSS  F9E.4
42CE:  BRA    42CC
42D0:  MOVWF  FAD
42D2:  BRA    42BC
42D4:  MOVLB  0
....................  
....................       printf("%u  ", anno); 
42D6:  MOVFF  70,27F
42DA:  MOVLW  1B
42DC:  MOVLB  2
42DE:  MOVWF  x80
42E0:  MOVLB  0
42E2:  CALL   38D2
42E6:  MOVLW  20
42E8:  BTFSS  F9E.4
42EA:  BRA    42E8
42EC:  MOVWF  FAD
42EE:  MOVLW  20
42F0:  BTFSS  F9E.4
42F2:  BRA    42F0
42F4:  MOVWF  FAD
....................  
....................       if(horas<10) 
42F6:  MOVF   71,W
42F8:  SUBLW  09
42FA:  BNC   431A
....................          printf("0"); 
42FC:  MOVLB  2
42FE:  CLRF   x7E
4300:  MOVF   x7E,W
4302:  MOVLB  0
4304:  CALL   0476
4308:  IORLW  00
430A:  BZ    431A
430C:  MOVLB  2
430E:  INCF   x7E,F
4310:  BTFSS  F9E.4
4312:  BRA    4310
4314:  MOVWF  FAD
4316:  BRA    4300
4318:  MOVLB  0
....................  
....................       printf("%u:", horas); 
431A:  MOVFF  71,27F
431E:  MOVLW  1B
4320:  MOVLB  2
4322:  MOVWF  x80
4324:  MOVLB  0
4326:  CALL   38D2
432A:  MOVLW  3A
432C:  BTFSS  F9E.4
432E:  BRA    432C
4330:  MOVWF  FAD
....................  
....................       if(minutos<10) 
4332:  MOVF   72,W
4334:  SUBLW  09
4336:  BNC   4356
....................          printf("0"); 
4338:  MOVLB  2
433A:  CLRF   x7E
433C:  MOVF   x7E,W
433E:  MOVLB  0
4340:  CALL   0476
4344:  IORLW  00
4346:  BZ    4356
4348:  MOVLB  2
434A:  INCF   x7E,F
434C:  BTFSS  F9E.4
434E:  BRA    434C
4350:  MOVWF  FAD
4352:  BRA    433C
4354:  MOVLB  0
....................  
....................       printf("%u ", minutos); 
4356:  MOVFF  72,27F
435A:  MOVLW  1B
435C:  MOVLB  2
435E:  MOVWF  x80
4360:  MOVLB  0
4362:  CALL   38D2
4366:  MOVLW  20
4368:  BTFSS  F9E.4
436A:  BRA    4368
436C:  MOVWF  FAD
....................  
....................       if(temp_int<10) 
436E:  MOVF   73,W
4370:  SUBLW  09
4372:  BNC   4392
....................          printf(" "); 
4374:  MOVLB  2
4376:  CLRF   x7E
4378:  MOVF   x7E,W
437A:  MOVLB  0
437C:  CALL   0AF4
4380:  IORLW  00
4382:  BZ    4392
4384:  MOVLB  2
4386:  INCF   x7E,F
4388:  BTFSS  F9E.4
438A:  BRA    4388
438C:  MOVWF  FAD
438E:  BRA    4378
4390:  MOVLB  0
....................  
....................       printf("%u.", temp_int); 
4392:  MOVFF  73,27F
4396:  MOVLW  1B
4398:  MOVLB  2
439A:  MOVWF  x80
439C:  MOVLB  0
439E:  CALL   38D2
43A2:  MOVLW  2E
43A4:  BTFSS  F9E.4
43A6:  BRA    43A4
43A8:  MOVWF  FAD
....................  
....................       if(temp_dec<10) 
43AA:  MOVF   74,W
43AC:  SUBLW  09
43AE:  BNC   43CE
....................          printf("0"); 
43B0:  MOVLB  2
43B2:  CLRF   x7E
43B4:  MOVF   x7E,W
43B6:  MOVLB  0
43B8:  CALL   0476
43BC:  IORLW  00
43BE:  BZ    43CE
43C0:  MOVLB  2
43C2:  INCF   x7E,F
43C4:  BTFSS  F9E.4
43C6:  BRA    43C4
43C8:  MOVWF  FAD
43CA:  BRA    43B4
43CC:  MOVLB  0
....................  
....................       printf("%u%cC  %u%cC   ", temp_dec, 223, term, 223); 
43CE:  MOVFF  74,27F
43D2:  MOVLW  1B
43D4:  MOVLB  2
43D6:  MOVWF  x80
43D8:  MOVLB  0
43DA:  CALL   38D2
43DE:  MOVLW  DF
43E0:  BTFSS  F9E.4
43E2:  BRA    43E0
43E4:  MOVWF  FAD
43E6:  MOVLW  43
43E8:  BTFSS  F9E.4
43EA:  BRA    43E8
43EC:  MOVWF  FAD
43EE:  MOVLW  20
43F0:  BTFSS  F9E.4
43F2:  BRA    43F0
43F4:  MOVWF  FAD
43F6:  MOVLW  20
43F8:  BTFSS  F9E.4
43FA:  BRA    43F8
43FC:  MOVWF  FAD
43FE:  MOVFF  77,27F
4402:  MOVLW  1B
4404:  MOVLB  2
4406:  MOVWF  x80
4408:  MOVLB  0
440A:  CALL   38D2
440E:  MOVLW  DF
4410:  BTFSS  F9E.4
4412:  BRA    4410
4414:  MOVWF  FAD
4416:  MOVLW  43
4418:  BTFSS  F9E.4
441A:  BRA    4418
441C:  MOVWF  FAD
441E:  MOVLW  03
4420:  MOVLB  2
4422:  MOVWF  x7E
4424:  MOVLW  20
4426:  BTFSS  F9E.4
4428:  BRA    4426
442A:  MOVWF  FAD
442C:  DECFSZ x7E,F
442E:  BRA    4424
....................  
....................       if(t_sistema<100) 
4430:  MOVF   75,W
4432:  SUBLW  63
4434:  BNC   4450
....................          printf(" "); 
4436:  CLRF   x7E
4438:  MOVF   x7E,W
443A:  MOVLB  0
443C:  CALL   0AF4
4440:  IORLW  00
4442:  BZ    4452
4444:  MOVLB  2
4446:  INCF   x7E,F
4448:  BTFSS  F9E.4
444A:  BRA    4448
444C:  MOVWF  FAD
444E:  BRA    4438
4450:  MOVLB  0
....................       if(t_sistema<10) 
4452:  MOVF   75,W
4454:  SUBLW  09
4456:  BNC   4476
....................          printf(" "); 
4458:  MOVLB  2
445A:  CLRF   x7E
445C:  MOVF   x7E,W
445E:  MOVLB  0
4460:  CALL   0AF4
4464:  IORLW  00
4466:  BZ    4476
4468:  MOVLB  2
446A:  INCF   x7E,F
446C:  BTFSS  F9E.4
446E:  BRA    446C
4470:  MOVWF  FAD
4472:  BRA    445C
4474:  MOVLB  0
....................  
....................       printf("%u     ", t_sistema); 
4476:  MOVFF  75,27F
447A:  MOVLW  1B
447C:  MOVLB  2
447E:  MOVWF  x80
4480:  MOVLB  0
4482:  CALL   38D2
4486:  MOVLW  05
4488:  MOVLB  2
448A:  MOVWF  x7E
448C:  MOVLW  20
448E:  BTFSS  F9E.4
4490:  BRA    448E
4492:  MOVWF  FAD
4494:  DECFSZ x7E,F
4496:  BRA    448C
....................  
....................       if(t_caldera<100) 
4498:  MOVF   76,W
449A:  SUBLW  63
449C:  BNC   44B8
....................          printf(" "); 
449E:  CLRF   x7E
44A0:  MOVF   x7E,W
44A2:  MOVLB  0
44A4:  CALL   0AF4
44A8:  IORLW  00
44AA:  BZ    44BA
44AC:  MOVLB  2
44AE:  INCF   x7E,F
44B0:  BTFSS  F9E.4
44B2:  BRA    44B0
44B4:  MOVWF  FAD
44B6:  BRA    44A0
44B8:  MOVLB  0
....................       if(t_caldera<10) 
44BA:  MOVF   76,W
44BC:  SUBLW  09
44BE:  BNC   44DE
....................          printf(" "); 
44C0:  MOVLB  2
44C2:  CLRF   x7E
44C4:  MOVF   x7E,W
44C6:  MOVLB  0
44C8:  CALL   0AF4
44CC:  IORLW  00
44CE:  BZ    44DE
44D0:  MOVLB  2
44D2:  INCF   x7E,F
44D4:  BTFSS  F9E.4
44D6:  BRA    44D4
44D8:  MOVWF  FAD
44DA:  BRA    44C4
44DC:  MOVLB  0
....................  
....................       printf("%u\r", t_caldera); 
44DE:  MOVFF  76,27F
44E2:  MOVLW  1B
44E4:  MOVLB  2
44E6:  MOVWF  x80
44E8:  MOVLB  0
44EA:  CALL   38D2
44EE:  MOVLW  0D
44F0:  BTFSS  F9E.4
44F2:  BRA    44F0
44F4:  MOVWF  FAD
....................  
....................    } 
44F6:  INCF   6B,F
44F8:  BRA    3D5E
....................  
....................    //Debemos realizar la operación de guardado para el último día. El proceso es el mismo 
....................    //que hemos seguido arriba. 
....................    if(fecha[0]!=0) 
44FA:  MOVLB  2
44FC:  MOVF   x79,F
44FE:  BZ    45D4
....................    { 
....................       valor = valor + (float)tiempo_x_dia; 
4500:  MOVFF  276,285
4504:  MOVFF  275,284
4508:  MOVLB  0
450A:  CALL   2426
450E:  BCF    FD8.1
4510:  MOVFF  BB,281
4514:  MOVFF  BA,280
4518:  MOVFF  B9,27F
451C:  MOVFF  B8,27E
4520:  MOVFF  03,285
4524:  MOVFF  02,284
4528:  MOVFF  01,283
452C:  MOVFF  00,282
4530:  CALL   21AC
4534:  MOVFF  03,BB
4538:  MOVFF  02,BA
453C:  MOVFF  01,B9
4540:  MOVFF  00,B8
....................       media_dia_mes[fecha[1]-1] = valor; 
4544:  MOVLW  01
4546:  MOVLB  2
4548:  SUBWF  x7A,W
454A:  MULLW  04
454C:  MOVF   FF3,W
454E:  CLRF   03
4550:  ADDLW  78
4552:  MOVWF  FE9
4554:  MOVLW  00
4556:  ADDWFC 03,W
4558:  MOVWF  FEA
455A:  MOVFF  B8,FEF
455E:  MOVFF  B9,FEC
4562:  MOVFF  BA,FEC
4566:  MOVFF  BB,FEC
....................       media_dia_caldera = media_dia_caldera + (float)tiempo_x_dia_caldera; 
456A:  MOVFF  278,285
456E:  MOVFF  277,284
4572:  MOVLB  0
4574:  CALL   2426
4578:  BCF    FD8.1
457A:  MOVFF  B7,281
457E:  MOVFF  B6,280
4582:  MOVFF  B5,27F
4586:  MOVFF  B4,27E
458A:  MOVFF  03,285
458E:  MOVFF  02,284
4592:  MOVFF  01,283
4596:  MOVFF  00,282
459A:  CALL   21AC
459E:  MOVFF  03,B7
45A2:  MOVFF  02,B6
45A6:  MOVFF  01,B5
45AA:  MOVFF  00,B4
....................       media_dia_mes_caldera[fecha[1]-1] = media_dia_caldera; 
45AE:  MOVLW  01
45B0:  MOVLB  2
45B2:  SUBWF  x7A,W
45B4:  MULLW  04
45B6:  MOVF   FF3,W
45B8:  CLRF   03
45BA:  ADDLW  BC
45BC:  MOVWF  FE9
45BE:  MOVLW  00
45C0:  ADDWFC 03,W
45C2:  MOVWF  FEA
45C4:  MOVFF  B4,FEF
45C8:  MOVFF  B5,FEC
45CC:  MOVFF  B6,FEC
45D0:  MOVFF  B7,FEC
....................    } 
....................  
....................    //Comprobamos que no nos encontrabamos en el año introducido por defecto 
....................    if(fecha[2]!=0) 
45D4:  MOVF   x7B,F
45D6:  BTFSC  FD8.2
45D8:  BRA    47EC
....................    { 
....................       for(contador2=0; contador2<12; contador2++) 
45DA:  CLRF   6C
45DC:  MOVF   6C,W
45DE:  SUBLW  0B
45E0:  BTFSS  FD8.0
45E2:  BRA    47D8
....................       { 
....................          media_dia_mes[contador2] = media_dia_mes[contador2]/(float)dias_meses[contador2]; 
45E4:  MOVF   6C,W
45E6:  MULLW  04
45E8:  MOVF   FF3,W
45EA:  CLRF   03
45EC:  ADDLW  78
45EE:  MOVWF  01
45F0:  MOVLW  00
45F2:  ADDWFC 03,F
45F4:  MOVFF  01,27E
45F8:  MOVFF  03,27F
45FC:  MOVF   6C,W
45FE:  MULLW  04
4600:  MOVF   FF3,W
4602:  CLRF   03
4604:  ADDLW  78
4606:  MOVWF  FE9
4608:  MOVLW  00
460A:  ADDWFC 03,W
460C:  MOVWF  FEA
460E:  MOVFF  FEF,280
4612:  MOVFF  FEC,281
4616:  MOVFF  FEC,282
461A:  MOVFF  FEC,283
461E:  CLRF   03
4620:  MOVF   6C,W
4622:  ADDLW  A8
4624:  MOVWF  FE9
4626:  MOVLW  00
4628:  ADDWFC 03,W
462A:  MOVWF  FEA
462C:  MOVF   FEF,W
462E:  CLRF   x85
4630:  MOVWF  x84
4632:  MOVLB  0
4634:  CALL   2426
4638:  MOVFF  283,287
463C:  MOVFF  282,286
4640:  MOVFF  281,285
4644:  MOVFF  280,284
4648:  MOVFF  03,28B
464C:  MOVFF  02,28A
4650:  MOVFF  01,289
4654:  MOVFF  00,288
4658:  CALL   1EF2
465C:  MOVFF  27F,FEA
4660:  MOVFF  27E,FE9
4664:  MOVFF  00,FEF
4668:  MOVFF  01,FEC
466C:  MOVFF  02,FEC
4670:  MOVFF  03,FEC
....................          media_dia_mes_caldera[contador2] = media_dia_mes_caldera[contador2]/(float)dias_meses[contador2]; 
4674:  MOVF   6C,W
4676:  MULLW  04
4678:  MOVF   FF3,W
467A:  CLRF   03
467C:  ADDLW  BC
467E:  MOVWF  01
4680:  MOVLW  00
4682:  ADDWFC 03,F
4684:  MOVFF  01,27E
4688:  MOVLB  2
468A:  MOVFF  03,27F
468E:  MOVF   6C,W
4690:  MULLW  04
4692:  MOVF   FF3,W
4694:  CLRF   03
4696:  ADDLW  BC
4698:  MOVWF  FE9
469A:  MOVLW  00
469C:  ADDWFC 03,W
469E:  MOVWF  FEA
46A0:  MOVFF  FEF,280
46A4:  MOVFF  FEC,281
46A8:  MOVFF  FEC,282
46AC:  MOVFF  FEC,283
46B0:  CLRF   03
46B2:  MOVF   6C,W
46B4:  ADDLW  A8
46B6:  MOVWF  FE9
46B8:  MOVLW  00
46BA:  ADDWFC 03,W
46BC:  MOVWF  FEA
46BE:  MOVF   FEF,W
46C0:  CLRF   x85
46C2:  MOVWF  x84
46C4:  MOVLB  0
46C6:  CALL   2426
46CA:  MOVFF  283,287
46CE:  MOVFF  282,286
46D2:  MOVFF  281,285
46D6:  MOVFF  280,284
46DA:  MOVFF  03,28B
46DE:  MOVFF  02,28A
46E2:  MOVFF  01,289
46E6:  MOVFF  00,288
46EA:  CALL   1EF2
46EE:  MOVFF  27F,FEA
46F2:  MOVFF  27E,FE9
46F6:  MOVFF  00,FEF
46FA:  MOVFF  01,FEC
46FE:  MOVFF  02,FEC
4702:  MOVFF  03,FEC
....................          media_annos[num_annos][contador2] = media_dia_mes[contador2]; 
4706:  MOVLB  2
4708:  MOVF   x70,W
470A:  MULLW  30
470C:  MOVF   FF3,W
470E:  CLRF   x7F
4710:  MOVWF  x7E
4712:  MOVF   6C,W
4714:  MULLW  04
4716:  MOVF   FF3,W
4718:  CLRF   03
471A:  ADDWF  x7E,W
471C:  MOVWF  01
471E:  MOVF   x7F,W
4720:  ADDWFC 03,F
4722:  MOVF   01,W
4724:  ADDLW  F0
4726:  MOVWF  01
4728:  MOVLW  00
472A:  ADDWFC 03,F
472C:  MOVFF  01,280
4730:  MOVFF  03,281
4734:  MOVF   6C,W
4736:  MULLW  04
4738:  MOVF   FF3,W
473A:  CLRF   03
473C:  ADDLW  78
473E:  MOVWF  FE9
4740:  MOVLW  00
4742:  ADDWFC 03,W
4744:  MOVWF  FEA
4746:  MOVFF  FEF,00
474A:  MOVFF  FEC,01
474E:  MOVFF  FEC,02
4752:  MOVFF  FEC,03
4756:  MOVFF  281,FEA
475A:  MOVFF  280,FE9
475E:  MOVFF  00,FEF
4762:  MOVFF  01,FEC
4766:  MOVFF  02,FEC
476A:  MOVFF  03,FEC
....................          media_annos_caldera[num_annos][contador2] = media_dia_mes_caldera[contador2]; 
476E:  MOVF   x70,W
4770:  MULLW  30
4772:  MOVF   FF3,W
4774:  CLRF   x7F
4776:  MOVWF  x7E
4778:  MOVF   6C,W
477A:  MULLW  04
477C:  MOVF   FF3,W
477E:  CLRF   03
4780:  ADDWF  x7E,W
4782:  MOVWF  01
4784:  MOVF   x7F,W
4786:  ADDWFC 03,F
4788:  MOVF   01,W
478A:  ADDLW  B0
478C:  MOVWF  01
478E:  MOVLW  01
4790:  ADDWFC 03,F
4792:  MOVFF  01,280
4796:  MOVFF  03,281
479A:  MOVF   6C,W
479C:  MULLW  04
479E:  MOVF   FF3,W
47A0:  CLRF   03
47A2:  ADDLW  BC
47A4:  MOVWF  FE9
47A6:  MOVLW  00
47A8:  ADDWFC 03,W
47AA:  MOVWF  FEA
47AC:  MOVFF  FEF,00
47B0:  MOVFF  FEC,01
47B4:  MOVFF  FEC,02
47B8:  MOVFF  FEC,03
47BC:  MOVFF  281,FEA
47C0:  MOVFF  280,FE9
47C4:  MOVFF  00,FEF
47C8:  MOVFF  01,FEC
47CC:  MOVFF  02,FEC
47D0:  MOVFF  03,FEC
....................       } 
47D4:  INCF   6C,F
47D6:  BRA    45DC
....................  
....................       annos[num_annos]=fecha[2]; 
47D8:  CLRF   03
47DA:  MOVF   x70,W
47DC:  ADDLW  71
47DE:  MOVWF  FE9
47E0:  MOVLW  02
47E2:  ADDWFC 03,W
47E4:  MOVWF  FEA
47E6:  MOVFF  27B,FEF
....................  
....................       num_annos++; 
47EA:  INCF   x70,F
....................    } 
....................  
....................    //Calculamos la media como el cociente entre los valore de tiempo calculados y el número de 
....................    //días en los que se ha encendido la caldera 
....................    valor = valor/(float)num_dias; 
47EC:  MOVFF  27D,285
47F0:  MOVFF  27C,284
47F4:  MOVLB  0
47F6:  CALL   2426
47FA:  MOVFF  BB,287
47FE:  MOVFF  BA,286
4802:  MOVFF  B9,285
4806:  MOVFF  B8,284
480A:  MOVFF  03,28B
480E:  MOVFF  02,28A
4812:  MOVFF  01,289
4816:  MOVFF  00,288
481A:  CALL   1EF2
481E:  MOVFF  03,BB
4822:  MOVFF  02,BA
4826:  MOVFF  01,B9
482A:  MOVFF  00,B8
....................    media_dia_caldera = media_dia_caldera/(float)num_dias; 
482E:  MOVFF  27D,285
4832:  MOVFF  27C,284
4836:  CALL   2426
483A:  MOVFF  B7,287
483E:  MOVFF  B6,286
4842:  MOVFF  B5,285
4846:  MOVFF  B4,284
484A:  MOVFF  03,28B
484E:  MOVFF  02,28A
4852:  MOVFF  01,289
4856:  MOVFF  00,288
485A:  CALL   1EF2
485E:  MOVFF  03,B7
4862:  MOVFF  02,B6
4866:  MOVFF  01,B5
486A:  MOVFF  00,B4
....................  
....................    repetir: 
....................    //Menú para mostrar los datos 
....................    printf("\r=============================================\r"); 
486E:  MOVLB  2
4870:  CLRF   x7E
4872:  MOVF   x7E,W
4874:  MOVLB  0
4876:  CALL   0B10
487A:  IORLW  00
487C:  BZ    488C
487E:  MOVLB  2
4880:  INCF   x7E,F
4882:  BTFSS  F9E.4
4884:  BRA    4882
4886:  MOVWF  FAD
4888:  BRA    4872
488A:  MOVLB  0
....................    printf("¿Que operacion desea realizar?\r"); 
488C:  MOVLB  2
488E:  CLRF   x7E
4890:  MOVF   x7E,W
4892:  MOVLB  0
4894:  CALL   0B5A
4898:  IORLW  00
489A:  BZ    48AA
489C:  MOVLB  2
489E:  INCF   x7E,F
48A0:  BTFSS  F9E.4
48A2:  BRA    48A0
48A4:  MOVWF  FAD
48A6:  BRA    4890
48A8:  MOVLB  0
....................    printf("0. Salir\r"); 
48AA:  MOVLB  2
48AC:  CLRF   x7E
48AE:  MOVF   x7E,W
48B0:  MOVLB  0
48B2:  CALL   0B94
48B6:  IORLW  00
48B8:  BZ    48C8
48BA:  MOVLB  2
48BC:  INCF   x7E,F
48BE:  BTFSS  F9E.4
48C0:  BRA    48BE
48C2:  MOVWF  FAD
48C4:  BRA    48AE
48C6:  MOVLB  0
....................    printf("1. Extraer tiempos medios por dia\r"); 
48C8:  MOVLB  2
48CA:  CLRF   x7E
48CC:  MOVF   x7E,W
48CE:  MOVLB  0
48D0:  CALL   0BB8
48D4:  IORLW  00
48D6:  BZ    48E6
48D8:  MOVLB  2
48DA:  INCF   x7E,F
48DC:  BTFSS  F9E.4
48DE:  BRA    48DC
48E0:  MOVWF  FAD
48E2:  BRA    48CC
48E4:  MOVLB  0
....................    printf("2. Extraer tiempos totales\r"); 
48E6:  MOVLB  2
48E8:  CLRF   x7E
48EA:  MOVF   x7E,W
48EC:  MOVLB  0
48EE:  CALL   0BF6
48F2:  IORLW  00
48F4:  BZ    4904
48F6:  MOVLB  2
48F8:  INCF   x7E,F
48FA:  BTFSS  F9E.4
48FC:  BRA    48FA
48FE:  MOVWF  FAD
4900:  BRA    48EA
4902:  MOVLB  0
....................    printf("3. Extraer datos mensuales\r"); 
4904:  MOVLB  2
4906:  CLRF   x7E
4908:  MOVF   x7E,W
490A:  MOVLB  0
490C:  CALL   0C2C
4910:  IORLW  00
4912:  BZ    4922
4914:  MOVLB  2
4916:  INCF   x7E,F
4918:  BTFSS  F9E.4
491A:  BRA    4918
491C:  MOVWF  FAD
491E:  BRA    4908
4920:  MOVLB  0
....................    printf("=============================================\r"); 
4922:  MOVLB  2
4924:  CLRF   x7E
4926:  MOVF   x7E,W
4928:  MOVLB  0
492A:  CALL   0C62
492E:  IORLW  00
4930:  BZ    4940
4932:  MOVLB  2
4934:  INCF   x7E,F
4936:  BTFSS  F9E.4
4938:  BRA    4936
493A:  MOVWF  FAD
493C:  BRA    4926
493E:  MOVLB  0
....................  
....................    //Esperamos la introducción de una de las opciones por parte del técnico. 
....................    //Cuando se pulse uno de los botones, asignamos a la variable caracter el valor correspondiente. 
....................    caracter='J'; 
4940:  MOVLW  4A
4942:  MOVWF  6D
....................    while(caracter!='0' && caracter!='1' && caracter!='2' && caracter!='3'){ 
4944:  MOVF   6D,W
4946:  SUBLW  30
4948:  BZ    4966
494A:  MOVF   6D,W
494C:  SUBLW  31
494E:  BZ    4966
4950:  MOVF   6D,W
4952:  SUBLW  32
4954:  BZ    4966
4956:  MOVF   6D,W
4958:  SUBLW  33
495A:  BZ    4966
....................       caracter=getch(); 
495C:  BTFSS  F9E.5
495E:  BRA    495C
4960:  MOVFF  FAE,6D
....................    } 
4964:  BRA    4944
....................  
....................    switch(caracter) 
....................    { 
4966:  MOVLW  30
4968:  SUBWF  6D,W
496A:  ADDLW  FC
496C:  BTFSC  FD8.0
496E:  GOTO   56A8
4972:  ADDLW  04
4974:  GOTO   56AC
....................       //En el caso 0, se sale del sistema 
....................       case '0': 
....................                //Se indica por pantalla la salida 
....................                printf("\rSaliendo...\r"); 
4978:  MOVLB  2
497A:  CLRF   x7E
497C:  MOVF   x7E,W
497E:  MOVLB  0
4980:  CALL   0CAC
4984:  IORLW  00
4986:  BZ    4996
4988:  MOVLB  2
498A:  INCF   x7E,F
498C:  BTFSS  F9E.4
498E:  BRA    498C
4990:  MOVWF  FAD
4992:  BRA    497C
4994:  MOVLB  0
....................                break; 
4996:  GOTO   56A8
....................  
....................       //En el caso 1, se muestran los valores medios 
....................       case '1': 
....................                printf("\rT. medio encendido sistema por dia: %3.2f minutos\r\r", valor); 
499A:  MOVLB  2
499C:  CLRF   x7E
499E:  MOVF   x7E,W
49A0:  MOVLB  0
49A2:  CALL   0CD4
49A6:  MOVLB  2
49A8:  INCF   x7E,F
49AA:  MOVWF  00
49AC:  MOVF   00,W
49AE:  BTFSS  F9E.4
49B0:  BRA    49AE
49B2:  MOVWF  FAD
49B4:  MOVLW  25
49B6:  SUBWF  x7E,W
49B8:  BNZ   499E
49BA:  MOVLW  02
49BC:  MOVWF  FE9
49BE:  MOVFF  BB,290
49C2:  MOVFF  BA,28F
49C6:  MOVFF  B9,28E
49CA:  MOVFF  B8,28D
49CE:  MOVWF  x91
49D0:  MOVLB  0
49D2:  CALL   3954
49D6:  MOVLW  2A
49D8:  MOVLB  2
49DA:  MOVWF  x7F
49DC:  MOVF   x7F,W
49DE:  MOVLB  0
49E0:  CALL   0CD4
49E4:  MOVLB  2
49E6:  INCF   x7F,F
49E8:  MOVWF  00
49EA:  MOVF   00,W
49EC:  BTFSS  F9E.4
49EE:  BRA    49EC
49F0:  MOVWF  FAD
49F2:  MOVLW  34
49F4:  SUBWF  x7F,W
49F6:  BNZ   49DC
....................                printf("T. medio encendido caldera por dia: %3.2f minutos\r\r", media_dia_caldera); 
49F8:  CLRF   x7E
49FA:  MOVF   x7E,W
49FC:  MOVLB  0
49FE:  CALL   0D24
4A02:  MOVLB  2
4A04:  INCF   x7E,F
4A06:  MOVWF  00
4A08:  MOVF   00,W
4A0A:  BTFSS  F9E.4
4A0C:  BRA    4A0A
4A0E:  MOVWF  FAD
4A10:  MOVLW  24
4A12:  SUBWF  x7E,W
4A14:  BNZ   49FA
4A16:  MOVLW  02
4A18:  MOVWF  FE9
4A1A:  MOVFF  B7,290
4A1E:  MOVFF  B6,28F
4A22:  MOVFF  B5,28E
4A26:  MOVFF  B4,28D
4A2A:  MOVWF  x91
4A2C:  MOVLB  0
4A2E:  CALL   3954
4A32:  MOVLW  29
4A34:  MOVLB  2
4A36:  MOVWF  x7F
4A38:  MOVF   x7F,W
4A3A:  MOVLB  0
4A3C:  CALL   0D24
4A40:  MOVLB  2
4A42:  INCF   x7F,F
4A44:  MOVWF  00
4A46:  MOVF   00,W
4A48:  BTFSS  F9E.4
4A4A:  BRA    4A48
4A4C:  MOVWF  FAD
4A4E:  MOVLW  33
4A50:  SUBWF  x7F,W
4A52:  BNZ   4A38
....................                goto repetir; 
4A54:  MOVLB  0
4A56:  BRA    486E
....................                break; 
4A58:  GOTO   56A8
....................  
....................       //En el caso 2, se muestran los valores totales 
....................       case '2': 
....................                printf("\rT. total encendido sistema: %lu minutos\r\r", valor_total); 
4A5C:  MOVLB  2
4A5E:  CLRF   x7E
4A60:  MOVF   x7E,W
4A62:  MOVLB  0
4A64:  CALL   0D72
4A68:  MOVLB  2
4A6A:  INCF   x7E,F
4A6C:  MOVWF  00
4A6E:  MOVF   00,W
4A70:  BTFSS  F9E.4
4A72:  BRA    4A70
4A74:  MOVWF  FAD
4A76:  MOVLW  1D
4A78:  SUBWF  x7E,W
4A7A:  BNZ   4A60
4A7C:  MOVLW  10
4A7E:  MOVWF  FE9
4A80:  MOVFF  ED,280
4A84:  MOVFF  EC,27F
4A88:  MOVLB  0
4A8A:  CALL   3AFE
4A8E:  MOVLW  20
4A90:  MOVLB  2
4A92:  MOVWF  x7F
4A94:  MOVF   x7F,W
4A96:  MOVLB  0
4A98:  CALL   0D72
4A9C:  MOVLB  2
4A9E:  INCF   x7F,F
4AA0:  MOVWF  00
4AA2:  MOVF   00,W
4AA4:  BTFSS  F9E.4
4AA6:  BRA    4AA4
4AA8:  MOVWF  FAD
4AAA:  MOVLW  2A
4AAC:  SUBWF  x7F,W
4AAE:  BNZ   4A94
....................                printf("T. total encendido caldera: %lu minutos\r\r", valor_total_caldera); 
4AB0:  CLRF   x7E
4AB2:  MOVF   x7E,W
4AB4:  MOVLB  0
4AB6:  CALL   0DB8
4ABA:  MOVLB  2
4ABC:  INCF   x7E,F
4ABE:  MOVWF  00
4AC0:  MOVF   00,W
4AC2:  BTFSS  F9E.4
4AC4:  BRA    4AC2
4AC6:  MOVWF  FAD
4AC8:  MOVLW  1C
4ACA:  SUBWF  x7E,W
4ACC:  BNZ   4AB2
4ACE:  MOVLW  10
4AD0:  MOVWF  FE9
4AD2:  MOVFF  EF,280
4AD6:  MOVFF  EE,27F
4ADA:  MOVLB  0
4ADC:  CALL   3AFE
4AE0:  MOVLW  1F
4AE2:  MOVLB  2
4AE4:  MOVWF  x7F
4AE6:  MOVF   x7F,W
4AE8:  MOVLB  0
4AEA:  CALL   0DB8
4AEE:  MOVLB  2
4AF0:  INCF   x7F,F
4AF2:  MOVWF  00
4AF4:  MOVF   00,W
4AF6:  BTFSS  F9E.4
4AF8:  BRA    4AF6
4AFA:  MOVWF  FAD
4AFC:  MOVLW  29
4AFE:  SUBWF  x7F,W
4B00:  BNZ   4AE6
....................                goto repetir; 
4B02:  MOVLB  0
4B04:  BRA    486E
....................                break; 
4B06:  GOTO   56A8
....................  
....................       //En el caso 3, se muestran todos los valores medios por meses y años 
....................       case '3': 
....................                //Se representan todos los años de los que se tiene registro 
....................                for(contador=0; contador<num_annos; contador++) 
4B0A:  CLRF   6B
4B0C:  MOVLB  2
4B0E:  MOVF   x70,W
4B10:  SUBWF  6B,W
4B12:  BTFSC  FD8.0
4B14:  GOTO   56A0
....................                { 
....................                   //Imprimimos el año en el que nos encontramos 
....................                   printf("\r20"); 
4B18:  CLRF   x7E
4B1A:  MOVF   x7E,W
4B1C:  MOVLB  0
4B1E:  CALL   0DFC
4B22:  IORLW  00
4B24:  BZ    4B34
4B26:  MOVLB  2
4B28:  INCF   x7E,F
4B2A:  BTFSS  F9E.4
4B2C:  BRA    4B2A
4B2E:  MOVWF  FAD
4B30:  BRA    4B1A
4B32:  MOVLB  0
....................                   if(annos[contador]<10) 
4B34:  CLRF   03
4B36:  MOVF   6B,W
4B38:  ADDLW  71
4B3A:  MOVWF  FE9
4B3C:  MOVLW  02
4B3E:  ADDWFC 03,W
4B40:  MOVWF  FEA
4B42:  MOVF   FEF,W
4B44:  SUBLW  09
4B46:  BNC   4B66
....................                      printf("0"); 
4B48:  MOVLB  2
4B4A:  CLRF   x7E
4B4C:  MOVF   x7E,W
4B4E:  MOVLB  0
4B50:  CALL   0476
4B54:  IORLW  00
4B56:  BZ    4B66
4B58:  MOVLB  2
4B5A:  INCF   x7E,F
4B5C:  BTFSS  F9E.4
4B5E:  BRA    4B5C
4B60:  MOVWF  FAD
4B62:  BRA    4B4C
4B64:  MOVLB  0
....................                   printf("%u\r", annos[contador]); 
4B66:  CLRF   03
4B68:  MOVF   6B,W
4B6A:  ADDLW  71
4B6C:  MOVWF  FE9
4B6E:  MOVLW  02
4B70:  ADDWFC 03,W
4B72:  MOVWF  FEA
4B74:  MOVFF  FEF,27E
4B78:  MOVFF  27E,27F
4B7C:  MOVLW  1B
4B7E:  MOVLB  2
4B80:  MOVWF  x80
4B82:  MOVLB  0
4B84:  CALL   38D2
4B88:  MOVLW  0D
4B8A:  BTFSS  F9E.4
4B8C:  BRA    4B8A
4B8E:  MOVWF  FAD
....................                   printf("-----------------------------------------------------\r"); 
4B90:  MOVLB  2
4B92:  CLRF   x7E
4B94:  MOVF   x7E,W
4B96:  MOVLB  0
4B98:  CALL   0E1A
4B9C:  IORLW  00
4B9E:  BZ    4BAE
4BA0:  MOVLB  2
4BA2:  INCF   x7E,F
4BA4:  BTFSS  F9E.4
4BA6:  BRA    4BA4
4BA8:  MOVWF  FAD
4BAA:  BRA    4B94
4BAC:  MOVLB  0
....................                   printf("           T. sistema (min/dia)  T. caldera (min/dia)\r"); 
4BAE:  MOVLB  2
4BB0:  CLRF   x7E
4BB2:  MOVF   x7E,W
4BB4:  MOVLB  0
4BB6:  CALL   0E6C
4BBA:  IORLW  00
4BBC:  BZ    4BCC
4BBE:  MOVLB  2
4BC0:  INCF   x7E,F
4BC2:  BTFSS  F9E.4
4BC4:  BRA    4BC2
4BC6:  MOVWF  FAD
4BC8:  BRA    4BB2
4BCA:  MOVLB  0
....................                   printf("ENERO              %3.2f                %3.2f\r", media_annos[contador][0], media_annos_caldera[contador][0]); 
4BCC:  MOVF   6B,W
4BCE:  MULLW  30
4BD0:  MOVF   FF3,W
4BD2:  MOVLB  2
4BD4:  CLRF   x7F
4BD6:  MOVWF  x7E
4BD8:  MOVLW  F0
4BDA:  ADDWF  x7E,W
4BDC:  MOVWF  FE9
4BDE:  MOVLW  00
4BE0:  ADDWFC x7F,W
4BE2:  MOVWF  FEA
4BE4:  MOVFF  FEF,280
4BE8:  MOVFF  FEC,281
4BEC:  MOVFF  FEC,282
4BF0:  MOVFF  FEC,283
4BF4:  MOVF   6B,W
4BF6:  MULLW  30
4BF8:  MOVF   FF3,W
4BFA:  CLRF   x85
4BFC:  MOVWF  x84
4BFE:  MOVLW  B0
4C00:  ADDWF  x84,W
4C02:  MOVWF  FE9
4C04:  MOVLW  01
4C06:  ADDWFC x85,W
4C08:  MOVWF  FEA
4C0A:  MOVFF  FEF,286
4C0E:  MOVFF  FEC,287
4C12:  MOVFF  FEC,288
4C16:  MOVFF  FEC,289
4C1A:  CLRF   x8A
4C1C:  MOVF   x8A,W
4C1E:  MOVLB  0
4C20:  CALL   0EBE
4C24:  MOVLB  2
4C26:  INCF   x8A,F
4C28:  MOVWF  00
4C2A:  MOVF   00,W
4C2C:  BTFSS  F9E.4
4C2E:  BRA    4C2C
4C30:  MOVWF  FAD
4C32:  MOVLW  05
4C34:  SUBWF  x8A,W
4C36:  BNZ   4C1C
4C38:  MOVLW  0E
4C3A:  MOVWF  x8B
4C3C:  MOVLW  20
4C3E:  BTFSS  F9E.4
4C40:  BRA    4C3E
4C42:  MOVWF  FAD
4C44:  DECFSZ x8B,F
4C46:  BRA    4C3C
4C48:  MOVLW  02
4C4A:  MOVWF  FE9
4C4C:  MOVFF  283,290
4C50:  MOVFF  282,28F
4C54:  MOVFF  281,28E
4C58:  MOVFF  280,28D
4C5C:  MOVWF  x91
4C5E:  MOVLB  0
4C60:  CALL   3954
4C64:  MOVLW  10
4C66:  MOVLB  2
4C68:  MOVWF  x8C
4C6A:  MOVLW  20
4C6C:  BTFSS  F9E.4
4C6E:  BRA    4C6C
4C70:  MOVWF  FAD
4C72:  DECFSZ x8C,F
4C74:  BRA    4C6A
4C76:  MOVLW  02
4C78:  MOVWF  FE9
4C7A:  MOVFF  289,290
4C7E:  MOVFF  288,28F
4C82:  MOVFF  287,28E
4C86:  MOVFF  286,28D
4C8A:  MOVWF  x91
4C8C:  MOVLB  0
4C8E:  CALL   3954
4C92:  MOVLW  0D
4C94:  BTFSS  F9E.4
4C96:  BRA    4C94
4C98:  MOVWF  FAD
....................                   printf("FEBRERO            %3.2f                %3.2f\r", media_annos[contador][1], media_annos_caldera[contador][1]); 
4C9A:  MOVF   6B,W
4C9C:  MULLW  30
4C9E:  MOVF   FF3,W
4CA0:  MOVLB  2
4CA2:  CLRF   x7F
4CA4:  MOVWF  x7E
4CA6:  MOVLW  04
4CA8:  ADDWF  x7E,W
4CAA:  MOVWF  01
4CAC:  MOVLW  00
4CAE:  ADDWFC x7F,W
4CB0:  MOVWF  03
4CB2:  MOVF   01,W
4CB4:  ADDLW  F0
4CB6:  MOVWF  FE9
4CB8:  MOVLW  00
4CBA:  ADDWFC 03,W
4CBC:  MOVWF  FEA
4CBE:  MOVFF  FEF,280
4CC2:  MOVFF  FEC,281
4CC6:  MOVFF  FEC,282
4CCA:  MOVFF  FEC,283
4CCE:  MOVF   6B,W
4CD0:  MULLW  30
4CD2:  MOVF   FF3,W
4CD4:  CLRF   x85
4CD6:  MOVWF  x84
4CD8:  MOVLW  04
4CDA:  ADDWF  x84,W
4CDC:  MOVWF  01
4CDE:  MOVLW  00
4CE0:  ADDWFC x85,W
4CE2:  MOVWF  03
4CE4:  MOVF   01,W
4CE6:  ADDLW  B0
4CE8:  MOVWF  FE9
4CEA:  MOVLW  01
4CEC:  ADDWFC 03,W
4CEE:  MOVWF  FEA
4CF0:  MOVFF  FEF,286
4CF4:  MOVFF  FEC,287
4CF8:  MOVFF  FEC,288
4CFC:  MOVFF  FEC,289
4D00:  CLRF   x8A
4D02:  MOVF   x8A,W
4D04:  MOVLB  0
4D06:  CALL   0EEA
4D0A:  MOVLB  2
4D0C:  INCF   x8A,F
4D0E:  MOVWF  00
4D10:  MOVF   00,W
4D12:  BTFSS  F9E.4
4D14:  BRA    4D12
4D16:  MOVWF  FAD
4D18:  MOVLW  07
4D1A:  SUBWF  x8A,W
4D1C:  BNZ   4D02
4D1E:  MOVLW  0C
4D20:  MOVWF  x8B
4D22:  MOVLW  20
4D24:  BTFSS  F9E.4
4D26:  BRA    4D24
4D28:  MOVWF  FAD
4D2A:  DECFSZ x8B,F
4D2C:  BRA    4D22
4D2E:  MOVLW  02
4D30:  MOVWF  FE9
4D32:  MOVFF  283,290
4D36:  MOVFF  282,28F
4D3A:  MOVFF  281,28E
4D3E:  MOVFF  280,28D
4D42:  MOVWF  x91
4D44:  MOVLB  0
4D46:  CALL   3954
4D4A:  MOVLW  10
4D4C:  MOVLB  2
4D4E:  MOVWF  x8C
4D50:  MOVLW  20
4D52:  BTFSS  F9E.4
4D54:  BRA    4D52
4D56:  MOVWF  FAD
4D58:  DECFSZ x8C,F
4D5A:  BRA    4D50
4D5C:  MOVLW  02
4D5E:  MOVWF  FE9
4D60:  MOVFF  289,290
4D64:  MOVFF  288,28F
4D68:  MOVFF  287,28E
4D6C:  MOVFF  286,28D
4D70:  MOVWF  x91
4D72:  MOVLB  0
4D74:  CALL   3954
4D78:  MOVLW  0D
4D7A:  BTFSS  F9E.4
4D7C:  BRA    4D7A
4D7E:  MOVWF  FAD
....................                   printf("MARZO              %3.2f                %3.2f\r", media_annos[contador][2], media_annos_caldera[contador][2]); 
4D80:  MOVF   6B,W
4D82:  MULLW  30
4D84:  MOVF   FF3,W
4D86:  MOVLB  2
4D88:  CLRF   x7F
4D8A:  MOVWF  x7E
4D8C:  MOVLW  08
4D8E:  ADDWF  x7E,W
4D90:  MOVWF  01
4D92:  MOVLW  00
4D94:  ADDWFC x7F,W
4D96:  MOVWF  03
4D98:  MOVF   01,W
4D9A:  ADDLW  F0
4D9C:  MOVWF  FE9
4D9E:  MOVLW  00
4DA0:  ADDWFC 03,W
4DA2:  MOVWF  FEA
4DA4:  MOVFF  FEF,280
4DA8:  MOVFF  FEC,281
4DAC:  MOVFF  FEC,282
4DB0:  MOVFF  FEC,283
4DB4:  MOVF   6B,W
4DB6:  MULLW  30
4DB8:  MOVF   FF3,W
4DBA:  CLRF   x85
4DBC:  MOVWF  x84
4DBE:  MOVLW  08
4DC0:  ADDWF  x84,W
4DC2:  MOVWF  01
4DC4:  MOVLW  00
4DC6:  ADDWFC x85,W
4DC8:  MOVWF  03
4DCA:  MOVF   01,W
4DCC:  ADDLW  B0
4DCE:  MOVWF  FE9
4DD0:  MOVLW  01
4DD2:  ADDWFC 03,W
4DD4:  MOVWF  FEA
4DD6:  MOVFF  FEF,286
4DDA:  MOVFF  FEC,287
4DDE:  MOVFF  FEC,288
4DE2:  MOVFF  FEC,289
4DE6:  CLRF   x8A
4DE8:  MOVF   x8A,W
4DEA:  MOVLB  0
4DEC:  CALL   0F18
4DF0:  MOVLB  2
4DF2:  INCF   x8A,F
4DF4:  MOVWF  00
4DF6:  MOVF   00,W
4DF8:  BTFSS  F9E.4
4DFA:  BRA    4DF8
4DFC:  MOVWF  FAD
4DFE:  MOVLW  05
4E00:  SUBWF  x8A,W
4E02:  BNZ   4DE8
4E04:  MOVLW  0E
4E06:  MOVWF  x8B
4E08:  MOVLW  20
4E0A:  BTFSS  F9E.4
4E0C:  BRA    4E0A
4E0E:  MOVWF  FAD
4E10:  DECFSZ x8B,F
4E12:  BRA    4E08
4E14:  MOVLW  02
4E16:  MOVWF  FE9
4E18:  MOVFF  283,290
4E1C:  MOVFF  282,28F
4E20:  MOVFF  281,28E
4E24:  MOVFF  280,28D
4E28:  MOVWF  x91
4E2A:  MOVLB  0
4E2C:  CALL   3954
4E30:  MOVLW  10
4E32:  MOVLB  2
4E34:  MOVWF  x8C
4E36:  MOVLW  20
4E38:  BTFSS  F9E.4
4E3A:  BRA    4E38
4E3C:  MOVWF  FAD
4E3E:  DECFSZ x8C,F
4E40:  BRA    4E36
4E42:  MOVLW  02
4E44:  MOVWF  FE9
4E46:  MOVFF  289,290
4E4A:  MOVFF  288,28F
4E4E:  MOVFF  287,28E
4E52:  MOVFF  286,28D
4E56:  MOVWF  x91
4E58:  MOVLB  0
4E5A:  CALL   3954
4E5E:  MOVLW  0D
4E60:  BTFSS  F9E.4
4E62:  BRA    4E60
4E64:  MOVWF  FAD
....................                   printf("ABRIL              %3.2f                %3.2f\r", media_annos[contador][3], media_annos_caldera[contador][3]); 
4E66:  MOVF   6B,W
4E68:  MULLW  30
4E6A:  MOVF   FF3,W
4E6C:  MOVLB  2
4E6E:  CLRF   x7F
4E70:  MOVWF  x7E
4E72:  MOVLW  0C
4E74:  ADDWF  x7E,W
4E76:  MOVWF  01
4E78:  MOVLW  00
4E7A:  ADDWFC x7F,W
4E7C:  MOVWF  03
4E7E:  MOVF   01,W
4E80:  ADDLW  F0
4E82:  MOVWF  FE9
4E84:  MOVLW  00
4E86:  ADDWFC 03,W
4E88:  MOVWF  FEA
4E8A:  MOVFF  FEF,280
4E8E:  MOVFF  FEC,281
4E92:  MOVFF  FEC,282
4E96:  MOVFF  FEC,283
4E9A:  MOVF   6B,W
4E9C:  MULLW  30
4E9E:  MOVF   FF3,W
4EA0:  CLRF   x85
4EA2:  MOVWF  x84
4EA4:  MOVLW  0C
4EA6:  ADDWF  x84,W
4EA8:  MOVWF  01
4EAA:  MOVLW  00
4EAC:  ADDWFC x85,W
4EAE:  MOVWF  03
4EB0:  MOVF   01,W
4EB2:  ADDLW  B0
4EB4:  MOVWF  FE9
4EB6:  MOVLW  01
4EB8:  ADDWFC 03,W
4EBA:  MOVWF  FEA
4EBC:  MOVFF  FEF,286
4EC0:  MOVFF  FEC,287
4EC4:  MOVFF  FEC,288
4EC8:  MOVFF  FEC,289
4ECC:  CLRF   x8A
4ECE:  MOVF   x8A,W
4ED0:  MOVLB  0
4ED2:  CALL   0F44
4ED6:  MOVLB  2
4ED8:  INCF   x8A,F
4EDA:  MOVWF  00
4EDC:  MOVF   00,W
4EDE:  BTFSS  F9E.4
4EE0:  BRA    4EDE
4EE2:  MOVWF  FAD
4EE4:  MOVLW  05
4EE6:  SUBWF  x8A,W
4EE8:  BNZ   4ECE
4EEA:  MOVLW  0E
4EEC:  MOVWF  x8B
4EEE:  MOVLW  20
4EF0:  BTFSS  F9E.4
4EF2:  BRA    4EF0
4EF4:  MOVWF  FAD
4EF6:  DECFSZ x8B,F
4EF8:  BRA    4EEE
4EFA:  MOVLW  02
4EFC:  MOVWF  FE9
4EFE:  MOVFF  283,290
4F02:  MOVFF  282,28F
4F06:  MOVFF  281,28E
4F0A:  MOVFF  280,28D
4F0E:  MOVWF  x91
4F10:  MOVLB  0
4F12:  CALL   3954
4F16:  MOVLW  10
4F18:  MOVLB  2
4F1A:  MOVWF  x8C
4F1C:  MOVLW  20
4F1E:  BTFSS  F9E.4
4F20:  BRA    4F1E
4F22:  MOVWF  FAD
4F24:  DECFSZ x8C,F
4F26:  BRA    4F1C
4F28:  MOVLW  02
4F2A:  MOVWF  FE9
4F2C:  MOVFF  289,290
4F30:  MOVFF  288,28F
4F34:  MOVFF  287,28E
4F38:  MOVFF  286,28D
4F3C:  MOVWF  x91
4F3E:  MOVLB  0
4F40:  CALL   3954
4F44:  MOVLW  0D
4F46:  BTFSS  F9E.4
4F48:  BRA    4F46
4F4A:  MOVWF  FAD
....................                   printf("MAYO               %3.2f                %3.2f\r", media_annos[contador][4], media_annos_caldera[contador][4]); 
4F4C:  MOVF   6B,W
4F4E:  MULLW  30
4F50:  MOVF   FF3,W
4F52:  MOVLB  2
4F54:  CLRF   x7F
4F56:  MOVWF  x7E
4F58:  MOVLW  10
4F5A:  ADDWF  x7E,W
4F5C:  MOVWF  01
4F5E:  MOVLW  00
4F60:  ADDWFC x7F,W
4F62:  MOVWF  03
4F64:  MOVF   01,W
4F66:  ADDLW  F0
4F68:  MOVWF  FE9
4F6A:  MOVLW  00
4F6C:  ADDWFC 03,W
4F6E:  MOVWF  FEA
4F70:  MOVFF  FEF,280
4F74:  MOVFF  FEC,281
4F78:  MOVFF  FEC,282
4F7C:  MOVFF  FEC,283
4F80:  MOVF   6B,W
4F82:  MULLW  30
4F84:  MOVF   FF3,W
4F86:  CLRF   x85
4F88:  MOVWF  x84
4F8A:  MOVLW  10
4F8C:  ADDWF  x84,W
4F8E:  MOVWF  01
4F90:  MOVLW  00
4F92:  ADDWFC x85,W
4F94:  MOVWF  03
4F96:  MOVF   01,W
4F98:  ADDLW  B0
4F9A:  MOVWF  FE9
4F9C:  MOVLW  01
4F9E:  ADDWFC 03,W
4FA0:  MOVWF  FEA
4FA2:  MOVFF  FEF,286
4FA6:  MOVFF  FEC,287
4FAA:  MOVFF  FEC,288
4FAE:  MOVFF  FEC,289
4FB2:  CLRF   x8A
4FB4:  MOVF   x8A,W
4FB6:  MOVLB  0
4FB8:  CALL   0F70
4FBC:  MOVLB  2
4FBE:  INCF   x8A,F
4FC0:  MOVWF  00
4FC2:  MOVF   00,W
4FC4:  BTFSS  F9E.4
4FC6:  BRA    4FC4
4FC8:  MOVWF  FAD
4FCA:  MOVLW  04
4FCC:  SUBWF  x8A,W
4FCE:  BNZ   4FB4
4FD0:  MOVLW  0F
4FD2:  MOVWF  x8B
4FD4:  MOVLW  20
4FD6:  BTFSS  F9E.4
4FD8:  BRA    4FD6
4FDA:  MOVWF  FAD
4FDC:  DECFSZ x8B,F
4FDE:  BRA    4FD4
4FE0:  MOVLW  02
4FE2:  MOVWF  FE9
4FE4:  MOVFF  283,290
4FE8:  MOVFF  282,28F
4FEC:  MOVFF  281,28E
4FF0:  MOVFF  280,28D
4FF4:  MOVWF  x91
4FF6:  MOVLB  0
4FF8:  CALL   3954
4FFC:  MOVLW  10
4FFE:  MOVLB  2
5000:  MOVWF  x8C
5002:  MOVLW  20
5004:  BTFSS  F9E.4
5006:  BRA    5004
5008:  MOVWF  FAD
500A:  DECFSZ x8C,F
500C:  BRA    5002
500E:  MOVLW  02
5010:  MOVWF  FE9
5012:  MOVFF  289,290
5016:  MOVFF  288,28F
501A:  MOVFF  287,28E
501E:  MOVFF  286,28D
5022:  MOVWF  x91
5024:  MOVLB  0
5026:  CALL   3954
502A:  MOVLW  0D
502C:  BTFSS  F9E.4
502E:  BRA    502C
5030:  MOVWF  FAD
....................                   printf("JUNIO              %3.2f                %3.2f\r", media_annos[contador][5], media_annos_caldera[contador][5]); 
5032:  MOVF   6B,W
5034:  MULLW  30
5036:  MOVF   FF3,W
5038:  MOVLB  2
503A:  CLRF   x7F
503C:  MOVWF  x7E
503E:  MOVLW  14
5040:  ADDWF  x7E,W
5042:  MOVWF  01
5044:  MOVLW  00
5046:  ADDWFC x7F,W
5048:  MOVWF  03
504A:  MOVF   01,W
504C:  ADDLW  F0
504E:  MOVWF  FE9
5050:  MOVLW  00
5052:  ADDWFC 03,W
5054:  MOVWF  FEA
5056:  MOVFF  FEF,280
505A:  MOVFF  FEC,281
505E:  MOVFF  FEC,282
5062:  MOVFF  FEC,283
5066:  MOVF   6B,W
5068:  MULLW  30
506A:  MOVF   FF3,W
506C:  CLRF   x85
506E:  MOVWF  x84
5070:  MOVLW  14
5072:  ADDWF  x84,W
5074:  MOVWF  01
5076:  MOVLW  00
5078:  ADDWFC x85,W
507A:  MOVWF  03
507C:  MOVF   01,W
507E:  ADDLW  B0
5080:  MOVWF  FE9
5082:  MOVLW  01
5084:  ADDWFC 03,W
5086:  MOVWF  FEA
5088:  MOVFF  FEF,286
508C:  MOVFF  FEC,287
5090:  MOVFF  FEC,288
5094:  MOVFF  FEC,289
5098:  CLRF   x8A
509A:  MOVF   x8A,W
509C:  MOVLB  0
509E:  CALL   0F9A
50A2:  MOVLB  2
50A4:  INCF   x8A,F
50A6:  MOVWF  00
50A8:  MOVF   00,W
50AA:  BTFSS  F9E.4
50AC:  BRA    50AA
50AE:  MOVWF  FAD
50B0:  MOVLW  05
50B2:  SUBWF  x8A,W
50B4:  BNZ   509A
50B6:  MOVLW  0E
50B8:  MOVWF  x8B
50BA:  MOVLW  20
50BC:  BTFSS  F9E.4
50BE:  BRA    50BC
50C0:  MOVWF  FAD
50C2:  DECFSZ x8B,F
50C4:  BRA    50BA
50C6:  MOVLW  02
50C8:  MOVWF  FE9
50CA:  MOVFF  283,290
50CE:  MOVFF  282,28F
50D2:  MOVFF  281,28E
50D6:  MOVFF  280,28D
50DA:  MOVWF  x91
50DC:  MOVLB  0
50DE:  CALL   3954
50E2:  MOVLW  10
50E4:  MOVLB  2
50E6:  MOVWF  x8C
50E8:  MOVLW  20
50EA:  BTFSS  F9E.4
50EC:  BRA    50EA
50EE:  MOVWF  FAD
50F0:  DECFSZ x8C,F
50F2:  BRA    50E8
50F4:  MOVLW  02
50F6:  MOVWF  FE9
50F8:  MOVFF  289,290
50FC:  MOVFF  288,28F
5100:  MOVFF  287,28E
5104:  MOVFF  286,28D
5108:  MOVWF  x91
510A:  MOVLB  0
510C:  CALL   3954
5110:  MOVLW  0D
5112:  BTFSS  F9E.4
5114:  BRA    5112
5116:  MOVWF  FAD
....................                   printf("JULIO              %3.2f                %3.2f\r", media_annos[contador][6], media_annos_caldera[contador][6]); 
5118:  MOVF   6B,W
511A:  MULLW  30
511C:  MOVF   FF3,W
511E:  MOVLB  2
5120:  CLRF   x7F
5122:  MOVWF  x7E
5124:  MOVLW  18
5126:  ADDWF  x7E,W
5128:  MOVWF  01
512A:  MOVLW  00
512C:  ADDWFC x7F,W
512E:  MOVWF  03
5130:  MOVF   01,W
5132:  ADDLW  F0
5134:  MOVWF  FE9
5136:  MOVLW  00
5138:  ADDWFC 03,W
513A:  MOVWF  FEA
513C:  MOVFF  FEF,280
5140:  MOVFF  FEC,281
5144:  MOVFF  FEC,282
5148:  MOVFF  FEC,283
514C:  MOVF   6B,W
514E:  MULLW  30
5150:  MOVF   FF3,W
5152:  CLRF   x85
5154:  MOVWF  x84
5156:  MOVLW  18
5158:  ADDWF  x84,W
515A:  MOVWF  01
515C:  MOVLW  00
515E:  ADDWFC x85,W
5160:  MOVWF  03
5162:  MOVF   01,W
5164:  ADDLW  B0
5166:  MOVWF  FE9
5168:  MOVLW  01
516A:  ADDWFC 03,W
516C:  MOVWF  FEA
516E:  MOVFF  FEF,286
5172:  MOVFF  FEC,287
5176:  MOVFF  FEC,288
517A:  MOVFF  FEC,289
517E:  CLRF   x8A
5180:  MOVF   x8A,W
5182:  MOVLB  0
5184:  CALL   0FC6
5188:  MOVLB  2
518A:  INCF   x8A,F
518C:  MOVWF  00
518E:  MOVF   00,W
5190:  BTFSS  F9E.4
5192:  BRA    5190
5194:  MOVWF  FAD
5196:  MOVLW  05
5198:  SUBWF  x8A,W
519A:  BNZ   5180
519C:  MOVLW  0E
519E:  MOVWF  x8B
51A0:  MOVLW  20
51A2:  BTFSS  F9E.4
51A4:  BRA    51A2
51A6:  MOVWF  FAD
51A8:  DECFSZ x8B,F
51AA:  BRA    51A0
51AC:  MOVLW  02
51AE:  MOVWF  FE9
51B0:  MOVFF  283,290
51B4:  MOVFF  282,28F
51B8:  MOVFF  281,28E
51BC:  MOVFF  280,28D
51C0:  MOVWF  x91
51C2:  MOVLB  0
51C4:  CALL   3954
51C8:  MOVLW  10
51CA:  MOVLB  2
51CC:  MOVWF  x8C
51CE:  MOVLW  20
51D0:  BTFSS  F9E.4
51D2:  BRA    51D0
51D4:  MOVWF  FAD
51D6:  DECFSZ x8C,F
51D8:  BRA    51CE
51DA:  MOVLW  02
51DC:  MOVWF  FE9
51DE:  MOVFF  289,290
51E2:  MOVFF  288,28F
51E6:  MOVFF  287,28E
51EA:  MOVFF  286,28D
51EE:  MOVWF  x91
51F0:  MOVLB  0
51F2:  CALL   3954
51F6:  MOVLW  0D
51F8:  BTFSS  F9E.4
51FA:  BRA    51F8
51FC:  MOVWF  FAD
....................                   printf("AGOSTO             %3.2f                %3.2f\r", media_annos[contador][7], media_annos_caldera[contador][7]); 
51FE:  MOVF   6B,W
5200:  MULLW  30
5202:  MOVF   FF3,W
5204:  MOVLB  2
5206:  CLRF   x7F
5208:  MOVWF  x7E
520A:  MOVLW  1C
520C:  ADDWF  x7E,W
520E:  MOVWF  01
5210:  MOVLW  00
5212:  ADDWFC x7F,W
5214:  MOVWF  03
5216:  MOVF   01,W
5218:  ADDLW  F0
521A:  MOVWF  FE9
521C:  MOVLW  00
521E:  ADDWFC 03,W
5220:  MOVWF  FEA
5222:  MOVFF  FEF,280
5226:  MOVFF  FEC,281
522A:  MOVFF  FEC,282
522E:  MOVFF  FEC,283
5232:  MOVF   6B,W
5234:  MULLW  30
5236:  MOVF   FF3,W
5238:  CLRF   x85
523A:  MOVWF  x84
523C:  MOVLW  1C
523E:  ADDWF  x84,W
5240:  MOVWF  01
5242:  MOVLW  00
5244:  ADDWFC x85,W
5246:  MOVWF  03
5248:  MOVF   01,W
524A:  ADDLW  B0
524C:  MOVWF  FE9
524E:  MOVLW  01
5250:  ADDWFC 03,W
5252:  MOVWF  FEA
5254:  MOVFF  FEF,286
5258:  MOVFF  FEC,287
525C:  MOVFF  FEC,288
5260:  MOVFF  FEC,289
5264:  CLRF   x8A
5266:  MOVF   x8A,W
5268:  MOVLB  0
526A:  CALL   0FF2
526E:  MOVLB  2
5270:  INCF   x8A,F
5272:  MOVWF  00
5274:  MOVF   00,W
5276:  BTFSS  F9E.4
5278:  BRA    5276
527A:  MOVWF  FAD
527C:  MOVLW  06
527E:  SUBWF  x8A,W
5280:  BNZ   5266
5282:  MOVLW  0D
5284:  MOVWF  x8B
5286:  MOVLW  20
5288:  BTFSS  F9E.4
528A:  BRA    5288
528C:  MOVWF  FAD
528E:  DECFSZ x8B,F
5290:  BRA    5286
5292:  MOVLW  02
5294:  MOVWF  FE9
5296:  MOVFF  283,290
529A:  MOVFF  282,28F
529E:  MOVFF  281,28E
52A2:  MOVFF  280,28D
52A6:  MOVWF  x91
52A8:  MOVLB  0
52AA:  CALL   3954
52AE:  MOVLW  10
52B0:  MOVLB  2
52B2:  MOVWF  x8C
52B4:  MOVLW  20
52B6:  BTFSS  F9E.4
52B8:  BRA    52B6
52BA:  MOVWF  FAD
52BC:  DECFSZ x8C,F
52BE:  BRA    52B4
52C0:  MOVLW  02
52C2:  MOVWF  FE9
52C4:  MOVFF  289,290
52C8:  MOVFF  288,28F
52CC:  MOVFF  287,28E
52D0:  MOVFF  286,28D
52D4:  MOVWF  x91
52D6:  MOVLB  0
52D8:  CALL   3954
52DC:  MOVLW  0D
52DE:  BTFSS  F9E.4
52E0:  BRA    52DE
52E2:  MOVWF  FAD
....................                   printf("SEPTIEMBRE         %3.2f                %3.2f\r", media_annos[contador][8], media_annos_caldera[contador][8]); 
52E4:  MOVF   6B,W
52E6:  MULLW  30
52E8:  MOVF   FF3,W
52EA:  MOVLB  2
52EC:  CLRF   x7F
52EE:  MOVWF  x7E
52F0:  MOVLW  20
52F2:  ADDWF  x7E,W
52F4:  MOVWF  01
52F6:  MOVLW  00
52F8:  ADDWFC x7F,W
52FA:  MOVWF  03
52FC:  MOVF   01,W
52FE:  ADDLW  F0
5300:  MOVWF  FE9
5302:  MOVLW  00
5304:  ADDWFC 03,W
5306:  MOVWF  FEA
5308:  MOVFF  FEF,280
530C:  MOVFF  FEC,281
5310:  MOVFF  FEC,282
5314:  MOVFF  FEC,283
5318:  MOVF   6B,W
531A:  MULLW  30
531C:  MOVF   FF3,W
531E:  CLRF   x85
5320:  MOVWF  x84
5322:  MOVLW  20
5324:  ADDWF  x84,W
5326:  MOVWF  01
5328:  MOVLW  00
532A:  ADDWFC x85,W
532C:  MOVWF  03
532E:  MOVF   01,W
5330:  ADDLW  B0
5332:  MOVWF  FE9
5334:  MOVLW  01
5336:  ADDWFC 03,W
5338:  MOVWF  FEA
533A:  MOVFF  FEF,286
533E:  MOVFF  FEC,287
5342:  MOVFF  FEC,288
5346:  MOVFF  FEC,289
534A:  CLRF   x8A
534C:  MOVF   x8A,W
534E:  MOVLB  0
5350:  CALL   101E
5354:  MOVLB  2
5356:  INCF   x8A,F
5358:  MOVWF  00
535A:  MOVF   00,W
535C:  BTFSS  F9E.4
535E:  BRA    535C
5360:  MOVWF  FAD
5362:  MOVLW  0A
5364:  SUBWF  x8A,W
5366:  BNZ   534C
5368:  MOVLW  09
536A:  MOVWF  x8B
536C:  MOVLW  20
536E:  BTFSS  F9E.4
5370:  BRA    536E
5372:  MOVWF  FAD
5374:  DECFSZ x8B,F
5376:  BRA    536C
5378:  MOVLW  02
537A:  MOVWF  FE9
537C:  MOVFF  283,290
5380:  MOVFF  282,28F
5384:  MOVFF  281,28E
5388:  MOVFF  280,28D
538C:  MOVWF  x91
538E:  MOVLB  0
5390:  CALL   3954
5394:  MOVLW  10
5396:  MOVLB  2
5398:  MOVWF  x8C
539A:  MOVLW  20
539C:  BTFSS  F9E.4
539E:  BRA    539C
53A0:  MOVWF  FAD
53A2:  DECFSZ x8C,F
53A4:  BRA    539A
53A6:  MOVLW  02
53A8:  MOVWF  FE9
53AA:  MOVFF  289,290
53AE:  MOVFF  288,28F
53B2:  MOVFF  287,28E
53B6:  MOVFF  286,28D
53BA:  MOVWF  x91
53BC:  MOVLB  0
53BE:  CALL   3954
53C2:  MOVLW  0D
53C4:  BTFSS  F9E.4
53C6:  BRA    53C4
53C8:  MOVWF  FAD
....................                   printf("OCTUBRE            %3.2f                %3.2f\r", media_annos[contador][9], media_annos_caldera[contador][9]); 
53CA:  MOVF   6B,W
53CC:  MULLW  30
53CE:  MOVF   FF3,W
53D0:  MOVLB  2
53D2:  CLRF   x7F
53D4:  MOVWF  x7E
53D6:  MOVLW  24
53D8:  ADDWF  x7E,W
53DA:  MOVWF  01
53DC:  MOVLW  00
53DE:  ADDWFC x7F,W
53E0:  MOVWF  03
53E2:  MOVF   01,W
53E4:  ADDLW  F0
53E6:  MOVWF  FE9
53E8:  MOVLW  00
53EA:  ADDWFC 03,W
53EC:  MOVWF  FEA
53EE:  MOVFF  FEF,280
53F2:  MOVFF  FEC,281
53F6:  MOVFF  FEC,282
53FA:  MOVFF  FEC,283
53FE:  MOVF   6B,W
5400:  MULLW  30
5402:  MOVF   FF3,W
5404:  CLRF   x85
5406:  MOVWF  x84
5408:  MOVLW  24
540A:  ADDWF  x84,W
540C:  MOVWF  01
540E:  MOVLW  00
5410:  ADDWFC x85,W
5412:  MOVWF  03
5414:  MOVF   01,W
5416:  ADDLW  B0
5418:  MOVWF  FE9
541A:  MOVLW  01
541C:  ADDWFC 03,W
541E:  MOVWF  FEA
5420:  MOVFF  FEF,286
5424:  MOVFF  FEC,287
5428:  MOVFF  FEC,288
542C:  MOVFF  FEC,289
5430:  CLRF   x8A
5432:  MOVF   x8A,W
5434:  MOVLB  0
5436:  CALL   104E
543A:  MOVLB  2
543C:  INCF   x8A,F
543E:  MOVWF  00
5440:  MOVF   00,W
5442:  BTFSS  F9E.4
5444:  BRA    5442
5446:  MOVWF  FAD
5448:  MOVLW  07
544A:  SUBWF  x8A,W
544C:  BNZ   5432
544E:  MOVLW  0C
5450:  MOVWF  x8B
5452:  MOVLW  20
5454:  BTFSS  F9E.4
5456:  BRA    5454
5458:  MOVWF  FAD
545A:  DECFSZ x8B,F
545C:  BRA    5452
545E:  MOVLW  02
5460:  MOVWF  FE9
5462:  MOVFF  283,290
5466:  MOVFF  282,28F
546A:  MOVFF  281,28E
546E:  MOVFF  280,28D
5472:  MOVWF  x91
5474:  MOVLB  0
5476:  CALL   3954
547A:  MOVLW  10
547C:  MOVLB  2
547E:  MOVWF  x8C
5480:  MOVLW  20
5482:  BTFSS  F9E.4
5484:  BRA    5482
5486:  MOVWF  FAD
5488:  DECFSZ x8C,F
548A:  BRA    5480
548C:  MOVLW  02
548E:  MOVWF  FE9
5490:  MOVFF  289,290
5494:  MOVFF  288,28F
5498:  MOVFF  287,28E
549C:  MOVFF  286,28D
54A0:  MOVWF  x91
54A2:  MOVLB  0
54A4:  CALL   3954
54A8:  MOVLW  0D
54AA:  BTFSS  F9E.4
54AC:  BRA    54AA
54AE:  MOVWF  FAD
....................                   printf("NOVIEMBRE          %3.2f                %3.2f\r", media_annos[contador][10], media_annos_caldera[contador][10]); 
54B0:  MOVF   6B,W
54B2:  MULLW  30
54B4:  MOVF   FF3,W
54B6:  MOVLB  2
54B8:  CLRF   x7F
54BA:  MOVWF  x7E
54BC:  MOVLW  28
54BE:  ADDWF  x7E,W
54C0:  MOVWF  01
54C2:  MOVLW  00
54C4:  ADDWFC x7F,W
54C6:  MOVWF  03
54C8:  MOVF   01,W
54CA:  ADDLW  F0
54CC:  MOVWF  FE9
54CE:  MOVLW  00
54D0:  ADDWFC 03,W
54D2:  MOVWF  FEA
54D4:  MOVFF  FEF,280
54D8:  MOVFF  FEC,281
54DC:  MOVFF  FEC,282
54E0:  MOVFF  FEC,283
54E4:  MOVF   6B,W
54E6:  MULLW  30
54E8:  MOVF   FF3,W
54EA:  CLRF   x85
54EC:  MOVWF  x84
54EE:  MOVLW  28
54F0:  ADDWF  x84,W
54F2:  MOVWF  01
54F4:  MOVLW  00
54F6:  ADDWFC x85,W
54F8:  MOVWF  03
54FA:  MOVF   01,W
54FC:  ADDLW  B0
54FE:  MOVWF  FE9
5500:  MOVLW  01
5502:  ADDWFC 03,W
5504:  MOVWF  FEA
5506:  MOVFF  FEF,286
550A:  MOVFF  FEC,287
550E:  MOVFF  FEC,288
5512:  MOVFF  FEC,289
5516:  CLRF   x8A
5518:  MOVF   x8A,W
551A:  MOVLB  0
551C:  CALL   107C
5520:  MOVLB  2
5522:  INCF   x8A,F
5524:  MOVWF  00
5526:  MOVF   00,W
5528:  BTFSS  F9E.4
552A:  BRA    5528
552C:  MOVWF  FAD
552E:  MOVLW  09
5530:  SUBWF  x8A,W
5532:  BNZ   5518
5534:  MOVLW  0A
5536:  MOVWF  x8B
5538:  MOVLW  20
553A:  BTFSS  F9E.4
553C:  BRA    553A
553E:  MOVWF  FAD
5540:  DECFSZ x8B,F
5542:  BRA    5538
5544:  MOVLW  02
5546:  MOVWF  FE9
5548:  MOVFF  283,290
554C:  MOVFF  282,28F
5550:  MOVFF  281,28E
5554:  MOVFF  280,28D
5558:  MOVWF  x91
555A:  MOVLB  0
555C:  CALL   3954
5560:  MOVLW  10
5562:  MOVLB  2
5564:  MOVWF  x8C
5566:  MOVLW  20
5568:  BTFSS  F9E.4
556A:  BRA    5568
556C:  MOVWF  FAD
556E:  DECFSZ x8C,F
5570:  BRA    5566
5572:  MOVLW  02
5574:  MOVWF  FE9
5576:  MOVFF  289,290
557A:  MOVFF  288,28F
557E:  MOVFF  287,28E
5582:  MOVFF  286,28D
5586:  MOVWF  x91
5588:  MOVLB  0
558A:  CALL   3954
558E:  MOVLW  0D
5590:  BTFSS  F9E.4
5592:  BRA    5590
5594:  MOVWF  FAD
....................                   printf("DICIEMBRE          %3.2f                %3.2f\r", media_annos[contador][11], media_annos_caldera[contador][11]); 
5596:  MOVF   6B,W
5598:  MULLW  30
559A:  MOVF   FF3,W
559C:  MOVLB  2
559E:  CLRF   x7F
55A0:  MOVWF  x7E
55A2:  MOVLW  2C
55A4:  ADDWF  x7E,W
55A6:  MOVWF  01
55A8:  MOVLW  00
55AA:  ADDWFC x7F,W
55AC:  MOVWF  03
55AE:  MOVF   01,W
55B0:  ADDLW  F0
55B2:  MOVWF  FE9
55B4:  MOVLW  00
55B6:  ADDWFC 03,W
55B8:  MOVWF  FEA
55BA:  MOVFF  FEF,280
55BE:  MOVFF  FEC,281
55C2:  MOVFF  FEC,282
55C6:  MOVFF  FEC,283
55CA:  MOVF   6B,W
55CC:  MULLW  30
55CE:  MOVF   FF3,W
55D0:  CLRF   x85
55D2:  MOVWF  x84
55D4:  MOVLW  2C
55D6:  ADDWF  x84,W
55D8:  MOVWF  01
55DA:  MOVLW  00
55DC:  ADDWFC x85,W
55DE:  MOVWF  03
55E0:  MOVF   01,W
55E2:  ADDLW  B0
55E4:  MOVWF  FE9
55E6:  MOVLW  01
55E8:  ADDWFC 03,W
55EA:  MOVWF  FEA
55EC:  MOVFF  FEF,286
55F0:  MOVFF  FEC,287
55F4:  MOVFF  FEC,288
55F8:  MOVFF  FEC,289
55FC:  CLRF   x8A
55FE:  MOVF   x8A,W
5600:  MOVLB  0
5602:  CALL   10AC
5606:  MOVLB  2
5608:  INCF   x8A,F
560A:  MOVWF  00
560C:  MOVF   00,W
560E:  BTFSS  F9E.4
5610:  BRA    560E
5612:  MOVWF  FAD
5614:  MOVLW  09
5616:  SUBWF  x8A,W
5618:  BNZ   55FE
561A:  MOVLW  0A
561C:  MOVWF  x8B
561E:  MOVLW  20
5620:  BTFSS  F9E.4
5622:  BRA    5620
5624:  MOVWF  FAD
5626:  DECFSZ x8B,F
5628:  BRA    561E
562A:  MOVLW  02
562C:  MOVWF  FE9
562E:  MOVFF  283,290
5632:  MOVFF  282,28F
5636:  MOVFF  281,28E
563A:  MOVFF  280,28D
563E:  MOVWF  x91
5640:  MOVLB  0
5642:  CALL   3954
5646:  MOVLW  10
5648:  MOVLB  2
564A:  MOVWF  x8C
564C:  MOVLW  20
564E:  BTFSS  F9E.4
5650:  BRA    564E
5652:  MOVWF  FAD
5654:  DECFSZ x8C,F
5656:  BRA    564C
5658:  MOVLW  02
565A:  MOVWF  FE9
565C:  MOVFF  289,290
5660:  MOVFF  288,28F
5664:  MOVFF  287,28E
5668:  MOVFF  286,28D
566C:  MOVWF  x91
566E:  MOVLB  0
5670:  CALL   3954
5674:  MOVLW  0D
5676:  BTFSS  F9E.4
5678:  BRA    5676
567A:  MOVWF  FAD
....................                   printf("-----------------------------------------------------\r"); 
567C:  MOVLB  2
567E:  CLRF   x7E
5680:  MOVF   x7E,W
5682:  MOVLB  0
5684:  CALL   0E1A
5688:  IORLW  00
568A:  BZ    569A
568C:  MOVLB  2
568E:  INCF   x7E,F
5690:  BTFSS  F9E.4
5692:  BRA    5690
5694:  MOVWF  FAD
5696:  BRA    5680
5698:  MOVLB  0
....................                } 
569A:  INCF   6B,F
569C:  GOTO   4B0C
....................  
....................                goto repetir; 
56A0:  MOVLB  0
56A2:  GOTO   486E
....................                break; 
56A6:  BRA    56A8
....................  
....................       //En los tres casos, vuelve a mostrarse el menú tras imprimir las estadísticas 
....................    } 
.................... } 
56A8:  GOTO   6650 (RETURN)
....................  
.................... //------------------------------------------------------------------------------------------------------------------------------------ 
....................  
.................... void seleccionar_alarma() 
.................... { 
....................    //Contador y variables auxiliares 
....................    int contador; 
....................    int hora, minutos, hora_p, min_p; 
....................  
....................    //Ponemos la posición en el vector de alarmas incialmente a 0 
....................    posicion_alarmas = 0; 
*
36E4:  CLRF   44
....................  
....................    //Leemos el tiempo actual 
....................    PCF8583_read_datetime(&tiempo); 
36E6:  CLRF   74
36E8:  MOVLW  45
36EA:  MOVWF  73
36EC:  CALL   2746
....................    hora = tiempo.hours; 
36F0:  MOVFF  47,6C
....................    minutos = tiempo.minutes; 
36F4:  MOVFF  46,6D
....................  
....................    //Recorremos todas las programaciones 
....................    for(contador=0; contador<num_intervalos; contador++) 
36F8:  CLRF   6B
36FA:  MOVF   43,W
36FC:  SUBWF  6B,W
36FE:  BC    3762
....................    { 
....................        hora_p = programaciones[contador].horas_inicio; 
3700:  MOVF   6B,W
3702:  MULLW  05
3704:  MOVF   FF3,W
3706:  CLRF   71
3708:  MOVWF  70
370A:  MOVLW  2F
370C:  ADDWF  70,W
370E:  MOVWF  FE9
3710:  MOVLW  00
3712:  ADDWFC 71,W
3714:  MOVWF  FEA
3716:  MOVFF  FEF,6E
....................        min_p  = programaciones[contador].minutos_inicio; 
371A:  MOVF   6B,W
371C:  MULLW  05
371E:  MOVF   FF3,W
3720:  CLRF   71
3722:  MOVWF  70
3724:  MOVLW  01
3726:  ADDWF  70,W
3728:  MOVWF  01
372A:  MOVLW  00
372C:  ADDWFC 71,W
372E:  MOVWF  03
3730:  MOVF   01,W
3732:  ADDLW  2F
3734:  MOVWF  FE9
3736:  MOVLW  00
3738:  ADDWFC 03,W
373A:  MOVWF  FEA
373C:  MOVFF  FEF,6F
....................  
....................        //Comprobamos las horas y tomamos la primera programación que tenga una 
....................        //hora mayor que la actual 
....................        if(!comprobar_hora(hora_p, min_p, hora, minutos)) 
3740:  MOVFF  6E,7D
3744:  MOVFF  6F,7E
3748:  MOVFF  6C,7F
374C:  MOVFF  6D,80
3750:  CALL   2926
3754:  MOVF   01,F
3756:  BNZ   375E
....................        { 
....................            //Guardamos la posición de esta programación y salimos 
....................            posicion_alarmas = contador; 
3758:  MOVFF  6B,44
....................            break; 
375C:  BRA    3762
....................        } 
....................    } 
375E:  INCF   6B,F
3760:  BRA    36FA
.................... } 
3762:  GOTO   64F0 (RETURN)

Configuration Fuses:
   Word  1: 0200   HS NOIESO NOFCMEN RESERVED
   Word  2: 181E   BROWNOUT NOWDT BORV25 PUT WDT4096
   Word  3: 8300   PBADEN CCP2C1 NOLPT1OSC MCLR RESERVED
   Word  4: 0081   STVREN NODEBUG NOLVP NOXINST RESERVED
   Word  5: C00F   NOPROTECT NOCPD NOCPB
   Word  6: E00F   NOWRT NOWRTD NOWRTC NOWRTB
   Word  7: 400F   NOEBTR NOEBTRB
